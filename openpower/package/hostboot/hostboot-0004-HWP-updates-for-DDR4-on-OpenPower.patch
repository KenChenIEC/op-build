From 4dd831628e3fe17128600e2e089c6f3e9372c08d Mon Sep 17 00:00:00 2001
From: aalugore <aalugore@us.ibm.com>
Date: Tue, 3 Nov 2015 15:55:57 -0600
Subject: [PATCH] HWP updates for ddr4 support on Garrison

Change-Id: I89a5524f0098a0c16dfee2b2e061f0b160caf307
---
 .../usr/hwpf/hwp/mvpd_accessors/getMBvpdAttr.H     |     3 +-
 .../dram_training/mss_draminit/mss_ddr4_funcs.H    |    31 +-
 .../hwp/dram_training/mss_draminit/mss_draminit.C  |     7 +-
 .../mss_draminit_trainadv/mss_ddr4_funcs.C         |  2125 +++-
 .../mss_draminit_trainadv/mss_ddr4_pda.C           |  2968 ++---
 .../mss_draminit_trainadv/mss_ddr4_pda.H           |    52 +-
 .../mss_draminit_training_advanced.C               |   382 +-
 .../mss_draminit_trainadv/mss_generic_shmoo.C      |   423 +-
 .../mss_draminit_trainadv/mss_generic_shmoo.H      |     8 +-
 .../mss_draminit_trainadv/mss_mrs6_DDR4.C          |    22 +-
 .../mss_draminit_training/mss_draminit_training.C  | 11026 ++++++++++---------
 src/usr/hwpf/hwp/dram_training/mss_funcs.C         |    35 +-
 .../hwp/mc_config/mss_eff_config/mss_eff_config.C  |   680 +-
 src/usr/hwpf/hwp/mc_config/mss_freq/mss_freq.C     |    16 +
 src/usr/hwpf/hwp/memory_attributes.xml             |   207 +-
 src/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttr.C     |    66 +-
 src/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttrData.C |    10 +-
 .../targeting/common/xmltohb/attribute_types.xml   |   130 +-
 18 files changed, 9845 insertions(+), 8346 deletions(-)

diff --git a/src/include/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttr.H b/src/include/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttr.H
index 5916174..397a59b 100644
--- a/src/include/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttr.H
+++ b/src/include/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttr.H
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: getMBvpdAttr.H,v 1.7 2015/10/06 18:04:03 janssens Exp $
+// $Id: getMBvpdAttr.H,v 1.8 2015/11/02 21:42:22 sglancy Exp $
 
 /**
  *  @file getMBvpdAttr.H
@@ -198,6 +198,7 @@ namespace getAttrData
     // for UNIT8_BY2_BY2_BY4 (all mutually exclusive)
         XLATE_RTT_NOM  = 0x0100,
         XLATE_RTT_WR   = 0x0200,
+        XLATE_RTT_PARK   = 0x0400,
 
     // for UINT32_BY2 (all mutually exclusive)
         XLATE_RD_VREF  = 0x0100,
diff --git a/src/usr/hwpf/hwp/dram_training/mss_draminit/mss_ddr4_funcs.H b/src/usr/hwpf/hwp/dram_training/mss_draminit/mss_ddr4_funcs.H
index 327b894..5dc9177 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_draminit/mss_ddr4_funcs.H
+++ b/src/usr/hwpf/hwp/dram_training/mss_draminit/mss_ddr4_funcs.H
@@ -22,12 +22,12 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_ddr4_funcs.H,v 1.5 2015/09/04 18:14:20 thi Exp $
+// $Id: mss_ddr4_funcs.H,v 1.6 2015/11/09 17:22:00 sglancy Exp $
 
 //------------------------------------------------------------------------------
 // *! (C) Copyright International Business Machines Corp. 2013
 // *! All Rights Reserved -- Property of IBM
-// *! ***  ***
+// *! *** IBM Confidential ***
 //------------------------------------------------------------------------------
 // *! TITLE : mss_ddr4_funcs.H
 // *! DESCRIPTION : Tools for DDR4 DIMMs centaur procedures
@@ -105,6 +105,33 @@ fapi::ReturnCode mss_rcd_load_ddr4(
 //--------------------------------------------------------------
 fapi::ReturnCode mss_create_rcd_ddr4( const fapi::Target& i_target_mba);
 
+/**
+ * @loads in a nominal MRS value into the address_16 and bank_3
+ *
+ * @param[in]  target:  Reference to centaur.mba target, 
+ * @param[out]  ecmdDataBufferBase& bank_3:  bank bits to be issued during MRS
+ * @param[out]  ecmdDataBufferBase& address_16:  16 address lanes to be issued during MRS - setup during function
+ * @param[in]  uint8_t MRS:  which MRS to configure
+ * @param[in]  uint8_t i_port_number: the port on which to configure the MRS - used for ID'ing which attributes to use
+ * @param[in]  uint8_t dimm_number: the DIMM on which to configure the MRS - used for ID'ing which attributes to use
+ * @param[in]  uint8_t rank_number: the rank on which to configure the MRS - used for ID'ing which attributes to use
+ *
+ * @return ReturnCode
+ */
+fapi::ReturnCode mss_ddr4_load_nominal_mrs_pda(fapi::Target& i_target,ecmdDataBufferBase& bank_3,ecmdDataBufferBase& address_16,uint8_t MRS,uint8_t i_port_number, uint8_t dimm_number, uint8_t rank_number);
+/**
+ * @Modifies the passed in address_16 buffer based upon the given attribute and data
+ *
+ * @param[in]  target:  Reference to centaur.mba target, 
+ * @param[in/out]  ecmdDataBufferBase& address_16:  MRS values - this is modified by the given attribute name and data
+ * @param[in]  uint32_t attribute_name:  enumerated value containing the attribute name to be modified - attr_name tells the function which bits to modify
+ * @param[in]  uint8_t attribute_data:   data telss the function what values to set to the modified bits
+ *
+ * @return ReturnCode
+ */
+fapi::ReturnCode mss_ddr4_modify_mrs_pda(fapi::Target& i_target,ecmdDataBufferBase& address_16,uint32_t attribute_name,uint8_t attribute_data);
+
+fapi::ReturnCode mss_ddr4_rtt_nom_rtt_wr_swap(fapi::Target& i_target, uint8_t i_mbaPosition, uint32_t i_port_number, uint8_t i_rank, uint32_t i_rank_pair_group, uint32_t& io_ccs_inst_cnt, uint8_t& io_dram_rtt_nom_original);
 #endif /* _MSS_DDR4_FUNCS_H */
 
 
diff --git a/src/usr/hwpf/hwp/dram_training/mss_draminit/mss_draminit.C b/src/usr/hwpf/hwp/dram_training/mss_draminit/mss_draminit.C
index e95011a..4e23503 100755
--- a/src/usr/hwpf/hwp/dram_training/mss_draminit/mss_draminit.C
+++ b/src/usr/hwpf/hwp/dram_training/mss_draminit/mss_draminit.C
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_draminit.C,v 1.70 2015/09/04 01:10:11 kmack Exp $
+// $Id: mss_draminit.C,v 1.71 2015/11/09 17:22:01 sglancy Exp $
 //------------------------------------------------------------------------------
 // Don't forget to create CVS comments when you check in your changes!
 //------------------------------------------------------------------------------
@@ -30,6 +30,7 @@
 //------------------------------------------------------------------------------
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|-----------------------------------------------
+//  1.71   | sglancy  |03-NOV-15| Fixed attribute names for DDR4 RDIMM
 //  1.70   | kmack    |01-Sep-15| Fixed more RCs and removed extraneous comments
 //  1.69   | kmack    |28-Aug-15| Fixed an RC
 //  1.68   | kmack    |10-Aug-15| Moved the mss_lrdimm_ddr4_db_load call to the be included or not included based on def FAPI_LRDIMM
@@ -347,7 +348,7 @@ ReturnCode mss_draminit_cloned(Target& i_target)
     rc = FAPI_ATTR_GET(ATTR_IS_SIMULATION, NULL, is_sim);
     if(rc) return rc;
     uint8_t address_mirror_map[2][2]; //address_mirror_map[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
     if(rc) return rc;
 
 
@@ -1885,7 +1886,7 @@ ReturnCode mss_mrs_load(
     if(rc) return rc;
 
     uint8_t address_mirror_map[2][2]; //address_mirror_map[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
     if(rc) return rc;
 
 
diff --git a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_funcs.C b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_funcs.C
index 9454c34..d84479d 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_funcs.C
+++ b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_funcs.C
@@ -22,11 +22,11 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_ddr4_funcs.C,v 1.15 2015/08/28 18:15:08 sglancy Exp $
+// $Id: mss_ddr4_funcs.C,v 1.19 2015/11/16 18:41:34 sglancy Exp $
 //------------------------------------------------------------------------------
 // *! (C) Copyright International Business Machines Corp. 2013
 // *! All Rights Reserved -- Property of IBM
-// *! ***  ***
+// *! *** IBM Confidential ***
 //------------------------------------------------------------------------------
 // *! TITLE : mss_ddr4_funcs.C
 // *! DESCRIPTION : Tools for DDR4 DIMMs centaur procedures
@@ -43,6 +43,10 @@
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|-----------------------------------------------
 //         |          |         |
+//  1.19   | 11/16/15 | sglancy | Fixed R/LRDIMM bug
+//  1.18   | 11/03/15 | sglancy | Fixed attribute names for DDR4 RDIMM
+//  1.17   | 10/23/15 | sglancy | Changed attribute names
+//  1.16   | 10/21/15 | sglancy | Changed attribute names
 //  1.15   | 08/28/15 | sglancy | Added RCs - addressed FW comments
 //  1.14   | 08/21/15 | sglancy | Fixed ODT initialization bug - ODT must be held low through ZQ cal 
 //  1.13   | 08/05/15 | kmack   | Commented out FAPI_DDR4 code
@@ -146,7 +150,7 @@ ReturnCode mss_ddr4_invert_mpr_write( Target& i_target_mba) {
     if(rc) return rc;
 
     uint8_t address_mirror_map[2][2]; //address_mirror_map[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_ADDRESS_MIRRORING, &i_target_mba, address_mirror_map);
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_ADDRESS_MIRRORING, &i_target_mba, address_mirror_map);
     if(rc) return rc;
 
    uint8_t dram_stack[2][2];
@@ -704,6 +708,20 @@ ReturnCode mss_create_rcd_ddr4(const Target& i_target_mba) {
          else {
             l_rcd_cntl_word_15 = 0; // 1nCk latency adder with DB control bus
          }
+	 
+	 FAPI_INF("RCD_CNTL_WORDS %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x %02x ",l_rcd_cntl_word_0_1,
+l_rcd_cntl_word_2,  
+l_rcd_cntl_word_3,  
+l_rcd_cntl_word_4,  
+l_rcd_cntl_word_5,  
+l_rcd_cntl_word_6_7,
+l_rcd_cntl_word_8_9,
+l_rcd_cntl_word_10, 
+l_rcd_cntl_word_11, 
+l_rcd_cntl_word_12, 
+l_rcd_cntl_word_13, 
+l_rcd_cntl_word_14, 
+l_rcd_cntl_word_15 );
 
          rc_num |= data_buffer_64.insertFromRight(&l_rcd_cntl_word_0_1, 0 , 8);
          rc_num |= data_buffer_64.insertFromRight(&l_rcd_cntl_word_2,   8 , 4);
@@ -800,6 +818,10 @@ ReturnCode mss_rcd_load_ddr4(
             )    {
 
     ReturnCode rc;
+    //generates the RCD words
+    rc = mss_create_rcd_ddr4(i_target);
+    if(rc) return rc;
+    
     ReturnCode rc_buff;
     uint32_t rc_num = 0;
     uint32_t dimm_number;
@@ -1187,7 +1209,7 @@ ReturnCode mss_mrs_load_ddr4(
     if(rc) return rc;
 
     uint8_t address_mirror_map[2][2]; //address_mirror_map[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
     if(rc) return rc;
 
 
@@ -1730,7 +1752,7 @@ ReturnCode mss_mrs_load_ddr4(
     rc = FAPI_ATTR_GET(ATTR_EFF_ODT_INPUT_BUFF , &i_target, odt_input_buffer);
     if(rc) return rc;
     uint8_t rtt_park[2][2][4]; //RTT_Park value  -  NEW
-    rc = FAPI_ATTR_GET(ATTR_EFF_RTT_PARK , &i_target, rtt_park);
+    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_RTT_PARK , &i_target, rtt_park);
     if(rc) return rc;
     uint8_t ca_parity; //CA Parity Persistance Error  -  NEW
     rc = FAPI_ATTR_GET(ATTR_EFF_CA_PARITY , &i_target, ca_parity);
@@ -1833,13 +1855,13 @@ ReturnCode mss_mrs_load_ddr4(
 
     //MRS6
     uint8_t vrefdq_train_value[2][2][4]; //vrefdq_train value   -  NEW
-    rc = FAPI_ATTR_GET( ATTR_VREF_DQ_TRAIN_VALUE, &i_target, vrefdq_train_value);
+    rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_VALUE, &i_target, vrefdq_train_value);
     if(rc) return rc;
     uint8_t vrefdq_train_range[2][2][4]; //vrefdq_train range   -  NEW
-    rc = FAPI_ATTR_GET( ATTR_VREF_DQ_TRAIN_RANGE, &i_target, vrefdq_train_range);
+    rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_RANGE, &i_target, vrefdq_train_range);
     if(rc) return rc;
     uint8_t vrefdq_train_enable[2][2][4]; //vrefdq_train enable  -  NEW
-    rc = FAPI_ATTR_GET( ATTR_VREF_DQ_TRAIN_ENABLE, &i_target, vrefdq_train_enable);
+    rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target, vrefdq_train_enable);
     if(rc) return rc;
     uint8_t tccd_l; //tccd_l  -  NEW
     rc = FAPI_ATTR_GET( ATTR_TCCD_L, &i_target, tccd_l);
@@ -2080,35 +2102,35 @@ ReturnCode mss_mrs_load_ddr4(
 
 
                     //MRS5
-                    if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_RTT_PARK_DISABLE)
+                    if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_DISABLE)
                     {
                         rtt_park[i_port_number][dimm_number][rank_number] = 0x00;
                     }
-                    else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_RTT_PARK_60OHM)
+                    else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_60OHM)
                     {
                         rtt_park[i_port_number][dimm_number][rank_number] = 0x80;
                     }
-                    else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_RTT_PARK_40OHM)
+                    else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_40OHM)
                     {
                         rtt_park[i_port_number][dimm_number][rank_number] = 0xC0;
                     }
-                    else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_RTT_PARK_120OHM)
+                    else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_120OHM)
                     {
                         rtt_park[i_port_number][dimm_number][rank_number] = 0x40;
                     }
-                    else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_RTT_PARK_240OHM)
+                    else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_240OHM)
                     {
                         rtt_park[i_port_number][dimm_number][rank_number] = 0x20;
                     }
-                    else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_RTT_PARK_48OHM)
+                    else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_48OHM)
                     {
                         rtt_park[i_port_number][dimm_number][rank_number] = 0xA0;
                     }
-                    else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_RTT_PARK_80OHM)
+                    else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_80OHM)
                     {
                         rtt_park[i_port_number][dimm_number][rank_number] = 0x60;
                     }
-                    else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_RTT_PARK_34OHM)
+                    else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_34OHM)
                     {
                         rtt_park[i_port_number][dimm_number][rank_number] = 0xE0;
                     }
@@ -2135,20 +2157,20 @@ ReturnCode mss_mrs_load_ddr4(
 
                     vrefdq_train_value[i_port_number][dimm_number][rank_number] = mss_reverse_8bits(vrefdq_train_value[i_port_number][dimm_number][rank_number]);
 
-                    if (vrefdq_train_range[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VREF_DQ_TRAIN_RANGE_RANGE1)
+                    if (vrefdq_train_range[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_VREF_DQ_TRAIN_RANGE_RANGE1)
                     {
                         vrefdq_train_range[i_port_number][dimm_number][rank_number] = 0x00;
                     }
-                    else if (vrefdq_train_range[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VREF_DQ_TRAIN_RANGE_RANGE2)
+                    else if (vrefdq_train_range[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_VREF_DQ_TRAIN_RANGE_RANGE2)
                     {
                         vrefdq_train_range[i_port_number][dimm_number][rank_number] = 0xFF;
                     }
 
-                    if (vrefdq_train_enable[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_ENABLE)
+                    if (vrefdq_train_enable[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE)
                     {
                         vrefdq_train_enable[i_port_number][dimm_number][rank_number] = 0xFF;
                     }
-                    else if (vrefdq_train_enable[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_DISABLE)
+                    else if (vrefdq_train_enable[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_DISABLE)
                     {
                         vrefdq_train_enable[i_port_number][dimm_number][rank_number] = 0x00;
                     }
@@ -2438,6 +2460,2069 @@ ReturnCode mss_mrs_load_ddr4(
     return rc;
 }
 
+//Converts RTT_WR values to RTT_NOM
+void convert_rtt_wr_to_rtt_nom(uint8_t rtt_wr, uint8_t & rtt_nom) {
+   switch(rtt_wr) {
+      case ENUM_ATTR_VPD_DRAM_RTT_WR_OHM120:
+           rtt_nom = ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM120;
+	   break;
+      case 240:
+           rtt_nom = ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM240;
+	   break;
+      case 0xFF:
+      case ENUM_ATTR_VPD_DRAM_RTT_WR_DISABLE: 
+      default:
+           FAPI_INF("RTT_WR is disabled! Skipping the swap of termination values to keep RTT_NOM with it's nominal values!!");
+	   break;
+   }
+}
+
+ReturnCode mss_ddr4_rtt_nom_rtt_wr_swap(
+            Target& i_target,
+            uint8_t i_mbaPosition,
+            uint32_t i_port_number,
+            uint8_t i_rank,
+	    uint32_t i_rank_pair_group,
+            uint32_t& io_ccs_inst_cnt,
+	    uint8_t& io_dram_rtt_nom_original
+            )
+{
+    // Target MBA level
+    // This is a function written specifically for mss_draminit_training
+    // Meant for placing RTT_WR into RTT_NOM within MR1 before wr_lvl
+    // If the function argument dram_rtt_nom_original has a value of 0xFF it will put the original rtt_nom there
+    // and write rtt_wr to the rtt_nom value
+    // If the function argument dram_rtt_nom_original has any value besides 0xFF it will try to write that value to rtt_nom.
+    
+    FAPI_INF("Swapping RTT_WR values into RTT_NOM or swapping RTT_NOM back to its nominal value");
+    
+    ReturnCode rc;
+    ReturnCode rc_buff;
+    uint32_t rc_num = 0;
+
+    ecmdDataBufferBase address_16(16);
+    ecmdDataBufferBase address_16_backup(16);
+    ecmdDataBufferBase bank_3(3);
+    ecmdDataBufferBase activate_1(1);
+    rc_num = rc_num | activate_1.setBit(0);
+    ecmdDataBufferBase rasn_1(1);
+    rc_num = rc_num | rasn_1.clearBit(0);
+    ecmdDataBufferBase casn_1(1);
+    rc_num = rc_num | casn_1.clearBit(0);
+    ecmdDataBufferBase wen_1(1);
+    rc_num = rc_num | wen_1.clearBit(0);
+    ecmdDataBufferBase cke_4(4);
+    rc_num = rc_num | cke_4.setBit(0,4);
+    ecmdDataBufferBase csn_8(8);
+    rc_num = rc_num | csn_8.setBit(0,8);
+    ecmdDataBufferBase odt_4(4);
+    rc_num = rc_num | odt_4.clearBit(0,4);
+    ecmdDataBufferBase ddr_cal_type_4(4);
+
+    ecmdDataBufferBase num_idles_16(16);
+    ecmdDataBufferBase num_repeat_16(16);
+    ecmdDataBufferBase data_20(20);
+    ecmdDataBufferBase read_compare_1(1);
+    ecmdDataBufferBase rank_cal_4(4);
+    ecmdDataBufferBase ddr_cal_enable_1(1);
+    ecmdDataBufferBase ccs_end_1(1);
+
+    ecmdDataBufferBase mrs1_16(16);
+    ecmdDataBufferBase mrs2_16(16);
+
+    ecmdDataBufferBase data_buffer_64(64);
+
+    uint8_t dimm = 0;
+    uint8_t dimm_rank = 0;
+
+    // dimm 0, dimm_rank 0-3 = ranks 0-3; dimm 1, dimm_rank 0-3 = ranks 4-7
+    dimm = (i_rank) / 4;
+    dimm_rank = i_rank - 4*dimm;
+
+
+    uint8_t dimm_type;
+    rc = FAPI_ATTR_GET(ATTR_EFF_DIMM_TYPE, &i_target, dimm_type);
+    if(rc) return rc;
+
+    uint8_t is_sim = 0;
+    rc = FAPI_ATTR_GET(ATTR_IS_SIMULATION, NULL, is_sim);
+    if(rc) return rc;
+    
+    uint8_t dram_stack[2][2];
+    rc = FAPI_ATTR_GET(ATTR_EFF_STACK_TYPE, &i_target, dram_stack);
+    if(rc) return rc;
+   
+    
+
+    uint8_t address_mirror_map[2][2]; //address_mirror_map[port][dimm]
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
+    if(rc) return rc;
+
+
+    // Raise CKE high with NOPS, waiting min Reset CKE exit time (tXPR) - 400 cycles
+    rc_num = rc_num | csn_8.setBit(0,8);
+    rc_num = rc_num | address_16.clearBit(0, 16);
+    rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 400, 0, 16);
+    if(rc_num)
+    {
+	rc.setEcmdError(rc_num);
+	return rc;
+    }
+    rc = mss_ccs_inst_arry_0( i_target,
+                              io_ccs_inst_cnt,
+                              address_16,
+                              bank_3,
+                              activate_1,
+                              rasn_1,
+                              casn_1,
+                              wen_1,
+                              cke_4,
+                              csn_8,
+                              odt_4,
+                              ddr_cal_type_4,
+                              i_port_number);
+    if(rc) return rc;
+    rc = mss_ccs_inst_arry_1( i_target,
+                              io_ccs_inst_cnt,
+                              num_idles_16,
+                              num_repeat_16,
+                              data_20,
+                              read_compare_1,
+                              rank_cal_4,
+                              ddr_cal_enable_1,
+                              ccs_end_1);
+    if(rc) return rc;
+    io_ccs_inst_cnt ++;
+
+    rc_num = rc_num | csn_8.setBit(0,8);
+    rc_num = rc_num | csn_8.clearBit(i_rank);
+    //sets up the MRS
+    rc_num = rc_num | rasn_1.clearBit(0,1);
+    rc_num = rc_num | casn_1.clearBit(0,1);
+    rc_num = rc_num | wen_1.clearBit(0,1);
+    
+    // MRS CMD to CMD spacing = 12 cycles
+    rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 12, 0, 16);
+    if(rc_num)
+    {
+	rc.setEcmdError(rc_num);
+	return rc;
+    }
+
+    FAPI_INF( "Editing RTT_NOM during wr_lvl or for PDA for %s PORT: %d RP: %d", i_target.toEcmdString(), i_port_number, i_rank_pair_group);
+    
+    //load nominal MRS values for the MR1, which contains RTT_NOM
+    rc = mss_ddr4_load_nominal_mrs_pda(i_target, bank_3, address_16,MRS1_BA, i_port_number,  dimm,  dimm_rank);
+    if(rc) return rc;
+    
+    uint8_t dram_rtt_nom[2][2][4];
+    uint8_t dram_rtt_wr[2][2][4];
+    
+    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_RTT_WR, &i_target, dram_rtt_wr);
+    if(rc) return rc;
+    
+    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_RTT_NOM, &i_target, dram_rtt_nom);
+    if(rc) return rc;
+    
+    uint32_t addr16_print1,addr16_print2;
+    addr16_print1 = addr16_print2 = 0;
+    
+    //do modifications based upon RTT_WR values if need be - a 0xFF indicates no swap done, so do the swap
+    if(io_dram_rtt_nom_original == 0xFF) {
+       io_dram_rtt_nom_original = 1;
+       convert_rtt_wr_to_rtt_nom(dram_rtt_wr[i_port_number][dimm][dimm_rank], dram_rtt_nom[i_port_number][dimm][dimm_rank]);
+       
+       FAPI_INF("Swapping RTT_WR value of 0x%02x into RTT_NOM=0x%02x",dram_rtt_wr[i_port_number][dimm][dimm_rank],dram_rtt_nom[i_port_number][dimm][dimm_rank]);
+       rc_num = rc_num | address_16.extractPreserve(&addr16_print1, 0, 16, 0);
+       if(rc_num)
+       {
+	   rc.setEcmdError(rc_num);
+	   return rc;
+       }
+       
+       rc = mss_ddr4_modify_mrs_pda(i_target,address_16,ATTR_VPD_DRAM_RTT_NOM,dram_rtt_nom[i_port_number][dimm][dimm_rank]);
+       if(rc) return rc;
+       rc_num = rc_num | address_16.extractPreserve(&addr16_print2, 0, 16, 0);
+       if(rc_num)
+       {
+	   rc.setEcmdError(rc_num);
+	   return rc;
+       }
+       FAPI_INF("Modified MR1 to have RTT_WR's value in RTT_NOM");
+       FAPI_INF("Printing before 0x%04x and after 0x%04x",addr16_print1,addr16_print2);
+    }
+    else {
+       FAPI_INF("Not doing the swap, just setting back to nominal values 0x%02x",io_dram_rtt_nom_original);
+    }
+   
+   rc_num = rc_num | address_16_backup.insert(address_16, 0, 16, 0);
+   if(rc_num)
+   {
+       rc.setEcmdError(rc_num);
+       return rc;
+   }
+   
+   
+   FAPI_INF("Issueing MRS command"); 
+   
+    //loads the previous DRAM
+   if (( address_mirror_map[i_port_number][dimm] & (0x08 >> dimm_rank) ) && (is_sim == 0))
+   {
+       FAPI_INF("Doing address_mirroring_swizzle for %d %d %d %02x",i_port_number,dimm,dimm_rank,address_mirror_map[i_port_number][dimm] );
+       rc = mss_address_mirror_swizzle(i_target, i_port_number, dimm, dimm_rank, address_16, bank_3);
+       if(rc) return rc;
+   }
+   else {
+      FAPI_INF("No swizzle for address_mirroring_swizzle necessary for %d %d %d 0x%02x",i_port_number,dimm,dimm_rank,address_mirror_map[i_port_number][dimm] );
+   }
+
+   // Only corresponding CS to rank
+   rc_num = rc_num | csn_8.setBit(0,8); 
+   rc_num = rc_num | csn_8.clearBit(i_rank);
+   if(dram_stack[i_port_number][dimm]  == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+      rc_num = rc_num | csn_8.clearBit(2,2); 
+      rc_num = rc_num | csn_8.clearBit(6,2); 
+   }
+   
+   if(rc_num)
+   {
+       rc.setEcmdError(rc_num);
+       return rc;
+   }
+   
+   // Send out to the CCS array 
+   rc = mss_ccs_inst_arry_0( i_target,
+   	    io_ccs_inst_cnt,
+   	    address_16,
+   	    bank_3,
+   	    activate_1,
+   	    rasn_1,
+   	    casn_1,
+   	    wen_1,
+   	    cke_4,
+   	    csn_8,
+   	    odt_4,
+   	    ddr_cal_type_4,
+   	    i_port_number);
+   if(rc) return rc;
+   rc = mss_ccs_inst_arry_1( i_target,
+   	    io_ccs_inst_cnt,
+   	    num_idles_16,
+   	    num_repeat_16,
+   	    data_20,
+   	    read_compare_1,
+   	    rank_cal_4,
+   	    ddr_cal_enable_1,
+   	    ccs_end_1);
+   if(rc) return rc;
+   io_ccs_inst_cnt ++;
+
+   //is an R or LR DIMM -> do a B side MRS write
+   if ( (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_RDIMM) || (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) ) {
+      //takes values from the backup
+      address_16.clearBit(0, 16);
+      rc_num = rc_num | address_16.insert(address_16_backup, 0, 16, 0);
+      
+      //FLIPS all necessary bits
+      // Indicate B-Side DRAMS BG1=1 
+      rc_num = rc_num | address_16.setBit(15);  // Set BG1 = 1
+ 
+      rc_num = rc_num | address_16.flipBit(3,7); // Invert A3:A9
+      rc_num = rc_num | address_16.flipBit(11);  // Invert A11
+      rc_num = rc_num | address_16.flipBit(13);  // Invert A13
+      rc_num = rc_num | address_16.flipBit(14);  // Invert A17
+      rc_num = rc_num | bank_3.flipBit(0,3);	 // Invert BA0,BA1,BG0
+      
+      if(rc_num)
+      {
+         rc.setEcmdError(rc_num);
+         return rc;
+      }
+      
+      //loads the previous DRAM
+      if (( address_mirror_map[i_port_number][dimm] & (0x08 >> dimm_rank) ) && (is_sim == 0))
+      {
+   	  rc = mss_address_mirror_swizzle(i_target, i_port_number, dimm, dimm_rank, address_16, bank_3);
+   	  if(rc) return rc;
+      }
+      
+      // Only corresponding CS to rank
+      rc_num = rc_num | csn_8.setBit(0,8); 
+      rc_num = rc_num | csn_8.clearBit(i_rank);
+      if(dram_stack[i_port_number][dimm]  == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+         rc_num = rc_num | csn_8.clearBit(2,2); 
+         rc_num = rc_num | csn_8.clearBit(6,2); 
+      }
+   
+      if(rc_num)
+      {
+         rc.setEcmdError(rc_num);
+         return rc;
+      }
+      
+      // Send out to the CCS array 
+      rc = mss_ccs_inst_arry_0( i_target,
+   	       io_ccs_inst_cnt,
+   	       address_16,
+   	       bank_3,
+   	       activate_1,
+   	       rasn_1,
+   	       casn_1,
+   	       wen_1,
+   	       cke_4,
+   	       csn_8,
+   	       odt_4,
+   	       ddr_cal_type_4,
+   	       i_port_number);
+      if(rc) return rc;
+      rc = mss_ccs_inst_arry_1( i_target,
+   	       io_ccs_inst_cnt,
+   	       num_idles_16,
+   	       num_repeat_16,
+   	       data_20,
+   	       read_compare_1,
+   	       rank_cal_4,
+   	       ddr_cal_enable_1,
+   	       ccs_end_1);
+      if(rc) return rc;
+      io_ccs_inst_cnt ++;
+   }
+   
+   
+   //sets a NOP as the last command
+   rc_num = rc_num | cke_4.setBit(0,4);
+   rc_num = rc_num | csn_8.setBit(0,8);
+   rc_num = rc_num | address_16.clearBit(0, 16);
+   rc_num = rc_num | rasn_1.setBit(0,1);
+   rc_num = rc_num | casn_1.setBit(0,1);
+   rc_num = rc_num | wen_1.setBit(0,1);
+   
+   if(rc_num)
+   {
+       rc.setEcmdError(rc_num);
+       return rc;
+   }
+   
+   // Send out to the CCS array 
+   rc = mss_ccs_inst_arry_0( i_target,
+   	    io_ccs_inst_cnt,
+   	    address_16,
+   	    bank_3,
+   	    activate_1,
+   	    rasn_1,
+   	    casn_1,
+   	    wen_1,
+   	    cke_4,
+   	    csn_8,
+   	    odt_4,
+   	    ddr_cal_type_4,
+   	    i_port_number);
+   if(rc) return rc;
+   rc = mss_ccs_inst_arry_1( i_target,
+   	    io_ccs_inst_cnt,
+   	    num_idles_16,
+   	    num_repeat_16,
+   	    data_20,
+   	    read_compare_1,
+   	    rank_cal_4,
+   	    ddr_cal_enable_1,
+   	    ccs_end_1);
+   if(rc) return rc;
+   io_ccs_inst_cnt ++;
+   
+   //Setup end bit for CCS
+   rc = mss_ccs_set_end_bit (i_target, io_ccs_inst_cnt-1);
+   if (rc) return rc;
+   
+   //Execute the CCS array
+   FAPI_INF("Executing the CCS array\n");
+   rc = mss_execute_ccs_inst_array (i_target, 100, 60);
+   if(rc) return rc;
+    
+    return rc;
+
+}
+
+
+//////////////////////////////////////////////////////////////////////////////////
+/// mss_ddr4_modify_mrs_pda
+/// disables per-DRAM addressability funcitonality on both ports on the passed MBA
+//////////////////////////////////////////////////////////////////////////////////
+ReturnCode mss_ddr4_modify_mrs_pda(Target& i_target,ecmdDataBufferBase& address_16,uint32_t attribute_name,uint8_t attribute_data) {
+   ReturnCode rc;
+   uint32_t rc_num = 0;
+   uint8_t dram_bl = attribute_data;
+   uint8_t read_bt = attribute_data; //Read Burst Type 
+   uint8_t dram_cl = attribute_data;
+   uint8_t test_mode = attribute_data; //TEST MODE 
+   uint8_t dll_reset = attribute_data; //DLL Reset 
+   uint8_t dram_wr = attribute_data; //DRAM write recovery
+   uint8_t dram_rtp = attribute_data; //DRAM RTP - read to precharge
+   uint8_t dram_wr_rtp = attribute_data;
+   uint8_t dll_precharge = attribute_data; //DLL Control For Precharge if (dll_precharge == ENUM_ATTR_EFF_DRAM_DLL_PPD_SLOWEXIT)
+   uint8_t dll_enable = attribute_data; //DLL Enable 
+   uint8_t out_drv_imp_cntl = attribute_data;
+   uint8_t dram_rtt_nom = attribute_data;
+   uint8_t dram_al = attribute_data;
+   uint8_t wr_lvl = attribute_data; //write leveling enable
+   uint8_t tdqs_enable = attribute_data; //TDQS Enable 
+   uint8_t q_off = attribute_name; //Qoff - Output buffer Enable 
+   uint8_t lpasr = attribute_data; // Low Power Auto Self-Refresh -- new not yet supported
+   uint8_t cwl = attribute_data; // CAS Write Latency 
+   uint8_t dram_rtt_wr = attribute_data;
+   uint8_t mpr_op = attribute_data; // MPR Op
+   uint8_t mpr_page = attribute_data; // MPR Page Selection  
+   uint8_t geardown_mode = attribute_data; // Gear Down Mode  
+   uint8_t temp_readout = attribute_data; // Temperature sensor readout  
+   uint8_t fine_refresh = attribute_data; // fine refresh mode  
+   uint8_t wr_latency = attribute_data; // write latency for CRC and DM  
+   uint8_t write_crc = attribute_data; // CAS Write Latency 
+   uint8_t read_format = attribute_data; // MPR READ FORMAT  
+   uint8_t max_pd_mode = attribute_data; // Max Power down mode 
+   uint8_t temp_ref_range = attribute_data; // Temp ref range 
+   uint8_t temp_ref_mode = attribute_data; // Temp controlled ref mode 
+   uint8_t vref_mon = attribute_data; // Internal Vref Monitor 
+   uint8_t cs_cmd_latency = attribute_data; // CS to CMD/ADDR Latency 
+   uint8_t ref_abort = attribute_data; // Self Refresh Abort 
+   uint8_t rd_pre_train_mode = attribute_data; // Read Pre amble Training Mode 
+   uint8_t rd_preamble = attribute_data; // Read Pre amble 
+   uint8_t wr_preamble = attribute_data; // Write Pre amble 
+   uint8_t ca_parity_latency = attribute_data; //C/A Parity Latency Mode  
+   uint8_t crc_error_clear = attribute_data; //CRC Error Clear  
+   uint8_t ca_parity_error_status = attribute_data; //C/A Parity Error Status  
+   uint8_t odt_input_buffer = attribute_data; //ODT Input Buffer during power down  
+   uint8_t rtt_park = attribute_data; //RTT_Park value  
+   uint8_t ca_parity = attribute_data; //CA Parity Persistance Error  
+   uint8_t data_mask = attribute_data; //Data Mask  
+   uint8_t write_dbi = attribute_data; //Write DBI  
+   uint8_t read_dbi = attribute_data; //Read DBI  
+   uint8_t vrefdq_train_value = attribute_data; //vrefdq_train value   
+   uint8_t vrefdq_train_range = attribute_data; //vrefdq_train range   
+   uint8_t vrefdq_train_enable = attribute_data; //vrefdq_train enable  
+   uint8_t tccd_l = attribute_data; //tccd_l  
+   uint8_t dram_access;
+
+   switch (attribute_name) {
+       case ATTR_EFF_DRAM_BL:
+	   if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_BL8)
+           {
+               dram_bl = 0x00;
+           }
+           else if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_OTF)
+           {
+               dram_bl = 0x80;
+           }
+           else if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_BC4)
+           {
+               dram_bl = 0x40;
+           }
+	   rc_num = rc_num | address_16.insert((uint8_t) dram_bl, 0, 2, 0);
+	   break;
+       case ATTR_EFF_DRAM_RBT:
+	   if (read_bt == ENUM_ATTR_EFF_DRAM_RBT_SEQUENTIAL)
+           {
+               read_bt = 0x00;
+           }
+           else if (read_bt == ENUM_ATTR_EFF_DRAM_RBT_INTERLEAVE)
+           {
+               read_bt = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) read_bt, 3, 1, 0);
+	   break;
+       case ATTR_EFF_DRAM_CL:
+	   if ((dram_cl > 8)&&(dram_cl < 17))
+           {
+               dram_cl = dram_cl - 9; 
+           }
+           else if ((dram_cl > 17)&&(dram_cl < 25))
+           {
+               dram_cl = (dram_cl >> 1) - 1;   
+           }
+           dram_cl = mss_reverse_8bits(dram_cl);
+           rc_num = rc_num | address_16.insert((uint8_t) dram_cl, 2, 1, 0);
+           rc_num = rc_num | address_16.insert((uint8_t) dram_cl, 4, 3, 1);
+	   break;
+       case ATTR_EFF_DRAM_TM:
+	   if (test_mode == ENUM_ATTR_EFF_DRAM_TM_NORMAL)
+           {
+               test_mode = 0x00;
+           }
+           else if (test_mode == ENUM_ATTR_EFF_DRAM_TM_TEST)
+           {
+               test_mode = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) test_mode, 7, 1);
+	   break;
+       case ATTR_EFF_DRAM_DLL_RESET:
+	   dll_reset = 0x00;
+	   FAPI_ERR( "ERROR: ATTR_EFF_DRAM_DLL_RESET accessed during PDA functionality, overwritten");
+           rc_num = rc_num | address_16.insert((uint8_t) dll_reset, 8, 1);
+	   break;
+       case ATTR_EFF_DRAM_WR:
+           if ( (dram_wr == 10) )//&& (dram_rtp == 5) )
+           {
+               dram_wr_rtp = 0x00;
+           }
+           else if ( (dram_wr == 12) )//&& (dram_rtp == 6) )
+           {
+               dram_wr_rtp = 0x80;
+           }
+           else if ( (dram_wr == 13) )//&& (dram_rtp == 7) )
+           {
+               dram_wr_rtp = 0x40;
+           }
+           else if ( (dram_wr == 14) )//&& (dram_rtp == 8) )
+           {
+               dram_wr_rtp = 0xC0;
+           }
+           else if ( (dram_wr == 18) )//&& (dram_rtp == 9) )
+           {
+               dram_wr_rtp = 0x20;
+           }
+           else if ( (dram_wr == 20) )//&& (dram_rtp == 10) )
+           {
+               dram_wr_rtp = 0xA0;
+           }
+           else if ( (dram_wr == 24) )//&& (dram_rtp == 12) )
+           {
+               dram_wr_rtp = 0x60;
+           }
+    	   rc_num = rc_num | address_16.insert((uint8_t) dram_wr_rtp, 9, 3);
+	   break;
+       case ATTR_EFF_DRAM_TRTP:
+           if ( (dram_rtp == 5) )
+           {
+               dram_wr_rtp = 0x00;
+           }
+           else if ( (dram_rtp == 6) )
+           {
+               dram_wr_rtp = 0x80;
+           }
+           else if ( (dram_rtp == 7) )
+           {
+               dram_wr_rtp = 0x40;
+           }
+           else if ( (dram_rtp == 8) )
+           {
+               dram_wr_rtp = 0xC0;
+           }
+           else if ( (dram_rtp == 9) )
+           {
+               dram_wr_rtp = 0x20;
+           }
+           else if ( (dram_rtp == 10) )
+           {
+               dram_wr_rtp = 0xA0;
+           }
+           else if ( (dram_rtp == 12) )
+           {
+               dram_wr_rtp = 0x60;
+           }
+    	   rc_num = rc_num | address_16.insert((uint8_t) dram_wr_rtp, 9, 3);
+	   break;
+       case ATTR_EFF_DRAM_DLL_PPD:
+           if (dll_precharge == ENUM_ATTR_EFF_DRAM_DLL_PPD_SLOWEXIT)
+	   {
+               dll_precharge = 0x00;
+           }
+           else if (dll_precharge == ENUM_ATTR_EFF_DRAM_DLL_PPD_FASTEXIT)
+           {
+               dll_precharge = 0xFF;
+           }
+	   FAPI_INF("ERROR: ATTR_EFF_DRAM_DLL_PPD is an unused MRS value!!! Skipping...");
+	   break;
+       case ATTR_EFF_DRAM_DLL_ENABLE:
+           if (dll_enable == ENUM_ATTR_EFF_DRAM_DLL_ENABLE_DISABLE)
+           {
+               dll_enable = 0x00;
+           }
+           else if (dll_enable == ENUM_ATTR_EFF_DRAM_DLL_ENABLE_ENABLE)
+           {
+               dll_enable = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) dll_enable, 0, 1, 0);
+	   break;
+       case ATTR_VPD_DRAM_RON:
+	   if (out_drv_imp_cntl == ENUM_ATTR_VPD_DRAM_RON_OHM34)
+           {
+               out_drv_imp_cntl = 0x00;
+           }
+    	   // Not currently supported
+           else if (out_drv_imp_cntl == ENUM_ATTR_VPD_DRAM_RON_OHM48) //not supported
+           {
+               out_drv_imp_cntl = 0x80;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) out_drv_imp_cntl, 1, 2, 0);
+	   break;
+       case ATTR_VPD_DRAM_RTT_NOM:
+	   if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_DISABLE)
+           {
+               dram_rtt_nom = 0x00;
+           }
+           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM240) //not supported
+           {
+               dram_rtt_nom = 0x20;
+           }
+           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM48) //not supported
+           {
+               dram_rtt_nom = 0xA0;
+           }
+           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM40)
+           {
+               dram_rtt_nom = 0xC0;
+           }
+           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM60)
+           {
+               dram_rtt_nom = 0x80;
+           }
+           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM120)
+           {
+               dram_rtt_nom = 0x40;
+           }
+           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM80) // not supported
+           {
+               dram_rtt_nom = 0x60;
+           }
+           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM34) // not supported
+           {
+               dram_rtt_nom = 0xE0;
+           }
+	   
+           rc_num = rc_num | address_16.insert((uint8_t) dram_rtt_nom, 8, 3, 0);
+	   break;
+       case ATTR_EFF_DRAM_AL:
+	   if (dram_al == ENUM_ATTR_EFF_DRAM_AL_DISABLE)
+           {
+               dram_al = 0x00;
+           }
+           else if (dram_al == ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_1)
+           {
+               dram_al = 0x80;
+           }
+           else if (dram_al == ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_2)
+           {
+               dram_al = 0x40;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) dram_al, 3, 2, 0);
+	   break;
+       case ATTR_EFF_DRAM_WR_LVL_ENABLE:
+	   if (wr_lvl == ENUM_ATTR_EFF_DRAM_WR_LVL_ENABLE_DISABLE)
+           {
+               wr_lvl = 0x00;
+           }
+           else if (wr_lvl == ENUM_ATTR_EFF_DRAM_WR_LVL_ENABLE_ENABLE)
+           {
+               wr_lvl = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) wr_lvl, 7, 1, 0);
+	   break;
+       case ATTR_EFF_DRAM_TDQS:
+	   if (tdqs_enable == ENUM_ATTR_EFF_DRAM_TDQS_DISABLE)
+           {
+               tdqs_enable = 0x00;
+           }
+           else if (tdqs_enable == ENUM_ATTR_EFF_DRAM_TDQS_ENABLE)
+           {
+               tdqs_enable = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) tdqs_enable, 11, 1, 0);
+	   break;
+       case ATTR_EFF_DRAM_OUTPUT_BUFFER:
+           if (q_off == ENUM_ATTR_EFF_DRAM_OUTPUT_BUFFER_DISABLE)
+           {
+               q_off = 0xFF;
+           }
+           else if (q_off == ENUM_ATTR_EFF_DRAM_OUTPUT_BUFFER_ENABLE)
+           {
+               q_off = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) q_off, 12, 1, 0);
+	   break;
+       case ATTR_EFF_DRAM_LPASR:
+           if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_NORMAL)
+           {
+               lpasr = 0x00;
+           }
+           else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_REDUCED)
+           {
+               lpasr = 0x80;
+           }
+           else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_EXTENDED)
+           {
+               lpasr = 0x40;
+           }
+           else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_ASR)
+           {
+               lpasr = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) lpasr, 6, 2);
+	   break;
+       case ATTR_EFF_DRAM_CWL:
+	   if ((cwl > 8)&&(cwl < 13))
+           {
+               cwl = cwl - 9; 
+           }
+           else if ((cwl > 13)&&(cwl < 19))
+           {
+               cwl = (cwl >> 1) - 3;   
+           }
+           else
+           {
+              //no correcct value for CWL was found
+              FAPI_INF("ERROR: Improper CWL value found. Setting CWL to 9 and continuing...");
+              cwl = 0;
+           }
+	   cwl = mss_reverse_8bits(cwl);
+	   rc_num = rc_num | address_16.insert((uint8_t) cwl, 3, 3);
+	   break;
+       case ATTR_VPD_DRAM_RTT_WR:
+	   if (dram_rtt_wr == ENUM_ATTR_VPD_DRAM_RTT_WR_DISABLE)
+           {
+               dram_rtt_wr = 0x00;
+           }
+           else if (dram_rtt_wr == ENUM_ATTR_VPD_DRAM_RTT_WR_OHM120)
+           {
+               dram_rtt_wr = 0x80;
+           }
+           else if (dram_rtt_wr == 240)//ENUM_ATTR_EFF_DRAM_RTT_WR_OHM240)
+           {
+               dram_rtt_wr = 0x40;
+           }
+           else if (dram_rtt_wr == 0xFF)//ENUM_ATTR_EFF_DRAM_RTT_WR_HIGHZ)
+           {
+               dram_rtt_wr = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) dram_rtt_wr, 9, 2);
+           break;
+       case ATTR_EFF_WRITE_CRC:
+	   if ( write_crc == ENUM_ATTR_EFF_WRITE_CRC_ENABLE)
+           {
+               write_crc = 0xFF;
+           }
+           else if (write_crc == ENUM_ATTR_EFF_WRITE_CRC_DISABLE)
+           {
+               write_crc = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) write_crc, 12, 1);
+	   break;
+       case ATTR_EFF_MPR_MODE:
+	   if (mpr_op == ENUM_ATTR_EFF_MPR_MODE_ENABLE)
+           {
+               mpr_op = 0xFF;
+           }
+           else if (mpr_op == ENUM_ATTR_EFF_MPR_MODE_DISABLE)
+           {
+               mpr_op = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) mpr_op, 2, 1);
+	   break;
+       case ATTR_EFF_MPR_PAGE:
+           mpr_page = mss_reverse_8bits(mpr_page);
+    	   rc_num = rc_num | address_16.insert((uint8_t) mpr_page, 0, 2);
+	   break;
+       case ATTR_EFF_GEARDOWN_MODE:
+	   if ( geardown_mode == ENUM_ATTR_EFF_GEARDOWN_MODE_HALF)
+           {
+        	geardown_mode = 0x00;
+           }
+           else if ( geardown_mode == ENUM_ATTR_EFF_GEARDOWN_MODE_QUARTER)
+           {
+        	geardown_mode = 0xFF;
+           }
+           
+           if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_ENABLE)
+           {
+               temp_readout = 0xFF;
+           }
+           else if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_DISABLE)
+           {
+               temp_readout = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) geardown_mode, 3, 1);
+	   break;
+       case ATTR_EFF_TEMP_READOUT:
+	   if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_ENABLE)
+    	   {
+    	       temp_readout = 0xFF;
+    	   }
+    	   else if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_DISABLE)
+    	   {
+    	       temp_readout = 0x00;
+    	   }
+           rc_num = rc_num | address_16.insert((uint8_t) temp_readout, 5, 1);
+	   break;
+       case ATTR_EFF_FINE_REFRESH_MODE:
+	   if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_NORMAL)
+           {
+               fine_refresh = 0x00;
+           }
+           else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FIXED_2X)
+           {
+               fine_refresh = 0x80;
+           }
+           else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FIXED_4X)
+           {
+               fine_refresh = 0x40;
+           }
+           else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FLY_2X)
+           {
+               fine_refresh = 0xA0;
+           }
+           else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FLY_4X)
+           {
+               fine_refresh = 0x60;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) fine_refresh, 6, 3);
+	   break;
+       case ATTR_EFF_CRC_WR_LATENCY:
+           if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_4NCK)
+           {
+               wr_latency = 0x00;
+           }
+           else if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_5NCK)
+           {
+               wr_latency = 0x80;
+           }
+           else if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_6NCK)
+           {
+               wr_latency = 0xC0;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) wr_latency, 9, 2);
+	   break;
+       case ATTR_EFF_MPR_RD_FORMAT:
+           if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_SERIAL)
+           {
+               read_format = 0x00;
+           }
+           else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_PARALLEL)
+           {
+               read_format = 0x80;
+           }
+           else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_STAGGERED)
+           {
+               read_format = 0x40;
+           }
+           else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_RESERVED_TEMP)
+           {
+               read_format = 0xC0;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) read_format, 11, 2);
+	   break;
+       case ATTR_EFF_PER_DRAM_ACCESS:
+           FAPI_INF("ERROR: ATTR_EFF_PER_DRAM_ACCESS selected.  Forcing PDA to be on for this function");
+	   dram_access = 0xFF;
+	   rc_num = rc_num | address_16.insert((uint8_t) dram_access, 4, 1);
+	   break;
+       case ATTR_EFF_MAX_POWERDOWN_MODE:
+	   if ( max_pd_mode == ENUM_ATTR_EFF_MAX_POWERDOWN_MODE_ENABLE)
+           {
+               max_pd_mode = 0xF0;
+           }
+           else if ( max_pd_mode == ENUM_ATTR_EFF_MAX_POWERDOWN_MODE_DISABLE)
+           {
+               max_pd_mode = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) max_pd_mode, 1, 1);
+	   break;
+       case ATTR_EFF_TEMP_REF_RANGE:
+	   if (temp_ref_range == ENUM_ATTR_EFF_TEMP_REF_RANGE_NORMAL)
+           {
+               temp_ref_range = 0x00;
+           }
+           else if ( temp_ref_range== ENUM_ATTR_EFF_TEMP_REF_RANGE_EXTEND)
+           {
+               temp_ref_range = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) temp_ref_range, 2, 1);
+	   break;
+       case ATTR_EFF_TEMP_REF_MODE:
+	   if (temp_ref_mode == ENUM_ATTR_EFF_TEMP_REF_MODE_ENABLE)
+           {
+               temp_ref_mode = 0x80;
+           }
+           else if (temp_ref_mode == ENUM_ATTR_EFF_TEMP_REF_MODE_DISABLE)
+           {
+               temp_ref_mode = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) temp_ref_mode, 3, 1);
+	   break;
+       case ATTR_EFF_INT_VREF_MON:
+	   if ( vref_mon == ENUM_ATTR_EFF_INT_VREF_MON_ENABLE)
+           {
+               vref_mon = 0xFF;
+           }
+           else if ( vref_mon == ENUM_ATTR_EFF_INT_VREF_MON_DISABLE)
+           {
+               vref_mon = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) vref_mon, 4, 1);
+	   break;
+       case ATTR_EFF_CS_CMD_LATENCY:
+	   if ( cs_cmd_latency == 3)
+           {
+               cs_cmd_latency = 0x80;
+           }
+           else if (cs_cmd_latency == 4)
+           {
+               cs_cmd_latency = 0x40;
+           }
+           else if (cs_cmd_latency == 5)
+           {
+               cs_cmd_latency = 0xC0;
+           }
+           else if (cs_cmd_latency == 6)
+           {
+               cs_cmd_latency = 0x20;
+           }
+           else if (cs_cmd_latency == 8)
+           {
+               cs_cmd_latency = 0xA0;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) cs_cmd_latency, 6, 3);
+	   break;
+       case ATTR_EFF_SELF_REF_ABORT:
+	   if (ref_abort == ENUM_ATTR_EFF_SELF_REF_ABORT_ENABLE)
+           {
+               ref_abort = 0xFF;
+           }
+           else if (ref_abort == ENUM_ATTR_EFF_SELF_REF_ABORT_DISABLE)
+           {
+               ref_abort = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) ref_abort, 9, 1);
+	   break;
+       case ATTR_EFF_RD_PREAMBLE_TRAIN:
+	   if (rd_pre_train_mode == ENUM_ATTR_EFF_RD_PREAMBLE_TRAIN_ENABLE)
+           {
+               rd_pre_train_mode = 0xFF;
+           }
+           else if (rd_pre_train_mode == ENUM_ATTR_EFF_RD_PREAMBLE_TRAIN_DISABLE)
+           {
+               rd_pre_train_mode = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) rd_pre_train_mode, 10, 1);
+	   break;
+       case ATTR_EFF_RD_PREAMBLE:
+	   if (rd_preamble == ENUM_ATTR_EFF_RD_PREAMBLE_1NCLK)
+           {
+               rd_preamble = 0x00;
+           }
+           else if (rd_preamble == ENUM_ATTR_EFF_RD_PREAMBLE_2NCLK)
+           {
+               rd_preamble = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) rd_preamble, 11, 1);
+	   break;
+       case ATTR_EFF_WR_PREAMBLE:
+           if (wr_preamble == ENUM_ATTR_EFF_WR_PREAMBLE_1NCLK)
+           {
+               wr_preamble = 0x00;
+           }
+           else if (wr_preamble == ENUM_ATTR_EFF_WR_PREAMBLE_2NCLK)
+           {
+               wr_preamble = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) wr_preamble, 12, 1);
+	   break;
+       case ATTR_EFF_CA_PARITY_LATENCY:
+	   if (ca_parity_latency == 4)
+           {
+               ca_parity_latency = 0x80;
+           }
+           else if (ca_parity_latency == 5)
+           {
+               ca_parity_latency = 0x40;
+           }
+           else if (ca_parity_latency == 6)
+           {
+               ca_parity_latency = 0xC0;
+           }
+           else if (ca_parity_latency == 8)
+           {
+               ca_parity_latency = 0x20;
+           }
+           else if (ca_parity_latency == ENUM_ATTR_EFF_CA_PARITY_LATENCY_DISABLE)
+           {
+               ca_parity_latency = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) ca_parity_latency, 0, 2);
+	   break;
+       case ATTR_EFF_CRC_ERROR_CLEAR:
+	   if (crc_error_clear == ENUM_ATTR_EFF_CRC_ERROR_CLEAR_ERROR)
+           {
+               crc_error_clear = 0xFF;
+           }
+           else if (crc_error_clear == ENUM_ATTR_EFF_CRC_ERROR_CLEAR_CLEAR)
+           {
+               crc_error_clear = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) crc_error_clear, 3, 1);
+	   break;
+       case ATTR_EFF_CA_PARITY_ERROR_STATUS:
+	   if (ca_parity_error_status == ENUM_ATTR_EFF_CA_PARITY_ERROR_STATUS_ERROR)
+           {
+               ca_parity_error_status = 0xFF;
+           }
+           else if (ca_parity_error_status == ENUM_ATTR_EFF_CA_PARITY_ERROR_STATUS_CLEAR)
+           {
+               ca_parity_error_status = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) ca_parity_error_status, 4, 1);
+	   break;
+       case ATTR_EFF_ODT_INPUT_BUFF:
+	   if (odt_input_buffer == ENUM_ATTR_EFF_ODT_INPUT_BUFF_ACTIVATED)
+           {
+               odt_input_buffer = 0x00;
+           }
+           else if (odt_input_buffer == ENUM_ATTR_EFF_ODT_INPUT_BUFF_DEACTIVATED)
+           {
+               odt_input_buffer = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) odt_input_buffer, 5, 1);
+	   break;
+       case ATTR_VPD_DRAM_RTT_PARK:
+	   if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_DISABLE)
+           {
+               rtt_park = 0x00;
+           }
+           else if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_60OHM)
+           {
+               rtt_park = 0x80;
+           }
+           else if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_40OHM)
+           {
+               rtt_park = 0xC0;
+           }
+           else if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_120OHM)
+           {
+               rtt_park = 0x40;
+           }
+           else if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_240OHM)
+           {
+               rtt_park = 0x20;
+           }
+           else if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_48OHM)
+           {
+               rtt_park = 0xA0;
+           }
+           else if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_80OHM)
+           {
+               rtt_park = 0x60;
+           }
+           else if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_34OHM)
+           {
+               rtt_park = 0xE0;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) rtt_park, 6, 3);
+	   break;
+       case ATTR_EFF_CA_PARITY:
+	   if (ca_parity == ENUM_ATTR_EFF_CA_PARITY_ENABLE)
+           {
+               ca_parity = 0xFF;
+           }
+           else if (ca_parity == ENUM_ATTR_EFF_CA_PARITY_DISABLE)
+           {
+               ca_parity = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) ca_parity, 9, 1);
+	   break;
+       case ATTR_EFF_DATA_MASK:
+	   if (data_mask == ENUM_ATTR_EFF_DATA_MASK_DISABLE)
+           {
+               data_mask = 0x00;
+           }
+           else if (data_mask == ENUM_ATTR_EFF_DATA_MASK_ENABLE)
+           {
+               data_mask = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) data_mask, 10, 1);
+	   break;
+       case ATTR_EFF_WRITE_DBI:
+	   if (write_dbi == ENUM_ATTR_EFF_WRITE_DBI_DISABLE)
+           {
+               write_dbi = 0x00;
+           }
+           else if (write_dbi == ENUM_ATTR_EFF_WRITE_DBI_ENABLE)
+           {
+               write_dbi = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) write_dbi, 11, 1);
+	   break;
+       case ATTR_EFF_READ_DBI:
+           if (read_dbi == ENUM_ATTR_EFF_READ_DBI_DISABLE)
+           {
+               read_dbi = 0x00;
+           }
+           else if (read_dbi == ENUM_ATTR_EFF_READ_DBI_ENABLE)
+           {
+               read_dbi = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) read_dbi, 12, 1);
+	   break;
+       case ATTR_EFF_VREF_DQ_TRAIN_VALUE:
+	   vrefdq_train_value = mss_reverse_8bits(vrefdq_train_value);
+           rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_value, 0, 6);
+	   break;
+       case ATTR_EFF_VREF_DQ_TRAIN_RANGE:
+	   if (vrefdq_train_range == ENUM_ATTR_EFF_VREF_DQ_TRAIN_RANGE_RANGE1)
+           {
+               vrefdq_train_range = 0x00;
+           }
+           else if (vrefdq_train_range == ENUM_ATTR_EFF_VREF_DQ_TRAIN_RANGE_RANGE2)
+           {
+               vrefdq_train_range = 0xFF;
+           } 
+           rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_range, 6, 1);
+	   break;
+       case ATTR_EFF_VREF_DQ_TRAIN_ENABLE:
+	   if (vrefdq_train_enable == ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE)
+           {
+               vrefdq_train_enable = 0xFF;
+           }
+           else if (vrefdq_train_enable == ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_DISABLE)
+           {
+               vrefdq_train_enable = 0x00;
+           }   
+           rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_enable, 7, 1);
+	   break;
+       case ATTR_TCCD_L:
+           if (tccd_l == 4)
+           {
+               tccd_l = 0x00;
+           }
+           else if (tccd_l == 5)
+           {
+               tccd_l = 0x80;
+           }
+           else if (tccd_l == 6)
+           {
+               tccd_l = 0x40;
+           }	
+           else if (tccd_l == 7)
+           {
+               tccd_l = 0xC0;
+           }
+           else if (tccd_l == 8)
+           {
+               tccd_l = 0x20;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) tccd_l, 10, 3);
+	   break;
+	//MRS attribute not found, error out
+      default: 
+         const uint32_t NONMRS_ATTR_NAME = attribute_name;
+	 const fapi::Target & MBA_TARGET = i_target; 
+	 FAPI_SET_HWP_ERROR(rc, RC_MSS_PDA_NONMRS_ATTR_NAME);
+	 FAPI_ERR("ERROR!! Found attribute name not associated with an MRS! Exiting...");
+   }
+   if (rc_num)
+   {
+       FAPI_ERR( "mss_ddr4_modify_mrs_pda: Error setting up buffers");
+       rc.setEcmdError(rc_num);
+       return rc;
+   }
+   return rc;
+}
+
+//////////////////////////////////////////////////////////////////////////////////
+/// mss_ddr4_load_nominal_mrs_pda
+/// disables per-DRAM addressability funcitonality on both ports on the passed MBA
+//////////////////////////////////////////////////////////////////////////////////
+ReturnCode mss_ddr4_load_nominal_mrs_pda(Target& i_target,ecmdDataBufferBase& bank_3,ecmdDataBufferBase& address_16,uint8_t MRS,uint8_t i_port_number, uint8_t dimm_number, uint8_t rank_number) {
+    ReturnCode rc;  
+    ReturnCode rc_buff;
+    uint32_t rc_num = 0;
+    
+    rc_num = rc_num | address_16.clearBit(0,16);
+    rc_num = rc_num | bank_3.clearBit(0,3);
+    if (rc_num)
+    {
+    	FAPI_ERR( "mss_mrs_load: Error setting up buffers");
+    	rc_buff.setEcmdError(rc_num);
+    	return rc_buff;
+    }
+
+    //Lines commented out in the following section are waiting for xml attribute adds
+    //MRS0
+    if(MRS == MRS0_BA) {
+    	uint8_t dram_bl;
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_BL, &i_target, dram_bl);
+    	if(rc) return rc;
+    	uint8_t read_bt; //Read Burst Type 
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_RBT, &i_target, read_bt);
+    	if(rc) return rc;
+    	uint8_t dram_cl;
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_CL, &i_target, dram_cl);
+    	if(rc) return rc;
+    	uint8_t test_mode; //TEST MODE 
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_TM, &i_target, test_mode);
+    	if(rc) return rc;
+    	uint8_t dll_reset; //DLL Reset 
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_DLL_RESET, &i_target, dll_reset);
+    	if(rc) return rc;
+    	uint8_t dram_wr; //DRAM write recovery
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_WR, &i_target, dram_wr);
+    	if(rc) return rc;
+    	uint8_t dram_rtp; //DRAM RTP - read to precharge
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_TRTP, &i_target, dram_rtp);
+    	if(rc) return rc;
+    	uint8_t dll_precharge; //DLL Control For Precharge 
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_DLL_PPD, &i_target, dll_precharge);
+    	if(rc) return rc;
+
+    	if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_BL8)
+    	{
+    	    dram_bl = 0x00;
+    	}
+    	else if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_OTF)
+    	{
+    	    dram_bl = 0x80;
+    	}
+    	else if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_BC4)
+    	{
+    	    dram_bl = 0x40;
+    	}
+
+    	uint8_t dram_wr_rtp = 0x00;
+    	if ( (dram_wr == 10) )//&& (dram_rtp == 5) )
+    	{
+    	    dram_wr_rtp = 0x00;
+    	}
+    	else if ( (dram_wr == 12) )//&& (dram_rtp == 6) )
+    	{
+    	    dram_wr_rtp = 0x80;
+    	}
+    	else if ( (dram_wr == 13) )//&& (dram_rtp == 7) )
+    	{
+    	    dram_wr_rtp = 0x40;
+    	}
+    	else if ( (dram_wr == 14) )//&& (dram_rtp == 8) )
+    	{
+    	    dram_wr_rtp = 0xC0;
+    	}
+    	else if ( (dram_wr == 18) )//&& (dram_rtp == 9) )
+    	{
+    	    dram_wr_rtp = 0x20;
+    	}
+    	else if ( (dram_wr == 20) )//&& (dram_rtp == 10) )
+    	{
+    	    dram_wr_rtp = 0xA0;
+    	}
+    	else if ( (dram_wr == 24) )//&& (dram_rtp == 12) )
+    	{
+    	    dram_wr_rtp = 0x60;
+    	}
+
+    	if (read_bt == ENUM_ATTR_EFF_DRAM_RBT_SEQUENTIAL)
+    	{
+    	    read_bt = 0x00;
+    	}
+    	else if (read_bt == ENUM_ATTR_EFF_DRAM_RBT_INTERLEAVE)
+    	{
+    	    read_bt = 0xFF;
+    	}
+
+    	if ((dram_cl > 8)&&(dram_cl < 17))
+    	{
+    	    dram_cl = dram_cl - 9; 
+    	}
+    	else if ((dram_cl > 17)&&(dram_cl < 25))
+    	{
+    	    dram_cl = (dram_cl >> 1) - 1;   
+    	}
+    	dram_cl = mss_reverse_8bits(dram_cl);
+
+    	if (test_mode == ENUM_ATTR_EFF_DRAM_TM_NORMAL)
+    	{
+    	    test_mode = 0x00;
+    	}
+    	else if (test_mode == ENUM_ATTR_EFF_DRAM_TM_TEST)
+    	{
+    	    test_mode = 0xFF;
+    	}
+	
+	FAPI_INF("Overwriting DLL reset with values to not reset the DRAM.");
+    	dll_reset = 0x00;
+
+    	if (dll_precharge == ENUM_ATTR_EFF_DRAM_DLL_PPD_SLOWEXIT)
+    	{
+    	    dll_precharge = 0x00;
+    	}
+    	else if (dll_precharge == ENUM_ATTR_EFF_DRAM_DLL_PPD_FASTEXIT)
+    	{
+    	    dll_precharge = 0xFF;
+    	}
+	//For DDR4:
+	//Address 14 = Address 17, Address 15 = BG1
+        rc_num = rc_num | address_16.insert((uint8_t) dram_bl, 0, 2, 0);
+        rc_num = rc_num | address_16.insert((uint8_t) dram_cl, 2, 1, 0);
+        rc_num = rc_num | address_16.insert((uint8_t) read_bt, 3, 1, 0);
+        rc_num = rc_num | address_16.insert((uint8_t) dram_cl, 4, 3, 1);
+        rc_num = rc_num | address_16.insert((uint8_t) test_mode, 7, 1);
+        rc_num = rc_num | address_16.insert((uint8_t) dll_reset, 8, 1);
+	rc_num = rc_num | address_16.insert((uint8_t) dram_wr_rtp, 9, 3);
+	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 12, 4);
+	
+	rc_num = rc_num | bank_3.insert((uint8_t) MRS0_BA, 0, 1, 7);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS0_BA, 1, 1, 6);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS0_BA, 2, 1, 5);
+	if (rc_num)
+        {
+            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
+            rc_buff.setEcmdError(rc_num);
+            return rc_buff;
+        }
+    }
+    
+    //MRS1
+    else if(MRS == MRS1_BA) {
+    	uint8_t dll_enable; //DLL Enable 
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_DLL_ENABLE, &i_target, dll_enable);
+    	if(rc) return rc;
+    	uint8_t out_drv_imp_cntl[2][2];
+    	rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_RON, &i_target, out_drv_imp_cntl);
+    	if(rc) return rc;
+    	uint8_t dram_rtt_nom[2][2][4];
+    	rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_RTT_NOM, &i_target, dram_rtt_nom);
+    	if(rc) return rc;
+    	uint8_t dram_al;
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_AL, &i_target, dram_al);
+    	if(rc) return rc;
+    	uint8_t wr_lvl; //write leveling enable
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_WR_LVL_ENABLE, &i_target, wr_lvl);
+    	if(rc) return rc;
+    	uint8_t tdqs_enable; //TDQS Enable 
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_TDQS, &i_target, tdqs_enable);
+    	if(rc) return rc;
+    	uint8_t q_off; //Qoff - Output buffer Enable 
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_OUTPUT_BUFFER, &i_target, q_off);
+    	if(rc) return rc;
+
+    	if (dll_enable == ENUM_ATTR_EFF_DRAM_DLL_ENABLE_DISABLE)
+    	{
+    	    dll_enable = 0x00;
+    	}
+    	else if (dll_enable == ENUM_ATTR_EFF_DRAM_DLL_ENABLE_ENABLE)
+    	{
+    	    dll_enable = 0xFF;
+    	}
+
+    	if (dram_al == ENUM_ATTR_EFF_DRAM_AL_DISABLE)
+    	{
+    	    dram_al = 0x00;
+    	}
+    	else if (dram_al == ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_1)
+    	{
+    	    dram_al = 0x80;
+    	}
+    	else if (dram_al == ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_2)
+    	{
+    	    dram_al = 0x40;
+    	}
+
+    	if (wr_lvl == ENUM_ATTR_EFF_DRAM_WR_LVL_ENABLE_DISABLE)
+    	{
+    	    wr_lvl = 0x00;
+    	}
+    	else if (wr_lvl == ENUM_ATTR_EFF_DRAM_WR_LVL_ENABLE_ENABLE)
+    	{
+    	    wr_lvl = 0xFF;
+    	}
+
+    	if (tdqs_enable == ENUM_ATTR_EFF_DRAM_TDQS_DISABLE)
+    	{
+    	    tdqs_enable = 0x00;
+    	}
+    	else if (tdqs_enable == ENUM_ATTR_EFF_DRAM_TDQS_ENABLE)
+    	{
+    	    tdqs_enable = 0xFF;
+    	}
+
+    	if (q_off == ENUM_ATTR_EFF_DRAM_OUTPUT_BUFFER_DISABLE)
+    	{
+    	    q_off = 0xFF;
+    	}
+    	else if (q_off == ENUM_ATTR_EFF_DRAM_OUTPUT_BUFFER_ENABLE)
+    	{
+    	    q_off = 0x00;
+    	}
+        if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_DISABLE)
+        {
+            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0x00;
+        }
+        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM240) //not supported
+        {
+            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0x20;
+        }
+        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM48) //not supported
+        {
+            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0xA0;
+        }
+        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM40)
+        {
+            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0xC0;
+        }
+        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM60)
+        {
+            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0x80;
+        }
+        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM120)
+        {
+            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0x40;
+        }
+        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM80) // not supported
+        {
+            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0x60;
+        }
+        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM34) // not supported
+        {
+            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0xE0;
+        }
+
+        if (out_drv_imp_cntl[i_port_number][dimm_number] == ENUM_ATTR_VPD_DRAM_RON_OHM34)
+        {
+            out_drv_imp_cntl[i_port_number][dimm_number] = 0x00;
+        }
+	// Not currently supported
+        else if (out_drv_imp_cntl[i_port_number][dimm_number] == ENUM_ATTR_VPD_DRAM_RON_OHM48) //not supported
+        {
+            out_drv_imp_cntl[i_port_number][dimm_number] = 0x80;
+        }
+
+	//For DDR4:
+	//Address 14 = Address 17, Address 15 = BG1
+        rc_num = rc_num | address_16.insert((uint8_t) dll_enable, 0, 1, 0);
+        rc_num = rc_num | address_16.insert((uint8_t) out_drv_imp_cntl[i_port_number][dimm_number], 1, 2, 0);
+        rc_num = rc_num | address_16.insert((uint8_t) dram_al, 3, 2, 0);
+        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 5, 2);
+        rc_num = rc_num | address_16.insert((uint8_t) wr_lvl, 7, 1, 0);
+        rc_num = rc_num | address_16.insert((uint8_t) dram_rtt_nom[i_port_number][dimm_number][rank_number], 8, 3, 0);
+        rc_num = rc_num | address_16.insert((uint8_t) tdqs_enable, 11, 1, 0);
+        rc_num = rc_num | address_16.insert((uint8_t) q_off, 12, 1, 0);
+        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 13, 3);
+	
+	rc_num = rc_num | bank_3.insert((uint8_t) MRS1_BA, 0, 1, 7);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS1_BA, 1, 1, 6);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS1_BA, 2, 1, 5);
+	if (rc_num)
+        {
+            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
+            rc_buff.setEcmdError(rc_num);
+            return rc_buff;
+        }
+    }
+    //MRS2
+    else if(MRS == MRS2_BA) {
+    	uint8_t lpasr; // Low Power Auto Self-Refresh -- new not yet supported
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_LPASR, &i_target, lpasr);
+    	if(rc) return rc;
+    	uint8_t cwl; // CAS Write Latency 
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_CWL, &i_target, cwl);
+    	if(rc) return rc;
+    	uint8_t dram_rtt_wr[2][2][4];
+    	rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_RTT_WR, &i_target, dram_rtt_wr);
+    	if(rc) return rc;
+    	uint8_t write_crc; // CAS Write Latency 
+    	rc = FAPI_ATTR_GET(ATTR_EFF_WRITE_CRC, &i_target, write_crc);
+    	if(rc) return rc;
+
+    	if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_NORMAL)
+    	{
+    	    lpasr = 0x00;
+    	}
+    	else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_REDUCED)
+    	{
+    	    lpasr = 0x80;
+    	}
+    	else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_EXTENDED)
+    	{
+    	    lpasr = 0x40;
+    	}
+    	else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_ASR)
+    	{
+    	    lpasr = 0xFF;
+    	}
+
+    	if ((cwl > 8)&&(cwl < 13))
+    	{
+    	    cwl = cwl - 9; 
+    	}
+    	else if ((cwl > 13)&&(cwl < 19))
+    	{
+    	    cwl = (cwl >> 1) - 3;   
+    	}
+    	else
+    	{
+    	   //no correcct value for CWL was found
+    	   FAPI_INF("ERROR: Improper CWL value found. Setting CWL to 9 and continuing...");
+    	   cwl = 0;
+    	}
+    	cwl = mss_reverse_8bits(cwl);
+
+    	if ( write_crc == ENUM_ATTR_EFF_WRITE_CRC_ENABLE)
+    	{
+    	    write_crc = 0xFF;
+    	}
+    	else if (write_crc == ENUM_ATTR_EFF_WRITE_CRC_DISABLE)
+    	{
+    	    write_crc = 0x00;
+    	}
+	if (dram_rtt_wr[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_WR_DISABLE)
+        {
+            dram_rtt_wr[i_port_number][dimm_number][rank_number] = 0x00;
+        }
+        else if (dram_rtt_wr[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_WR_OHM120)
+        {
+            dram_rtt_wr[i_port_number][dimm_number][rank_number] = 0x80;
+        }
+        else if (dram_rtt_wr[i_port_number][dimm_number][rank_number] == 240)//ENUM_ATTR_EFF_DRAM_RTT_WR_OHM240)
+        {
+            dram_rtt_wr[i_port_number][dimm_number][rank_number] = 0x40;
+        }
+        else if (dram_rtt_wr[i_port_number][dimm_number][rank_number] == 0xFF)//ENUM_ATTR_EFF_DRAM_RTT_WR_HIGHZ)
+        {
+            dram_rtt_wr[i_port_number][dimm_number][rank_number] = 0xFF;
+        }
+
+        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 0, 3);
+        rc_num = rc_num | address_16.insert((uint8_t) cwl, 3, 3);
+        rc_num = rc_num | address_16.insert((uint8_t) lpasr, 6, 2);
+        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 8, 1);
+        rc_num = rc_num | address_16.insert((uint8_t) dram_rtt_wr[i_port_number][dimm_number][rank_number], 9, 2);
+        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 11, 1);
+        rc_num = rc_num | address_16.insert((uint8_t) write_crc, 12, 1);
+        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 13, 2);
+	
+	rc_num = rc_num | bank_3.insert((uint8_t) MRS2_BA, 0, 1, 7);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS2_BA, 1, 1, 6);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS2_BA, 2, 1, 5);
+	if (rc_num)
+        {
+            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
+            rc_buff.setEcmdError(rc_num);
+            return rc_buff;
+        }
+    }
+    //MRS3
+    else if(MRS == MRS3_BA) {
+    	uint8_t mpr_op; // MPR Op
+    	rc = FAPI_ATTR_GET(ATTR_EFF_MPR_MODE, &i_target, mpr_op);
+    	if(rc) return rc;
+    	uint8_t mpr_page; // MPR Page Selection  - NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_MPR_PAGE, &i_target, mpr_page);
+    	if(rc) return rc;
+    	uint8_t geardown_mode; // Gear Down Mode  - NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_GEARDOWN_MODE, &i_target, geardown_mode);
+    	if(rc) return rc;
+    	uint8_t temp_readout; // Temperature sensor readout  - NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_TEMP_READOUT, &i_target, temp_readout);
+    	if(rc) return rc;
+    	uint8_t fine_refresh; // fine refresh mode  - NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_FINE_REFRESH_MODE, &i_target, fine_refresh);
+    	if(rc) return rc;
+    	uint8_t wr_latency; // write latency for CRC and DM  - NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_CRC_WR_LATENCY, &i_target, wr_latency);
+    	if(rc) return rc;
+    	uint8_t read_format; // MPR READ FORMAT  - NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_MPR_RD_FORMAT, &i_target, read_format);
+    	if(rc) return rc;
+
+    	if (mpr_op == ENUM_ATTR_EFF_MPR_MODE_ENABLE)
+    	{
+    	    mpr_op = 0xFF;
+    	}
+    	else if (mpr_op == ENUM_ATTR_EFF_MPR_MODE_DISABLE)
+    	{
+    	    mpr_op = 0x00;
+    	}
+
+    	mpr_page = mss_reverse_8bits(mpr_page);
+
+    	if ( geardown_mode == ENUM_ATTR_EFF_GEARDOWN_MODE_HALF)
+    	{
+    	     geardown_mode = 0x00;
+    	}
+    	else if ( geardown_mode == ENUM_ATTR_EFF_GEARDOWN_MODE_QUARTER)
+    	{
+    	     geardown_mode = 0xFF;
+    	}
+    	
+    	if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_ENABLE)
+    	{
+    	    temp_readout = 0xFF;
+    	}
+    	else if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_DISABLE)
+    	{
+    	    temp_readout = 0x00;
+    	}
+
+    	if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_NORMAL)
+    	{
+    	    fine_refresh = 0x00;
+    	}
+    	else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FIXED_2X)
+    	{
+    	    fine_refresh = 0x80;
+    	}
+    	else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FIXED_4X)
+    	{
+    	    fine_refresh = 0x40;
+    	}
+    	else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FLY_2X)
+    	{
+    	    fine_refresh = 0xA0;
+    	}
+    	else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FLY_4X)
+    	{
+    	    fine_refresh = 0x60;
+    	}
+
+    	if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_4NCK)
+    	{
+    	    wr_latency = 0x00;
+    	}
+    	else if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_5NCK)
+    	{
+    	    wr_latency = 0x80;
+    	}
+    	else if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_6NCK)
+    	{
+    	    wr_latency = 0xC0;
+    	}
+
+    	if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_SERIAL)
+    	{
+    	    read_format = 0x00;
+    	}
+    	else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_PARALLEL)
+    	{
+    	    read_format = 0x80;
+    	}
+    	else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_STAGGERED)
+    	{
+    	    read_format = 0x40;
+    	}
+    	else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_RESERVED_TEMP)
+    	{
+    	    read_format = 0xC0;
+    	}
+	
+	rc_num = rc_num | address_16.insert((uint8_t) mpr_page, 0, 2);
+        rc_num = rc_num | address_16.insert((uint8_t) mpr_op, 2, 1);
+        rc_num = rc_num | address_16.insert((uint8_t) geardown_mode, 3, 1);
+        rc_num = rc_num | address_16.insert((uint8_t) 0xFF, 4, 1); //has PDA mode enabled!!!! just for this code!
+        rc_num = rc_num | address_16.insert((uint8_t) temp_readout, 5, 1);
+        rc_num = rc_num | address_16.insert((uint8_t) fine_refresh, 6, 3);
+        rc_num = rc_num | address_16.insert((uint8_t) wr_latency, 9, 2);
+        rc_num = rc_num | address_16.insert((uint8_t) read_format, 11, 2);
+        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 13, 2);
+	
+	rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 0, 1, 7);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 1, 1, 6);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 2, 1, 5);
+	if (rc_num)
+        {
+            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
+            rc_buff.setEcmdError(rc_num);
+            return rc_buff;
+        }
+    }
+    //MRS4
+    else if(MRS == MRS4_BA) {
+    	uint8_t max_pd_mode; // Max Power down mode -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_MAX_POWERDOWN_MODE, &i_target, max_pd_mode);
+    	if(rc) return rc;
+    	uint8_t temp_ref_range; // Temp ref range -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_TEMP_REF_RANGE, &i_target, temp_ref_range);
+    	if(rc) return rc;
+    	uint8_t temp_ref_mode; // Temp controlled ref mode -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_TEMP_REF_MODE, &i_target, temp_ref_mode);
+    	if(rc) return rc;
+    	uint8_t vref_mon; // Internal Vref Monitor -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_INT_VREF_MON, &i_target, vref_mon);
+    	if(rc) return rc;
+    	uint8_t cs_cmd_latency; // CS to CMD/ADDR Latency -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_CS_CMD_LATENCY, &i_target, cs_cmd_latency);
+    	if(rc) return rc;
+    	uint8_t ref_abort; // Self Refresh Abort -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_SELF_REF_ABORT, &i_target, ref_abort);
+    	if(rc) return rc;
+    	uint8_t rd_pre_train_mode; // Read Pre amble Training Mode -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_RD_PREAMBLE_TRAIN, &i_target, rd_pre_train_mode);
+    	if(rc) return rc;
+    	uint8_t rd_preamble; // Read Pre amble -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_RD_PREAMBLE, &i_target, rd_preamble);
+    	if(rc) return rc;
+    	uint8_t wr_preamble; // Write Pre amble -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_WR_PREAMBLE, &i_target, wr_preamble);
+    	if(rc) return rc;
+
+    	if ( max_pd_mode == ENUM_ATTR_EFF_MAX_POWERDOWN_MODE_ENABLE)
+    	{
+    	    max_pd_mode = 0xF0;
+    	}
+    	else if ( max_pd_mode == ENUM_ATTR_EFF_MAX_POWERDOWN_MODE_DISABLE)
+    	{
+    	    max_pd_mode = 0x00;
+    	}
+
+    	if (temp_ref_range == ENUM_ATTR_EFF_TEMP_REF_RANGE_NORMAL)
+    	{
+    	    temp_ref_range = 0x00;
+    	}
+    	else if ( temp_ref_range== ENUM_ATTR_EFF_TEMP_REF_RANGE_EXTEND)
+    	{
+    	    temp_ref_range = 0xFF;
+    	}
+
+    	if (temp_ref_mode == ENUM_ATTR_EFF_TEMP_REF_MODE_ENABLE)
+    	{
+    	    temp_ref_mode = 0x80;
+    	}
+    	else if (temp_ref_mode == ENUM_ATTR_EFF_TEMP_REF_MODE_DISABLE)
+    	{
+    	    temp_ref_mode = 0x00;
+    	}
+
+    	if ( vref_mon == ENUM_ATTR_EFF_INT_VREF_MON_ENABLE)
+    	{
+    	    vref_mon = 0xFF;
+    	}
+    	else if ( vref_mon == ENUM_ATTR_EFF_INT_VREF_MON_DISABLE)
+    	{
+    	    vref_mon = 0x00;
+    	}
+
+
+    	if ( cs_cmd_latency == 3)
+    	{
+    	    cs_cmd_latency = 0x80;
+    	}
+    	else if (cs_cmd_latency == 4)
+    	{
+    	    cs_cmd_latency = 0x40;
+    	}
+    	else if (cs_cmd_latency == 5)
+    	{
+    	    cs_cmd_latency = 0xC0;
+    	}
+    	else if (cs_cmd_latency == 6)
+    	{
+    	    cs_cmd_latency = 0x20;
+    	}
+    	else if (cs_cmd_latency == 8)
+    	{
+    	    cs_cmd_latency = 0xA0;
+    	}
+
+    	if (ref_abort == ENUM_ATTR_EFF_SELF_REF_ABORT_ENABLE)
+    	{
+    	    ref_abort = 0xFF;
+    	}
+    	else if (ref_abort == ENUM_ATTR_EFF_SELF_REF_ABORT_DISABLE)
+    	{
+    	    ref_abort = 0x00;
+    	}
+
+    	if (rd_pre_train_mode == ENUM_ATTR_EFF_RD_PREAMBLE_TRAIN_ENABLE)
+    	{
+    	    rd_pre_train_mode = 0xFF;
+    	}
+    	else if (rd_pre_train_mode == ENUM_ATTR_EFF_RD_PREAMBLE_TRAIN_DISABLE)
+    	{
+    	    rd_pre_train_mode = 0x00;
+    	}
+
+    	if (rd_preamble == ENUM_ATTR_EFF_RD_PREAMBLE_1NCLK)
+    	{
+    	    rd_preamble = 0x00;
+    	}
+    	else if (rd_preamble == ENUM_ATTR_EFF_RD_PREAMBLE_2NCLK)
+    	{
+    	    rd_preamble = 0xFF;
+    	}
+
+    	if (wr_preamble == ENUM_ATTR_EFF_WR_PREAMBLE_1NCLK)
+    	{
+    	    wr_preamble = 0x00;
+    	}
+    	else if (wr_preamble == ENUM_ATTR_EFF_WR_PREAMBLE_2NCLK)
+    	{
+    	    wr_preamble = 0xFF;
+    	}
+    	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 0, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) max_pd_mode, 1, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) temp_ref_range, 2, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) temp_ref_mode, 3, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) vref_mon, 4, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 5, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) cs_cmd_latency, 6, 3);
+    	rc_num = rc_num | address_16.insert((uint8_t) ref_abort, 9, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) rd_pre_train_mode, 10, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) rd_preamble, 11, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) wr_preamble, 12, 1);
+	
+	rc_num = rc_num | bank_3.insert((uint8_t) MRS4_BA, 0, 1, 7);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS4_BA, 1, 1, 6);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS4_BA, 2, 1, 5);
+	if (rc_num)
+        {
+            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
+            rc_buff.setEcmdError(rc_num);
+            return rc_buff;
+        }
+    }
+    //MRS5
+    else if(MRS == MRS5_BA) {
+    	uint8_t ca_parity_latency; //C/A Parity Latency Mode  -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_CA_PARITY_LATENCY , &i_target, ca_parity_latency);
+    	if(rc) return rc;
+    	uint8_t crc_error_clear; //CRC Error Clear  -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_CRC_ERROR_CLEAR , &i_target, crc_error_clear);
+    	if(rc) return rc;
+    	uint8_t ca_parity_error_status; //C/A Parity Error Status  -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_CA_PARITY_ERROR_STATUS , &i_target, ca_parity_error_status);
+    	if(rc) return rc;
+    	uint8_t odt_input_buffer; //ODT Input Buffer during power down  -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_ODT_INPUT_BUFF , &i_target, odt_input_buffer);
+    	if(rc) return rc;
+    	uint8_t rtt_park[2][2][4]; //RTT_Park value  -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_RTT_PARK , &i_target, rtt_park);
+    	if(rc) return rc;
+    	uint8_t ca_parity; //CA Parity Persistance Error  -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_CA_PARITY , &i_target, ca_parity);
+    	if(rc) return rc;
+    	uint8_t data_mask; //Data Mask  -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DATA_MASK , &i_target, data_mask);
+    	if(rc) return rc;
+    	uint8_t write_dbi; //Write DBI  -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_WRITE_DBI , &i_target, write_dbi);
+    	if(rc) return rc;
+    	uint8_t read_dbi; //Read DBI  -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_READ_DBI , &i_target, read_dbi);
+    	if(rc) return rc;
+
+
+    	if (ca_parity_latency == 4)
+    	{
+    	    ca_parity_latency = 0x80;
+    	}
+    	else if (ca_parity_latency == 5)
+    	{
+    	    ca_parity_latency = 0x40;
+    	}
+    	else if (ca_parity_latency == 6)
+    	{
+    	    ca_parity_latency = 0xC0;
+    	}
+    	else if (ca_parity_latency == 8)
+    	{
+    	    ca_parity_latency = 0x20;
+    	}
+    	else if (ca_parity_latency == ENUM_ATTR_EFF_CA_PARITY_LATENCY_DISABLE)
+    	{
+    	    ca_parity_latency = 0x00;
+    	}
+
+    	if (crc_error_clear == ENUM_ATTR_EFF_CRC_ERROR_CLEAR_ERROR)
+    	{
+    	    crc_error_clear = 0xFF;
+    	}
+    	else if (crc_error_clear == ENUM_ATTR_EFF_CRC_ERROR_CLEAR_CLEAR)
+    	{
+    	    crc_error_clear = 0x00;
+    	}
+
+    	if (ca_parity_error_status == ENUM_ATTR_EFF_CA_PARITY_ERROR_STATUS_ERROR)
+    	{
+    	    ca_parity_error_status = 0xFF;
+    	}
+    	else if (ca_parity_error_status == ENUM_ATTR_EFF_CA_PARITY_ERROR_STATUS_CLEAR)
+    	{
+    	    ca_parity_error_status = 0x00;
+    	}
+
+    	if (odt_input_buffer == ENUM_ATTR_EFF_ODT_INPUT_BUFF_ACTIVATED)
+    	{
+    	    odt_input_buffer = 0x00;
+    	}
+    	else if (odt_input_buffer == ENUM_ATTR_EFF_ODT_INPUT_BUFF_DEACTIVATED)
+    	{
+    	    odt_input_buffer = 0xFF;
+    	}
+
+
+    	if (ca_parity == ENUM_ATTR_EFF_CA_PARITY_ENABLE)
+    	{
+    	    ca_parity = 0xFF;
+    	}
+    	else if (ca_parity == ENUM_ATTR_EFF_CA_PARITY_DISABLE)
+    	{
+    	    ca_parity = 0x00;
+    	}
+
+    	if (data_mask == ENUM_ATTR_EFF_DATA_MASK_DISABLE)
+    	{
+    	    data_mask = 0x00;
+    	}
+    	else if (data_mask == ENUM_ATTR_EFF_DATA_MASK_ENABLE)
+    	{
+    	    data_mask = 0xFF;
+    	}
+
+    	if (write_dbi == ENUM_ATTR_EFF_WRITE_DBI_DISABLE)
+    	{
+    	    write_dbi = 0x00;
+    	}
+    	else if (write_dbi == ENUM_ATTR_EFF_WRITE_DBI_ENABLE)
+    	{
+    	    write_dbi = 0xFF;
+    	}
+
+    	if (read_dbi == ENUM_ATTR_EFF_READ_DBI_DISABLE)
+    	{
+    	    read_dbi = 0x00;
+    	}
+    	else if (read_dbi == ENUM_ATTR_EFF_READ_DBI_ENABLE)
+    	{
+    	    read_dbi = 0xFF;
+    	}
+    	if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_DISABLE)
+    	{
+    	    rtt_park[i_port_number][dimm_number][rank_number] = 0x00;
+    	}
+    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_60OHM)
+    	{
+    	    rtt_park[i_port_number][dimm_number][rank_number] = 0x80;
+    	}
+    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_40OHM)
+    	{
+    	    rtt_park[i_port_number][dimm_number][rank_number] = 0xC0;
+    	}
+    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_120OHM)
+    	{
+    	    rtt_park[i_port_number][dimm_number][rank_number] = 0x40;
+    	}
+    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_240OHM)
+    	{
+    	    rtt_park[i_port_number][dimm_number][rank_number] = 0x20;
+    	}
+    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_48OHM)
+    	{
+    	    rtt_park[i_port_number][dimm_number][rank_number] = 0xA0;
+    	}
+    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_80OHM)
+    	{
+    	    rtt_park[i_port_number][dimm_number][rank_number] = 0x60;
+    	}
+    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_34OHM)
+    	{
+    	    rtt_park[i_port_number][dimm_number][rank_number] = 0xE0;
+    	}
+
+    	rc_num = rc_num | address_16.insert((uint8_t) ca_parity_latency, 0, 2);
+    	rc_num = rc_num | address_16.insert((uint8_t) crc_error_clear, 3, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) ca_parity_error_status, 4, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) odt_input_buffer, 5, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) rtt_park[i_port_number][dimm_number][rank_number], 6, 3);
+    	rc_num = rc_num | address_16.insert((uint8_t) ca_parity, 9, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) data_mask, 10, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) write_dbi, 11, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) read_dbi, 12, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 13, 2);
+	
+	rc_num = rc_num | bank_3.insert((uint8_t) MRS5_BA, 0, 1, 7);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS5_BA, 1, 1, 6);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS5_BA, 2, 1, 5);
+	if (rc_num)
+        {
+            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
+            rc_buff.setEcmdError(rc_num);
+            return rc_buff;
+        }
+    }
+    //MRS6
+    else if(MRS == MRS6_BA) {
+    	uint8_t vrefdq_train_value[2][2][4]; //vrefdq_train value   -  NEW
+    	rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_VALUE, &i_target, vrefdq_train_value);
+    	if(rc) return rc;
+    	uint8_t vrefdq_train_range[2][2][4]; //vrefdq_train range   -  NEW
+    	rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_RANGE, &i_target, vrefdq_train_range);
+    	if(rc) return rc;
+    	uint8_t vrefdq_train_enable[2][2][4]; //vrefdq_train enable  -  NEW
+    	rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target, vrefdq_train_enable);
+    	if(rc) return rc;
+    	uint8_t tccd_l; //tccd_l  -  NEW
+    	rc = FAPI_ATTR_GET( ATTR_TCCD_L, &i_target, tccd_l);
+    	if(rc) return rc;
+    	if (tccd_l == 4)
+    	{
+    	    tccd_l = 0x00;
+    	}
+    	else if (tccd_l == 5)
+    	{
+    	    tccd_l = 0x80;
+    	}
+    	else if (tccd_l == 6)
+    	{
+    	    tccd_l = 0x40;
+    	}    
+    	else if (tccd_l == 7)
+    	{
+    	    tccd_l = 0xC0;
+    	}
+    	else if (tccd_l == 8)
+    	{
+    	    tccd_l = 0x20;
+    	}
+
+    	vrefdq_train_value[i_port_number][dimm_number][rank_number] = mss_reverse_8bits(vrefdq_train_value[i_port_number][dimm_number][rank_number]);
+
+    	if (vrefdq_train_range[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_VREF_DQ_TRAIN_RANGE_RANGE1)
+    	{
+    	    vrefdq_train_range[i_port_number][dimm_number][rank_number] = 0x00;
+    	}
+    	else if (vrefdq_train_range[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_VREF_DQ_TRAIN_RANGE_RANGE2)
+    	{
+    	    vrefdq_train_range[i_port_number][dimm_number][rank_number] = 0xFF;
+    	}   
+
+    	if (vrefdq_train_enable[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE)
+    	{
+    	    vrefdq_train_enable[i_port_number][dimm_number][rank_number] = 0xFF;
+    	}
+    	else if (vrefdq_train_enable[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_DISABLE)
+    	{
+    	    vrefdq_train_enable[i_port_number][dimm_number][rank_number] = 0x00;
+    	}   
+
+    	rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_value[i_port_number][dimm_number][rank_number], 0, 6);
+    	rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_range[i_port_number][dimm_number][rank_number], 6, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_enable[i_port_number][dimm_number][rank_number], 7, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 8, 2);
+    	rc_num = rc_num | address_16.insert((uint8_t) tccd_l, 10, 3);
+    	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 13, 2);
+	
+	rc_num = rc_num | bank_3.insert((uint8_t) MRS6_BA, 0, 1, 7);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS6_BA, 1, 1, 6);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS6_BA, 2, 1, 5);
+	if (rc_num)
+        {
+            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
+            rc_buff.setEcmdError(rc_num);
+            return rc_buff;
+        }
+    }
+    else {
+        const uint32_t MRS_VALUE = MRS;
+	const fapi::Target & MBA_TARGET = i_target; 
+	FAPI_SET_HWP_ERROR(rc, RC_MSS_PDA_MRS_NOT_FOUND);
+	FAPI_ERR("ERROR!! Found attribute name not associated with an MRS! Exiting...");
+    }
+    
+    return rc;
+}
+
 //#endif
 
 
diff --git a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_pda.C b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_pda.C
index 9dd69c7..5e874b7 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_pda.C
+++ b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_pda.C
@@ -22,11 +22,11 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_ddr4_pda.C,v 1.42 2015/07/23 14:18:55 sglancy Exp $
+// $Id: mss_ddr4_pda.C,v 1.46 2015/11/09 18:46:20 sglancy Exp $
 //------------------------------------------------------------------------------
 // *! (C) Copyright International Business Machines Corp. 2013
 // *! All Rights Reserved -- Property of IBM
-// *! ***  ***
+// *! *** IBM Confidential ***
 //------------------------------------------------------------------------------
 // *! TITLE : mss_ddr4_pda.C
 // *! DESCRIPTION : Tools for DDR4 DIMMs centaur procedures
@@ -42,6 +42,10 @@
 //------------------------------------------------------------------------------
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|-----------------------------------------------
+//  1.15   | 11/09/15 | sglancy | Patch to fix cronus compile issue
+//  1.14   | 11/03/15 | sglancy | Fixed attribute names for DDR4 RDIMM
+//  1.13   | 10/23/15 | sglancy | Changed attribute names
+//  1.12   | 10/21/15 | sglancy | Changed attribute names
 //  1.11   | 07/23/15 | sglancy | Changed code to address FW comments
 //  1.10   | 06/09/15 | sglancy | Fixed bug
 //  1.9    | 05/27/15 | sglancy | Fixed bug
@@ -61,6 +65,7 @@
 #include <fapi.H>
 #include <mss_ddr4_pda.H>
 #include <mss_funcs.H>
+#include <mss_ddr4_funcs.H>
 #include <cen_scom_addresses.H>
 #include <mss_access_delay_reg.H>
 #include <vector>
@@ -144,7 +149,17 @@ ReturnCode PDA_MRS_Storage::checkPDAValid(Target& i_target) {
    
    //now checks based upon attributes
    uint8_t num_ranks[2][2];
-   rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM,&i_target,num_ranks); 
+   uint8_t dram_stack[2][2];
+   rc = FAPI_ATTR_GET(ATTR_EFF_STACK_TYPE, &i_target, dram_stack);
+   if(rc) return rc;
+   //get num master ranks per dimm for 3DS
+   if(dram_stack[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+      rc = FAPI_ATTR_GET(ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, &i_target, num_ranks);
+   }
+   //get num ranks per dimm for non-3DS
+   else {
+      rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target, num_ranks);
+   }
    if(rc) return rc;
    
    //no ranks on the selected dimm
@@ -265,16 +280,16 @@ ReturnCode PDA_MRS_Storage::setMRSbyAttr(Target& i_target) {
       case ATTR_EFF_CRC_ERROR_CLEAR : MRS = MRS5_BA; break;
       case ATTR_EFF_CA_PARITY_ERROR_STATUS : MRS = MRS5_BA; break;
       case ATTR_EFF_ODT_INPUT_BUFF : MRS = MRS5_BA; break;
-      case ATTR_EFF_RTT_PARK : MRS = MRS5_BA; break;
+      case ATTR_VPD_DRAM_RTT_PARK : MRS = MRS5_BA; break;
       case ATTR_EFF_CA_PARITY : MRS = MRS5_BA; break;
       case ATTR_EFF_DATA_MASK : MRS = MRS5_BA; break;
       case ATTR_EFF_WRITE_DBI : MRS = MRS5_BA; break;
       case ATTR_EFF_READ_DBI : MRS = MRS5_BA; break;
 
    //MRS6
-      case ATTR_VREF_DQ_TRAIN_VALUE: MRS = MRS6_BA; break;
-      case ATTR_VREF_DQ_TRAIN_RANGE: MRS = MRS6_BA; break;
-      case ATTR_VREF_DQ_TRAIN_ENABLE: MRS = MRS6_BA; break;
+      case ATTR_EFF_VREF_DQ_TRAIN_VALUE: MRS = MRS6_BA; break;
+      case ATTR_EFF_VREF_DQ_TRAIN_RANGE: MRS = MRS6_BA; break;
+      case ATTR_EFF_VREF_DQ_TRAIN_ENABLE: MRS = MRS6_BA; break;
       case ATTR_TCCD_L: MRS = MRS6_BA; break;
       
       //MRS attribute not found, error out
@@ -409,12 +424,14 @@ ReturnCode mss_ddr4_checksort_pda(Target& i_target, vector<PDA_MRS_Storage>& pda
 /////////////////////////////////////////////////////////////////////////////////
 ReturnCode mss_ddr4_setup_pda(
             Target& i_target,
-            uint32_t& io_ccs_inst_cnt
+            uint32_t& io_ccs_inst_cnt,
+	    uint8_t dimm_to_run,
+	    uint8_t rank_to_run
             )
 {
     uint32_t i_port_number=0;
-    uint32_t dimm_number;
-    uint32_t rank_number;
+    uint32_t dimm_number = dimm_to_run;
+    uint32_t rank_number = rank_to_run;
     const uint32_t NUM_POLL = 10;
     const uint32_t WAIT_TIMER = 1500;
     ReturnCode rc;  
@@ -449,12 +466,22 @@ ReturnCode mss_ddr4_setup_pda(
     
     uint8_t num_ranks_array[2][2]; //[port][dimm]
     
+    uint8_t dram_stack[2][2];
+    rc = FAPI_ATTR_GET(ATTR_EFF_STACK_TYPE, &i_target, dram_stack);
+    if(rc) return rc;
+    
     uint8_t dimm_type;
     rc = FAPI_ATTR_GET(ATTR_EFF_DIMM_TYPE, &i_target, dimm_type);
     if(rc) return rc;
     
-    uint8_t num_ranks;
-    rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target, num_ranks_array);
+    //get num master ranks per dimm for 3DS
+    if(dram_stack[dimm_to_run][rank_to_run] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+       rc = FAPI_ATTR_GET(ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, &i_target, num_ranks_array);
+    }
+    //get num ranks per dimm for non-3DS
+    else {
+       rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target, num_ranks_array);
+    }
     if(rc) return rc;
 
     uint8_t is_sim = 0;
@@ -462,7 +489,7 @@ ReturnCode mss_ddr4_setup_pda(
     if(rc) return rc;
 
     uint8_t address_mirror_map[2][2]; //address_mirror_map[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
     if(rc) return rc;
 
     // WORKAROUNDS 
@@ -486,6 +513,11 @@ ReturnCode mss_ddr4_setup_pda(
        // Raise CKE high with NOPS, waiting min Reset CKE exit time (tXPR) - 400 cycles
        rc_num = rc_num | cke_4.setBit(0,4);
        rc_num = rc_num | csn_8.setBit(0,8);
+       
+       if(dram_stack[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+          rc_num = rc_num | csn_8.clearBit(2,2); 
+          rc_num = rc_num | csn_8.clearBit(6,2); 
+       }
        rc_num = rc_num | address_16.clearBit(0, 16);
        rc_num = rc_num | odt_4.clearBit(0,4);
        rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 400, 0, 16);
@@ -523,6 +555,15 @@ ReturnCode mss_ddr4_setup_pda(
        io_ccs_inst_cnt ++;
     }
     
+    //Does the RTT_WR to RTT_NOM swapping
+    //loops through all ports
+    for(i_port_number=0;i_port_number<MAX_NUM_PORTS;i_port_number++) {
+       uint8_t io_dram_rtt_nom_original = 0xff;
+       rc = mss_ddr4_rtt_nom_rtt_wr_swap(i_target,0,i_port_number,rank_to_run+dimm_to_run*4,0xFF,io_ccs_inst_cnt,io_dram_rtt_nom_original);
+       if(rc) return rc;
+       io_ccs_inst_cnt = 0;
+    }
+    
     
     //Sets up MRS3 -> the MRS that has PDA
     uint8_t mpr_op; // MPR Op
@@ -550,152 +591,145 @@ ReturnCode mss_ddr4_setup_pda(
     //enables PDA mode
     //loops through all ports
     for(i_port_number=0;i_port_number<MAX_NUM_PORTS;i_port_number++) {
-    	// Dimm 0-1
-    	for ( dimm_number = 0; dimm_number < MAX_NUM_DIMMS; dimm_number++)
-    	{
-    	    num_ranks = num_ranks_array[i_port_number][dimm_number];
-
-    	    if (num_ranks == 0)
-    	    {
-    		FAPI_INF( "PORT%d DIMM%d not configured. Num_ranks: %d ", i_port_number, dimm_number, num_ranks);
-    	    }
-    	    else
-    	    {
-    		// Rank 0-3
-    		for ( rank_number = 0; rank_number < num_ranks; rank_number++)
-    		{
-    		   // Only corresponding CS to rank
-    		   rc_num = rc_num | csn_8.setBit(0,8); 
-    		   rc_num = rc_num | csn_8.clearBit(rank_number+4*dimm_number);
-    			
-    		   rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 0, 1, 7);
-    		   rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 1, 1, 6);
-    		   rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 2, 1, 5);
-    		   
-		   //sets up MRS3 ecmd buffer
-	           rc_num = rc_num | mrs3.insert((uint8_t) mpr_page, 0, 2);
-	           rc_num = rc_num | mrs3.insert((uint8_t) mpr_op, 2, 1);
-	           rc_num = rc_num | mrs3.insert((uint8_t) geardown_mode, 3, 1);
-	           rc_num = rc_num | mrs3.insert((uint8_t) 0xff, 4, 1); //enables PDA mode!!!!
-	           rc_num = rc_num | mrs3.insert((uint8_t) temp_readout, 5, 1);
-	           rc_num = rc_num | mrs3.insert((uint8_t) fine_refresh, 6, 3);
-	           rc_num = rc_num | mrs3.insert((uint8_t) wr_latency, 9, 2);
-	           rc_num = rc_num | mrs3.insert((uint8_t) read_format, 11, 2);
-	           rc_num = rc_num | mrs3.insert((uint8_t) 0x00, 13, 2);
-	           rc_num = rc_num | mrs3.extractPreserve(&MRS3, 0, 16, 0);
-	           rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 24, 0, 16);
-		   rc_num = rc_num | address_16.insert(mrs3, 0, 16, 0);
-		   
-    		   if (rc_num)
-    		   {
-    		       FAPI_ERR( "mss_ddr4_setup_pda: Error setting up buffers");
-    		       rc_buff.setEcmdError(rc_num);
-    		       return rc_buff;
-    		   }
-    		   
-	           
-    		   if (( address_mirror_map[i_port_number][dimm_number] & (0x08 >> rank_number) ) && (is_sim == 0))
-    		   {
-    		      rc = mss_address_mirror_swizzle(i_target, i_port_number, dimm_number, rank_number, address_16, bank_3);
-    		      if(rc) return rc;
-    		   }
-    		   
-    		   
-    		   // Send out to the CCS array 
-    		   rc = mss_ccs_inst_arry_0( i_target,
-    				     io_ccs_inst_cnt,
-    				     address_16,
-    				     bank_3,
-    				     activate_1,
-    				     rasn_1,
-    				     casn_1,
-    				     wen_1,
-    				     cke_4,
-    				     csn_8,
-    				     odt_4,
-    				     ddr_cal_type_4,
-    				     i_port_number);
-    		   if(rc) return rc;
-    		   rc = mss_ccs_inst_arry_1( i_target,
-    				     io_ccs_inst_cnt,
-    				     num_idles_16,
-    				     num_repeat_16,
-    				     data_20,
-    				     read_compare_1,
-    				     rank_cal_4,
-    				     ddr_cal_enable_1,
-    				     ccs_end_1);
-    		   if(rc) return rc;
-    		   io_ccs_inst_cnt ++;
-		   
-		   //if the DIMM is an R or LR DIMM, then run inverted for the B-Side DRAM
-                    if ( (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_RDIMM) || (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) ) 
-                    {
-		       //reload all MRS values (removes address swizzling)
-		       // Only corresponding CS to rank
-    		       rc_num = rc_num | csn_8.setBit(0,8); 
-    		       rc_num = rc_num | csn_8.clearBit(rank_number+4*dimm_number);
-    		    	    
-    		       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 0, 1, 7);
-    		       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 1, 1, 6);
-    		       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 2, 1, 5);
-    		       
-		       //sets up MRS3 ecmd buffer
-		       rc_num = rc_num | address_16.insert(mrs3, 0, 16, 0);
-		       
-		       //FLIPS all necessary bits
-		       // Indicate B-Side DRAMS BG1=1 
-                       rc_num = rc_num | address_16.setBit(15);  // Set BG1 = 1
+    	
+       // Only corresponding CS to rank
+       rc_num = rc_num | csn_8.setBit(0,8); 
+       if(dram_stack[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+          rc_num = rc_num | csn_8.clearBit(2,2); 
+          rc_num = rc_num | csn_8.clearBit(6,2); 
+       }
+       rc_num = rc_num | csn_8.clearBit(rank_number+4*dimm_number);
+    
+       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 0, 1, 7);
+       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 1, 1, 6);
+       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 2, 1, 5);
+    
+       //sets up MRS3 ecmd buffer
+       rc_num = rc_num | mrs3.insert((uint8_t) mpr_page, 0, 2);
+       rc_num = rc_num | mrs3.insert((uint8_t) mpr_op, 2, 1);
+       rc_num = rc_num | mrs3.insert((uint8_t) geardown_mode, 3, 1);
+       rc_num = rc_num | mrs3.insert((uint8_t) 0xff, 4, 1); //enables PDA mode!!!!
+       rc_num = rc_num | mrs3.insert((uint8_t) temp_readout, 5, 1);
+       rc_num = rc_num | mrs3.insert((uint8_t) fine_refresh, 6, 3);
+       rc_num = rc_num | mrs3.insert((uint8_t) wr_latency, 9, 2);
+       rc_num = rc_num | mrs3.insert((uint8_t) read_format, 11, 2);
+       rc_num = rc_num | mrs3.insert((uint8_t) 0x00, 13, 2);
+       rc_num = rc_num | mrs3.extractPreserve(&MRS3, 0, 16, 0);
+       rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 24, 0, 16);
+       rc_num = rc_num | address_16.insert(mrs3, 0, 16, 0);
+
+       if (rc_num)
+       {
+           FAPI_ERR( "mss_ddr4_setup_pda: Error setting up buffers");
+           rc_buff.setEcmdError(rc_num);
+           return rc_buff;
+       }
+    
+
+       if (( address_mirror_map[i_port_number][dimm_number] & (0x08 >> rank_number) ) && (is_sim == 0))
+       {
+          rc = mss_address_mirror_swizzle(i_target, i_port_number, dimm_number, rank_number, address_16, bank_3);
+          if(rc) return rc;
+       }
+    
+    
+       // Send out to the CCS array 
+       rc = mss_ccs_inst_arry_0( i_target,
+    	    		 io_ccs_inst_cnt,
+    	    		 address_16,
+    	    		 bank_3,
+    	    		 activate_1,
+    	    		 rasn_1,
+    	    		 casn_1,
+    	    		 wen_1,
+    	    		 cke_4,
+    	    		 csn_8,
+    	    		 odt_4,
+    	    		 ddr_cal_type_4,
+    	    		 i_port_number);
+       if(rc) return rc;
+       rc = mss_ccs_inst_arry_1( i_target,
+    	    		 io_ccs_inst_cnt,
+    	    		 num_idles_16,
+    	    		 num_repeat_16,
+    	    		 data_20,
+    	    		 read_compare_1,
+    	    		 rank_cal_4,
+    	    		 ddr_cal_enable_1,
+    	    		 ccs_end_1);
+       if(rc) return rc;
+       io_ccs_inst_cnt ++;
+
+       //if the DIMM is an R or LR DIMM, then run inverted for the B-Side DRAM
+        if ( (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_RDIMM) || (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) ) 
+        {
+           //reload all MRS values (removes address swizzling)
+           // Only corresponding CS to rank
+           rc_num = rc_num | csn_8.setBit(0,8); 
+           if(dram_stack[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+              rc_num = rc_num | csn_8.clearBit(2,2); 
+              rc_num = rc_num | csn_8.clearBit(6,2); 
+           }
+           rc_num = rc_num | csn_8.clearBit(rank_number+4*dimm_number);
+        	
+           rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 0, 1, 7);
+           rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 1, 1, 6);
+           rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 2, 1, 5);
+           
+           //sets up MRS3 ecmd buffer
+           rc_num = rc_num | address_16.insert(mrs3, 0, 16, 0);
+           
+           //FLIPS all necessary bits
+           // Indicate B-Side DRAMS BG1=1 
+           rc_num = rc_num | address_16.setBit(15);  // Set BG1 = 1
  
-                       rc_num = rc_num | address_16.flipBit(3,7); // Invert A3:A9
-                       rc_num = rc_num | address_16.flipBit(11);  // Invert A11
-                       rc_num = rc_num | address_16.flipBit(13);  // Invert A13
-                       rc_num = rc_num | address_16.flipBit(14);  // Invert A17
-                       rc_num = rc_num | bank_3.flipBit(0,3);	  // Invert BA0,BA1,BG0
-		       
-		       if (rc_num)
-    		       {
-    		     	   FAPI_ERR( "mss_ddr4_setup_pda: Error setting up buffers");
-    		     	   rc_buff.setEcmdError(rc_num);
-    		     	   return rc_buff;
-    		       }
-		     	   
-		     	   if (( address_mirror_map[i_port_number][dimm_number] & (0x08 >> rank_number) ) && (is_sim == 0))
-    		       {
-    		     	  rc = mss_address_mirror_swizzle(i_target, i_port_number, dimm_number, rank_number, address_16, bank_3);
-    		     	  if(rc) return rc;
-    		       }
-    		       
-    		       // Send out to the CCS array 
-    		       rc = mss_ccs_inst_arry_0( i_target,
-    		     	 		 io_ccs_inst_cnt,
-    		     	 		 address_16,
-    		     	 		 bank_3,
-    		     	 		 activate_1,
-    		     	 		 rasn_1,
-    		     	 		 casn_1,
-    		     	 		 wen_1,
-    		     	 		 cke_4,
-    		     	 		 csn_8,
-    		     	 		 odt_4,
-    		     	 		 ddr_cal_type_4,
-    		     	 		 i_port_number);
-    		       if(rc) return rc;
-    		       rc = mss_ccs_inst_arry_1( i_target,
-    		     	 		 io_ccs_inst_cnt,
-    		     	 		 num_idles_16,
-    		     	 		 num_repeat_16,
-    		     	 		 data_20,
-    		     	 		 read_compare_1,
-    		     	 		 rank_cal_4,
-    		     	 		 ddr_cal_enable_1,
-    		     	 		 ccs_end_1);
-    		       if(rc) return rc;
-    		       io_ccs_inst_cnt ++;
-		    }
-    		}    
-    	    }
-    	}
+           rc_num = rc_num | address_16.flipBit(3,7); // Invert A3:A9
+           rc_num = rc_num | address_16.flipBit(11);  // Invert A11
+           rc_num = rc_num | address_16.flipBit(13);  // Invert A13
+           rc_num = rc_num | address_16.flipBit(14);  // Invert A17
+           rc_num = rc_num | bank_3.flipBit(0,3);     // Invert BA0,BA1,BG0
+           
+           if (rc_num)
+           {
+               FAPI_ERR( "mss_ddr4_setup_pda: Error setting up buffers");
+               rc_buff.setEcmdError(rc_num);
+               return rc_buff;
+           }
+               
+               if (( address_mirror_map[i_port_number][dimm_number] & (0x08 >> rank_number) ) && (is_sim == 0))
+           {
+              rc = mss_address_mirror_swizzle(i_target, i_port_number, dimm_number, rank_number, address_16, bank_3);
+              if(rc) return rc;
+           }
+           
+           // Send out to the CCS array 
+           rc = mss_ccs_inst_arry_0( i_target,
+        		     io_ccs_inst_cnt,
+        		     address_16,
+        		     bank_3,
+        		     activate_1,
+        		     rasn_1,
+        		     casn_1,
+        		     wen_1,
+        		     cke_4,
+        		     csn_8,
+        		     odt_4,
+        		     ddr_cal_type_4,
+        		     i_port_number);
+           if(rc) return rc;
+           rc = mss_ccs_inst_arry_1( i_target,
+        		     io_ccs_inst_cnt,
+        		     num_idles_16,
+        		     num_repeat_16,
+        		     data_20,
+        		     read_compare_1,
+        		     rank_cal_4,
+        		     ddr_cal_enable_1,
+        		     ccs_end_1);
+           if(rc) return rc;
+           io_ccs_inst_cnt ++;
+        }
+    
     }
     
     //runs a NOP command for 24 cycle
@@ -789,10 +823,21 @@ ReturnCode mss_ddr4_setup_pda(
       }
    }
    
+   
+   //sets up the DRAM DQ drive time
+   uint8_t wl_launch_time;
+   uint8_t odt_hold_time;
+   uint8_t post_odt_nop_idle;
+   rc = mss_get_pda_odt_timings(i_target, wl_launch_time, odt_hold_time, post_odt_nop_idle);
+   if(rc) return rc;
+   wl_launch_time -= 7;
+   
    rc = fapiGetScom(i_target,  DPHY01_DDRPHY_WC_CONFIG3_P0_0x8000CC050301143F, data_buffer);
    if(rc) return rc;
    //Setting up CCS mode
    rc_num = rc_num | data_buffer.setBit(48);
+   rc_num = rc_num | data_buffer.insertFromRight(wl_launch_time,49,6);
+   rc_num = rc_num | data_buffer.insertFromRight(odt_hold_time,55,6);
    if (rc_num)
    {
        FAPI_ERR( "mss_ddr4_setup_pda: Error setting up buffers");
@@ -806,6 +851,8 @@ ReturnCode mss_ddr4_setup_pda(
    if(rc) return rc;
    //Setting up CCS mode
    rc_num = rc_num | data_buffer.setBit(48);
+   rc_num = rc_num | data_buffer.insertFromRight(wl_launch_time,49,6);
+   rc_num = rc_num | data_buffer.insertFromRight(odt_hold_time,55,6);
    if (rc_num)
    {
        FAPI_ERR( "mss_ddr4_setup_pda: Error setting up buffers");
@@ -831,10 +878,20 @@ ReturnCode mss_ddr4_pda(
     ReturnCode rc;
     uint8_t dram_loop_end;
     uint8_t dram_loop_end_with_spare;
-    
+    FAPI_INF("Commonly used PDA attributes: fapi::ATTR_EFF_VREF_DQ_TRAIN_ENABLE=0x%08x fapi::ATTR_EFF_VREF_DQ_TRAIN_VALUE=0x%08x",ATTR_EFF_VREF_DQ_TRAIN_ENABLE,ATTR_EFF_VREF_DQ_TRAIN_VALUE);
     //gets the rank information
     uint8_t num_ranks_array[2][2]; //[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target, num_ranks_array);
+    uint8_t dram_stack[2][2];
+    rc = FAPI_ATTR_GET(ATTR_EFF_STACK_TYPE, &i_target, dram_stack);
+    if(rc) return rc;
+    //get num master ranks per dimm for 3DS
+    if(dram_stack[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+       rc = FAPI_ATTR_GET(ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, &i_target, num_ranks_array);
+    }
+    //get num ranks per dimm for non-3DS
+    else {
+       rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target, num_ranks_array);
+    }
     if(rc) return rc;
     
     //gets the spare information
@@ -844,7 +901,7 @@ ReturnCode mss_ddr4_pda(
     
     //gets the WR VREF information
     uint8_t wr_vref[2][2][4]; //[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_VREF_DQ_TRAIN_VALUE, &i_target, wr_vref);
+    rc = FAPI_ATTR_GET(ATTR_EFF_VREF_DQ_TRAIN_VALUE, &i_target, wr_vref);
     if(rc) return rc;
     
     
@@ -883,7 +940,7 @@ ReturnCode mss_ddr4_pda(
     		    if(port == 0) wr_vref[port][dimm][rank] = dram*3;
     		    else wr_vref[port][dimm][rank] = 57-dram*3;
     		    if(wr_vref[port][dimm][rank]  > 50) wr_vref[port][dimm][rank] = 50;
-    		    pda.push_back(PDA_MRS_Storage(array[port][dimm][dram],ATTR_VREF_DQ_TRAIN_VALUE,dram,dimm,rank,port));
+    		    pda.push_back(PDA_MRS_Storage(array[port][dimm][dram],ATTR_EFF_VREF_DQ_TRAIN_VALUE,dram,dimm,rank,port));
     		    FAPI_INF("PDA STRING: %d %s",pda.size()-1,pda[pda.size()-1].c_str());
     		 }
     	      }
@@ -894,19 +951,63 @@ ReturnCode mss_ddr4_pda(
     return rc;
 }
 
-/////////////////////////////////////////////////////////////////////////////////
-/// mss_ddr4_run_pda
-/// runs per-DRAM addressability funcitonality on both ports on the passed MBA
-/////////////////////////////////////////////////////////////////////////////////
+//loops through and runs PDA on all MBA's
 ReturnCode mss_ddr4_run_pda(
             Target& i_target,
 	    vector<PDA_MRS_Storage> pda
+            ) {
+   ReturnCode rc;  
+   if(pda.size() == 0) return rc;
+   
+   
+   uint8_t num_ranks_array[2][2]; //[port][dimm]
+   
+   uint8_t dram_stack[2][2];
+   rc = FAPI_ATTR_GET(ATTR_EFF_STACK_TYPE, &i_target, dram_stack);
+   if(rc) return rc;
+   
+   if(dram_stack[0][0]  == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+      rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target, num_ranks_array);
+   }
+   else {
+      rc = FAPI_ATTR_GET(ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, &i_target, num_ranks_array);
+   }
+   if(rc) return rc;
+   
+   //loops through all DIMMs all Ranks
+   for(uint8_t dimm_to_run=0;dimm_to_run<2;dimm_to_run++) {
+      uint8_t largest_num_ranks = num_ranks_array[0][dimm_to_run];
+      if(largest_num_ranks < num_ranks_array[1][dimm_to_run]) largest_num_ranks = num_ranks_array[1][dimm_to_run];
+      
+      for(uint8_t rank_to_run=0;rank_to_run<largest_num_ranks;rank_to_run++) {
+         FAPI_INF("Running PDA on DIMM %d Rank %d!!",dimm_to_run, rank_to_run);
+         rc = mss_ddr4_run_pda_by_dimm_rank(i_target, pda, dimm_to_run, rank_to_run);
+	 if(rc) return rc;
+      }
+   }
+   
+   return rc;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////////
+/// mss_ddr4_run_pda_by_dimm_rank
+/// runs per-DRAM addressability funcitonality on both ports on the passed MBA by dimm and rank
+/////////////////////////////////////////////////////////////////////////////////
+ReturnCode mss_ddr4_run_pda_by_dimm_rank(
+            Target& i_target,
+	    vector<PDA_MRS_Storage> pda,
+	    uint8_t dimm_to_run,
+	    uint8_t rank_to_run
             )
 {
     ReturnCode rc;  
     //no PDA was entered, just exit
     if(pda.size() == 0) return rc;
     
+    //DIMM/rank not found - exit
+    if(mss_ddr4_check_pda_empty_for_rank(pda,dimm_to_run,rank_to_run)) return rc;
+    
     uint32_t io_ccs_inst_cnt = 0;
     const uint32_t NUM_POLL = 10;
     const uint32_t WAIT_TIMER = 1500;
@@ -921,6 +1022,17 @@ ReturnCode mss_ddr4_run_pda(
     ecmdDataBufferBase rasn_1(1);
     ecmdDataBufferBase casn_1(1);
     ecmdDataBufferBase wen_1(1);
+    ecmdDataBufferBase rasn_1_odt(1);
+    ecmdDataBufferBase casn_1_odt(1);
+    ecmdDataBufferBase wen_1_odt(1);
+    ecmdDataBufferBase num_repeat_16_odt(16);
+    ecmdDataBufferBase num_idles_16_odt(16);
+    ecmdDataBufferBase csn_8_odt(8);
+    rc_num = rc_num | rasn_1_odt.clearBit(0,1);
+    rc_num = rc_num | casn_1_odt.clearBit(0,1);
+    rc_num = rc_num | wen_1_odt.clearBit(0,1);
+    rc_num = rc_num | csn_8_odt.setBit(0,8);
+    rc_num = rc_num | csn_8_odt.clearBit(7,1);
     ecmdDataBufferBase cke_4(4);
     rc_num = rc_num | cke_4.setBit(0,4);
     ecmdDataBufferBase csn_8(8);
@@ -954,8 +1066,8 @@ ReturnCode mss_ddr4_run_pda(
     
     ecmdDataBufferBase data_buffer(64);
     
-    uint8_t num_ranks_array[2][2]; //[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target, num_ranks_array);
+    uint8_t dram_stack[2][2];
+    rc = FAPI_ATTR_GET(ATTR_EFF_STACK_TYPE, &i_target, dram_stack);
     if(rc) return rc;
 
     uint8_t is_sim = 0;
@@ -963,40 +1075,78 @@ ReturnCode mss_ddr4_run_pda(
     if(rc) return rc;
 
     uint8_t address_mirror_map[2][2]; //address_mirror_map[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
     if(rc) return rc;
 
-    rc = mss_ddr4_setup_pda(i_target, io_ccs_inst_cnt );
-    if(rc)  return rc;
-    
-    rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 100, 0, 16);
+   rc = mss_ddr4_setup_pda(i_target, io_ccs_inst_cnt, dimm_to_run,rank_to_run );
+   if(rc) return rc;
+   FAPI_INF("WAITING FOR LA SETUP!!!!");
+ //  sleep(30);
    
+   uint8_t wl_launch_time;
+   uint8_t odt_hold_time;
+   uint8_t post_odt_nop_idle;
+   rc = mss_get_pda_odt_timings(i_target, wl_launch_time, odt_hold_time, post_odt_nop_idle);
    
+   rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 0, 0, 16);
+   rc_num = rc_num | num_repeat_16.insertFromRight((uint32_t) 0, 0, 16);
    
-    rc_num = rc_num | cke_4.setBit(0,4);
-    rc_num = rc_num | csn_8.setBit(0,8);
-    rc_num = rc_num | address_16.clearBit(0, 16);
-    rc_num = rc_num | odt_4.clearBit(0,4);
-    rc_num = rc_num | rasn_1.clearBit(0,1);
-    rc_num = rc_num | casn_1.clearBit(0,1);
-    rc_num = rc_num | wen_1.clearBit(0,1);
+   rc_num = rc_num | num_idles_16_odt.insertFromRight( post_odt_nop_idle, 0, 8);
+   rc_num = rc_num | num_repeat_16_odt.insertFromRight( odt_hold_time, 0, 8);
    
-   //gets the start PDA values
-   uint8_t prev_dram = pda[0].dram;
-   uint8_t prev_port = pda[0].port;
-   uint8_t prev_rank = pda[0].rank;
-   uint8_t prev_dimm = pda[0].dimm;
-   uint8_t prev_mrs  = pda[0].MRS;
-   rc = mss_ddr4_load_nominal_mrs_pda(i_target,bank_3,address_16, prev_mrs, prev_port, prev_dimm, prev_rank);
-   if(rc) return rc;
    
-   vector<PDA_Scom_Storage> scom_storage;
-   scom_storage.clear();
-   rc = mss_ddr4_add_dram_pda(i_target,prev_port,prev_dram,scom_storage);
+   
+   rc_num = rc_num | cke_4.setBit(0,4);
+   rc_num = rc_num | csn_8.setBit(0,8);
+   rc_num = rc_num | address_16.clearBit(0, 16);
+   rc_num = rc_num | odt_4.clearBit(0,4);
+   rc_num = rc_num | rasn_1.clearBit(0,1);
+   rc_num = rc_num | casn_1.clearBit(0,1);
+   rc_num = rc_num | wen_1.clearBit(0,1);
+   
+   if(rc_num)
+   {
+       rc.setEcmdError(rc_num);
+       return rc;
+   }
+   
+   uint8_t odt_wr[2][2][4];
+   rc = FAPI_ATTR_GET(ATTR_VPD_ODT_WR,  &i_target, odt_wr);
    if(rc) return rc;
    
+   bool prev_dram_set = false;
+   vector<PDA_Scom_Storage> scom_storage;
+   uint8_t prev_dram = 0;
+   uint8_t prev_port = 0;
+   uint8_t prev_rank = 0;
+   uint8_t prev_dimm = 0;
+   uint8_t prev_mrs  = 0;
+
    //runs through each PDA command
    for(uint32_t i=0;i<pda.size();i++) {
+      //did not find a PDA with the same DIMM and rank as requested
+      if(pda[i].rank != rank_to_run || pda[i].dimm != dimm_to_run) {
+         continue;
+      }
+      
+      //found a PDA of the same dimm and rank, but storage not set
+      if(!prev_dram_set) {
+         //gets the start PDA values
+         prev_dram = pda[i].dram;
+         prev_port = pda[i].port;
+         prev_rank = pda[i].rank;
+         prev_dimm = pda[i].dimm;
+         prev_mrs  = pda[i].MRS;
+	 prev_dram_set = true;
+	 
+         rc = mss_ddr4_load_nominal_mrs_pda(i_target,bank_3,address_16, prev_mrs, prev_port, prev_dimm, prev_rank);
+         if(rc) return rc;
+	 
+	 scom_storage.clear();
+	 rc = mss_ddr4_add_dram_pda(i_target,prev_port,prev_dram,scom_storage);
+	 if(rc) return rc;
+      }
+   
       FAPI_INF("Target %s On PDA %d is %s",i_target.toEcmdString(),i,pda[i].c_str());
       //dram, port, rank, dimm, and mrs are the same
       if(prev_dram == pda[i].dram && prev_port == pda[i].port && prev_rank == pda[i].rank && prev_dimm == pda[i].dimm && prev_mrs == pda[i].MRS) {
@@ -1022,6 +1172,12 @@ ReturnCode mss_ddr4_run_pda(
    	 rc_num = rc_num | csn_8.setBit(0,8); 
    	 rc_num = rc_num | csn_8.clearBit(prev_rank+4*prev_dimm);
 	 
+         if(dram_stack[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+            rc_num = rc_num | csn_8.clearBit(2,2); 
+            rc_num = rc_num | csn_8.clearBit(6,2); 
+         }
+	 rc_num = rc_num | odt_4.insert(odt_wr[prev_port][prev_dimm][prev_rank], 0, 4, 0);
+	 
    	 // Send out to the CCS array 
    	 rc = mss_ccs_inst_arry_0( i_target,
    	     	  io_ccs_inst_cnt,
@@ -1049,6 +1205,33 @@ ReturnCode mss_ddr4_run_pda(
    	 if(rc) return rc;
    	 io_ccs_inst_cnt ++;
 	 
+	 // Send out to the CCS array 
+   	 rc = mss_ccs_inst_arry_0( i_target,
+   	     	  io_ccs_inst_cnt,
+   	     	  address_16,
+   	     	  bank_3,
+   	     	  activate_1,
+   	     	  rasn_1_odt,
+   	     	  casn_1_odt,
+   	     	  wen_1_odt,
+   	     	  cke_4,
+   	     	  csn_8_odt,
+   	     	  odt_4,
+   	     	  ddr_cal_type_4,
+   	     	  prev_port);
+   	 if(rc) return rc;
+   	 rc = mss_ccs_inst_arry_1( i_target,
+   	     	  io_ccs_inst_cnt,
+   	     	  num_idles_16_odt,
+   	     	  num_repeat_16_odt,
+   	     	  data_20,
+   	     	  read_compare_1,
+   	     	  rank_cal_4,
+   	     	  ddr_cal_enable_1,
+   	     	  ccs_end_1);
+   	 if(rc) return rc;
+   	 io_ccs_inst_cnt ++;
+	 
 	 //is an R or LR DIMM -> do a B side MRS write
 	 if ( (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_RDIMM) || (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) ) {
 	    //takes values from the backup
@@ -1076,6 +1259,12 @@ ReturnCode mss_ddr4_run_pda(
    	    rc_num = rc_num | csn_8.setBit(0,8); 
    	    rc_num = rc_num | csn_8.clearBit(prev_rank+4*prev_dimm);
 	    
+            if(dram_stack[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+               rc_num = rc_num | csn_8.clearBit(2,2); 
+               rc_num = rc_num | csn_8.clearBit(6,2); 
+            }
+	    rc_num = rc_num | odt_4.insert(odt_wr[prev_port][prev_dimm][prev_rank], 0, 4, 0);
+	    
    	    // Send out to the CCS array 
    	    rc = mss_ccs_inst_arry_0( i_target,
    	   	     io_ccs_inst_cnt,
@@ -1102,7 +1291,34 @@ ReturnCode mss_ddr4_run_pda(
    	   	     ccs_end_1);
    	    if(rc) return rc;
    	    io_ccs_inst_cnt ++;
-	 }
+	    
+	    // Send out to the CCS array 
+            rc = mss_ccs_inst_arry_0( i_target,
+            	     io_ccs_inst_cnt,
+            	     address_16,
+            	     bank_3,
+            	     activate_1,
+            	     rasn_1_odt,
+            	     casn_1_odt,
+            	     wen_1_odt,
+            	     cke_4,
+            	     csn_8_odt,
+            	     odt_4,
+            	     ddr_cal_type_4,
+            	     prev_port);
+            if(rc) return rc;
+            rc = mss_ccs_inst_arry_1( i_target,
+            	     io_ccs_inst_cnt,
+            	     num_idles_16_odt,
+            	     num_repeat_16_odt,
+            	     data_20,
+            	     read_compare_1,
+            	     rank_cal_4,
+            	     ddr_cal_enable_1,
+            	     ccs_end_1);
+            if(rc) return rc;
+            io_ccs_inst_cnt ++;
+         }
 	 
 	 //the DRAM are different, so kick off CCS, and clear out the MRS DRAMs and set up a new DRAM
 	 if(prev_dram != pda[i].dram) {
@@ -1113,6 +1329,7 @@ ReturnCode mss_ddr4_run_pda(
     	    rc_num = rc_num | rasn_1.setBit(0,1);
     	    rc_num = rc_num | casn_1.setBit(0,1);
     	    rc_num = rc_num | wen_1.setBit(0,1);
+	    rc_num = rc_num | odt_4.insert((uint8_t) 0, 0, 4, 0);
 	    
 	    // Send out to the CCS array 
             rc = mss_ccs_inst_arry_0( i_target,
@@ -1225,76 +1442,29 @@ ReturnCode mss_ddr4_run_pda(
       } 
    }      
    
-   //runs the last PDA command
-   //adds values to a backup address_16 before doing the mirroring
-   address_16_backup.clearBit(0, 16);
-   rc_num = rc_num | address_16_backup.insert(address_16, 0, 16, 0);
-
-   //loads the previous DRAM
-   if (( address_mirror_map[prev_port][prev_dimm] & (0x08 >> prev_rank) ) && (is_sim == 0))
-   {
-       rc = mss_address_mirror_swizzle(i_target, prev_port, prev_dimm, prev_rank, address_16, bank_3);
-       if(rc) return rc;
-   }
-
-   // Only corresponding CS to rank
-   rc_num = rc_num | csn_8.setBit(0,8); 
-   rc_num = rc_num | csn_8.clearBit(prev_rank+4*prev_dimm);
-
-   // Send out to the CCS array 
-   rc = mss_ccs_inst_arry_0( i_target,
-   	    io_ccs_inst_cnt,
-   	    address_16,
-   	    bank_3,
-   	    activate_1,
-   	    rasn_1,
-   	    casn_1,
-   	    wen_1,
-   	    cke_4,
-   	    csn_8,
-   	    odt_4,
-   	    ddr_cal_type_4,
-   	    prev_port);
-   if(rc) return rc;
-   rc = mss_ccs_inst_arry_1( i_target,
-   	    io_ccs_inst_cnt,
-   	    num_idles_16,
-   	    num_repeat_16,
-   	    data_20,
-   	    read_compare_1,
-   	    rank_cal_4,
-   	    ddr_cal_enable_1,
-   	    ccs_end_1);
-   if(rc) return rc;
-   io_ccs_inst_cnt ++;
+   //runs the last PDA command, if and only if a PDA of the desired rank and dimm was run
+   if(prev_dram_set) {
+      //adds values to a backup address_16 before doing the mirroring
+      address_16_backup.clearBit(0, 16);
+      rc_num = rc_num | address_16_backup.insert(address_16, 0, 16, 0);
+      rc_num = rc_num | odt_4.insert(odt_wr[prev_port][prev_dimm][prev_rank], 0, 4, 0);
 
-   //is an R or LR DIMM -> do a B side MRS write
-   if ( (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_RDIMM) || (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) ) {
-      //takes values from the backup
-      address_16.clearBit(0, 16);
-      rc_num = rc_num | address_16.insert(address_16_backup, 0, 16, 0);
-      
-      //FLIPS all necessary bits
-      // Indicate B-Side DRAMS BG1=1 
-      rc_num = rc_num | address_16.setBit(15);  // Set BG1 = 1
- 
-      rc_num = rc_num | address_16.flipBit(3,7); // Invert A3:A9
-      rc_num = rc_num | address_16.flipBit(11);  // Invert A11
-      rc_num = rc_num | address_16.flipBit(13);  // Invert A13
-      rc_num = rc_num | address_16.flipBit(14);  // Invert A17
-      rc_num = rc_num | bank_3.flipBit(0,3);	 // Invert BA0,BA1,BG0
-      
       //loads the previous DRAM
       if (( address_mirror_map[prev_port][prev_dimm] & (0x08 >> prev_rank) ) && (is_sim == 0))
       {
    	  rc = mss_address_mirror_swizzle(i_target, prev_port, prev_dimm, prev_rank, address_16, bank_3);
    	  if(rc) return rc;
       }
-      
+
       // Only corresponding CS to rank
       rc_num = rc_num | csn_8.setBit(0,8); 
-      rc_num = rc_num | csn_8.clearBit(prev_rank+4*prev_dimm);
       
+      if(dram_stack[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+   	 rc_num = rc_num | csn_8.clearBit(2,2); 
+   	 rc_num = rc_num | csn_8.clearBit(6,2); 
+      }
+      rc_num = rc_num | csn_8.clearBit(prev_rank+4*prev_dimm);
+
       // Send out to the CCS array 
       rc = mss_ccs_inst_arry_0( i_target,
    	       io_ccs_inst_cnt,
@@ -1321,9 +1491,122 @@ ReturnCode mss_ddr4_run_pda(
    	       ccs_end_1);
       if(rc) return rc;
       io_ccs_inst_cnt ++;
+      
+      // Send out to the CCS array 
+      rc = mss_ccs_inst_arry_0( i_target,
+   	       io_ccs_inst_cnt,
+   	       address_16,
+   	       bank_3,
+   	       activate_1,
+   	       rasn_1_odt,
+   	       casn_1_odt,
+   	       wen_1_odt,
+   	       cke_4,
+   	       csn_8_odt,
+   	       odt_4,
+   	       ddr_cal_type_4,
+   	       prev_port);
+      if(rc) return rc;
+      rc = mss_ccs_inst_arry_1( i_target,
+   	       io_ccs_inst_cnt,
+   	       num_idles_16_odt,
+   	       num_repeat_16_odt,
+   	       data_20,
+   	       read_compare_1,
+   	       rank_cal_4,
+   	       ddr_cal_enable_1,
+   	       ccs_end_1);
+      if(rc) return rc;
+      io_ccs_inst_cnt ++;
+
+      //is an R or LR DIMM -> do a B side MRS write
+      if ( (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_RDIMM) || (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) ) {
+   	 //takes values from the backup
+   	 address_16.clearBit(0, 16);
+   	 rc_num = rc_num | address_16.insert(address_16_backup, 0, 16, 0);
+   	 
+   	 //FLIPS all necessary bits
+   	 // Indicate B-Side DRAMS BG1=1 
+   	 rc_num = rc_num | address_16.setBit(15);  // Set BG1 = 1
+    
+   	 rc_num = rc_num | address_16.flipBit(3,7); // Invert A3:A9
+   	 rc_num = rc_num | address_16.flipBit(11);  // Invert A11
+   	 rc_num = rc_num | address_16.flipBit(13);  // Invert A13
+   	 rc_num = rc_num | address_16.flipBit(14);  // Invert A17
+   	 rc_num = rc_num | bank_3.flipBit(0,3);     // Invert BA0,BA1,BG0
+   	 
+   	 //loads the previous DRAM
+   	 if (( address_mirror_map[prev_port][prev_dimm] & (0x08 >> prev_rank) ) && (is_sim == 0))
+   	 {
+   	     rc = mss_address_mirror_swizzle(i_target, prev_port, prev_dimm, prev_rank, address_16, bank_3);
+   	     if(rc) return rc;
+   	 }
+   	 
+   	 // Only corresponding CS to rank
+   	 rc_num = rc_num | csn_8.setBit(0,8); 
+   	 
+   	 if(dram_stack[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+   	    rc_num = rc_num | csn_8.clearBit(2,2); 
+   	    rc_num = rc_num | csn_8.clearBit(6,2); 
+   	 }
+   	 rc_num = rc_num | csn_8.clearBit(prev_rank+4*prev_dimm);
+   	 
+   	 // Send out to the CCS array 
+   	 rc = mss_ccs_inst_arry_0( i_target,
+   		  io_ccs_inst_cnt,
+   		  address_16,
+   		  bank_3,
+   		  activate_1,
+   		  rasn_1,
+   		  casn_1,
+   		  wen_1,
+   		  cke_4,
+   		  csn_8,
+   		  odt_4,
+   		  ddr_cal_type_4,
+   		  prev_port);
+   	 if(rc) return rc;
+   	 rc = mss_ccs_inst_arry_1( i_target,
+   		  io_ccs_inst_cnt,
+   		  num_idles_16,
+   		  num_repeat_16,
+   		  data_20,
+   		  read_compare_1,
+   		  rank_cal_4,
+   		  ddr_cal_enable_1,
+   		  ccs_end_1);
+   	 if(rc) return rc;
+   	 io_ccs_inst_cnt ++;
+   	 
+   	 // Send out to the CCS array 
+   	 rc = mss_ccs_inst_arry_0( i_target,
+   		  io_ccs_inst_cnt,
+   		  address_16,
+   		  bank_3,
+   		  activate_1,
+   		  rasn_1_odt,
+   		  casn_1_odt,
+   		  wen_1_odt,
+   		  cke_4,
+   		  csn_8_odt,
+   		  odt_4,
+   		  ddr_cal_type_4,
+   		  prev_port);
+   	 if(rc) return rc;
+   	 rc = mss_ccs_inst_arry_1( i_target,
+   		  io_ccs_inst_cnt,
+   		  num_idles_16_odt,
+   		  num_repeat_16_odt,
+   		  data_20,
+   		  read_compare_1,
+   		  rank_cal_4,
+   		  ddr_cal_enable_1,
+   		  ccs_end_1);
+   	 if(rc) return rc;
+   	 io_ccs_inst_cnt ++;
+      }
    }
    
-   
    //sets a NOP as the last command
    rc_num = rc_num | cke_4.setBit(0,4);
    rc_num = rc_num | csn_8.setBit(0,8);
@@ -1342,7 +1625,7 @@ ReturnCode mss_ddr4_run_pda(
    	    casn_1,
    	    wen_1,
    	    cke_4,
-   	    csn_8,
+   	    csn_8_odt,
    	    odt_4,
    	    ddr_cal_type_4,
    	    prev_port);
@@ -1385,7 +1668,7 @@ ReturnCode mss_ddr4_run_pda(
    //}
       
    io_ccs_inst_cnt = 0;
-   rc = mss_ddr4_disable_pda(i_target,io_ccs_inst_cnt);
+   rc = mss_ddr4_disable_pda(i_target,io_ccs_inst_cnt,dimm_to_run,rank_to_run);
    return rc;
 }
 
@@ -1453,10 +1736,10 @@ ReturnCode mss_ddr4_add_dram_pda(Target& i_target,uint8_t port,uint8_t dram,vect
 /// mss_ddr4_disable_pda
 /// disables per-DRAM addressability funcitonality on both ports on the passed MBA
 //////////////////////////////////////////////////////////////////////////////////
-ReturnCode mss_ddr4_disable_pda(Target& i_target,uint32_t& io_ccs_inst_cnt) {
+ReturnCode mss_ddr4_disable_pda(Target& i_target,uint32_t& io_ccs_inst_cnt, uint8_t dimm_to_run, uint8_t rank_to_run) {
     uint32_t i_port_number=0;
-    uint32_t dimm_number;
-    uint32_t rank_number;
+    uint32_t dimm_number = dimm_to_run;
+    uint32_t rank_number = rank_to_run;
     const uint32_t NUM_POLL = 10;
     const uint32_t WAIT_TIMER = 1500;
     ReturnCode rc;  
@@ -1486,14 +1769,35 @@ ReturnCode mss_ddr4_disable_pda(Target& i_target,uint32_t& io_ccs_inst_cnt) {
     ecmdDataBufferBase rank_cal_4(4);
     ecmdDataBufferBase ddr_cal_enable_1(1);
     ecmdDataBufferBase ccs_end_1(1);
+    
+    ecmdDataBufferBase rasn_1_odt(1);
+    ecmdDataBufferBase casn_1_odt(1);
+    ecmdDataBufferBase wen_1_odt(1);
+    ecmdDataBufferBase num_repeat_16_odt(16);
+    ecmdDataBufferBase num_idles_16_odt(16);
+    ecmdDataBufferBase csn_8_odt(8);
+    rc_num = rc_num | rasn_1_odt.clearBit(0,1);
+    rc_num = rc_num | casn_1_odt.clearBit(0,1);
+    rc_num = rc_num | wen_1_odt.clearBit(0,1);
+    rc_num = rc_num | csn_8_odt.setBit(0,8);
+    rc_num = rc_num | csn_8_odt.clearBit(7,1);
+    
+    if (rc_num) {
+       FAPI_ERR( "disable ccs setup: Error disabling up buffers");
+       rc_buff.setEcmdError(rc_num);
+       return rc_buff;
+    }
 
     ecmdDataBufferBase mrs3(16);
     uint16_t MRS3 = 0;
     
-    uint8_t num_ranks_array[2][2]; //[port][dimm]
     
-    uint8_t num_ranks;
-    rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target, num_ranks_array);
+    uint8_t odt_wr[2][2][4];
+    rc = FAPI_ATTR_GET(ATTR_VPD_ODT_WR,  &i_target, odt_wr);
+    if(rc) return rc;
+    
+    uint8_t dram_stack[2][2];
+    rc = FAPI_ATTR_GET(ATTR_EFF_STACK_TYPE, &i_target, dram_stack);
     if(rc) return rc;
 
     uint8_t dimm_type;
@@ -1505,7 +1809,7 @@ ReturnCode mss_ddr4_disable_pda(Target& i_target,uint32_t& io_ccs_inst_cnt) {
     if(rc) return rc;
 
     uint8_t address_mirror_map[2][2]; //address_mirror_map[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
     if(rc) return rc;
 
     // WORKAROUNDS 
@@ -1585,6 +1889,19 @@ ReturnCode mss_ddr4_disable_pda(Target& i_target,uint32_t& io_ccs_inst_cnt) {
     rc = FAPI_ATTR_GET(ATTR_EFF_MPR_RD_FORMAT, &i_target, read_format);
     if(rc) return rc;
     
+    
+    //sets up the DRAM DQ drive time
+    uint8_t wl_launch_time;
+    uint8_t odt_hold_time;
+    uint8_t post_odt_nop_idle;
+    rc = mss_get_pda_odt_timings(i_target, wl_launch_time, odt_hold_time, post_odt_nop_idle);
+   
+    rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 0, 0, 16);
+    rc_num = rc_num | num_repeat_16.insertFromRight((uint32_t) 0, 0, 16);
+   
+    rc_num = rc_num | num_idles_16_odt.insertFromRight( post_odt_nop_idle, 0, 8);
+    rc_num = rc_num | num_repeat_16_odt.insertFromRight( odt_hold_time, 0, 8);
+    
     //exits PDA
     for(i_port_number=0;i_port_number<2;i_port_number++) {
     //loops through the DP18's and sets everything to 0's
@@ -1606,182 +1923,229 @@ ReturnCode mss_ddr4_disable_pda(Target& i_target,uint32_t& io_ccs_inst_cnt) {
     
     //exits PDA
     for(i_port_number=0;i_port_number<2;i_port_number++) {
-    	for ( dimm_number = 0; dimm_number < MAX_NUM_DIMMS; dimm_number++)
-    	{
-    	    num_ranks = num_ranks_array[i_port_number][dimm_number];
-
-    	    if (num_ranks == 0)
-    	    {
-    		FAPI_INF( "PORT%d DIMM%d not configured. Num_ranks: %d ", i_port_number, dimm_number, num_ranks);
-    	    }
-    	    else
-    	    {
-    		// Rank 0-3
-    		for ( rank_number = 0; rank_number < num_ranks; rank_number++)
-    		{
-    		   // Only corresponding CS to rank
-    		   rc_num = rc_num | csn_8.setBit(0,8); 
-    		   rc_num = rc_num | csn_8.clearBit(rank_number+4*dimm_number);
-    			
-    		   rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 0, 1, 7);
-    		   rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 1, 1, 6);
-    		   rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 2, 1, 5);
-    				
-	           //enables PDA
-	           rc_num = rc_num | mrs3.insert((uint8_t) mpr_page, 0, 2);
-	           rc_num = rc_num | mrs3.insert((uint8_t) mpr_op, 2, 1);
-	           rc_num = rc_num | mrs3.insert((uint8_t) geardown_mode, 3, 1);
-	           rc_num = rc_num | mrs3.insert((uint8_t) 0x00, 4, 1);
-	           rc_num = rc_num | mrs3.insert((uint8_t) temp_readout, 5, 1);
-	           rc_num = rc_num | mrs3.insert((uint8_t) fine_refresh, 6, 3);
-	           rc_num = rc_num | mrs3.insert((uint8_t) wr_latency, 9, 2);
-	           rc_num = rc_num | mrs3.insert((uint8_t) read_format, 11, 2);
-	           rc_num = rc_num | mrs3.insert((uint8_t) 0x00, 13, 2);
-	           rc_num = rc_num | mrs3.extractPreserve(&MRS3, 0, 16, 0);
-	           rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 100, 0, 16);
-		   
-		   //copies over values
-    		   rc_num = rc_num | address_16.insert(mrs3, 0, 16, 0);
-    		   if (rc_num)
-    		   {
-    		       FAPI_ERR( "mss_mrs_load: Error setting up buffers");
-    		       rc_buff.setEcmdError(rc_num);
-    		       return rc_buff;
-    		   }
-		   
-    		   if (( address_mirror_map[i_port_number][dimm_number] & (0x08 >> rank_number) ) && (is_sim == 0))
-    		   {
-    		      rc = mss_address_mirror_swizzle(i_target, i_port_number, dimm_number, rank_number, address_16, bank_3);
-    		      if(rc) return rc;
-    		   }
-		   
-    		   // Send out to the CCS array 
-    		   rc = mss_ccs_inst_arry_0( i_target,
-    				     io_ccs_inst_cnt,
-    				     address_16,
-    				     bank_3,
-    				     activate_1,
-    				     rasn_1,
-    				     casn_1,
-    				     wen_1,
-    				     cke_4,
-    				     csn_8,
-    				     odt_4,
-    				     ddr_cal_type_4,
-    				     i_port_number);
-    		   if(rc) return rc;
-    		   rc = mss_ccs_inst_arry_1( i_target,
-    				     io_ccs_inst_cnt,
-    				     num_idles_16,
-    				     num_repeat_16,
-    				     data_20,
-    				     read_compare_1,
-    				     rank_cal_4,
-    				     ddr_cal_enable_1,
-    				     ccs_end_1);
-    		   if(rc) return rc;
-    		   io_ccs_inst_cnt ++;
-		   
-		   //if the DIMM is an R or LR DIMM, then run inverted for the B-Side DRAM
-                   if ( (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_RDIMM) || (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) ) 
-		   {
-		   
-		       //reload all MRS values (removes address swizzling)
-		        // Only corresponding CS to rank
-    		       rc_num = rc_num | csn_8.setBit(0,8); 
-    		       rc_num = rc_num | csn_8.clearBit(rank_number+4*dimm_number);
-    		    	    
-    		       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 0, 1, 7);
-    		       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 1, 1, 6);
-    		       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 2, 1, 5);
-    		    		    
-	               //enables PDA
-	               rc_num = rc_num | mrs3.insert((uint8_t) mpr_page, 0, 2);
-	               rc_num = rc_num | mrs3.insert((uint8_t) mpr_op, 2, 1);
-	               rc_num = rc_num | mrs3.insert((uint8_t) geardown_mode, 3, 1);
-	               rc_num = rc_num | mrs3.insert((uint8_t) 0x00, 4, 1);
-	               rc_num = rc_num | mrs3.insert((uint8_t) temp_readout, 5, 1);
-	               rc_num = rc_num | mrs3.insert((uint8_t) fine_refresh, 6, 3);
-	               rc_num = rc_num | mrs3.insert((uint8_t) wr_latency, 9, 2);
-	               rc_num = rc_num | mrs3.insert((uint8_t) read_format, 11, 2);
-	               rc_num = rc_num | mrs3.insert((uint8_t) 0x00, 13, 2);
-	               rc_num = rc_num | mrs3.extractPreserve(&MRS3, 0, 16, 0);
-	               rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 100, 0, 16);
-		       //copies over values
-		       rc_num = rc_num | address_16.insert(mrs3, 0, 16, 0);
-		       
-		       //FLIPS all necessary bits
-		       // Indicate B-Side DRAMS BG1=1 
-                       rc_num = rc_num | address_16.setBit(15);  // Set BG1 = 1
- 
-                       rc_num = rc_num | address_16.flipBit(3,7); // Invert A3:A9
-                       rc_num = rc_num | address_16.flipBit(11);  // Invert A11
-                       rc_num = rc_num | address_16.flipBit(13);  // Invert A13
-                       rc_num = rc_num | address_16.flipBit(14);  // Invert A17
-                       rc_num = rc_num | bank_3.flipBit(0,3);	  // Invert BA0,BA1,BG0
-		       
-		       if (rc_num)
-    		       {
-    		     	   FAPI_ERR( "mss_ddr4_setup_pda: Error setting up buffers");
-    		     	   rc_buff.setEcmdError(rc_num);
-    		     	   return rc_buff;
-    		       }
-		     	   
-		     	   if (( address_mirror_map[i_port_number][dimm_number] & (0x08 >> rank_number) ) && (is_sim == 0))
-    		       {
-    		     	  rc = mss_address_mirror_swizzle(i_target, i_port_number, dimm_number, rank_number, address_16, bank_3);
-    		     	  if(rc) return rc;
-    		       }
-    		       
-    		       // Send out to the CCS array 
-    		       rc = mss_ccs_inst_arry_0( i_target,
-    		     	 		 io_ccs_inst_cnt,
-    		     	 		 address_16,
-    		     	 		 bank_3,
-    		     	 		 activate_1,
-    		     	 		 rasn_1,
-    		     	 		 casn_1,
-    		     	 		 wen_1,
-    		     	 		 cke_4,
-    		     	 		 csn_8,
-    		     	 		 odt_4,
-    		     	 		 ddr_cal_type_4,
-    		     	 		 i_port_number);
-    		       if(rc) return rc;
-    		       rc = mss_ccs_inst_arry_1( i_target,
-    		     	 		 io_ccs_inst_cnt,
-    		     	 		 num_idles_16,
-    		     	 		 num_repeat_16,
-    		     	 		 data_20,
-    		     	 		 read_compare_1,
-    		     	 		 rank_cal_4,
-    		     	 		 ddr_cal_enable_1,
-    		     	 		 ccs_end_1);
-    		       if(rc) return rc;
-    		       io_ccs_inst_cnt ++;
-		    }
-    		}    
-    	    }
-    	}
-   }
-   
-   //Setup end bit for CCS
-    rc = mss_ccs_set_end_bit (i_target, io_ccs_inst_cnt-1);
-    if (rc) return rc;
-   
-   //Execute the CCS array
-   FAPI_INF("Executing the CCS array\n");
-   rc = mss_execute_ccs_inst_array (i_target, NUM_POLL, WAIT_TIMER);
-   
-   //Disable CCS
-   FAPI_INF("Disabling CCS\n");
-   reg_address = CCS_MODEQ_AB_REG_0x030106A7;
-   rc = fapiGetScom(i_target, reg_address, data_buffer);
-   if(rc) return rc;
-
-
-   rc_num |= data_buffer.clearBit(29);
-   if (rc_num) {
+       // Only corresponding CS to rank
+       rc_num = rc_num | csn_8.setBit(0,8); 
+       if(dram_stack[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+          rc_num = rc_num | csn_8.clearBit(2,2); 
+          rc_num = rc_num | csn_8.clearBit(6,2); 
+       }
+       rc_num = rc_num | csn_8.clearBit(rank_number+4*dimm_number);
+    
+       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 0, 1, 7);
+       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 1, 1, 6);
+       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 2, 1, 5);
+    	    	    
+       //enables PDA
+       rc_num = rc_num | mrs3.insert((uint8_t) mpr_page, 0, 2);
+       rc_num = rc_num | mrs3.insert((uint8_t) mpr_op, 2, 1);
+       rc_num = rc_num | mrs3.insert((uint8_t) geardown_mode, 3, 1);
+       rc_num = rc_num | mrs3.insert((uint8_t) 0x00, 4, 1);
+       rc_num = rc_num | mrs3.insert((uint8_t) temp_readout, 5, 1);
+       rc_num = rc_num | mrs3.insert((uint8_t) fine_refresh, 6, 3);
+       rc_num = rc_num | mrs3.insert((uint8_t) wr_latency, 9, 2);
+       rc_num = rc_num | mrs3.insert((uint8_t) read_format, 11, 2);
+       rc_num = rc_num | mrs3.insert((uint8_t) 0x00, 13, 2);
+       rc_num = rc_num | mrs3.extractPreserve(&MRS3, 0, 16, 0);
+       rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 100, 0, 16);
+       rc_num = rc_num | odt_4.insert(odt_wr[i_port_number][dimm_number][rank_number], 0, 4, 0);
+
+       //copies over values
+       rc_num = rc_num | address_16.insert(mrs3, 0, 16, 0);
+       if (rc_num)
+       {
+           FAPI_ERR( "mss_mrs_load: Error setting up buffers");
+           rc_buff.setEcmdError(rc_num);
+           return rc_buff;
+       }
+
+       if (( address_mirror_map[i_port_number][dimm_number] & (0x08 >> rank_number) ) && (is_sim == 0))
+       {
+          rc = mss_address_mirror_swizzle(i_target, i_port_number, dimm_number, rank_number, address_16, bank_3);
+          if(rc) return rc;
+       }
+
+       // Send out to the CCS array 
+       rc = mss_ccs_inst_arry_0( i_target,
+    	    		 io_ccs_inst_cnt,
+    	    		 address_16,
+    	    		 bank_3,
+    	    		 activate_1,
+    	    		 rasn_1,
+    	    		 casn_1,
+    	    		 wen_1,
+    	    		 cke_4,
+    	    		 csn_8,
+    	    		 odt_4,
+    	    		 ddr_cal_type_4,
+    	    		 i_port_number);
+       if(rc) return rc;
+       rc = mss_ccs_inst_arry_1( i_target,
+    	    		 io_ccs_inst_cnt,
+    	    		 num_idles_16,
+    	    		 num_repeat_16,
+    	    		 data_20,
+    	    		 read_compare_1,
+    	    		 rank_cal_4,
+    	    		 ddr_cal_enable_1,
+    	    		 ccs_end_1);
+       if(rc) return rc;
+       io_ccs_inst_cnt ++;
+
+       // Send out to the CCS array 
+       rc = mss_ccs_inst_arry_0( i_target,
+        	io_ccs_inst_cnt,
+        	address_16,
+        	bank_3,
+        	activate_1,
+        	rasn_1_odt,
+        	casn_1_odt,
+        	wen_1_odt,
+        	cke_4,
+        	csn_8_odt,
+        	odt_4,
+        	ddr_cal_type_4,
+        	i_port_number);
+       if(rc) return rc;
+       rc = mss_ccs_inst_arry_1( i_target,
+        	io_ccs_inst_cnt,
+        	num_idles_16_odt,
+        	num_repeat_16_odt,
+        	data_20,
+        	read_compare_1,
+        	rank_cal_4,
+        	ddr_cal_enable_1,
+        	ccs_end_1);
+       if(rc) return rc;
+       io_ccs_inst_cnt ++;
+
+       //if the DIMM is an R or LR DIMM, then run inverted for the B-Side DRAM
+       if ( (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_RDIMM) || (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) ) 
+       {
+
+           //reload all MRS values (removes address swizzling)
+            // Only corresponding CS to rank
+           rc_num = rc_num | csn_8.setBit(0,8); 
+           if(dram_stack[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+              rc_num = rc_num | csn_8.clearBit(2,2); 
+              rc_num = rc_num | csn_8.clearBit(6,2); 
+           }
+           rc_num = rc_num | csn_8.clearBit(rank_number+4*dimm_number);
+        	
+           rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 0, 1, 7);
+           rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 1, 1, 6);
+           rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 2, 1, 5);
+        		
+           //enables PDA
+           rc_num = rc_num | mrs3.insert((uint8_t) mpr_page, 0, 2);
+           rc_num = rc_num | mrs3.insert((uint8_t) mpr_op, 2, 1);
+           rc_num = rc_num | mrs3.insert((uint8_t) geardown_mode, 3, 1);
+           rc_num = rc_num | mrs3.insert((uint8_t) 0x00, 4, 1);
+           rc_num = rc_num | mrs3.insert((uint8_t) temp_readout, 5, 1);
+           rc_num = rc_num | mrs3.insert((uint8_t) fine_refresh, 6, 3);
+           rc_num = rc_num | mrs3.insert((uint8_t) wr_latency, 9, 2);
+           rc_num = rc_num | mrs3.insert((uint8_t) read_format, 11, 2);
+           rc_num = rc_num | mrs3.insert((uint8_t) 0x00, 13, 2);
+           rc_num = rc_num | mrs3.extractPreserve(&MRS3, 0, 16, 0);
+           rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 100, 0, 16);
+           //copies over values
+           rc_num = rc_num | address_16.insert(mrs3, 0, 16, 0);
+           
+           //FLIPS all necessary bits
+           // Indicate B-Side DRAMS BG1=1 
+           rc_num = rc_num | address_16.setBit(15);  // Set BG1 = 1
+ 
+           rc_num = rc_num | address_16.flipBit(3,7); // Invert A3:A9
+           rc_num = rc_num | address_16.flipBit(11);  // Invert A11
+           rc_num = rc_num | address_16.flipBit(13);  // Invert A13
+           rc_num = rc_num | address_16.flipBit(14);  // Invert A17
+           rc_num = rc_num | bank_3.flipBit(0,3);     // Invert BA0,BA1,BG0
+           
+           if (rc_num)
+           {
+               FAPI_ERR( "mss_ddr4_setup_pda: Error setting up buffers");
+               rc_buff.setEcmdError(rc_num);
+               return rc_buff;
+           }
+               
+               if (( address_mirror_map[i_port_number][dimm_number] & (0x08 >> rank_number) ) && (is_sim == 0))
+           {
+              rc = mss_address_mirror_swizzle(i_target, i_port_number, dimm_number, rank_number, address_16, bank_3);
+              if(rc) return rc;
+           }
+           
+           // Send out to the CCS array 
+           rc = mss_ccs_inst_arry_0( i_target,
+        		     io_ccs_inst_cnt,
+        		     address_16,
+        		     bank_3,
+        		     activate_1,
+        		     rasn_1,
+        		     casn_1,
+        		     wen_1,
+        		     cke_4,
+        		     csn_8,
+        		     odt_4,
+        		     ddr_cal_type_4,
+        		     i_port_number);
+           if(rc) return rc;
+           rc = mss_ccs_inst_arry_1( i_target,
+        		     io_ccs_inst_cnt,
+        		     num_idles_16,
+        		     num_repeat_16,
+        		     data_20,
+        		     read_compare_1,
+        		     rank_cal_4,
+        		     ddr_cal_enable_1,
+        		     ccs_end_1);
+           if(rc) return rc;
+           io_ccs_inst_cnt ++;
+           
+           // Send out to the CCS array 
+           rc = mss_ccs_inst_arry_0( i_target,
+	    	    io_ccs_inst_cnt,
+	    	    address_16,
+	    	    bank_3,
+	    	    activate_1,
+	    	    rasn_1_odt,
+	    	    casn_1_odt,
+	    	    wen_1_odt,
+	    	    cke_4,
+	    	    csn_8_odt,
+	    	    odt_4,
+	    	    ddr_cal_type_4,
+	    	    i_port_number);
+           if(rc) return rc;
+           rc = mss_ccs_inst_arry_1( i_target,
+	    	    io_ccs_inst_cnt,
+	    	    num_idles_16_odt,
+	    	    num_repeat_16_odt,
+	    	    data_20,
+	    	    read_compare_1,
+	    	    rank_cal_4,
+	    	    ddr_cal_enable_1,
+	    	    ccs_end_1);
+           if(rc) return rc;
+           io_ccs_inst_cnt ++;
+       }
+   }
+   
+   //Setup end bit for CCS
+    rc = mss_ccs_set_end_bit (i_target, io_ccs_inst_cnt-1);
+    if (rc) return rc;
+   
+   //Execute the CCS array
+   FAPI_INF("Executing the CCS array\n");
+   rc = mss_execute_ccs_inst_array (i_target, NUM_POLL, WAIT_TIMER);
+   
+   //Disable CCS
+   FAPI_INF("Disabling CCS\n");
+   reg_address = CCS_MODEQ_AB_REG_0x030106A7;
+   rc = fapiGetScom(i_target, reg_address, data_buffer);
+   if(rc) return rc;
+
+
+   rc_num |= data_buffer.clearBit(29);
+   if (rc_num) {
       FAPI_ERR( "disable ccs setup: Error disabling up buffers");
       rc_buff.setEcmdError(rc_num);
       return rc_buff;
@@ -1818,1686 +2182,82 @@ ReturnCode mss_ddr4_disable_pda(Target& i_target,uint32_t& io_ccs_inst_cnt) {
    
    FAPI_INF("Successfully exited out of PDA mode.");
    io_ccs_inst_cnt = 0;
+   
+   //Does the RTT_WR to RTT_NOM swapping
+    //loops through all ports
+    for(i_port_number=0;i_port_number<MAX_NUM_PORTS;i_port_number++) {
+       uint8_t io_dram_rtt_nom_original = 0;
+       rc = mss_ddr4_rtt_nom_rtt_wr_swap(i_target,0,i_port_number,rank_number+dimm_number*4,0xFF,io_ccs_inst_cnt,io_dram_rtt_nom_original);
+       if(rc) return rc;
+       io_ccs_inst_cnt = 0;
+    }
+   
    return rc;
 }
 
-//////////////////////////////////////////////////////////////////////////////////
-/// mss_ddr4_modify_mrs_pda
-/// disables per-DRAM addressability funcitonality on both ports on the passed MBA
-//////////////////////////////////////////////////////////////////////////////////
-ReturnCode mss_ddr4_modify_mrs_pda(Target& i_target,ecmdDataBufferBase& address_16,uint32_t attribute_name,uint8_t attribute_data) {
-   ReturnCode rc;
-   uint32_t rc_num = 0;
-   uint8_t dram_bl = attribute_data;
-   uint8_t read_bt = attribute_data; //Read Burst Type 
-   uint8_t dram_cl = attribute_data;
-   uint8_t test_mode = attribute_data; //TEST MODE 
-   uint8_t dll_reset = attribute_data; //DLL Reset 
-   uint8_t dram_wr = attribute_data; //DRAM write recovery
-   uint8_t dram_rtp = attribute_data; //DRAM RTP - read to precharge
-   uint8_t dram_wr_rtp = attribute_data;
-   uint8_t dll_precharge = attribute_data; //DLL Control For Precharge if (dll_precharge == ENUM_ATTR_EFF_DRAM_DLL_PPD_SLOWEXIT)
-   uint8_t dll_enable = attribute_data; //DLL Enable 
-   uint8_t out_drv_imp_cntl = attribute_data;
-   uint8_t dram_rtt_nom = attribute_data;
-   uint8_t dram_al = attribute_data;
-   uint8_t wr_lvl = attribute_data; //write leveling enable
-   uint8_t tdqs_enable = attribute_data; //TDQS Enable 
-   uint8_t q_off = attribute_name; //Qoff - Output buffer Enable 
-   uint8_t lpasr = attribute_data; // Low Power Auto Self-Refresh -- new not yet supported
-   uint8_t cwl = attribute_data; // CAS Write Latency 
-   uint8_t dram_rtt_wr = attribute_data;
-   uint8_t mpr_op = attribute_data; // MPR Op
-   uint8_t mpr_page = attribute_data; // MPR Page Selection  
-   uint8_t geardown_mode = attribute_data; // Gear Down Mode  
-   uint8_t temp_readout = attribute_data; // Temperature sensor readout  
-   uint8_t fine_refresh = attribute_data; // fine refresh mode  
-   uint8_t wr_latency = attribute_data; // write latency for CRC and DM  
-   uint8_t write_crc = attribute_data; // CAS Write Latency 
-   uint8_t read_format = attribute_data; // MPR READ FORMAT  
-   uint8_t max_pd_mode = attribute_data; // Max Power down mode 
-   uint8_t temp_ref_range = attribute_data; // Temp ref range 
-   uint8_t temp_ref_mode = attribute_data; // Temp controlled ref mode 
-   uint8_t vref_mon = attribute_data; // Internal Vref Monitor 
-   uint8_t cs_cmd_latency = attribute_data; // CS to CMD/ADDR Latency 
-   uint8_t ref_abort = attribute_data; // Self Refresh Abort 
-   uint8_t rd_pre_train_mode = attribute_data; // Read Pre amble Training Mode 
-   uint8_t rd_preamble = attribute_data; // Read Pre amble 
-   uint8_t wr_preamble = attribute_data; // Write Pre amble 
-   uint8_t ca_parity_latency = attribute_data; //C/A Parity Latency Mode  
-   uint8_t crc_error_clear = attribute_data; //CRC Error Clear  
-   uint8_t ca_parity_error_status = attribute_data; //C/A Parity Error Status  
-   uint8_t odt_input_buffer = attribute_data; //ODT Input Buffer during power down  
-   uint8_t rtt_park = attribute_data; //RTT_Park value  
-   uint8_t ca_parity = attribute_data; //CA Parity Persistance Error  
-   uint8_t data_mask = attribute_data; //Data Mask  
-   uint8_t write_dbi = attribute_data; //Write DBI  
-   uint8_t read_dbi = attribute_data; //Read DBI  
-   uint8_t vrefdq_train_value = attribute_data; //vrefdq_train value   
-   uint8_t vrefdq_train_range = attribute_data; //vrefdq_train range   
-   uint8_t vrefdq_train_enable = attribute_data; //vrefdq_train enable  
-   uint8_t tccd_l = attribute_data; //tccd_l  
-   uint8_t dram_access;
-
-   switch (attribute_name) {
-       case ATTR_EFF_DRAM_BL:
-	   if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_BL8)
-           {
-               dram_bl = 0x00;
-           }
-           else if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_OTF)
-           {
-               dram_bl = 0x80;
-           }
-           else if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_BC4)
-           {
-               dram_bl = 0x40;
-           }
-	   rc_num = rc_num | address_16.insert((uint8_t) dram_bl, 0, 2, 0);
-	   break;
-       case ATTR_EFF_DRAM_RBT:
-	   if (read_bt == ENUM_ATTR_EFF_DRAM_RBT_SEQUENTIAL)
-           {
-               read_bt = 0x00;
-           }
-           else if (read_bt == ENUM_ATTR_EFF_DRAM_RBT_INTERLEAVE)
-           {
-               read_bt = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) read_bt, 3, 1, 0);
-	   break;
-       case ATTR_EFF_DRAM_CL:
-	   if ((dram_cl > 8)&&(dram_cl < 17))
-           {
-               dram_cl = dram_cl - 9; 
-           }
-           else if ((dram_cl > 17)&&(dram_cl < 25))
-           {
-               dram_cl = (dram_cl >> 1) - 1;   
-           }
-           dram_cl = mss_reverse_8bits(dram_cl);
-           rc_num = rc_num | address_16.insert((uint8_t) dram_cl, 2, 1, 0);
-           rc_num = rc_num | address_16.insert((uint8_t) dram_cl, 4, 3, 1);
-	   break;
-       case ATTR_EFF_DRAM_TM:
-	   if (test_mode == ENUM_ATTR_EFF_DRAM_TM_NORMAL)
-           {
-               test_mode = 0x00;
-           }
-           else if (test_mode == ENUM_ATTR_EFF_DRAM_TM_TEST)
-           {
-               test_mode = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) test_mode, 7, 1);
-	   break;
-       case ATTR_EFF_DRAM_DLL_RESET:
-	   dll_reset = 0x00;
-	   FAPI_ERR( "ERROR: ATTR_EFF_DRAM_DLL_RESET accessed during PDA functionality, overwritten");
-           rc_num = rc_num | address_16.insert((uint8_t) dll_reset, 8, 1);
-	   break;
-       case ATTR_EFF_DRAM_WR:
-           if ( (dram_wr == 10) )//&& (dram_rtp == 5) )
-           {
-               dram_wr_rtp = 0x00;
-           }
-           else if ( (dram_wr == 12) )//&& (dram_rtp == 6) )
-           {
-               dram_wr_rtp = 0x80;
-           }
-           else if ( (dram_wr == 13) )//&& (dram_rtp == 7) )
-           {
-               dram_wr_rtp = 0x40;
-           }
-           else if ( (dram_wr == 14) )//&& (dram_rtp == 8) )
-           {
-               dram_wr_rtp = 0xC0;
-           }
-           else if ( (dram_wr == 18) )//&& (dram_rtp == 9) )
-           {
-               dram_wr_rtp = 0x20;
-           }
-           else if ( (dram_wr == 20) )//&& (dram_rtp == 10) )
-           {
-               dram_wr_rtp = 0xA0;
-           }
-           else if ( (dram_wr == 24) )//&& (dram_rtp == 12) )
-           {
-               dram_wr_rtp = 0x60;
-           }
-    	   rc_num = rc_num | address_16.insert((uint8_t) dram_wr_rtp, 9, 3);
-	   break;
-       case ATTR_EFF_DRAM_TRTP:
-           if ( (dram_rtp == 5) )
-           {
-               dram_wr_rtp = 0x00;
-           }
-           else if ( (dram_rtp == 6) )
-           {
-               dram_wr_rtp = 0x80;
-           }
-           else if ( (dram_rtp == 7) )
-           {
-               dram_wr_rtp = 0x40;
-           }
-           else if ( (dram_rtp == 8) )
-           {
-               dram_wr_rtp = 0xC0;
-           }
-           else if ( (dram_rtp == 9) )
-           {
-               dram_wr_rtp = 0x20;
-           }
-           else if ( (dram_rtp == 10) )
-           {
-               dram_wr_rtp = 0xA0;
-           }
-           else if ( (dram_rtp == 12) )
-           {
-               dram_wr_rtp = 0x60;
-           }
-    	   rc_num = rc_num | address_16.insert((uint8_t) dram_wr_rtp, 9, 3);
-	   break;
-       case ATTR_EFF_DRAM_DLL_PPD:
-           if (dll_precharge == ENUM_ATTR_EFF_DRAM_DLL_PPD_SLOWEXIT)
-	   {
-               dll_precharge = 0x00;
-           }
-           else if (dll_precharge == ENUM_ATTR_EFF_DRAM_DLL_PPD_FASTEXIT)
-           {
-               dll_precharge = 0xFF;
-           }
-	   FAPI_INF("ERROR: ATTR_EFF_DRAM_DLL_PPD is an unused MRS value!!! Skipping...");
-	   break;
-       case ATTR_EFF_DRAM_DLL_ENABLE:
-           if (dll_enable == ENUM_ATTR_EFF_DRAM_DLL_ENABLE_DISABLE)
-           {
-               dll_enable = 0x00;
-           }
-           else if (dll_enable == ENUM_ATTR_EFF_DRAM_DLL_ENABLE_ENABLE)
-           {
-               dll_enable = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) dll_enable, 0, 1, 0);
-	   break;
-       case ATTR_VPD_DRAM_RON:
-	   if (out_drv_imp_cntl == ENUM_ATTR_VPD_DRAM_RON_OHM34)
-           {
-               out_drv_imp_cntl = 0x00;
-           }
-    	   // Not currently supported
-           else if (out_drv_imp_cntl == ENUM_ATTR_VPD_DRAM_RON_OHM48) //not supported
-           {
-               out_drv_imp_cntl = 0x80;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) out_drv_imp_cntl, 1, 2, 0);
-	   break;
-       case ATTR_VPD_DRAM_RTT_NOM:
-	   if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_DISABLE)
-           {
-               dram_rtt_nom = 0x00;
-           }
-           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM240) //not supported
-           {
-               dram_rtt_nom = 0x20;
-           }
-           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM48) //not supported
-           {
-               dram_rtt_nom = 0xA0;
-           }
-           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM40)
-           {
-               dram_rtt_nom = 0xC0;
-           }
-           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM60)
-           {
-               dram_rtt_nom = 0x80;
-           }
-           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM120)
-           {
-               dram_rtt_nom = 0x40;
-           }
-           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM80) // not supported
-           {
-               dram_rtt_nom = 0x60;
-           }
-           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM34) // not supported
-           {
-               dram_rtt_nom = 0xE0;
-           }
-	   
-           rc_num = rc_num | address_16.insert((uint8_t) dram_rtt_nom, 8, 3, 0);
-	   break;
-       case ATTR_EFF_DRAM_AL:
-	   if (dram_al == ENUM_ATTR_EFF_DRAM_AL_DISABLE)
-           {
-               dram_al = 0x00;
-           }
-           else if (dram_al == ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_1)
-           {
-               dram_al = 0x80;
-           }
-           else if (dram_al == ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_2)
-           {
-               dram_al = 0x40;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) dram_al, 3, 2, 0);
-	   break;
-       case ATTR_EFF_DRAM_WR_LVL_ENABLE:
-	   if (wr_lvl == ENUM_ATTR_EFF_DRAM_WR_LVL_ENABLE_DISABLE)
-           {
-               wr_lvl = 0x00;
-           }
-           else if (wr_lvl == ENUM_ATTR_EFF_DRAM_WR_LVL_ENABLE_ENABLE)
-           {
-               wr_lvl = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) wr_lvl, 7, 1, 0);
-	   break;
-       case ATTR_EFF_DRAM_TDQS:
-	   if (tdqs_enable == ENUM_ATTR_EFF_DRAM_TDQS_DISABLE)
-           {
-               tdqs_enable = 0x00;
-           }
-           else if (tdqs_enable == ENUM_ATTR_EFF_DRAM_TDQS_ENABLE)
-           {
-               tdqs_enable = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) tdqs_enable, 11, 1, 0);
-	   break;
-       case ATTR_EFF_DRAM_OUTPUT_BUFFER:
-           if (q_off == ENUM_ATTR_EFF_DRAM_OUTPUT_BUFFER_DISABLE)
-           {
-               q_off = 0xFF;
-           }
-           else if (q_off == ENUM_ATTR_EFF_DRAM_OUTPUT_BUFFER_ENABLE)
-           {
-               q_off = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) q_off, 12, 1, 0);
-	   break;
-       case ATTR_EFF_DRAM_LPASR:
-           if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_NORMAL)
-           {
-               lpasr = 0x00;
-           }
-           else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_REDUCED)
-           {
-               lpasr = 0x80;
-           }
-           else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_EXTENDED)
-           {
-               lpasr = 0x40;
-           }
-           else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_ASR)
-           {
-               lpasr = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) lpasr, 6, 2);
-	   break;
-       case ATTR_EFF_DRAM_CWL:
-	   if ((cwl > 8)&&(cwl < 13))
-           {
-               cwl = cwl - 9; 
-           }
-           else if ((cwl > 13)&&(cwl < 19))
-           {
-               cwl = (cwl >> 1) - 3;   
-           }
-           else
-           {
-              //no correcct value for CWL was found
-              FAPI_INF("ERROR: Improper CWL value found. Setting CWL to 9 and continuing...");
-              cwl = 0;
-           }
-	   cwl = mss_reverse_8bits(cwl);
-	   rc_num = rc_num | address_16.insert((uint8_t) cwl, 3, 3);
-	   break;
-       case ATTR_VPD_DRAM_RTT_WR:
-	   if (dram_rtt_wr == ENUM_ATTR_VPD_DRAM_RTT_WR_DISABLE)
-           {
-               dram_rtt_wr = 0x00;
-           }
-           else if (dram_rtt_wr == ENUM_ATTR_VPD_DRAM_RTT_WR_OHM120)
-           {
-               dram_rtt_wr = 0x80;
-           }
-           else if (dram_rtt_wr == 240)//ENUM_ATTR_EFF_DRAM_RTT_WR_OHM240)
-           {
-               dram_rtt_wr = 0x40;
-           }
-           else if (dram_rtt_wr == 0xFF)//ENUM_ATTR_EFF_DRAM_RTT_WR_HIGHZ)
-           {
-               dram_rtt_wr = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) dram_rtt_wr, 9, 2);
-           break;
-       case ATTR_EFF_WRITE_CRC:
-	   if ( write_crc == ENUM_ATTR_EFF_WRITE_CRC_ENABLE)
-           {
-               write_crc = 0xFF;
-           }
-           else if (write_crc == ENUM_ATTR_EFF_WRITE_CRC_DISABLE)
-           {
-               write_crc = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) write_crc, 12, 1);
-	   break;
-       case ATTR_EFF_MPR_MODE:
-	   if (mpr_op == ENUM_ATTR_EFF_MPR_MODE_ENABLE)
-           {
-               mpr_op = 0xFF;
-           }
-           else if (mpr_op == ENUM_ATTR_EFF_MPR_MODE_DISABLE)
-           {
-               mpr_op = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) mpr_op, 2, 1);
-	   break;
-       case ATTR_EFF_MPR_PAGE:
-           mpr_page = mss_reverse_8bits(mpr_page);
-    	   rc_num = rc_num | address_16.insert((uint8_t) mpr_page, 0, 2);
-	   break;
-       case ATTR_EFF_GEARDOWN_MODE:
-	   if ( geardown_mode == ENUM_ATTR_EFF_GEARDOWN_MODE_HALF)
-           {
-        	geardown_mode = 0x00;
-           }
-           else if ( geardown_mode == ENUM_ATTR_EFF_GEARDOWN_MODE_QUARTER)
-           {
-        	geardown_mode = 0xFF;
-           }
-           
-           if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_ENABLE)
-           {
-               temp_readout = 0xFF;
-           }
-           else if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_DISABLE)
-           {
-               temp_readout = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) geardown_mode, 3, 1);
-	   break;
-       case ATTR_EFF_TEMP_READOUT:
-	   if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_ENABLE)
-    	   {
-    	       temp_readout = 0xFF;
-    	   }
-    	   else if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_DISABLE)
-    	   {
-    	       temp_readout = 0x00;
-    	   }
-           rc_num = rc_num | address_16.insert((uint8_t) temp_readout, 5, 1);
-	   break;
-       case ATTR_EFF_FINE_REFRESH_MODE:
-	   if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_NORMAL)
-           {
-               fine_refresh = 0x00;
-           }
-           else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FIXED_2X)
-           {
-               fine_refresh = 0x80;
-           }
-           else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FIXED_4X)
-           {
-               fine_refresh = 0x40;
-           }
-           else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FLY_2X)
-           {
-               fine_refresh = 0xA0;
-           }
-           else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FLY_4X)
-           {
-               fine_refresh = 0x60;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) fine_refresh, 6, 3);
-	   break;
-       case ATTR_EFF_CRC_WR_LATENCY:
-           if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_4NCK)
-           {
-               wr_latency = 0x00;
-           }
-           else if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_5NCK)
-           {
-               wr_latency = 0x80;
-           }
-           else if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_6NCK)
-           {
-               wr_latency = 0xC0;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) wr_latency, 9, 2);
-	   break;
-       case ATTR_EFF_MPR_RD_FORMAT:
-           if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_SERIAL)
-           {
-               read_format = 0x00;
-           }
-           else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_PARALLEL)
-           {
-               read_format = 0x80;
-           }
-           else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_STAGGERED)
-           {
-               read_format = 0x40;
-           }
-           else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_RESERVED_TEMP)
-           {
-               read_format = 0xC0;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) read_format, 11, 2);
-	   break;
-       case ATTR_EFF_PER_DRAM_ACCESS:
-           FAPI_INF("ERROR: ATTR_EFF_PER_DRAM_ACCESS selected.  Forcing PDA to be on for this function");
-	   dram_access = 0xFF;
-	   rc_num = rc_num | address_16.insert((uint8_t) dram_access, 4, 1);
-	   break;
-       case ATTR_EFF_MAX_POWERDOWN_MODE:
-	   if ( max_pd_mode == ENUM_ATTR_EFF_MAX_POWERDOWN_MODE_ENABLE)
-           {
-               max_pd_mode = 0xF0;
-           }
-           else if ( max_pd_mode == ENUM_ATTR_EFF_MAX_POWERDOWN_MODE_DISABLE)
-           {
-               max_pd_mode = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) max_pd_mode, 1, 1);
-	   break;
-       case ATTR_EFF_TEMP_REF_RANGE:
-	   if (temp_ref_range == ENUM_ATTR_EFF_TEMP_REF_RANGE_NORMAL)
-           {
-               temp_ref_range = 0x00;
-           }
-           else if ( temp_ref_range== ENUM_ATTR_EFF_TEMP_REF_RANGE_EXTEND)
-           {
-               temp_ref_range = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) temp_ref_range, 2, 1);
-	   break;
-       case ATTR_EFF_TEMP_REF_MODE:
-	   if (temp_ref_mode == ENUM_ATTR_EFF_TEMP_REF_MODE_ENABLE)
-           {
-               temp_ref_mode = 0x80;
-           }
-           else if (temp_ref_mode == ENUM_ATTR_EFF_TEMP_REF_MODE_DISABLE)
-           {
-               temp_ref_mode = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) temp_ref_mode, 3, 1);
-	   break;
-       case ATTR_EFF_INT_VREF_MON:
-	   if ( vref_mon == ENUM_ATTR_EFF_INT_VREF_MON_ENABLE)
-           {
-               vref_mon = 0xFF;
-           }
-           else if ( vref_mon == ENUM_ATTR_EFF_INT_VREF_MON_DISABLE)
-           {
-               vref_mon = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) vref_mon, 4, 1);
-	   break;
-       case ATTR_EFF_CS_CMD_LATENCY:
-	   if ( cs_cmd_latency == 3)
-           {
-               cs_cmd_latency = 0x80;
-           }
-           else if (cs_cmd_latency == 4)
-           {
-               cs_cmd_latency = 0x40;
-           }
-           else if (cs_cmd_latency == 5)
-           {
-               cs_cmd_latency = 0xC0;
-           }
-           else if (cs_cmd_latency == 6)
-           {
-               cs_cmd_latency = 0x20;
-           }
-           else if (cs_cmd_latency == 8)
-           {
-               cs_cmd_latency = 0xA0;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) cs_cmd_latency, 6, 3);
-	   break;
-       case ATTR_EFF_SELF_REF_ABORT:
-	   if (ref_abort == ENUM_ATTR_EFF_SELF_REF_ABORT_ENABLE)
-           {
-               ref_abort = 0xFF;
-           }
-           else if (ref_abort == ENUM_ATTR_EFF_SELF_REF_ABORT_DISABLE)
-           {
-               ref_abort = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) ref_abort, 9, 1);
-	   break;
-       case ATTR_EFF_RD_PREAMBLE_TRAIN:
-	   if (rd_pre_train_mode == ENUM_ATTR_EFF_RD_PREAMBLE_TRAIN_ENABLE)
-           {
-               rd_pre_train_mode = 0xFF;
-           }
-           else if (rd_pre_train_mode == ENUM_ATTR_EFF_RD_PREAMBLE_TRAIN_DISABLE)
-           {
-               rd_pre_train_mode = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) rd_pre_train_mode, 10, 1);
-	   break;
-       case ATTR_EFF_RD_PREAMBLE:
-	   if (rd_preamble == ENUM_ATTR_EFF_RD_PREAMBLE_1NCLK)
-           {
-               rd_preamble = 0x00;
-           }
-           else if (rd_preamble == ENUM_ATTR_EFF_RD_PREAMBLE_2NCLK)
-           {
-               rd_preamble = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) rd_preamble, 11, 1);
-	   break;
-       case ATTR_EFF_WR_PREAMBLE:
-           if (wr_preamble == ENUM_ATTR_EFF_WR_PREAMBLE_1NCLK)
-           {
-               wr_preamble = 0x00;
-           }
-           else if (wr_preamble == ENUM_ATTR_EFF_WR_PREAMBLE_2NCLK)
-           {
-               wr_preamble = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) wr_preamble, 12, 1);
-	   break;
-       case ATTR_EFF_CA_PARITY_LATENCY:
-	   if (ca_parity_latency == 4)
-           {
-               ca_parity_latency = 0x80;
-           }
-           else if (ca_parity_latency == 5)
-           {
-               ca_parity_latency = 0x40;
-           }
-           else if (ca_parity_latency == 6)
-           {
-               ca_parity_latency = 0xC0;
-           }
-           else if (ca_parity_latency == 8)
-           {
-               ca_parity_latency = 0x20;
-           }
-           else if (ca_parity_latency == ENUM_ATTR_EFF_CA_PARITY_LATENCY_DISABLE)
-           {
-               ca_parity_latency = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) ca_parity_latency, 0, 2);
-	   break;
-       case ATTR_EFF_CRC_ERROR_CLEAR:
-	   if (crc_error_clear == ENUM_ATTR_EFF_CRC_ERROR_CLEAR_ERROR)
-           {
-               crc_error_clear = 0xFF;
-           }
-           else if (crc_error_clear == ENUM_ATTR_EFF_CRC_ERROR_CLEAR_CLEAR)
-           {
-               crc_error_clear = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) crc_error_clear, 3, 1);
-	   break;
-       case ATTR_EFF_CA_PARITY_ERROR_STATUS:
-	   if (ca_parity_error_status == ENUM_ATTR_EFF_CA_PARITY_ERROR_STATUS_ERROR)
-           {
-               ca_parity_error_status = 0xFF;
-           }
-           else if (ca_parity_error_status == ENUM_ATTR_EFF_CA_PARITY_ERROR_STATUS_CLEAR)
-           {
-               ca_parity_error_status = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) ca_parity_error_status, 4, 1);
-	   break;
-       case ATTR_EFF_ODT_INPUT_BUFF:
-	   if (odt_input_buffer == ENUM_ATTR_EFF_ODT_INPUT_BUFF_ACTIVATED)
-           {
-               odt_input_buffer = 0x00;
-           }
-           else if (odt_input_buffer == ENUM_ATTR_EFF_ODT_INPUT_BUFF_DEACTIVATED)
-           {
-               odt_input_buffer = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) odt_input_buffer, 5, 1);
-	   break;
-       case ATTR_EFF_RTT_PARK:
-	   if (rtt_park == ENUM_ATTR_EFF_RTT_PARK_DISABLE)
-           {
-               rtt_park = 0x00;
-           }
-           else if (rtt_park == ENUM_ATTR_EFF_RTT_PARK_60OHM)
-           {
-               rtt_park = 0x80;
-           }
-           else if (rtt_park == ENUM_ATTR_EFF_RTT_PARK_40OHM)
-           {
-               rtt_park = 0xC0;
-           }
-           else if (rtt_park == ENUM_ATTR_EFF_RTT_PARK_120OHM)
-           {
-               rtt_park = 0x40;
-           }
-           else if (rtt_park == ENUM_ATTR_EFF_RTT_PARK_240OHM)
-           {
-               rtt_park = 0x20;
-           }
-           else if (rtt_park == ENUM_ATTR_EFF_RTT_PARK_48OHM)
-           {
-               rtt_park = 0xA0;
-           }
-           else if (rtt_park == ENUM_ATTR_EFF_RTT_PARK_80OHM)
-           {
-               rtt_park = 0x60;
-           }
-           else if (rtt_park == ENUM_ATTR_EFF_RTT_PARK_34OHM)
-           {
-               rtt_park = 0xE0;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) rtt_park, 6, 3);
-	   break;
-       case ATTR_EFF_CA_PARITY:
-	   if (ca_parity == ENUM_ATTR_EFF_CA_PARITY_ENABLE)
-           {
-               ca_parity = 0xFF;
-           }
-           else if (ca_parity == ENUM_ATTR_EFF_CA_PARITY_DISABLE)
-           {
-               ca_parity = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) ca_parity, 9, 1);
-	   break;
-       case ATTR_EFF_DATA_MASK:
-	   if (data_mask == ENUM_ATTR_EFF_DATA_MASK_DISABLE)
-           {
-               data_mask = 0x00;
-           }
-           else if (data_mask == ENUM_ATTR_EFF_DATA_MASK_ENABLE)
-           {
-               data_mask = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) data_mask, 10, 1);
-	   break;
-       case ATTR_EFF_WRITE_DBI:
-	   if (write_dbi == ENUM_ATTR_EFF_WRITE_DBI_DISABLE)
-           {
-               write_dbi = 0x00;
-           }
-           else if (write_dbi == ENUM_ATTR_EFF_WRITE_DBI_ENABLE)
-           {
-               write_dbi = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) write_dbi, 11, 1);
-	   break;
-       case ATTR_EFF_READ_DBI:
-           if (read_dbi == ENUM_ATTR_EFF_READ_DBI_DISABLE)
-           {
-               read_dbi = 0x00;
-           }
-           else if (read_dbi == ENUM_ATTR_EFF_READ_DBI_ENABLE)
-           {
-               read_dbi = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) read_dbi, 12, 1);
-	   break;
-       case ATTR_VREF_DQ_TRAIN_VALUE:
-	   vrefdq_train_value = mss_reverse_8bits(vrefdq_train_value);
-           rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_value, 0, 6);
-	   break;
-       case ATTR_VREF_DQ_TRAIN_RANGE:
-	   if (vrefdq_train_range == ENUM_ATTR_VREF_DQ_TRAIN_RANGE_RANGE1)
-           {
-               vrefdq_train_range = 0x00;
-           }
-           else if (vrefdq_train_range == ENUM_ATTR_VREF_DQ_TRAIN_RANGE_RANGE2)
-           {
-               vrefdq_train_range = 0xFF;
-           } 
-           rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_range, 6, 1);
-	   break;
-       case ATTR_VREF_DQ_TRAIN_ENABLE:
-	   if (vrefdq_train_enable == ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_ENABLE)
-           {
-               vrefdq_train_enable = 0xFF;
-           }
-           else if (vrefdq_train_enable == ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_DISABLE)
-           {
-               vrefdq_train_enable = 0x00;
-           }   
-           rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_enable, 7, 1);
-	   break;
-       case ATTR_TCCD_L:
-           if (tccd_l == 4)
-           {
-               tccd_l = 0x00;
-           }
-           else if (tccd_l == 5)
-           {
-               tccd_l = 0x80;
-           }
-           else if (tccd_l == 6)
-           {
-               tccd_l = 0x40;
-           }	
-           else if (tccd_l == 7)
-           {
-               tccd_l = 0xC0;
-           }
-           else if (tccd_l == 8)
-           {
-               tccd_l = 0x20;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) tccd_l, 10, 3);
-	   break;
-	//MRS attribute not found, error out
-      default: 
-         const uint32_t NONMRS_ATTR_NAME = attribute_name;
-	 const fapi::Target & MBA_TARGET = i_target; 
-	 FAPI_SET_HWP_ERROR(rc, RC_MSS_PDA_NONMRS_ATTR_NAME);
-	 FAPI_ERR("ERROR!! Found attribute name not associated with an MRS! Exiting...");
-   }
-   if (rc_num)
-   {
-       FAPI_ERR( "mss_ddr4_modify_mrs_pda: Error setting up buffers");
-       rc.setEcmdError(rc_num);
-       return rc;
-   }
-   return rc;
-}
 
-//////////////////////////////////////////////////////////////////////////////////
-/// mss_ddr4_load_nominal_mrs_pda
-/// disables per-DRAM addressability funcitonality on both ports on the passed MBA
-//////////////////////////////////////////////////////////////////////////////////
-ReturnCode mss_ddr4_load_nominal_mrs_pda(Target& i_target,ecmdDataBufferBase& bank_3,ecmdDataBufferBase& address_16,uint8_t MRS,uint8_t i_port_number, uint8_t dimm_number, uint8_t rank_number) {
+//sets up the ODT holdtime and number of idles to be issued after 
+ReturnCode mss_get_pda_odt_timings(Target& i_target,uint8_t & wl_launch_time,uint8_t & odt_hold_time,uint8_t & post_odt_nop_idle) {
     ReturnCode rc;  
     ReturnCode rc_buff;
     uint32_t rc_num = 0;
+    ecmdDataBufferBase data_buffer(64);
     
-    rc_num = rc_num | address_16.clearBit(0,16);
-    rc_num = rc_num | bank_3.clearBit(0,3);
-    if (rc_num)
+    //reads out the register values
+    rc = fapiGetScom(i_target, MBA01_MBA_DSM0_0x0301040a, data_buffer);
+    if(rc) return rc;
+    
+    //gets the hold time
+    uint8_t launch_delay;
+    rc_num = rc_num | data_buffer.extractToRight(&launch_delay,12,6);
+    rc_num = rc_num | data_buffer.extractToRight(&odt_hold_time,18,6);
+    
+    odt_hold_time = odt_hold_time + launch_delay;
+    
+    if(rc_num)
     {
-    	FAPI_ERR( "mss_mrs_load: Error setting up buffers");
-    	rc_buff.setEcmdError(rc_num);
-    	return rc_buff;
-    }
-
-    //Lines commented out in the following section are waiting for xml attribute adds
-    //MRS0
-    if(MRS == MRS0_BA) {
-    	uint8_t dram_bl;
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_BL, &i_target, dram_bl);
-    	if(rc) return rc;
-    	uint8_t read_bt; //Read Burst Type 
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_RBT, &i_target, read_bt);
-    	if(rc) return rc;
-    	uint8_t dram_cl;
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_CL, &i_target, dram_cl);
-    	if(rc) return rc;
-    	uint8_t test_mode; //TEST MODE 
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_TM, &i_target, test_mode);
-    	if(rc) return rc;
-    	uint8_t dll_reset; //DLL Reset 
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_DLL_RESET, &i_target, dll_reset);
-    	if(rc) return rc;
-    	uint8_t dram_wr; //DRAM write recovery
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_WR, &i_target, dram_wr);
-    	if(rc) return rc;
-    	uint8_t dram_rtp; //DRAM RTP - read to precharge
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_TRTP, &i_target, dram_rtp);
-    	if(rc) return rc;
-    	uint8_t dll_precharge; //DLL Control For Precharge 
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_DLL_PPD, &i_target, dll_precharge);
-    	if(rc) return rc;
-
-    	if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_BL8)
-    	{
-    	    dram_bl = 0x00;
-    	}
-    	else if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_OTF)
-    	{
-    	    dram_bl = 0x80;
-    	}
-    	else if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_BC4)
-    	{
-    	    dram_bl = 0x40;
-    	}
-
-    	uint8_t dram_wr_rtp = 0x00;
-    	if ( (dram_wr == 10) )//&& (dram_rtp == 5) )
-    	{
-    	    dram_wr_rtp = 0x00;
-    	}
-    	else if ( (dram_wr == 12) )//&& (dram_rtp == 6) )
-    	{
-    	    dram_wr_rtp = 0x80;
-    	}
-    	else if ( (dram_wr == 13) )//&& (dram_rtp == 7) )
-    	{
-    	    dram_wr_rtp = 0x40;
-    	}
-    	else if ( (dram_wr == 14) )//&& (dram_rtp == 8) )
-    	{
-    	    dram_wr_rtp = 0xC0;
-    	}
-    	else if ( (dram_wr == 18) )//&& (dram_rtp == 9) )
-    	{
-    	    dram_wr_rtp = 0x20;
-    	}
-    	else if ( (dram_wr == 20) )//&& (dram_rtp == 10) )
-    	{
-    	    dram_wr_rtp = 0xA0;
-    	}
-    	else if ( (dram_wr == 24) )//&& (dram_rtp == 12) )
-    	{
-    	    dram_wr_rtp = 0x60;
-    	}
-
-    	if (read_bt == ENUM_ATTR_EFF_DRAM_RBT_SEQUENTIAL)
-    	{
-    	    read_bt = 0x00;
-    	}
-    	else if (read_bt == ENUM_ATTR_EFF_DRAM_RBT_INTERLEAVE)
-    	{
-    	    read_bt = 0xFF;
-    	}
-
-    	if ((dram_cl > 8)&&(dram_cl < 17))
-    	{
-    	    dram_cl = dram_cl - 9; 
-    	}
-    	else if ((dram_cl > 17)&&(dram_cl < 25))
-    	{
-    	    dram_cl = (dram_cl >> 1) - 1;   
-    	}
-    	dram_cl = mss_reverse_8bits(dram_cl);
-
-    	if (test_mode == ENUM_ATTR_EFF_DRAM_TM_NORMAL)
-    	{
-    	    test_mode = 0x00;
-    	}
-    	else if (test_mode == ENUM_ATTR_EFF_DRAM_TM_TEST)
-    	{
-    	    test_mode = 0xFF;
-    	}
-	
-	FAPI_INF("Overwriting DLL reset with values to not reset the DRAM.");
-    	dll_reset = 0x00;
-
-    	if (dll_precharge == ENUM_ATTR_EFF_DRAM_DLL_PPD_SLOWEXIT)
-    	{
-    	    dll_precharge = 0x00;
-    	}
-    	else if (dll_precharge == ENUM_ATTR_EFF_DRAM_DLL_PPD_FASTEXIT)
-    	{
-    	    dll_precharge = 0xFF;
-    	}
-	//For DDR4:
-	//Address 14 = Address 17, Address 15 = BG1
-        rc_num = rc_num | address_16.insert((uint8_t) dram_bl, 0, 2, 0);
-        rc_num = rc_num | address_16.insert((uint8_t) dram_cl, 2, 1, 0);
-        rc_num = rc_num | address_16.insert((uint8_t) read_bt, 3, 1, 0);
-        rc_num = rc_num | address_16.insert((uint8_t) dram_cl, 4, 3, 1);
-        rc_num = rc_num | address_16.insert((uint8_t) test_mode, 7, 1);
-        rc_num = rc_num | address_16.insert((uint8_t) dll_reset, 8, 1);
-	rc_num = rc_num | address_16.insert((uint8_t) dram_wr_rtp, 9, 3);
-	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 12, 4);
-	
-	rc_num = rc_num | bank_3.insert((uint8_t) MRS0_BA, 0, 1, 7);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS0_BA, 1, 1, 6);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS0_BA, 2, 1, 5);
-	if (rc_num)
-        {
-            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
-            rc_buff.setEcmdError(rc_num);
-            return rc_buff;
-        }
+	rc.setEcmdError(rc_num);
+	return rc;
     }
     
-    //MRS1
-    else if(MRS == MRS1_BA) {
-    	uint8_t dll_enable; //DLL Enable 
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_DLL_ENABLE, &i_target, dll_enable);
-    	if(rc) return rc;
-    	uint8_t out_drv_imp_cntl[2][2];
-    	rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_RON, &i_target, out_drv_imp_cntl);
-    	if(rc) return rc;
-    	uint8_t dram_rtt_nom[2][2][4];
-    	rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_RTT_NOM, &i_target, dram_rtt_nom);
-    	if(rc) return rc;
-    	uint8_t dram_al;
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_AL, &i_target, dram_al);
-    	if(rc) return rc;
-    	uint8_t wr_lvl; //write leveling enable
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_WR_LVL_ENABLE, &i_target, wr_lvl);
-    	if(rc) return rc;
-    	uint8_t tdqs_enable; //TDQS Enable 
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_TDQS, &i_target, tdqs_enable);
-    	if(rc) return rc;
-    	uint8_t q_off; //Qoff - Output buffer Enable 
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_OUTPUT_BUFFER, &i_target, q_off);
-    	if(rc) return rc;
-
-    	if (dll_enable == ENUM_ATTR_EFF_DRAM_DLL_ENABLE_DISABLE)
-    	{
-    	    dll_enable = 0x00;
-    	}
-    	else if (dll_enable == ENUM_ATTR_EFF_DRAM_DLL_ENABLE_ENABLE)
-    	{
-    	    dll_enable = 0xFF;
-    	}
-
-    	if (dram_al == ENUM_ATTR_EFF_DRAM_AL_DISABLE)
-    	{
-    	    dram_al = 0x00;
-    	}
-    	else if (dram_al == ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_1)
-    	{
-    	    dram_al = 0x80;
-    	}
-    	else if (dram_al == ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_2)
-    	{
-    	    dram_al = 0x40;
-    	}
-
-    	if (wr_lvl == ENUM_ATTR_EFF_DRAM_WR_LVL_ENABLE_DISABLE)
-    	{
-    	    wr_lvl = 0x00;
-    	}
-    	else if (wr_lvl == ENUM_ATTR_EFF_DRAM_WR_LVL_ENABLE_ENABLE)
-    	{
-    	    wr_lvl = 0xFF;
-    	}
-
-    	if (tdqs_enable == ENUM_ATTR_EFF_DRAM_TDQS_DISABLE)
-    	{
-    	    tdqs_enable = 0x00;
-    	}
-    	else if (tdqs_enable == ENUM_ATTR_EFF_DRAM_TDQS_ENABLE)
-    	{
-    	    tdqs_enable = 0xFF;
-    	}
-
-    	if (q_off == ENUM_ATTR_EFF_DRAM_OUTPUT_BUFFER_DISABLE)
-    	{
-    	    q_off = 0xFF;
-    	}
-    	else if (q_off == ENUM_ATTR_EFF_DRAM_OUTPUT_BUFFER_ENABLE)
-    	{
-    	    q_off = 0x00;
-    	}
-        if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_DISABLE)
-        {
-            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0x00;
-        }
-        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM240) //not supported
-        {
-            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0x20;
-        }
-        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM48) //not supported
-        {
-            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0xA0;
-        }
-        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM40)
-        {
-            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0xC0;
-        }
-        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM60)
-        {
-            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0x80;
-        }
-        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM120)
-        {
-            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0x40;
-        }
-        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM80) // not supported
-        {
-            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0x60;
-        }
-        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM34) // not supported
-        {
-            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0xE0;
-        }
-
-        if (out_drv_imp_cntl[i_port_number][dimm_number] == ENUM_ATTR_VPD_DRAM_RON_OHM34)
-        {
-            out_drv_imp_cntl[i_port_number][dimm_number] = 0x00;
-        }
-	// Not currently supported
-        else if (out_drv_imp_cntl[i_port_number][dimm_number] == ENUM_ATTR_VPD_DRAM_RON_OHM48) //not supported
-        {
-            out_drv_imp_cntl[i_port_number][dimm_number] = 0x80;
-        }
-
-	//For DDR4:
-	//Address 14 = Address 17, Address 15 = BG1
-        rc_num = rc_num | address_16.insert((uint8_t) dll_enable, 0, 1, 0);
-        rc_num = rc_num | address_16.insert((uint8_t) out_drv_imp_cntl[i_port_number][dimm_number], 1, 2, 0);
-        rc_num = rc_num | address_16.insert((uint8_t) dram_al, 3, 2, 0);
-        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 5, 2);
-        rc_num = rc_num | address_16.insert((uint8_t) wr_lvl, 7, 1, 0);
-        rc_num = rc_num | address_16.insert((uint8_t) dram_rtt_nom[i_port_number][dimm_number][rank_number], 8, 3, 0);
-        rc_num = rc_num | address_16.insert((uint8_t) tdqs_enable, 11, 1, 0);
-        rc_num = rc_num | address_16.insert((uint8_t) q_off, 12, 1, 0);
-        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 13, 3);
-	
-	rc_num = rc_num | bank_3.insert((uint8_t) MRS1_BA, 0, 1, 7);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS1_BA, 1, 1, 6);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS1_BA, 2, 1, 5);
-	if (rc_num)
-        {
-            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
-            rc_buff.setEcmdError(rc_num);
-            return rc_buff;
-        }
-    }
-    //MRS2
-    else if(MRS == MRS2_BA) {
-    	uint8_t lpasr; // Low Power Auto Self-Refresh -- new not yet supported
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_LPASR, &i_target, lpasr);
-    	if(rc) return rc;
-    	uint8_t cwl; // CAS Write Latency 
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_CWL, &i_target, cwl);
-    	if(rc) return rc;
-    	uint8_t dram_rtt_wr[2][2][4];
-    	rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_RTT_WR, &i_target, dram_rtt_wr);
-    	if(rc) return rc;
-    	uint8_t write_crc; // CAS Write Latency 
-    	rc = FAPI_ATTR_GET(ATTR_EFF_WRITE_CRC, &i_target, write_crc);
-    	if(rc) return rc;
-
-    	if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_NORMAL)
-    	{
-    	    lpasr = 0x00;
-    	}
-    	else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_REDUCED)
-    	{
-    	    lpasr = 0x80;
-    	}
-    	else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_EXTENDED)
-    	{
-    	    lpasr = 0x40;
-    	}
-    	else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_ASR)
-    	{
-    	    lpasr = 0xFF;
-    	}
-
-    	if ((cwl > 8)&&(cwl < 13))
-    	{
-    	    cwl = cwl - 9; 
-    	}
-    	else if ((cwl > 13)&&(cwl < 19))
-    	{
-    	    cwl = (cwl >> 1) - 3;   
-    	}
-    	else
-    	{
-    	   //no correcct value for CWL was found
-    	   FAPI_INF("ERROR: Improper CWL value found. Setting CWL to 9 and continuing...");
-    	   cwl = 0;
-    	}
-    	cwl = mss_reverse_8bits(cwl);
-
-    	if ( write_crc == ENUM_ATTR_EFF_WRITE_CRC_ENABLE)
-    	{
-    	    write_crc = 0xFF;
-    	}
-    	else if (write_crc == ENUM_ATTR_EFF_WRITE_CRC_DISABLE)
-    	{
-    	    write_crc = 0x00;
-    	}
-	if (dram_rtt_wr[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_WR_DISABLE)
-        {
-            dram_rtt_wr[i_port_number][dimm_number][rank_number] = 0x00;
-        }
-        else if (dram_rtt_wr[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_WR_OHM120)
-        {
-            dram_rtt_wr[i_port_number][dimm_number][rank_number] = 0x80;
-        }
-        else if (dram_rtt_wr[i_port_number][dimm_number][rank_number] == 240)//ENUM_ATTR_EFF_DRAM_RTT_WR_OHM240)
-        {
-            dram_rtt_wr[i_port_number][dimm_number][rank_number] = 0x40;
-        }
-        else if (dram_rtt_wr[i_port_number][dimm_number][rank_number] == 0xFF)//ENUM_ATTR_EFF_DRAM_RTT_WR_HIGHZ)
-        {
-            dram_rtt_wr[i_port_number][dimm_number][rank_number] = 0xFF;
-        }
-
-        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 0, 3);
-        rc_num = rc_num | address_16.insert((uint8_t) cwl, 3, 3);
-        rc_num = rc_num | address_16.insert((uint8_t) lpasr, 6, 2);
-        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 8, 1);
-        rc_num = rc_num | address_16.insert((uint8_t) dram_rtt_wr[i_port_number][dimm_number][rank_number], 9, 2);
-        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 11, 1);
-        rc_num = rc_num | address_16.insert((uint8_t) write_crc, 12, 1);
-        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 13, 2);
-	
-	rc_num = rc_num | bank_3.insert((uint8_t) MRS2_BA, 0, 1, 7);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS2_BA, 1, 1, 6);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS2_BA, 2, 1, 5);
-	if (rc_num)
-        {
-            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
-            rc_buff.setEcmdError(rc_num);
-            return rc_buff;
-        }
-    }
-    //MRS3
-    else if(MRS == MRS3_BA) {
-    	uint8_t mpr_op; // MPR Op
-    	rc = FAPI_ATTR_GET(ATTR_EFF_MPR_MODE, &i_target, mpr_op);
-    	if(rc) return rc;
-    	uint8_t mpr_page; // MPR Page Selection  - NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_MPR_PAGE, &i_target, mpr_page);
-    	if(rc) return rc;
-    	uint8_t geardown_mode; // Gear Down Mode  - NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_GEARDOWN_MODE, &i_target, geardown_mode);
-    	if(rc) return rc;
-    	uint8_t temp_readout; // Temperature sensor readout  - NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_TEMP_READOUT, &i_target, temp_readout);
-    	if(rc) return rc;
-    	uint8_t fine_refresh; // fine refresh mode  - NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_FINE_REFRESH_MODE, &i_target, fine_refresh);
-    	if(rc) return rc;
-    	uint8_t wr_latency; // write latency for CRC and DM  - NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_CRC_WR_LATENCY, &i_target, wr_latency);
-    	if(rc) return rc;
-    	uint8_t read_format; // MPR READ FORMAT  - NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_MPR_RD_FORMAT, &i_target, read_format);
-    	if(rc) return rc;
-
-    	if (mpr_op == ENUM_ATTR_EFF_MPR_MODE_ENABLE)
-    	{
-    	    mpr_op = 0xFF;
-    	}
-    	else if (mpr_op == ENUM_ATTR_EFF_MPR_MODE_DISABLE)
-    	{
-    	    mpr_op = 0x00;
-    	}
-
-    	mpr_page = mss_reverse_8bits(mpr_page);
-
-    	if ( geardown_mode == ENUM_ATTR_EFF_GEARDOWN_MODE_HALF)
-    	{
-    	     geardown_mode = 0x00;
-    	}
-    	else if ( geardown_mode == ENUM_ATTR_EFF_GEARDOWN_MODE_QUARTER)
-    	{
-    	     geardown_mode = 0xFF;
-    	}
-    	
-    	if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_ENABLE)
-    	{
-    	    temp_readout = 0xFF;
-    	}
-    	else if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_DISABLE)
-    	{
-    	    temp_readout = 0x00;
-    	}
-
-    	if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_NORMAL)
-    	{
-    	    fine_refresh = 0x00;
-    	}
-    	else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FIXED_2X)
-    	{
-    	    fine_refresh = 0x80;
-    	}
-    	else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FIXED_4X)
-    	{
-    	    fine_refresh = 0x40;
-    	}
-    	else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FLY_2X)
-    	{
-    	    fine_refresh = 0xA0;
-    	}
-    	else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FLY_4X)
-    	{
-    	    fine_refresh = 0x60;
-    	}
-
-    	if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_4NCK)
-    	{
-    	    wr_latency = 0x00;
-    	}
-    	else if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_5NCK)
-    	{
-    	    wr_latency = 0x80;
-    	}
-    	else if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_6NCK)
-    	{
-    	    wr_latency = 0xC0;
-    	}
-
-    	if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_SERIAL)
-    	{
-    	    read_format = 0x00;
-    	}
-    	else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_PARALLEL)
-    	{
-    	    read_format = 0x80;
-    	}
-    	else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_STAGGERED)
-    	{
-    	    read_format = 0x40;
-    	}
-    	else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_RESERVED_TEMP)
-    	{
-    	    read_format = 0xC0;
-    	}
-	
-	rc_num = rc_num | address_16.insert((uint8_t) mpr_page, 0, 2);
-        rc_num = rc_num | address_16.insert((uint8_t) mpr_op, 2, 1);
-        rc_num = rc_num | address_16.insert((uint8_t) geardown_mode, 3, 1);
-        rc_num = rc_num | address_16.insert((uint8_t) 0xFF, 4, 1); //has PDA mode enabled!!!! just for this code!
-        rc_num = rc_num | address_16.insert((uint8_t) temp_readout, 5, 1);
-        rc_num = rc_num | address_16.insert((uint8_t) fine_refresh, 6, 3);
-        rc_num = rc_num | address_16.insert((uint8_t) wr_latency, 9, 2);
-        rc_num = rc_num | address_16.insert((uint8_t) read_format, 11, 2);
-        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 13, 2);
-	
-	rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 0, 1, 7);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 1, 1, 6);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 2, 1, 5);
-	if (rc_num)
-        {
-            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
-            rc_buff.setEcmdError(rc_num);
-            return rc_buff;
-        }
-    }
-    //MRS4
-    else if(MRS == MRS4_BA) {
-    	uint8_t max_pd_mode; // Max Power down mode -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_MAX_POWERDOWN_MODE, &i_target, max_pd_mode);
-    	if(rc) return rc;
-    	uint8_t temp_ref_range; // Temp ref range -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_TEMP_REF_RANGE, &i_target, temp_ref_range);
-    	if(rc) return rc;
-    	uint8_t temp_ref_mode; // Temp controlled ref mode -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_TEMP_REF_MODE, &i_target, temp_ref_mode);
-    	if(rc) return rc;
-    	uint8_t vref_mon; // Internal Vref Monitor -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_INT_VREF_MON, &i_target, vref_mon);
-    	if(rc) return rc;
-    	uint8_t cs_cmd_latency; // CS to CMD/ADDR Latency -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_CS_CMD_LATENCY, &i_target, cs_cmd_latency);
-    	if(rc) return rc;
-    	uint8_t ref_abort; // Self Refresh Abort -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_SELF_REF_ABORT, &i_target, ref_abort);
-    	if(rc) return rc;
-    	uint8_t rd_pre_train_mode; // Read Pre amble Training Mode -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_RD_PREAMBLE_TRAIN, &i_target, rd_pre_train_mode);
-    	if(rc) return rc;
-    	uint8_t rd_preamble; // Read Pre amble -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_RD_PREAMBLE, &i_target, rd_preamble);
-    	if(rc) return rc;
-    	uint8_t wr_preamble; // Write Pre amble -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_WR_PREAMBLE, &i_target, wr_preamble);
-    	if(rc) return rc;
-
-    	if ( max_pd_mode == ENUM_ATTR_EFF_MAX_POWERDOWN_MODE_ENABLE)
-    	{
-    	    max_pd_mode = 0xF0;
-    	}
-    	else if ( max_pd_mode == ENUM_ATTR_EFF_MAX_POWERDOWN_MODE_DISABLE)
-    	{
-    	    max_pd_mode = 0x00;
-    	}
-
-    	if (temp_ref_range == ENUM_ATTR_EFF_TEMP_REF_RANGE_NORMAL)
-    	{
-    	    temp_ref_range = 0x00;
-    	}
-    	else if ( temp_ref_range== ENUM_ATTR_EFF_TEMP_REF_RANGE_EXTEND)
-    	{
-    	    temp_ref_range = 0xFF;
-    	}
-
-    	if (temp_ref_mode == ENUM_ATTR_EFF_TEMP_REF_MODE_ENABLE)
-    	{
-    	    temp_ref_mode = 0x80;
-    	}
-    	else if (temp_ref_mode == ENUM_ATTR_EFF_TEMP_REF_MODE_DISABLE)
-    	{
-    	    temp_ref_mode = 0x00;
-    	}
-
-    	if ( vref_mon == ENUM_ATTR_EFF_INT_VREF_MON_ENABLE)
-    	{
-    	    vref_mon = 0xFF;
-    	}
-    	else if ( vref_mon == ENUM_ATTR_EFF_INT_VREF_MON_DISABLE)
-    	{
-    	    vref_mon = 0x00;
-    	}
-
-
-    	if ( cs_cmd_latency == 3)
-    	{
-    	    cs_cmd_latency = 0x80;
-    	}
-    	else if (cs_cmd_latency == 4)
-    	{
-    	    cs_cmd_latency = 0x40;
-    	}
-    	else if (cs_cmd_latency == 5)
-    	{
-    	    cs_cmd_latency = 0xC0;
-    	}
-    	else if (cs_cmd_latency == 6)
-    	{
-    	    cs_cmd_latency = 0x20;
-    	}
-    	else if (cs_cmd_latency == 8)
-    	{
-    	    cs_cmd_latency = 0xA0;
-    	}
-
-    	if (ref_abort == ENUM_ATTR_EFF_SELF_REF_ABORT_ENABLE)
-    	{
-    	    ref_abort = 0xFF;
-    	}
-    	else if (ref_abort == ENUM_ATTR_EFF_SELF_REF_ABORT_DISABLE)
-    	{
-    	    ref_abort = 0x00;
-    	}
-
-    	if (rd_pre_train_mode == ENUM_ATTR_EFF_RD_PREAMBLE_TRAIN_ENABLE)
-    	{
-    	    rd_pre_train_mode = 0xFF;
-    	}
-    	else if (rd_pre_train_mode == ENUM_ATTR_EFF_RD_PREAMBLE_TRAIN_DISABLE)
-    	{
-    	    rd_pre_train_mode = 0x00;
-    	}
-
-    	if (rd_preamble == ENUM_ATTR_EFF_RD_PREAMBLE_1NCLK)
-    	{
-    	    rd_preamble = 0x00;
-    	}
-    	else if (rd_preamble == ENUM_ATTR_EFF_RD_PREAMBLE_2NCLK)
-    	{
-    	    rd_preamble = 0xFF;
-    	}
-
-    	if (wr_preamble == ENUM_ATTR_EFF_WR_PREAMBLE_1NCLK)
-    	{
-    	    wr_preamble = 0x00;
-    	}
-    	else if (wr_preamble == ENUM_ATTR_EFF_WR_PREAMBLE_2NCLK)
-    	{
-    	    wr_preamble = 0xFF;
-    	}
-    	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 0, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) max_pd_mode, 1, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) temp_ref_range, 2, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) temp_ref_mode, 3, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) vref_mon, 4, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 5, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) cs_cmd_latency, 6, 3);
-    	rc_num = rc_num | address_16.insert((uint8_t) ref_abort, 9, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) rd_pre_train_mode, 10, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) rd_preamble, 11, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) wr_preamble, 12, 1);
-	
-	rc_num = rc_num | bank_3.insert((uint8_t) MRS4_BA, 0, 1, 7);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS4_BA, 1, 1, 6);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS4_BA, 2, 1, 5);
-	if (rc_num)
-        {
-            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
-            rc_buff.setEcmdError(rc_num);
-            return rc_buff;
-        }
-    }
-    //MRS5
-    else if(MRS == MRS5_BA) {
-    	uint8_t ca_parity_latency; //C/A Parity Latency Mode  -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_CA_PARITY_LATENCY , &i_target, ca_parity_latency);
-    	if(rc) return rc;
-    	uint8_t crc_error_clear; //CRC Error Clear  -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_CRC_ERROR_CLEAR , &i_target, crc_error_clear);
-    	if(rc) return rc;
-    	uint8_t ca_parity_error_status; //C/A Parity Error Status  -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_CA_PARITY_ERROR_STATUS , &i_target, ca_parity_error_status);
-    	if(rc) return rc;
-    	uint8_t odt_input_buffer; //ODT Input Buffer during power down  -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_ODT_INPUT_BUFF , &i_target, odt_input_buffer);
-    	if(rc) return rc;
-    	uint8_t rtt_park[2][2][4]; //RTT_Park value  -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_RTT_PARK , &i_target, rtt_park);
-    	if(rc) return rc;
-    	uint8_t ca_parity; //CA Parity Persistance Error  -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_CA_PARITY , &i_target, ca_parity);
-    	if(rc) return rc;
-    	uint8_t data_mask; //Data Mask  -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DATA_MASK , &i_target, data_mask);
-    	if(rc) return rc;
-    	uint8_t write_dbi; //Write DBI  -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_WRITE_DBI , &i_target, write_dbi);
-    	if(rc) return rc;
-    	uint8_t read_dbi; //Read DBI  -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_READ_DBI , &i_target, read_dbi);
-    	if(rc) return rc;
-
-
-    	if (ca_parity_latency == 4)
-    	{
-    	    ca_parity_latency = 0x80;
-    	}
-    	else if (ca_parity_latency == 5)
-    	{
-    	    ca_parity_latency = 0x40;
-    	}
-    	else if (ca_parity_latency == 6)
-    	{
-    	    ca_parity_latency = 0xC0;
-    	}
-    	else if (ca_parity_latency == 8)
-    	{
-    	    ca_parity_latency = 0x20;
-    	}
-    	else if (ca_parity_latency == ENUM_ATTR_EFF_CA_PARITY_LATENCY_DISABLE)
-    	{
-    	    ca_parity_latency = 0x00;
-    	}
-
-    	if (crc_error_clear == ENUM_ATTR_EFF_CRC_ERROR_CLEAR_ERROR)
-    	{
-    	    crc_error_clear = 0xFF;
-    	}
-    	else if (crc_error_clear == ENUM_ATTR_EFF_CRC_ERROR_CLEAR_CLEAR)
-    	{
-    	    crc_error_clear = 0x00;
-    	}
-
-    	if (ca_parity_error_status == ENUM_ATTR_EFF_CA_PARITY_ERROR_STATUS_ERROR)
-    	{
-    	    ca_parity_error_status = 0xFF;
-    	}
-    	else if (ca_parity_error_status == ENUM_ATTR_EFF_CA_PARITY_ERROR_STATUS_CLEAR)
-    	{
-    	    ca_parity_error_status = 0x00;
-    	}
-
-    	if (odt_input_buffer == ENUM_ATTR_EFF_ODT_INPUT_BUFF_ACTIVATED)
-    	{
-    	    odt_input_buffer = 0x00;
-    	}
-    	else if (odt_input_buffer == ENUM_ATTR_EFF_ODT_INPUT_BUFF_DEACTIVATED)
-    	{
-    	    odt_input_buffer = 0xFF;
-    	}
-
-
-    	if (ca_parity == ENUM_ATTR_EFF_CA_PARITY_ENABLE)
-    	{
-    	    ca_parity = 0xFF;
-    	}
-    	else if (ca_parity == ENUM_ATTR_EFF_CA_PARITY_DISABLE)
-    	{
-    	    ca_parity = 0x00;
-    	}
-
-    	if (data_mask == ENUM_ATTR_EFF_DATA_MASK_DISABLE)
-    	{
-    	    data_mask = 0x00;
-    	}
-    	else if (data_mask == ENUM_ATTR_EFF_DATA_MASK_ENABLE)
-    	{
-    	    data_mask = 0xFF;
-    	}
-
-    	if (write_dbi == ENUM_ATTR_EFF_WRITE_DBI_DISABLE)
-    	{
-    	    write_dbi = 0x00;
-    	}
-    	else if (write_dbi == ENUM_ATTR_EFF_WRITE_DBI_ENABLE)
-    	{
-    	    write_dbi = 0xFF;
-    	}
-
-    	if (read_dbi == ENUM_ATTR_EFF_READ_DBI_DISABLE)
-    	{
-    	    read_dbi = 0x00;
-    	}
-    	else if (read_dbi == ENUM_ATTR_EFF_READ_DBI_ENABLE)
-    	{
-    	    read_dbi = 0xFF;
-    	}
-    	if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_RTT_PARK_DISABLE)
-    	{
-    	    rtt_park[i_port_number][dimm_number][rank_number] = 0x00;
-    	}
-    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_RTT_PARK_60OHM)
-    	{
-    	    rtt_park[i_port_number][dimm_number][rank_number] = 0x80;
-    	}
-    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_RTT_PARK_40OHM)
-    	{
-    	    rtt_park[i_port_number][dimm_number][rank_number] = 0xC0;
-    	}
-    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_RTT_PARK_120OHM)
-    	{
-    	    rtt_park[i_port_number][dimm_number][rank_number] = 0x40;
-    	}
-    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_RTT_PARK_240OHM)
-    	{
-    	    rtt_park[i_port_number][dimm_number][rank_number] = 0x20;
-    	}
-    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_RTT_PARK_48OHM)
-    	{
-    	    rtt_park[i_port_number][dimm_number][rank_number] = 0xA0;
-    	}
-    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_RTT_PARK_80OHM)
-    	{
-    	    rtt_park[i_port_number][dimm_number][rank_number] = 0x60;
-    	}
-    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_RTT_PARK_34OHM)
-    	{
-    	    rtt_park[i_port_number][dimm_number][rank_number] = 0xE0;
-    	}
-
-    	rc_num = rc_num | address_16.insert((uint8_t) ca_parity_latency, 0, 2);
-    	rc_num = rc_num | address_16.insert((uint8_t) crc_error_clear, 3, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) ca_parity_error_status, 4, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) odt_input_buffer, 5, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) rtt_park[i_port_number][dimm_number][rank_number], 6, 3);
-    	rc_num = rc_num | address_16.insert((uint8_t) ca_parity, 9, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) data_mask, 10, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) write_dbi, 11, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) read_dbi, 12, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 13, 2);
-	
-	rc_num = rc_num | bank_3.insert((uint8_t) MRS5_BA, 0, 1, 7);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS5_BA, 1, 1, 6);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS5_BA, 2, 1, 5);
-	if (rc_num)
-        {
-            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
-            rc_buff.setEcmdError(rc_num);
-            return rc_buff;
-        }
-    }
-    //MRS6
-    else if(MRS == MRS6_BA) {
-    	uint8_t vrefdq_train_value[2][2][4]; //vrefdq_train value   -  NEW
-    	rc = FAPI_ATTR_GET( ATTR_VREF_DQ_TRAIN_VALUE, &i_target, vrefdq_train_value);
-    	if(rc) return rc;
-    	uint8_t vrefdq_train_range[2][2][4]; //vrefdq_train range   -  NEW
-    	rc = FAPI_ATTR_GET( ATTR_VREF_DQ_TRAIN_RANGE, &i_target, vrefdq_train_range);
-    	if(rc) return rc;
-    	uint8_t vrefdq_train_enable[2][2][4]; //vrefdq_train enable  -  NEW
-    	rc = FAPI_ATTR_GET( ATTR_VREF_DQ_TRAIN_ENABLE, &i_target, vrefdq_train_enable);
-    	if(rc) return rc;
-    	uint8_t tccd_l; //tccd_l  -  NEW
-    	rc = FAPI_ATTR_GET( ATTR_TCCD_L, &i_target, tccd_l);
-    	if(rc) return rc;
-    	if (tccd_l == 4)
-    	{
-    	    tccd_l = 0x00;
-    	}
-    	else if (tccd_l == 5)
-    	{
-    	    tccd_l = 0x80;
-    	}
-    	else if (tccd_l == 6)
-    	{
-    	    tccd_l = 0x40;
-    	}    
-    	else if (tccd_l == 7)
-    	{
-    	    tccd_l = 0xC0;
-    	}
-    	else if (tccd_l == 8)
-    	{
-    	    tccd_l = 0x20;
-    	}
-
-    	vrefdq_train_value[i_port_number][dimm_number][rank_number] = mss_reverse_8bits(vrefdq_train_value[i_port_number][dimm_number][rank_number]);
-
-    	if (vrefdq_train_range[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VREF_DQ_TRAIN_RANGE_RANGE1)
-    	{
-    	    vrefdq_train_range[i_port_number][dimm_number][rank_number] = 0x00;
-    	}
-    	else if (vrefdq_train_range[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VREF_DQ_TRAIN_RANGE_RANGE2)
-    	{
-    	    vrefdq_train_range[i_port_number][dimm_number][rank_number] = 0xFF;
-    	}   
-
-    	if (vrefdq_train_enable[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_ENABLE)
-    	{
-    	    vrefdq_train_enable[i_port_number][dimm_number][rank_number] = 0xFF;
-    	}
-    	else if (vrefdq_train_enable[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_DISABLE)
-    	{
-    	    vrefdq_train_enable[i_port_number][dimm_number][rank_number] = 0x00;
-    	}   
-
-    	rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_value[i_port_number][dimm_number][rank_number], 0, 6);
-    	rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_range[i_port_number][dimm_number][rank_number], 6, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_enable[i_port_number][dimm_number][rank_number], 7, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 8, 2);
-    	rc_num = rc_num | address_16.insert((uint8_t) tccd_l, 10, 3);
-    	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 13, 2);
-	
-	rc_num = rc_num | bank_3.insert((uint8_t) MRS6_BA, 0, 1, 7);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS6_BA, 1, 1, 6);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS6_BA, 2, 1, 5);
-	if (rc_num)
-        {
-            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
-            rc_buff.setEcmdError(rc_num);
-            return rc_buff;
-        }
-    }
-    else {
-        const uint32_t MRS_VALUE = MRS;
-	const fapi::Target & MBA_TARGET = i_target; 
-	FAPI_SET_HWP_ERROR(rc, RC_MSS_PDA_MRS_NOT_FOUND);
-	FAPI_ERR("ERROR!! Found attribute name not associated with an MRS! Exiting...");
+    //gets write latency
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_CWL, &i_target, wl_launch_time);
+    if(rc) return rc;
+    
+    wl_launch_time += launch_delay;
+    
+    uint8_t dram_al;
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_AL, &i_target, dram_al);
+    if(rc) return rc;
+    
+    //Addative latency enabled - need to add CL-AL
+    if(dram_al != ENUM_ATTR_EFF_DRAM_AL_DISABLE) {
+       uint8_t dram_cl;
+       rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_CL, &i_target, dram_cl);
+       if(rc) return rc;
+       wl_launch_time += (dram_cl-dram_al);
     }
     
+    post_odt_nop_idle = wl_launch_time + odt_hold_time + 50;
+    
     return rc;
 }
+
+//returns a 1 if the PDA is empty for the given DIMM rank - returns 0 if not empty
+uint32_t mss_ddr4_check_pda_empty_for_rank(
+	    vector<PDA_MRS_Storage> pda,
+	    uint8_t dimm_to_run,
+	    uint8_t rank_to_run
+            ) {
+   uint32_t rc = 1;
+   
+   for(uint32_t i=0;i<pda.size();i++) {
+      //found, return 0
+      if(pda[i].dimm == dimm_to_run && pda[i].rank == rank_to_run) return 0;
+   }
+   
+   //not found, return 1
+   return rc;
+}
 }
 
diff --git a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_pda.H b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_pda.H
index ac136bd..e46ee9f 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_pda.H
+++ b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_pda.H
@@ -22,11 +22,11 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_ddr4_pda.H,v 1.38 2015/07/27 14:49:59 sglancy Exp $
+// $Id: mss_ddr4_pda.H,v 1.40 2015/11/09 19:14:48 sglancy Exp $
 //------------------------------------------------------------------------------
 // *! (C) Copyright International Business Machines Corp. 2013
 // *! All Rights Reserved -- Property of IBM
-// *! ***  ***
+// *! *** IBM Confidential ***
 //------------------------------------------------------------------------------
 // *! TITLE : mss_ddr4_pda.H
 // *! DESCRIPTION : Tools for DDR4 DIMMs centaur procedures
@@ -42,6 +42,7 @@
 //------------------------------------------------------------------------------
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|-----------------------------------------------
+//  1.6    | 11/09/15 | sglancy | Added new function call
 //  1.5    | 05/13/15 | sglancy | Added dox and updated functions for better FFDC
 //  1.4    | 05/11/15 | sglancy | Addressed FW comments
 //  1.3    | 05/07/15 | sglancy | Updated Doxygen header
@@ -106,7 +107,12 @@ ReturnCode mss_ddr4_run_pda(Target& i_target,vector<PDA_MRS_Storage> pda);
  *
  * @return ReturnCode
  */
-ReturnCode mss_ddr4_setup_pda(Target& i_target,uint32_t& io_ccs_inst_cnt);
+ReturnCode mss_ddr4_setup_pda(
+            Target& i_target,
+            uint32_t& io_ccs_inst_cnt,
+	    uint8_t dimm_to_run,
+	    uint8_t rank_to_run
+            );
 /**
  * @Takes the DRAM out of per-DRAM addressability mode (PDA mode)
  *
@@ -115,7 +121,7 @@ ReturnCode mss_ddr4_setup_pda(Target& i_target,uint32_t& io_ccs_inst_cnt);
  *
  * @return ReturnCode
  */
-ReturnCode mss_ddr4_disable_pda(Target& i_target,uint32_t& io_ccs_inst_cnt);
+ReturnCode mss_ddr4_disable_pda(Target& i_target,uint32_t& io_ccs_inst_cnt, uint8_t dimm_to_run, uint8_t rank_to_run);
 /**
  * @called by wrapper - sets up a PDA vector if it's not already configured
  *
@@ -135,17 +141,6 @@ ReturnCode mss_ddr4_pda(Target& i_target,vector<PDA_MRS_Storage> pda);
  */
 ReturnCode mss_ddr4_checksort_pda(Target& i_target, vector<PDA_MRS_Storage>& pda);
 /**
- * @Modifies the passed in address_16 buffer based upon the given attribute and data
- *
- * @param[in]  target:  Reference to centaur.mba target, 
- * @param[in/out]  ecmdDataBufferBase& address_16:  MRS values - this is modified by the given attribute name and data
- * @param[in]  uint32_t attribute_name:  enumerated value containing the attribute name to be modified - attr_name tells the function which bits to modify
- * @param[in]  uint8_t attribute_data:   data telss the function what values to set to the modified bits
- *
- * @return ReturnCode
- */
-ReturnCode mss_ddr4_modify_mrs_pda(Target& i_target,ecmdDataBufferBase& address_16,uint32_t attribute_name,uint8_t attribute_data);
-/**
  * @Adds a given DRAM into the scom_storage vector
  *
  * @param[in]  target:  Reference to centaur.mba target, 
@@ -156,20 +151,31 @@ ReturnCode mss_ddr4_modify_mrs_pda(Target& i_target,ecmdDataBufferBase& address_
  * @return ReturnCode
  */
 ReturnCode mss_ddr4_add_dram_pda(Target& i_target,uint8_t port,uint8_t dram,vector<PDA_Scom_Storage> & scom_storage);
+
 /**
- * @loads in a nominal MRS value into the address_16 and bank_3
+ * @Adds a given DRAM into the scom_storage vector
  *
  * @param[in]  target:  Reference to centaur.mba target, 
- * @param[out]  ecmdDataBufferBase& bank_3:  bank bits to be issued during MRS
- * @param[out]  ecmdDataBufferBase& address_16:  16 address lanes to be issued during MRS - setup during function
- * @param[in]  uint8_t MRS:  which MRS to configure
- * @param[in]  uint8_t i_port_number: the port on which to configure the MRS - used for ID'ing which attributes to use
- * @param[in]  uint8_t dimm_number: the DIMM on which to configure the MRS - used for ID'ing which attributes to use
- * @param[in]  uint8_t rank_number: the rank on which to configure the MRS - used for ID'ing which attributes to use
+ * @param[out]  uint8_t wl_launch_time:  holds the number of cycles that the data must be launched after the PDA command is issued
+ * @param[out]  uint8_t odt_hold_time:  holds the number of cycles that the ODT must be held for PDA
+ * @param[out]  uint8_t post_odt_nop_idle:  holds the number of cycles that 
  *
  * @return ReturnCode
  */
-ReturnCode mss_ddr4_load_nominal_mrs_pda(Target& i_target,ecmdDataBufferBase& bank_3,ecmdDataBufferBase& address_16,uint8_t MRS,uint8_t i_port_number, uint8_t dimm_number, uint8_t rank_number);
+ReturnCode mss_get_pda_odt_timings(Target& i_target,uint8_t & wl_launch_time,uint8_t & odt_hold_time,uint8_t & post_odt_nop_idle);
+ReturnCode mss_ddr4_run_pda_by_dimm_rank(
+            Target& i_target,
+	    vector<PDA_MRS_Storage> pda,
+	    uint8_t dimm_to_run,
+	    uint8_t rank_to_run
+            );
+
+uint32_t mss_ddr4_check_pda_empty_for_rank(
+	    vector<PDA_MRS_Storage> pda,
+	    uint8_t dimm_to_run,
+	    uint8_t rank_to_run
+            );
+
 } // extern "C"
 
 #endif /* _MSS_DDR4_PDA_H */
diff --git a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_draminit_training_advanced.C b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_draminit_training_advanced.C
index c62c996..0f052d5 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_draminit_training_advanced.C
+++ b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_draminit_training_advanced.C
@@ -22,13 +22,13 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_draminit_training_advanced.C,v 1.50 2015/08/27 21:59:32 eliner Exp $
+// $Id: mss_draminit_training_advanced.C,v 1.55 2015/11/06 09:02:42 sasethur Exp $
 /* File is created by SARAVANAN SETHURAMAN on Thur 29 Sept 2011. */
 
 //------------------------------------------------------------------------------
 // *! (C) Copyright International Business Machines Corp. 2007
 // *! All Rights Reserved -- Property of IBM
-// *! ***  ***
+// *! *** IBM Confidential ***
 //------------------------------------------------------------------------------
 // *! TITLE :mss_draminit_training_advanced.C
 // *! DESCRIPTION : Tools for centaur procedures
@@ -92,6 +92,10 @@
 //  1.48   |preeragh  |19-Aug-14| Fix FW Review Comments
 //  1.49   |eliner    |27-Aug-15| Fixing Index Overflow Bug
 //  1.50   |eliner    |27-Aug-15| Fixing Index Overflow Bug
+//  1.51   |eliner    |07-Oct-15| PDA Write Back
+//  1.51   |preeragh  |21-Oct-15| Fix V-Ref Range 0-50
+//  1.53   |janssens  |21-Oct-15| 64 Bit compile Fix
+//  1.54   |sglancy   |10-Oct-15 | Changed attribute names
 // This procedure Schmoo's DRV_IMP, SLEW, VREF (DDR, CEN), RCV_IMP based on attribute from effective config procedure
 // DQ & DQS Driver impedance, Slew rate, WR_Vref shmoo would call only write_eye shmoo for margin calculation
 // DQ & DQS VREF (rd_vref), RCV_IMP shmoo would call rd_eye for margin calculation
@@ -166,12 +170,12 @@ extern "C"
 	fapi::ReturnCode delay_shmoo_ddr4(const fapi::Target & i_target_mba, uint8_t i_port,
 	shmoo_type_t i_shmoo_type_valid, 
 	uint32_t *o_left_margin, uint32_t *o_right_margin,
-	uint32_t i_shmoo_param,uint32_t pda_nibble_table[2][2][16][2]);
+	uint32_t i_shmoo_param,uint32_t pda_nibble_table[2][2][4][16][2]);
 	
 	fapi::ReturnCode delay_shmoo_ddr4_pda(const fapi::Target & i_target_mba, uint8_t i_port,
 	shmoo_type_t i_shmoo_type_valid, 
 	uint32_t *o_left_margin, uint32_t *o_right_margin,
-	uint32_t i_shmoo_param,uint32_t pda_nibble_table[2][2][16][2]);
+	uint32_t i_shmoo_param,uint32_t pda_nibble_table[2][2][4][16][2]);
 
 	void find_best_margin(shmoo_param i_shmoo_param_valid,uint32_t i_left[], 
 	uint32_t i_right[], const uint8_t l_max, 
@@ -829,7 +833,7 @@ fapi::ReturnCode wr_vref_shmoo_ddr4(const fapi::Target & i_target_mba)
 {
 	fapi::ReturnCode rc;
 	uint8_t max_port = 2;
-	uint8_t max_ddr4_vrefs1 = 52;
+	uint8_t max_ddr4_vrefs1 = 51;
 	shmoo_type_t i_shmoo_type_valid = MCBIST; // Hard coded - Temporary
 	ecmdDataBufferBase l_data_buffer_64(64);
 	uint32_t l_left_margin = 0;
@@ -840,23 +844,23 @@ fapi::ReturnCode wr_vref_shmoo_ddr4(const fapi::Target & i_target_mba)
 	uint8_t l_MAX_RANKS[2];
 	uint32_t rc_num = 0;
 	uint8_t l_SCHMOO_NIBBLES=20;
-	uint8_t base_percent = 60;
+	uint32_t base_percent = 60000;
 	
-	float index_mul_print = 0.65;
+	uint32_t index_mul_print = 650;
 	uint8_t l_attr_schmoo_test_type_u8 = 1;
-	float vref_val_print = 0;
+	uint32_t vref_val_print = 0;
 	rc = FAPI_ATTR_GET(ATTR_EFF_CUSTOM_DIMM, &i_target_mba, l_attr_eff_dimm_type_u8); if(rc) return rc;
 	rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target_mba, num_ranks_per_dimm); if(rc) return rc;
-	rc = FAPI_ATTR_GET( ATTR_VREF_DQ_TRAIN_RANGE, &i_target_mba, vrefdq_train_range);if(rc) return rc;
+	rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_RANGE, &i_target_mba, vrefdq_train_range);if(rc) return rc;
 	rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_TEST_VALID, &i_target_mba, l_attr_schmoo_test_type_u8); if(rc) return rc;
 	if(vrefdq_train_range[0][0][0] == 1)
 	{
-		base_percent = 45;
+		base_percent = 45000;
 	}
 	
 	l_MAX_RANKS[0]=num_ranks_per_dimm[0][0]+num_ranks_per_dimm[0][1];
 	l_MAX_RANKS[1]=num_ranks_per_dimm[1][0]+num_ranks_per_dimm[1][1];
-	FAPI_INF("\n ** l_max_rank 0 = %d",l_MAX_RANKS[0]);
+	//FAPI_INF("\n ** l_max_rank 0 = %d",l_MAX_RANKS[0]);
 	if ( l_attr_eff_dimm_type_u8 == fapi::ENUM_ATTR_EFF_CUSTOM_DIMM_YES )
 		{
 			l_SCHMOO_NIBBLES=20;
@@ -875,7 +879,7 @@ fapi::ReturnCode wr_vref_shmoo_ddr4(const fapi::Target & i_target_mba)
 	//uint32_t best_vref[50][2][8][20];
 	//uint32_t best_vref_nibble[2][8][20];
 	uint32_t vref_val=0;
-	uint32_t pda_nibble_table[2][2][16][2];
+	uint32_t pda_nibble_table[2][2][4][16][2];
 	uint8_t i=0;
 	uint8_t j=0;
 	uint8_t k=0;
@@ -921,8 +925,8 @@ for(l_vref_num=0; l_vref_num < max_ddr4_vrefs1; l_vref_num++){
 			}
 		}	
 		
-		rc = FAPI_ATTR_SET( ATTR_VREF_DQ_TRAIN_RANGE, &i_target_mba, vrefdq_train_range);if(rc) return rc;
-		rc = FAPI_ATTR_SET( ATTR_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);if(rc) return rc;
+		rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_RANGE, &i_target_mba, vrefdq_train_range);if(rc) return rc;
+		rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);if(rc) return rc;
 		rc = mss_mrs6_DDR4(l_target_centaur);
 		if(rc)
 		{
@@ -942,8 +946,8 @@ for(l_vref_num=0; l_vref_num < max_ddr4_vrefs1; l_vref_num++){
 			}
 		}
 		
-		rc = FAPI_ATTR_SET( ATTR_VREF_DQ_TRAIN_VALUE, &i_target_mba, vrefdq_train_value);
-		
+		rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_VALUE, &i_target_mba, vrefdq_train_value);
+		if(rc) { return rc;} //dc99
 		
 		rc = mss_mrs6_DDR4(l_target_centaur);
 		if(rc)
@@ -952,7 +956,7 @@ for(l_vref_num=0; l_vref_num < max_ddr4_vrefs1; l_vref_num++){
 			return rc;
 		}
 		
-		FAPI_INF("The Vref value is %d .... The percent voltage bump = %f ",vref_val,vref_val_print);
+		FAPI_INF("The Vref value is %d .... The percent voltage bump = %d ",vref_val,vref_val_print);
 		
 		for(i=0;i< max_port;i++){
 			for(j=0;j<l_MAX_RANKS[0];j++){
@@ -963,7 +967,7 @@ for(l_vref_num=0; l_vref_num < max_ddr4_vrefs1; l_vref_num++){
 				}
 			}
 		}	
-		rc = FAPI_ATTR_SET( ATTR_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);if(rc) return rc;
+		rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);if(rc) return rc;
 		rc = mss_mrs6_DDR4(l_target_centaur);
 		if(rc)
 		{
@@ -982,7 +986,7 @@ for(l_vref_num=0; l_vref_num < max_ddr4_vrefs1; l_vref_num++){
 		vref_val,pda_nibble_table);
 		if (rc) return rc;
 		
-		FAPI_INF("Wr Vref = %f ; Min Setup time = %d; Min Hold time = %d",
+		FAPI_INF("Wr Vref = %d ; Min Setup time = %d; Min Hold time = %d",
 		vref_val_print,
 		l_left_margin,
 		l_right_margin);
@@ -1005,7 +1009,8 @@ fapi::ReturnCode wr_vref_shmoo_ddr4_bin(const fapi::Target & i_target_mba)
 {
 	fapi::ReturnCode rc;
 	uint8_t MAX_PORT = 2;
-	uint8_t max_ddr4_vrefs1 = 50;
+	uint8_t MAX_DIMM = 2;
+	//uint8_t max_ddr4_vrefs1 = 52;
 	shmoo_type_t i_shmoo_type_valid = MCBIST;
 	ecmdDataBufferBase l_data_buffer_64(64);
 	ecmdDataBufferBase refresh_reg(64); 
@@ -1014,52 +1019,52 @@ fapi::ReturnCode wr_vref_shmoo_ddr4_bin(const fapi::Target & i_target_mba)
 	uint8_t l_attr_eff_dimm_type_u8 = 0;
 	uint8_t vrefdq_train_range[2][2][4];
 	uint8_t num_ranks_per_dimm[2][2];
-	uint8_t l_MAX_RANKS[2];
-	uint32_t rc_num = 0;
-	uint8_t l_SCHMOO_NIBBLES=20;
-	uint8_t base_percent = 60;
-	uint32_t pda_nibble_table[2][2][16][2];
-	uint32_t best_pda_nibble_table[2][2][16][2];
-	float index_mul_print = 0.65;
-	uint8_t l_attr_schmoo_test_type_u8 = 1;
-	float vref_val_print = 0;
-	rc = FAPI_ATTR_GET(ATTR_EFF_CUSTOM_DIMM, &i_target_mba, l_attr_eff_dimm_type_u8); if(rc) return rc;
-	rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target_mba, num_ranks_per_dimm); if(rc) return rc;
-	rc = FAPI_ATTR_GET( ATTR_VREF_DQ_TRAIN_RANGE, &i_target_mba, vrefdq_train_range);if(rc) return rc;
-	rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_TEST_VALID, &i_target_mba, l_attr_schmoo_test_type_u8); if(rc) return rc;
-	if(vrefdq_train_range[0][0][0] == 1)
-	{
-		base_percent = 45;
-	}
-	
-	l_MAX_RANKS[0]=num_ranks_per_dimm[0][0]+num_ranks_per_dimm[0][1];
-	l_MAX_RANKS[1]=num_ranks_per_dimm[1][0]+num_ranks_per_dimm[1][1];
-	FAPI_INF("\n ** l_max_rank 0 = %d Base Percent = %d",l_MAX_RANKS[0],base_percent);
-	if ( l_attr_eff_dimm_type_u8 == fapi::ENUM_ATTR_EFF_CUSTOM_DIMM_YES )
-	{
-		l_SCHMOO_NIBBLES=20;
-	}else{
-		l_SCHMOO_NIBBLES=18;
-	}
+	//uint8_t l_MAX_RANKS[2];
+	uint32_t total_val = 0;
+	uint32_t last_total = 0;
+	uint32_t base_percent = 60000;
+	uint32_t pda_nibble_table[2][2][4][16][2];  // Port,Dimm,Rank,Nibble,[2]
+	uint32_t best_pda_nibble_table[2][2][4][16][2];
+	//uint8_t cal_control = 0;
 	///// ddr4 vref //////
 	fapi::Target l_target_centaur=i_target_mba;
 	uint8_t vrefdq_train_value[2][2][4]; 
 	uint8_t vrefdq_train_enable[2][2][4]; 
-	uint32_t best_vref[50][1];
 	uint32_t vref_val=0;
-	uint8_t index = 0;	
 	uint8_t i=0;
 	uint8_t j=0;
 	uint8_t k=0;
 	uint8_t a=0;
 	uint8_t c=0;
-	uint8_t l_ranks = 0;
+	uint8_t l_dimm = 0;
 	uint8_t i_port=0;
 	uint8_t l_vref_mid = 0;
+	uint8_t imax = 	39;
+	uint8_t imin = 13;
+	uint8_t last_known_vref = 0;
+	uint8_t l_loop_count = 0;
 	vector<PDA_MRS_Storage> pda;
 	pda.clear();
-
-	FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++ Patch - Preet - WR_VREF - Check Sanity only at 500 ddr4 +++++++++++++++++++++++++++");
+	uint32_t index_mul_print = 650;
+	uint8_t l_attr_schmoo_test_type_u8 = 1;
+	uint32_t vref_val_print = 0;
+	rc = FAPI_ATTR_GET(ATTR_EFF_CUSTOM_DIMM, &i_target_mba, l_attr_eff_dimm_type_u8); if(rc) return rc;
+	rc = FAPI_ATTR_GET(ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, &i_target_mba, num_ranks_per_dimm); if(rc) return rc;
+	rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_RANGE, &i_target_mba, vrefdq_train_range);if(rc) return rc;
+	rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_TEST_VALID, &i_target_mba, l_attr_schmoo_test_type_u8); if(rc) return rc;
+	//rc = FAPI_ATTR_GET( ATTR_MSS_VREF_CAL_CNTL, &i_target_mba, cal_control);if(rc) return rc;
+	//FAPI_INF("++++++++++++++ATTR_MSS_VREF_CAL_CNTL = %d +++++++++++++++++++++++++++",cal_control);
+	
+	if(vrefdq_train_range[0][0][0] == 1)
+	{
+		base_percent = 45;
+	}
+	
+	//l_MAX_RANKS[0]=num_ranks_per_dimm[0][0]+num_ranks_per_dimm[0][1];
+	//l_MAX_RANKS[1]=num_ranks_per_dimm[1][0]+num_ranks_per_dimm[1][1];
+	//FAPI_INF("\n ** l_max_rank = %d Base Percent = %d",l_MAX_RANKS[0],base_percent);
+	
+	FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++ WR_VREF - Check Sanity only at 500 ddr4 +++++++++++++++++++++++++++");
 	rc = delay_shmoo_ddr4_pda(i_target_mba, i_port, i_shmoo_type_valid,
 	&l_left_margin, &l_right_margin,
 	vref_val,pda_nibble_table);
@@ -1068,35 +1073,36 @@ fapi::ReturnCode wr_vref_shmoo_ddr4_bin(const fapi::Target & i_target_mba)
 	FAPI_INF(" Setup and Sanity - Check disabled from now on..... Continuing .....");
 	rc = set_attribute(i_target_mba);
 	if (rc) return rc;
+	
 	i_shmoo_type_valid = WR_EYE;
 	l_attr_schmoo_test_type_u8 = 2;
 	rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_TEST_VALID, &i_target_mba, l_attr_schmoo_test_type_u8); if(rc) return rc;
 	//Initialize all to zero
-	for(index = 0; index < max_ddr4_vrefs1;index++)
+	/*for(index = 0; index < 50;index++)
 	{
-		best_vref[index][0] = 0;
+		best_vref[index] = 0;
+		
 	}
+	*/
+	//Initialise All to Zero [2][2][4]
 	
-	//Initialise All to Zero 
-	for(int k=0;k< MAX_PORT;k++)  // port
+	for(k=0;k < MAX_PORT;k++)  // port
 	{
-		for(int j=0;j < l_MAX_RANKS[0];j++)   //Rank
+		for(l_dimm=0;l_dimm < 2;l_dimm++)   //Dimm
 		{
-			for(int i=0;i<16;i++)  //Nibble
+			for(j=0;j < 4;j++)   //Rank
 			{
-				pda_nibble_table[k][j][i][0] = 0;  //  Index 0 Are V-refs
-				pda_nibble_table[k][j][i][1] = 0;   // Index 1 are Total Margin Values
-				best_pda_nibble_table[k][j][i][0] = 0;   //  Index 0 Are V-refs
-				best_pda_nibble_table[k][j][i][1] = 0;    // Index 1 are Total Margin Values
+				for(i=0;i<16;i++)  //Nibble
+				{
+				pda_nibble_table[k][l_dimm][j][i][0] = 0;  //  Index 0 Are V-refs
+				pda_nibble_table[k][l_dimm][j][i][1] = 0;   // Index 1 are Total Margin Values
+				best_pda_nibble_table[k][l_dimm][j][i][0] = 0;   //  Index 0 Are V-refs
+				best_pda_nibble_table[k][l_dimm][j][i][1] = 0;    // Index 1 are Total Margin Values
+				}
 			}
 		}
 	}               
-	uint8_t imax = 	39;
-	uint8_t imin = 13;
-	uint8_t last_known_vref = 0;
-	uint8_t l_loop_count = 0;		
-	//for(l_vref_num=0; l_vref_num < max_ddr4_vrefs1; l_vref_num++){
-	//Sweep Right
+			
 	while(imax >= imin){	
 
 		if(l_loop_count==0)
@@ -1106,246 +1112,146 @@ fapi::ReturnCode wr_vref_shmoo_ddr4_bin(const fapi::Target & i_target_mba)
 
 		vref_val = l_vref_mid;
 		vref_val_print = base_percent + (l_vref_mid * index_mul_print);
-		
+		FAPI_INF("The Vref value is = %d; The percent voltage bump = %d ",vref_val,vref_val_print);
+		//FAPI_INF("\n Before Clearing Refresh");
 		rc = fapiGetScom(i_target_mba,0x03010432,l_data_buffer_64); if(rc) return rc;
-		rc_num = rc_num | l_data_buffer_64.clearBit(0); if(rc_num) return rc;
+		l_data_buffer_64.clearBit(0);
 		rc = fapiPutScom(i_target_mba,0x03010432,l_data_buffer_64); if(rc) return rc;
-		
-		//system("putscom cen.mba 03010432 0 1 0 -ib -all");
-		FAPI_INF("\n After Clearing Refresh");
+		//FAPI_INF("\n After Clearing Refresh");
 		
 		for(i=0;i<MAX_PORT;i++){
-			for(j=0;j<l_MAX_RANKS[0];j++){
+			for(j=0;j<MAX_DIMM;j++){
 				for(k=0;k<4;k++){
 					
-					vrefdq_train_enable[i][j][k]=0x00;
+					vrefdq_train_enable[i][j][k]=0x01;
 					
 				}
 			}
 		}	
 		
-		rc = FAPI_ATTR_SET( ATTR_VREF_DQ_TRAIN_RANGE, &i_target_mba, vrefdq_train_range);if(rc) return rc;
-		rc = FAPI_ATTR_SET( ATTR_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);if(rc) return rc;
-		rc = mss_mrs6_DDR4(l_target_centaur);
-		if(rc)
-		{
-			//FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
-			return rc;
-		}
-		
+		rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_RANGE, &i_target_mba, vrefdq_train_range);if(rc) return rc;
+		rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);if(rc) return rc;
 		for(a=0;a < MAX_PORT;a++) //Port
 		{
-			for(l_ranks=0;l_ranks < l_MAX_RANKS[0];l_ranks++){
-				for(c=0;c < 4;c++){
+			for(l_dimm=0;l_dimm < MAX_DIMM;l_dimm++)  //Max dimms
+			{
+				for(c=0;c < 4;c++)   //Ranks
+				{
 					
-					vrefdq_train_value[a][l_ranks][c]=vref_val;
+					vrefdq_train_value[a][l_dimm][c]=vref_val;
 					
 				}
 			}
 		}
 		
-		rc = FAPI_ATTR_SET( ATTR_VREF_DQ_TRAIN_VALUE, &i_target_mba, vrefdq_train_value); if(rc) return rc;
-		
-		
+		rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_VALUE, &i_target_mba, vrefdq_train_value); if(rc) return rc;
 		rc = mss_mrs6_DDR4(l_target_centaur);
 		if(rc)
 		{
-			//FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
+			FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
 			return rc;
 		}
 		
-		FAPI_INF("The Vref value is %d .... The percent voltage bump = %f ",vref_val,vref_val_print);
-		
 		for(i=0;i < MAX_PORT;i++){
-			for(j=0;j<l_MAX_RANKS[0];j++){
+			for(j=0;j<2;j++){
 				for(k=0;k<4;k++){
 					
-					vrefdq_train_enable[i][j][k]=0x01;
+					vrefdq_train_enable[i][j][k]=0x00;
 					
 				}
 			}
 		}	
-		rc = FAPI_ATTR_SET( ATTR_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);if(rc) return rc;
+		rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);if(rc) return rc;
 		rc = mss_mrs6_DDR4(l_target_centaur);
 		if(rc)
 		{
-			//FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
+			FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
 			return rc;
 		}
 		
 		rc = fapiGetScom(i_target_mba,0x03010432,l_data_buffer_64); if(rc) return rc;
-		rc_num = rc_num | l_data_buffer_64.setBit(0); if(rc_num) return rc;
+		l_data_buffer_64.setBit(0);
 		rc = fapiPutScom(i_target_mba,0x03010432,l_data_buffer_64); if(rc) return rc;
-		//system("putscom cen.mba 03010432 0 1 1 -ib -all");
 		
-		rc = delay_shmoo_ddr4_pda(i_target_mba, i_port, i_shmoo_type_valid,
-		&l_left_margin, &l_right_margin,
-		vref_val,pda_nibble_table);
+		
+		rc = delay_shmoo_ddr4_pda(i_target_mba, i_port, i_shmoo_type_valid,&l_left_margin,&l_right_margin,vref_val,pda_nibble_table);
 		if (rc) return rc;
 		
-		FAPI_INF("Wr Vref = %f ; Min Setup time = %d; Min Hold time = %d",
-		vref_val_print,
-		l_left_margin,
-		l_right_margin);
-		best_vref[vref_val][0] = l_right_margin+l_left_margin;
+		total_val = l_right_margin+l_left_margin;
+		FAPI_INF("Preet2 - %d ; Wr Vref = %d ; Min Setup time = %d; Min Hold time = %d and Total = %d",vref_val,vref_val_print,l_left_margin,l_right_margin,total_val);
 		
-		//Get proper Criteria HERE
-		if(best_vref[vref_val][0] > best_vref[last_known_vref][0])
+		if(total_val > last_total)
 		{
 			last_known_vref = vref_val;
-			//if(l_loop_count !=0)
+			last_total = total_val;
+			if(l_loop_count != 0)
 			imin = l_vref_mid+1;
 		}
-		//imax = l_vref_mid + (imax - l_vref_mid)/2;
 		else
 		{
-			if(l_loop_count ==0)
-			{	FAPI_INF("Safety Fuse-1 !! "); 
-				imin = l_vref_mid+1;
-			}
-			else
-			imax = ((l_vref_mid + imax )/2)-2;
+			imax = l_vref_mid - 1;
 		}
 		l_loop_count ++;
 		for(int i_port=0;i_port < MAX_PORT;i_port++){
-			for(int i_rank=0;i_rank < l_MAX_RANKS[0];i_rank++){
-				for(int i_nibble=0;i_nibble < l_SCHMOO_NIBBLES;i_nibble++){
-					if (best_pda_nibble_table[i_port][i_rank][i_nibble][1] < pda_nibble_table[i_port][i_rank][i_nibble][1])
+			for(l_dimm=0;l_dimm < 2;l_dimm++){
+			for(int i_rank=0;i_rank < num_ranks_per_dimm[i_port][l_dimm];i_rank++){
+				for(int i_nibble=0;i_nibble < 16;i_nibble++){
+					if (best_pda_nibble_table[i_port][l_dimm][i_rank][i_nibble][1] < pda_nibble_table[i_port][l_dimm][i_rank][i_nibble][1])
 					{
-						best_pda_nibble_table[i_port][i_rank][i_nibble][1] = pda_nibble_table[i_port][i_rank][i_nibble][1];
-						best_pda_nibble_table[i_port][i_rank][i_nibble][0] = vref_val;
+						best_pda_nibble_table[i_port][l_dimm][i_rank][i_nibble][1] = pda_nibble_table[i_port][l_dimm][i_rank][i_nibble][1];
+						best_pda_nibble_table[i_port][l_dimm][i_rank][i_nibble][0] = vref_val;
 					}
-				}}}
-		
-	}
-
-	//imax = 	max_ddr4_vrefs1/2;
-	//imin = 0;
-	//Sweep Left
-	/*while(imax >= imin){	
-
-l_vref_mid = (imax+imin)/2;
-vref_val = l_vref_mid;
-vref_val_print = base_percent + (l_vref_mid * index_mul_print);	
-system("putscom cen.mba 03010432 0 1 0 -ib -all");
-FAPI_INF("\n After Clearing Refresh");
-		
-		for(i=0;i<2;i++){
-			for(j=0;j<l_MAX_RANKS[0];j++){
-				for(k=0;k<4;k++){
-					
-					vrefdq_train_enable[i][j][k]=0x00;
-					
 				}
-			}
-		}	
+			} //Rank Loop
+		} //dimm loop
+		} //Port loop
 		
-		rc = FAPI_ATTR_SET( ATTR_VREF_DQ_TRAIN_RANGE, &i_target_mba, vrefdq_train_range);if(rc) return rc;
-		rc = FAPI_ATTR_SET( ATTR_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);if(rc) return rc;
-				rc = mss_mrs6_DDR4(l_target_centaur);
-			if(rc)
-			{
-				//FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
-				return rc;
-			}
-			
-			for(a=0;a<2;a++){
-				for(l_ranks=0;l_ranks < l_MAX_RANKS[0];l_ranks++){
-					for(c=0;c<4;c++){
+	} //end of While
+
 	
-					vrefdq_train_value[a][l_ranks][c]=vref_val;
-					
-					}
+	vref_val_print = base_percent + (last_known_vref * index_mul_print);		
+	FAPI_INF("Best V-Ref - %d - %d  ; Total Window = %d",last_known_vref,vref_val_print,last_total);
+	// What do we do Once we know best V-Ref
+	
+	rc = fapiGetScom( i_target_mba,  0x03010432,  refresh_reg); if(rc) return rc;
+	refresh_reg.clearBit(0);
+	fapiPutScom( i_target_mba,  0x03010432,  refresh_reg);if(rc) return rc;
+	
+	for(int i_port=0;i_port < 2;i_port++){
+		for(int i_dimm=0;i_dimm < 2;i_dimm++){
+		for(int i_rank=0;i_rank < num_ranks_per_dimm[i_port][i_dimm];i_rank++){
+			for(int i_nibble=0;i_nibble < 16;i_nibble++){
+				FAPI_INF("\n Port %d Dimm %d Rank:%d Pda_Nibble: %d  V-ref:%d  Margin:%d",i_port,i_dimm,i_rank,i_nibble,best_pda_nibble_table[i_port][i_dimm][i_rank][i_nibble][0],best_pda_nibble_table[i_port][i_dimm][i_rank][i_nibble][1]);
+				pda.push_back(PDA_MRS_Storage(best_pda_nibble_table[i_port][i_dimm][i_rank][i_nibble][0],ATTR_EFF_VREF_DQ_TRAIN_VALUE,0,i_dimm,i_rank,i_port));
 				}
-			}
-		
-				rc = FAPI_ATTR_SET( ATTR_VREF_DQ_TRAIN_VALUE, &i_target_mba, vrefdq_train_value);
-		
-		
-			rc = mss_mrs6_DDR4(l_target_centaur);
-			if(rc)
-			{
-				//FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
-				return rc;
-			}
-			
-			FAPI_INF("The Vref value is %d .... The percent voltage bump = %f ",vref_val,vref_val_print);
-			
-			for(i=0;i<2;i++){
-			for(j=0;j<l_MAX_RANKS[0];j++){
+				FAPI_INF("FINAL %s PDA STRING: %d %s",i_target_mba.toEcmdString(),pda.size()-1,pda[pda.size()-1].c_str());
+				rc = mss_ddr4_run_pda((fapi::Target &)i_target_mba,pda); if(rc) return rc; 
+		} //End of Rank Loop
+		} //end of dimm loop
+} //End of Port Loop
+
+for(i=0;i<MAX_PORT;i++){
+			for(j=0;j<2;j++){
 				for(k=0;k<4;k++){
 					
-					vrefdq_train_enable[i][j][k]=0x01;
+					vrefdq_train_enable[i][j][k]=0x00;
 					
 				}
 			}
 		}	
-		rc = FAPI_ATTR_SET( ATTR_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);if(rc) return rc;
+rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);if(rc) return rc;
 		rc = mss_mrs6_DDR4(l_target_centaur);
-			if(rc)
-			{
-				//FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
-				return rc;
-			}
-		
-		system("putscom cen.mba 03010432 0 1 1 -ib -all");
-		
-		rc = delay_shmoo_ddr4(i_target_mba, i_port, i_shmoo_type_valid,
-								&l_left_margin, &l_right_margin,
-								vref_val);
-				if (rc) return rc;
-			
-	FAPI_INF("Wr Vref = %f ; Min Setup time = %d; Min Hold time = %d",
-						vref_val_print,
-						l_left_margin,
-						l_right_margin);
-		best_vref[vref_val][0] = l_right_margin+l_left_margin;
-		
-		//Get proper Criteria HERE
-		if(best_vref[vref_val][0] > best_vref[last_known_vref][0])
+		if(rc)
 		{
-			last_known_vref = vref_val;
-			imin = l_vref_mid+1;
-		}
-		//last_known_vref = vref_val;
-		//imax = l_vref_mid + (imax - l_vref_mid)/2;
-		else
-		imax = (l_vref_mid + imax )/2;
+			FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
+			return rc;
 		}
-
-		*/
-	vref_val_print = base_percent + (last_known_vref * index_mul_print);		
-	FAPI_INF("Best V-Ref - %f  ; Total Window = %d",
-	vref_val_print,best_vref[last_known_vref][0]);
-	// What do we do Once we know best V-Ref
-	for(a=0;a<50;a++)
-	{
-		vref_val_print = base_percent + (a * index_mul_print);
-		FAPI_INF("\n V-Ref - %f  ; Total Window = %d",vref_val_print,best_vref[a][0]);
-	}
-	rc = fapiGetScom( i_target_mba,  0x03010432,  refresh_reg); if(rc) return rc;
-	refresh_reg.clearBit(0);
-	fapiPutScom( i_target_mba,  0x03010432,  refresh_reg);if(rc) return rc;
-	
-	/*for(int i_port=0;i_port < 2;i_port++){
-		for(int i_rank=0;i_rank < 2;i_rank++){
-		for(int i_nibble=0;i_nibble < 16;i_nibble++){
-		FAPI_INF("\n Port %d Rank:%d Pda_Nibble: %d  V-ref:%d  Margin:%d",i_port,i_rank,i_nibble,best_pda_nibble_table[i_port][i_rank][i_nibble][0],best_pda_nibble_table[i_port][i_rank][i_nibble][1]);
-		pda.push_back(PDA_MRS_Storage(best_pda_nibble_table[i_port][i_rank][i_nibble][0],ATTR_VREF_DQ_TRAIN_VALUE,i_nibble,i_rank,0,i_port));
-}
-FAPI_INF("FINAL %s PDA STRING: %d %s",i_target_mba.toEcmdString(),pda.size()-1,pda[pda.size()-1].c_str());
-}}
-
-rc = fapiGetScom( i_target_mba,  0x03010432,  refresh_reg);
+	rc = fapiGetScom( i_target_mba,0x03010432,refresh_reg);
 	refresh_reg.setBit(0);
-	fapiPutScom( i_target_mba,  0x03010432,  refresh_reg);
+	fapiPutScom( i_target_mba,0x03010432,refresh_reg);
 			
 		
 	//Read the write vref attributes
-	
-				
-	rc = mss_ddr4_run_pda((fapi::Target &)i_target_mba,pda); 
-*/	
 	return rc;
 }
 
@@ -1642,7 +1548,7 @@ fapi::ReturnCode delay_shmoo_ddr4(const fapi::Target & i_target_mba, uint8_t i_p
 shmoo_type_t i_shmoo_type_valid,
 uint32_t *o_left_margin,
 uint32_t *o_right_margin,
-uint32_t i_shmoo_param,uint32_t pda_nibble_table[2][2][16][2])
+uint32_t i_shmoo_param,uint32_t pda_nibble_table[2][2][4][16][2])
 {
 	fapi::ReturnCode rc;
 
@@ -1660,7 +1566,7 @@ fapi::ReturnCode delay_shmoo_ddr4_pda(const fapi::Target & i_target_mba, uint8_t
 shmoo_type_t i_shmoo_type_valid,
 uint32_t *o_left_margin,
 uint32_t *o_right_margin,
-uint32_t i_shmoo_param,uint32_t pda_nibble_table[2][2][16][2])
+uint32_t i_shmoo_param,uint32_t pda_nibble_table[2][2][4][16][2])
 {
 	fapi::ReturnCode rc;
 
diff --git a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_generic_shmoo.C b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_generic_shmoo.C
index 15177eb..d366a16 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_generic_shmoo.C
+++ b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_generic_shmoo.C
@@ -22,12 +22,12 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_generic_shmoo.C,v 1.101 2015/09/25 20:19:34 sglancy Exp $
+// $Id: mss_generic_shmoo.C,v 1.106 2015/11/03 13:41:41 sasethur Exp $
 // $Source: /afs/awd/projects/eclipz/KnowledgeBase/.cvsroot/eclipz/chips/centaur/working/procedures/ipl/fapi/mss_generic_shmoo.C,v $
 // *!***************************************************************************
 // *! (C) Copyright International Business Machines Corp. 1997, 1998
 // *!           All Rights Reserved -- Property of IBM
-// *!                   ***  ***
+// *!                   *** IBM Confidential ***
 // *!***************************************************************************
 // *! FILENAME             : mss_generic_shmoo.C
 // *! TITLE                : MSS Generic Shmoo Implementation
@@ -42,6 +42,11 @@
 //------------------------------------------------------------------------------
 // Version:|Author: | Date:   | Comment:
 // --------|--------|---------|--------------------------------------------------
+//   1.106 |preeragh|02-Sep-15| Run Shmoos Only on Master Ranks!
+//   1.105 |sglancy| 10-Oct-15| Changed attribute names
+//   1.104 |preeragh|20-Oct-15| Fix Report Prints and Range for WR_DDR4_Vref Range 0-50
+//   1.103 |preeragh|20-Oct-15| Remove Floating Point for V-ref Prints
+//   1.102 |preeragh|07-Oct-15| PDA - Write Back Fix - DDR4
 //   1.101 |sglancy |25-Sep-15| Fixed bug where shmoos only had a granularity of 2 ticks instead of 1
 //   1.100 |preeragh|25-Aug-15| More FW Review Comments
 //   1.99  |preeragh|25-Aug-15| More FW Review Comments
@@ -213,7 +218,7 @@ extern "C"
         if(rc) return rc;
         rc = FAPI_ATTR_SET(ATTR_MCBIST_PRINTING_DISABLE, &i_target, l_mcbist_prnt_off);
         if(rc) return rc;
-        rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target, num_ranks_per_dimm);
+        rc = FAPI_ATTR_GET(ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, &i_target, num_ranks_per_dimm);
         if(rc) return rc;
         rc = FAPI_ATTR_GET(ATTR_EFF_CUSTOM_DIMM, &i_target, l_attr_eff_dimm_type_u8);
         if(rc) return rc;
@@ -267,7 +272,7 @@ extern "C"
                 else
                     valid_rank1[l_p][l_rnk] = rank_table_port1[l_rnk];
 
-                FAPI_INF("PORT - %d - RANK %d\n",l_p,valid_rank1[l_p][l_rnk]);
+                //FAPI_INF("PORT - %d - RANK %d\n",l_p,valid_rank1[l_p][l_rnk]);
             }
         }
         FAPI_DBG("mss_generic_shmoo : run() for shmoo type %d", shmoo_mask);
@@ -422,7 +427,7 @@ extern "C"
 
                 rc=get_min_margin2(i_target,o_right_min_margin,o_left_min_margin);
                 if(rc) return rc;
-                rc=print_report(i_target);
+                rc=print_report2(i_target);
                 if(rc) return rc;
                 FAPI_INF("%s:Minimum hold margin=%d ps and setup margin=%d ps",i_target.toEcmdString(), *o_left_min_margin,*o_right_min_margin);
             }
@@ -430,7 +435,7 @@ extern "C"
             {
                 rc=get_min_margin2(i_target,o_right_min_margin,o_left_min_margin);
                 if(rc) return rc;
-                rc=print_report(i_target);
+                rc=print_report2(i_target);
                 if(rc) return rc;
                 FAPI_INF("%s:Minimum hold margin=%d ps and setup margin=%d ps",i_target.toEcmdString(), *o_left_min_margin,*o_right_min_margin);
             }
@@ -3622,185 +3627,160 @@ extern "C"
         return rc;
     }
 
-    /*
-    	fapi::ReturnCode generic_shmoo::print_report2(const fapi::Target & i_target)
-    	{
-    		fapi::ReturnCode rc;
-    		FAPI_INF("\nIn print report!!!\n");
-    		uint8_t l_rnk, l_nibble;
-    		uint8_t l_p = 0;
-    		uint8_t i_rank = 0;
-    		uint8_t l_mbapos = 0;
-    		uint16_t l_total_margin = 0;
-    		//uint8_t l_SCHMOO_NIBBLES = 20;
-    		char * l_pMike = new char[128];
-    		char * l_str = new char[128];
-    		uint8_t l_i = 0;
-    		uint8_t l_dq = 0;
-    		uint8_t l_byte = 0;
-    		uint8_t l_bit = 0;
-    		uint8_t l_flag = 0;
-    		uint8_t l_CDarray0[80] = { 0 };
-    		uint8_t l_CDarray1[80] = { 0 };
-    		uint8_t vrefdq_train_range[2][2][4];
-    		uint32_t l_attr_mss_freq_u32 = 0;
-    		uint32_t l_attr_mss_volt_u32 = 0;
-    		uint8_t l_attr_eff_dimm_type_u8 = 0;
-    		uint8_t l_attr_eff_num_drops_per_port_u8 = 0;
-    		uint8_t l_attr_eff_dram_width_u8 = 0;
-    		fapi::Target l_target_centaur;
-    		uint8_t l_dram_gen = 1;
-    		uint8_t base_percent = 60;
-    		float index_mul_print = 0.65;
-    		float vref_val_print = 0;
-
-
-    		rc = fapiGetParentChip(i_target, l_target_centaur); if(rc) return rc;
-    		rc = FAPI_ATTR_GET( ATTR_VREF_DQ_TRAIN_RANGE, &i_target, vrefdq_train_range);if(rc) return rc;
-    		rc = FAPI_ATTR_GET(ATTR_MSS_FREQ, &l_target_centaur, l_attr_mss_freq_u32); if(rc) return rc;
-    		rc = FAPI_ATTR_GET(ATTR_MSS_VOLT, &l_target_centaur, l_attr_mss_volt_u32); if(rc) return rc;
-    		rc = FAPI_ATTR_GET(ATTR_EFF_CUSTOM_DIMM, &i_target, l_attr_eff_dimm_type_u8); if(rc) return rc;
-    		rc = FAPI_ATTR_GET(ATTR_EFF_NUM_DROPS_PER_PORT, &i_target, l_attr_eff_num_drops_per_port_u8); if(rc) return rc;
-    		rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_WIDTH, &i_target, l_attr_eff_dram_width_u8); if(rc) return rc;
-    		rc = FAPI_ATTR_GET(ATTR_CHIP_UNIT_POS, &i_target, l_mbapos);if(rc) return rc;
-    		rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_GEN, &i_target, l_dram_gen); if(rc) return rc;
-
-
-
-    		if(vrefdq_train_range[0][0][0] == 1)
-    		{
-    			base_percent = 45;
-    		}
-
-    		vref_val_print = base_percent + (iv_vref_mul * index_mul_print);
-    		FAPI_INF("%s: freq = %d on %s.",i_target.toEcmdString(),l_attr_mss_freq_u32, l_target_centaur.toEcmdString());
-    		FAPI_INF("%s: volt = %d on %s.",i_target.toEcmdString(), l_attr_mss_volt_u32, l_target_centaur.toEcmdString());
-    		FAPI_INF("%s: dimm_type = %d on %s.",i_target.toEcmdString(), l_attr_eff_dimm_type_u8, i_target.toEcmdString());
-    		if ( l_attr_eff_dimm_type_u8 == fapi::ENUM_ATTR_EFF_CUSTOM_DIMM_YES )
-    		{
-    			FAPI_INF("%s: It is a CDIMM",i_target.toEcmdString());
-    		}
-    		else
-    		{
-    			FAPI_INF("%s: It is an ISDIMM",i_target.toEcmdString());
-    		}
-    		FAPI_INF("%s: \n Number of ranks on port = 0 is %d ",i_target.toEcmdString(),iv_MAX_RANKS[0]);
-    		FAPI_INF("%s: \n Number of ranks on port = 1 is %d \n \n",i_target.toEcmdString(),iv_MAX_RANKS[1]);
-    		if (iv_shmoo_type == 2)
-    		{
-    			FAPI_INF("\n\n********************* WR_EYE Margins ********************** \n\n");
-    			sprintf(l_pMike, "\nSchmoo\tP\tP\tR\tB\tN\tBi\tNom\t\tRb\t\tLb\t\tSetup\t\tHold\t\tTotal\tfreq\tiv_ref_mul  ");
-
-    		}
-    		else
-    		{
-    			FAPI_INF("\n\n********************* RD_EYE Margins ********************** \n\n");
-    			sprintf(l_pMike, "\nSchmoo\tP\tP\tR\tB\tN\tBi\tNom\t\tRb\t\tLb\t\tSetup\t\tHold\t\tTotal\t\tfreq\t\tiv_ref_mul  ");
-    		}
-    		//printf("Schmoo  POS\tPort\tRank\tByte\tnibble\tbit\tNominal\t\tSetup_Limit\tHold_Limit \n");
-    		FAPI_INF("%s", l_pMike);
-    		delete[] l_pMike;
-
-
-
-    		rc=mcb_error_map(i_target,mcbist_error_map,l_CDarray0,l_CDarray1,count_bad_dq);if(rc)return rc;
-
-
-    		for (l_p = 0; l_p < MAX_PORT; l_p++)
-    		{
-    			for (l_rnk = 0; l_rnk < iv_MAX_RANKS[l_p]; l_rnk++)
-    			{
-    				//////
-
-    				i_rank = valid_rank1[l_p][l_rnk];
-    				////
-
-    				for (l_byte = 0; l_byte < iv_MAX_BYTES; l_byte++)
-    				{
-    					//Nibble loop
-    					for (l_nibble = 0; l_nibble < MAX_NIBBLES; l_nibble++)
-    					{
-
-    						l_dq=8 * l_byte + 4 * l_nibble;
-    						l_flag=0;
-    						if (l_p == 0)
-    						{
-    							for (l_i = 0; l_i < count_bad_dq[0]; l_i++)
-    							{
-    								if (l_CDarray0[l_i] == l_dq)
-    								{
-    									l_flag=1;
-
-    								}
-    							}
-    						}
-    						else
-    						{
-    							for (l_i = 0; l_i < count_bad_dq[1]; l_i++)
-    							{
-    								if (l_CDarray1[l_i] == l_dq)
-    								{
-    									l_flag=1;
-
-    								}
-    							}
-    						}
-
-    						if(l_flag==1)
-    						{
-    							//printf("Would normally skip prints...\n");
-    							//continue;
-    						}
-    						for (l_bit = 0; l_bit < MAX_BITS; l_bit++)
-    						{
-    							l_dq = 8 * l_byte + 4 * l_nibble + l_bit;
-    							l_total_margin
-    							= SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.left_margin_val[l_dq]
-    							+ SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.right_margin_val[l_dq];
-    							if(l_dram_gen ==2)
-    							{
-    								sprintf(l_str, "%d\t%d\t%d\t%d\t%d\t%d\t%d\t\t%d\t\t%d\t\t%d\t\t%d\t\t%d\t\t%d\t\t%f",
-    								l_mbapos, l_p, i_rank, l_byte, l_nibble, l_bit,
-    								SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.nom_val[l_dq],
-    								SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.rb_regval[l_dq],
-    								SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.lb_regval[l_dq],
-    								SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.right_margin_val[l_dq],
-    								SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.left_margin_val[l_dq],
-    								l_total_margin, l_attr_mss_freq_u32, vref_val_print);
-
-    							}
-    							else
-    							{
-    								sprintf(l_str, "%d\t%d\t%d\t%d\t%d\t%d\t%d\t\t%d\t\t%d\t\t%d\t\t%d\t\t%d\t\t%d\t\t%d",
-    								l_mbapos, l_p, i_rank, l_byte, l_nibble, l_bit,
-    								SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.nom_val[l_dq],
-    								SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.rb_regval[l_dq],
-    								SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.lb_regval[l_dq],
-    								SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.right_margin_val[l_dq],
-    								SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.left_margin_val[l_dq],
-    								l_total_margin, l_attr_mss_freq_u32, iv_vref_mul);
-    							}
-    							if (iv_shmoo_type == 2)
-    							{
-    								FAPI_INF("\nWR_EYE %s ", l_str);
-
-    							}
-    							else if (iv_shmoo_type == 8)
-    							{
-    								FAPI_INF("\nRD_EYE %s ", l_str);
-
-    							}
-    						}
-    					}
-    				}
-    			}
-    		}
-
-    		delete[] l_str;
-
-    		return rc;
-    	}
-    */  //end of print report test code
+fapi::ReturnCode generic_shmoo::print_report2(const fapi::Target & i_target)
+{
+    fapi::ReturnCode rc;
+
+    uint8_t l_rnk, l_byte, l_nibble, l_bit;
+    uint8_t l_p = 0;
+    uint8_t i_rank = 0;
+    uint8_t l_mbapos = 0;
+    uint32_t l_attr_mss_freq_u32 = 0;
+    uint32_t l_attr_mss_volt_u32 = 0;
+    uint8_t l_attr_eff_dimm_type_u8 = 0;
+    uint8_t l_attr_eff_num_drops_per_port_u8 = 0;
+    uint8_t l_attr_eff_dram_width_u8 = 0;
+    uint16_t l_total_margin = 0;
+	uint8_t l_dq = 0;
+	char * l_pMike = new char[128];
+    char * l_str = new char[128];
+	
+	fapi::Target l_target_centaur;
+
+    rc = fapiGetParentChip(i_target, l_target_centaur);
+    if (rc) return rc;
+	
+	uint8_t l_dram_gen = 1;
+	uint32_t base_percent = 60000;
+	uint32_t index_mul_print = 650;
+	uint32_t vref_val_print = 0;
+    uint8_t vrefdq_train_range[2][2][4];
+	
+	rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_RANGE, &i_target, vrefdq_train_range);if(rc) return rc;
+	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_GEN, &i_target, l_dram_gen); if(rc) return rc;
+	
+	if(vrefdq_train_range[0][0][0] == 1)
+	{
+	base_percent = 45000;
+	}
+	
+	vref_val_print = base_percent + (iv_vref_mul * index_mul_print);
+	
+    rc = FAPI_ATTR_GET(ATTR_MSS_FREQ, &l_target_centaur, l_attr_mss_freq_u32);
+    if (rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_MSS_VOLT, &l_target_centaur, l_attr_mss_volt_u32);
+    if (rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_EFF_CUSTOM_DIMM, &i_target, l_attr_eff_dimm_type_u8);
+    if (rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_EFF_NUM_DROPS_PER_PORT, &i_target,
+                       l_attr_eff_num_drops_per_port_u8);
+    if (rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_WIDTH, &i_target,
+                       l_attr_eff_dram_width_u8);
+    if (rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_CHIP_UNIT_POS, &i_target, l_mbapos);
+    if (rc) return rc;
+
+    FAPI_INF("%s: freq = %d on %s.", i_target.toEcmdString(),
+             l_attr_mss_freq_u32, l_target_centaur.toEcmdString());
+    FAPI_INF("%s: volt = %d on %s.", i_target.toEcmdString(),
+             l_attr_mss_volt_u32, l_target_centaur.toEcmdString());
+    FAPI_INF("%s: dimm_type = %d on %s.", i_target.toEcmdString(),
+             l_attr_eff_dimm_type_u8, i_target.toEcmdString());
+	//FAPI_INF("%s: +++ Preet1 %d +++ ", i_target.toEcmdString(),vref_val_print);
+			 
+    if (l_attr_eff_dimm_type_u8 == fapi::ENUM_ATTR_EFF_CUSTOM_DIMM_YES)
+    {
+        FAPI_INF("%s: It is a CDIMM", i_target.toEcmdString());
+    }
+    else
+    {
+        FAPI_INF("%s: It is an ISDIMM", i_target.toEcmdString());
+    }
+    FAPI_INF("%s: \n Number of ranks on port = 0 is %d ",
+             i_target.toEcmdString(), iv_MAX_RANKS[0]);
+    FAPI_INF("%s: \n Number of ranks on port = 1 is %d \n \n",
+             i_target.toEcmdString(), iv_MAX_RANKS[1]);
+
+    //FAPI_INF("%s:num_drops_per_port = %d on %s.", l_attr_eff_num_drops_per_port_u8, i_target.toEcmdString());
+    //FAPI_INF("%s:num_ranks  = %d on %s.", iv_MAX_RANKS,i_target.toEcmdString());
+    FAPI_INF("dram_width = %d  \n\n", l_attr_eff_dram_width_u8);
+    FAPI_INF("%s:+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++",
+             i_target.toEcmdString());
+    //// Based on schmoo param the print will change eventually
+
+    if (iv_shmoo_type == 0)
+    {
+        sprintf(l_pMike, "Schmoo  POS\tPort\tRank\tByte\tnibble\t\tSetup_Limit\tHold_Limit\tWrD_Setup(ps)\tWrD_Hold(ps)\tEye_Width(ps)\tBitRate\tVref_Multiplier  ");
+    }
+    else
+    {
+        sprintf(l_pMike, "Schmoo  POS\tPort\tRank\tByte\tnibble\t\tSetup_Limit\tHold_Limit\tRdD_Setup(ps)\tRdD_Hold(ps)\tEye_Width(ps)\tBitRate\tVref_Multiplier  ");
+    }
+    //FAPI_INF("Schmoo  POS\tPort\tRank\tByte\tnibble\tbit\tNominal\t\tSetup_Limit\tHold_Limit \n");
+    FAPI_INF("%s", l_pMike);
+    delete[] l_pMike;
+
+    for (l_p = 0; l_p < MAX_PORT; l_p++)
+    {
+        for (l_rnk = 0; l_rnk < iv_MAX_RANKS[l_p]; l_rnk++)
+        {
+            
+            i_rank = valid_rank1[l_p][l_rnk];
+            
+            for (l_byte = 0; l_byte < iv_MAX_BYTES; l_byte++)
+            {
+                //Nibble loop
+                for (l_nibble = 0; l_nibble < MAX_NIBBLES; l_nibble++)
+                {	
+				
+                    for (l_bit = 0; l_bit < MAX_BITS; l_bit++) 
+                    {
+                        l_dq = 8 * l_byte + 4 * l_nibble + l_bit;
+                        l_total_margin
+                            = SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.left_margin_val[l_dq]
+                                + SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.right_margin_val[l_dq];
+								if(l_dram_gen==2)
+								{
+								sprintf(l_str, "%d\t%d\t%d\t%d\t%d\t%d\t%d\t\t%d\t\t%d\t\t%d\t\t%d\t\t%d\t\t%d\t\t%d",
+                                l_mbapos, l_p, i_rank, l_byte, l_nibble, l_bit,
+                                SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.nom_val[l_dq],
+                                SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.rb_regval[l_dq],
+                                SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.lb_regval[l_dq],
+                                SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.left_margin_val[l_dq],
+                                SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.right_margin_val[l_dq],
+                                l_total_margin, l_attr_mss_freq_u32, vref_val_print);
+								}
+								else 
+								{
+								sprintf(l_str, "%d\t%d\t%d\t%d\t%d\t%d\t%d\t\t%d\t\t%d\t\t%d\t\t%d\t\t%d\t\t%d\t\t%d",
+                                l_mbapos, l_p, i_rank, l_byte, l_nibble, l_bit,
+                                SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.nom_val[l_dq],
+                                SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.rb_regval[l_dq],
+                                SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.lb_regval[l_dq],
+                                SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.left_margin_val[l_dq],
+                                SHMOO[iv_SHMOO_ON].MBA.P[l_p].S[i_rank].K.right_margin_val[l_dq],
+                                l_total_margin, l_attr_mss_freq_u32, iv_vref_mul);
+								}
+                        if (iv_shmoo_type == 2)
+                        {
+                            FAPI_ERR("WR_EYE %s ", l_str);
+                            
+                        }
+                        if (iv_shmoo_type == 8)
+                        {
+                            FAPI_ERR("RD_EYE %s ", l_str);
+                            
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    delete[] l_str;
+    return rc;
+}
 
     fapi::ReturnCode generic_shmoo::get_margin_dqs_by4(const fapi::Target & i_target)
     {
@@ -4280,38 +4260,47 @@ extern "C"
 
     }
 
-    fapi::ReturnCode generic_shmoo::get_nibble_pda(const fapi::Target & i_target,uint32_t pda_nibble_table[2][2][16][2])
-    {
-        fapi::ReturnCode rc;
-        uint8_t i_rank = 0;
-
-        for (int l_p=0; l_p < MAX_PORT; l_p++) {
-            for (int l_rnk=0; l_rnk<iv_MAX_RANKS[l_p]; l_rnk++)
-            {
-                ////
-                i_rank=valid_rank1[l_p][l_rnk];
-                for(int l_dq = 0; l_dq < 4; l_dq++) {
-                    for (int l_n=0; l_n < 16; l_n++) {
-                        // do necessary
-                        //if(pda_nibble_table[l_p][i_rank][l_n][1] < FAPI_INF.MBA.P[l_p].S[i_rank].K.total_margin[l_dq+l_n*4])
-                        {
-                            pda_nibble_table[l_p][i_rank][l_n][0] = iv_vref_mul;
-                            pda_nibble_table[l_p][i_rank][l_n][1] = SHMOO[iv_DQS_ON].MBA.P[l_p].S[i_rank].K.total_margin[l_dq+l_n*4];
-                        }
-                        //FAPI_INF("\n Port %d Rank:%d Pda_Nibble: %d  V-ref:%d  Margin:%d",l_p,i_rank,l_n,pda_nibble_table[l_p][i_rank][l_n][0],pda_nibble_table[l_p][i_rank][l_n][1]);
-                    }
-                }
-
-            }
-        }
-        return rc;
-    }
-    /*------------------------------------------------------------------------------
-    * Function: get_min_margin
-    * Description  : This function is used to get the minimum margin of all the schmoo margins
-    *
-    * Parameters: Target:MBA,right minimum margin , left minimum margin, pass fail
-    * ---------------------------------------------------------------------------*/
+	fapi::ReturnCode generic_shmoo::get_nibble_pda(const fapi::Target & i_target,uint32_t pda_nibble_table[2][2][4][16][2])
+	{
+		fapi::ReturnCode rc;
+		//uint8_t i_rank = 0;
+		uint8_t l_dimm = 0;
+		uint8_t num_ranks_per_dimm[2][2];
+		
+		rc = FAPI_ATTR_GET(ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, &i_target, num_ranks_per_dimm); if(rc) return rc;
+		
+		for (int l_p=0;l_p < MAX_PORT;l_p++){
+		 for (l_dimm=0;l_dimm < 2;l_dimm++){
+			for (int l_rnk=0;l_rnk < num_ranks_per_dimm[l_p][l_dimm];l_rnk++)
+			{
+				////
+				for(int l_dq = 0; l_dq < 4;l_dq++){
+					for (int l_n=0; l_n < 16;l_n++){
+						// do necessary
+						//if(pda_nibble_table[l_p][i_rank][l_n][1] < FAPI_INF.MBA.P[l_p].S[i_rank].K.total_margin[l_dq+l_n*4])
+						{
+							pda_nibble_table[l_p][l_dimm][l_rnk][l_n][0] = iv_vref_mul;
+							
+							if(l_dimm == 0)
+							{pda_nibble_table[l_p][l_dimm][l_rnk][l_n][1] = SHMOO[iv_DQS_ON].MBA.P[l_p].S[l_rnk].K.total_margin[l_dq+l_n*4];}
+							else
+							{pda_nibble_table[l_p][l_dimm][l_rnk][l_n][1] = SHMOO[iv_DQS_ON].MBA.P[l_p].S[l_rnk+4].K.total_margin[l_dq+l_n*4];}
+						}
+						//FAPI_INF("\n Port %d Rank:%d Pda_Nibble: %d  V-ref:%d  Margin:%d",l_p,i_rank,l_n,pda_nibble_table[l_p][i_rank][l_n][0],pda_nibble_table[l_p][i_rank][l_n][1]);
+					}
+				}
+				
+			}
+		}
+		}						
+		return rc;
+	}
+	/*------------------------------------------------------------------------------
+* Function: get_min_margin
+* Description  : This function is used to get the minimum margin of all the schmoo margins
+*
+* Parameters: Target:MBA,right minimum margin , left minimum margin, pass fail
+* ---------------------------------------------------------------------------*/
 
     fapi::ReturnCode generic_shmoo::get_min_margin2(const fapi::Target & i_target,uint32_t *o_right_min_margin,uint32_t *o_left_min_margin)
     {
diff --git a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_generic_shmoo.H b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_generic_shmoo.H
index f18bb55..15086ba 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_generic_shmoo.H
+++ b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_generic_shmoo.H
@@ -22,11 +22,11 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_generic_shmoo.H,v 1.29 2015/08/07 11:28:52 sasethur Exp $
+// $Id: mss_generic_shmoo.H,v 1.31 2015/10/20 12:14:43 sasethur Exp $
 // *!***************************************************************************
 // *! (C) Copyright International Business Machines Corp. 1997, 1998
 // *!           All Rights Reserved -- Property of IBM
-// *!                   ***  ***
+// *!                   *** IBM Confidential ***
 // *!***************************************************************************
 // *! FILENAME             : mss_generic_shmoo.H
 // *! TITLE                : MSS Generic Shmoo 
@@ -41,6 +41,8 @@
 //------------------------------------------------------------------------------
 // Version:|Author: | Date:  | Comment:
 // --------|--------|--------|--------------------------------------------------
+// 	 1.31  |preeragh|20/10/15| Header Fix
+// 	 1.30  |preeragh|07/10/15| PDA Table Size
 // 	 1.29  |preeragh|30/07/15| Optimized for FW Linear/Composite/Bin
 //   1.28  |preeragh|06/22/14|DDR4 Mods
 //   1.27  |mjjones |01/24/14|RAS Review Updates
@@ -224,7 +226,7 @@ public:
     fapi::ReturnCode shmoo_save_rest(const fapi::Target & i_target,
                                      uint64_t i_content_array[],
                                      uint8_t i_mode);
-	fapi::ReturnCode get_nibble_pda(const fapi::Target & i_target,uint32_t pda_nibble_table[2][2][16][2]);
+	fapi::ReturnCode get_nibble_pda(const fapi::Target & i_target,uint32_t pda_nibble_table[2][2][4][16][2]);
 	fapi::ReturnCode knob_update_bin_composite(const fapi::Target & i_target,bound_t bound,uint8_t scenario,uint8_t bit,uint8_t pass,bool &flag);
 	fapi::ReturnCode print_report2(const fapi::Target & i_target);
 
diff --git a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_mrs6_DDR4.C b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_mrs6_DDR4.C
index 36892a7..a401e3f 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_mrs6_DDR4.C
+++ b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_mrs6_DDR4.C
@@ -22,12 +22,14 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_mrs6_DDR4.C,v 1.6 2015/09/04 02:03:31 kmack Exp $
+// $Id: mss_mrs6_DDR4.C,v 1.8 2015/11/09 17:22:08 sglancy Exp $
 
 
 //------------------------------------------------------------------------------
 // *! (C) Copyright International Business Machines Corp. 2007
 // *! All Rights Reserved -- Property of IBM
+// *! *** IBM Confidential ***
+
 
 //------------------------------------------------------------------------------
 // Don't forget to create CVS comments when you check in your changes!
@@ -36,6 +38,8 @@
 //------------------------------------------------------------------------------
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|-----------------------------------------------
+//  1.07   | 11-03-15 |sglancy | Fixed attribute names for DDR4 RDIMM
+//  1.06   | 10-23-15 |sglancy | Fixed attribute names
 //  1.05   | 09/03/15 | kmack   | RC updates
 //  1.04   | 08/05/15 | sglancy | Fixed FW compile error
 //  1.03   | 08/04/15 | sglancy | Changed to address FW comments
@@ -248,7 +252,7 @@ ReturnCode mss_mr6_loader( fapi::Target& i_target,uint32_t i_port_number,uint32_
     if(rc) return rc;
 
     uint8_t address_mirror_map[2][2]; //address_mirror_map[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
     if(rc) return rc;
 
 
@@ -307,13 +311,13 @@ ReturnCode mss_mr6_loader( fapi::Target& i_target,uint32_t i_port_number,uint32_
 
     //MRS6
     uint8_t vrefdq_train_value[2][2][4]; //vrefdq_train value   -  NEW
-    rc = FAPI_ATTR_GET( ATTR_VREF_DQ_TRAIN_VALUE, &i_target, vrefdq_train_value);
+    rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_VALUE, &i_target, vrefdq_train_value);
     if(rc) return rc;
     uint8_t vrefdq_train_range[2][2][4]; //vrefdq_train range   -  NEW
-    rc = FAPI_ATTR_GET( ATTR_VREF_DQ_TRAIN_RANGE, &i_target, vrefdq_train_range);
+    rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_RANGE, &i_target, vrefdq_train_range);
     if(rc) return rc;
     uint8_t vrefdq_train_enable[2][2][4]; //vrefdq_train enable  -  NEW
-    rc = FAPI_ATTR_GET( ATTR_VREF_DQ_TRAIN_ENABLE, &i_target, vrefdq_train_enable);
+    rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target, vrefdq_train_enable);
     if(rc) return rc;
 
     FAPI_INF("enable attribute %d",vrefdq_train_enable[0][0][0]);
@@ -407,20 +411,20 @@ ReturnCode mss_mr6_loader( fapi::Target& i_target,uint32_t i_port_number,uint32_
 
                     vrefdq_train_value[i_port_number][dimm_number][rank_number] = mss_reverse_8bits(vrefdq_train_value[i_port_number][dimm_number][rank_number]);
 
-                    if (vrefdq_train_range[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VREF_DQ_TRAIN_RANGE_RANGE1)
+                    if (vrefdq_train_range[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_VREF_DQ_TRAIN_RANGE_RANGE1)
                     {
                         vrefdq_train_range[i_port_number][dimm_number][rank_number] = 0x00;
                     }
-                    else if (vrefdq_train_range[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VREF_DQ_TRAIN_RANGE_RANGE2)
+                    else if (vrefdq_train_range[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_VREF_DQ_TRAIN_RANGE_RANGE2)
                     {
                         vrefdq_train_range[i_port_number][dimm_number][rank_number] = 0xFF;
                     }
 
-                    if (vrefdq_train_enable[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_ENABLE)
+                    if (vrefdq_train_enable[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE)
                     {
                         vrefdq_train_enable[i_port_number][dimm_number][rank_number] = 0xff;FAPI_INF("ENABLE is enabled");
                     }
-                    else if (vrefdq_train_enable[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_DISABLE)
+                    else if (vrefdq_train_enable[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_DISABLE)
                     {
                         vrefdq_train_enable[i_port_number][dimm_number][rank_number] = 0x00;FAPI_INF("DISABLE is enabled");
                     }
diff --git a/src/usr/hwpf/hwp/dram_training/mss_draminit_training/mss_draminit_training.C b/src/usr/hwpf/hwp/dram_training/mss_draminit_training/mss_draminit_training.C
index 11905cb..3b7ced3 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_draminit_training/mss_draminit_training.C
+++ b/src/usr/hwpf/hwp/dram_training/mss_draminit_training/mss_draminit_training.C
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_draminit_training.C,v 1.103 2015/09/22 19:13:20 kmack Exp $
+// $Id: mss_draminit_training.C,v 1.107 2015/11/09 17:22:02 sglancy Exp $
 //------------------------------------------------------------------------------
 // Don't forget to create CVS comments when you check in your changes!
 //------------------------------------------------------------------------------
@@ -30,6 +30,10 @@
 //------------------------------------------------------------------------------
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|------------------------------------------------
+//  1.107  | sglancy  |03-NOV-15| Fixed attribute names for DDR4 RDIMM
+//  1.106  | sglancy  |23-OCT-15| Updated attribute names
+//  1.105  | rwheeler |20-OCT-15| updated the ifndef FAPI_LRDIMM.
+//  1.104  | rwheeler |19-OCT-15| Added support for the ddr4 lrdimm.
 //  1.103  | kmack    |16-SEP-15| Replaced sleep with fapiDelay
 //  1.102  | kmack    |16-SEP-15| DQS Alignment Workaround
 //  1.101  | sglancy  |14-JUL-15| Fixed compile issue
@@ -41,11 +45,11 @@
 //  1.95   | sglancy  |12-MAY-15| Added DDR4 WR VREF set
 //  1.94   | jdsloat  |27-JAN-14| Addressed FW concerns from gerrit.
 //  1.93   | jdsloat  |22-JAN-14| Moved the initialization of rank_invalid within BYTE DISABLE WORKAROUND
-//  1.92   | jdsloat  |20-JAN-14| Added new workaround for BYTE DISABLE and for WR LVL DISABLE.  This affects  RAS/BBM work.
-//  1.91   | jdsloat  |24-SEP-14| Disabling spare CKE bit modify for SW275629.  This bit will be modified via initfile.
+//  1.92   | jdsloat  |20-JAN-14| Added new workaround for BYTE DISABLE and for WR LVL DISABLE.  This affects  RAS/BBM work.  
+//  1.91   | jdsloat  |24-SEP-14| Disabling spare CKE bit modify for SW275629.  This bit will be modified via initfile. 
 //  1.90   | jdsloat  |29-JUL-14| disable for delay reset call moved to system level
-//  1.89   | jdsloat  |29-JUL-14| Added a disable for delay reset call
-//  1.88   | jdsloat  |14-JUL-14| Fixed delay reset call
+//  1.89   | jdsloat  |29-JUL-14| Added a disable for delay reset call 
+//  1.88   | jdsloat  |14-JUL-14| Fixed delay reset call 
 //  1.87   | jdsloat  |09-JUN-14| Fixed log numbering... Added additonal error logs for more debug ability in a training error situation.
 //  1.85   | jdsloat  |23-APL-14| Fixed attribute variable l_disable1_rdclk_fixed unitialized error in SW25701/v1.83
 //  1.84   | jdsloat  |23-APL-14| Fixed FAPI_ERR message within v1.83, mss_set_bbm_regs
@@ -87,9 +91,9 @@
 //  1.57   | jdsloat  |27-FEB-13| Added second workaround adjustment to waterfall problem in order to use 2 rank pairs.
 //  1.56   | jdsloat  |27-FEB-13| Fixed rtt_nom and rtt_wr swap bug during condition of rtt_nom = diabled and rtt_wr = non-disabled
 //         |          |         | Added workaround on a per quad resolution
-//         |          |         | Added workaround as a seperate sub
-//         |          |         | Added framework of binning workaround based on timing reference
-//         |          |         | Added putscom to enable spare cke mirroring
+//	   |          |         | Added workaround as a seperate sub
+//	   |          |         | Added framework of binning workaround based on timing reference
+//	   |          |         | Added putscom to enable spare cke mirroring
 //  1.55   | jdsloat  |25-FEB-13| Added MBA/Port info to debug messages.
 //  1.54   | jdsloat  |22-FEB-13| Edited WRITE_READ workaround to also edit DQSCLK PHASE
 //  1.53   | jdsloat  |14-FEB-13| Fixed WRITE_READ workaround so it will execute in a partial substep case
@@ -156,7 +160,7 @@
 //  1.11   | jdsloat  |21-Nov-11| Got rid of GOTO argument in CCS cmds.
 //  1.10   | divyakum |18-Nov-11| Fixed function calls to match procedure name.
 //  1.9    | divyakum |11-Oct-11| Fix to include mss_funcs instead of cen_funcs.
-//         |          |         | Changed usage of array attributes.
+//	   |          |         | Changed usage of array attributes.
 //         |          |         | NOTE: Needs to be compiled with mss_funcs v1.3.
 //  1.8    | divyakum |03-Oct-11| Removed primary_ranks_arrayvariable. Fixed rank loop for Socket1
 //  1.7    | divyakum |30-Sep-11| First drop for Centaur. This code compiles
@@ -187,6 +191,7 @@
 #include <mss_lrdimm_funcs.H>
 #include "mss_access_delay_reg.H"
 #include <mss_mrs6_DDR4.H>
+#include <mss_ddr4_funcs.H>
 #ifdef FAPI_LRDIMM
 #include <mss_lrdimm_ddr4_funcs.H>
 #endif
@@ -229,6 +234,49 @@ fapi::ReturnCode mss_dram_write_leveling(Target& i_target, uint32_t port)
    return rc;
 
 }
+
+fapi::ReturnCode mss_hwl_training_enable(Target& i_target_mba, uint8_t i_port_number) {
+
+   ReturnCode rc;
+
+   FAPI_ERR("Invalid exec of LRDIMM function on %s!", i_target_mba.toEcmdString());
+   FAPI_SET_HWP_ERROR(rc, RC_MSS_PLACE_HOLDER_ERROR);
+   return rc;
+}
+
+fapi::ReturnCode mss_hwl_training_disable(Target& i_target_mba, uint8_t i_port_number) {
+
+   ReturnCode rc;
+
+   FAPI_ERR("Invalid exec of LRDIMM function on %s!", i_target_mba.toEcmdString());
+   FAPI_SET_HWP_ERROR(rc, RC_MSS_PLACE_HOLDER_ERROR);
+   return rc;
+}
+fapi::ReturnCode mss_custom_DB_MPR_pattern(Target& i_target_mba, uint8_t i_port_number){
+
+   ReturnCode rc;
+
+   FAPI_ERR("Invalid exec of LRDIMM function on %s!", i_target_mba.toEcmdString());
+   FAPI_SET_HWP_ERROR(rc, RC_MSS_PLACE_HOLDER_ERROR);
+   return rc;
+}
+fapi::ReturnCode mss_hostside_read_training_enable(Target& i_target_mba, uint8_t i_port_number){
+
+   ReturnCode rc;
+
+   FAPI_ERR("Invalid exec of LRDIMM function on %s!", i_target_mba.toEcmdString());
+   FAPI_SET_HWP_ERROR(rc, RC_MSS_PLACE_HOLDER_ERROR);
+   return rc;
+}
+fapi::ReturnCode mss_hostside_read_training_disable(Target& i_target_mba, uint8_t i_port_number){
+
+   ReturnCode rc;
+
+   FAPI_ERR("Invalid exec of LRDIMM function on %s!", i_target_mba.toEcmdString());
+   FAPI_SET_HWP_ERROR(rc, RC_MSS_PLACE_HOLDER_ERROR);
+   return rc;
+}
+
 #endif
 
 //------------End My Includes-------------------------------------------
@@ -299,31 +347,31 @@ ReturnCode mss_draminit_training(Target& i_target)
     if (reset_disable != ENUM_ATTR_MSS_DRAMINIT_RESET_DISABLE_DISABLE)
     {
 
-        l_rc = mss_reset_delay_values(i_target);
-        if (l_rc)
-        {
-        return l_rc;
-        }
+	l_rc = mss_reset_delay_values(i_target);
+	if (l_rc)
+	{
+	return l_rc;
+	}
 
     }
 
     l_rc = mss_draminit_training_cloned(i_target);
     if (l_rc)
     {
-        return l_rc;
+	return l_rc;
     }
 
-        // If mss_unmask_draminit_training_errors gets it's own bad rc,
-        // it will commit the passed in rc (if non-zero), and return it's own bad rc.
-        // Else if mss_unmask_draminit_training_errors runs clean,
-        // it will just return the passed in rc.
-        l_rc = mss_unmask_draminit_training_errors(i_target, l_rc);
+	// If mss_unmask_draminit_training_errors gets it's own bad rc,
+	// it will commit the passed in rc (if non-zero), and return it's own bad rc.
+	// Else if mss_unmask_draminit_training_errors runs clean,
+	// it will just return the passed in rc.
+	l_rc = mss_unmask_draminit_training_errors(i_target, l_rc);
     if (l_rc)
     {
-        return l_rc;
+	return l_rc;
     }
 
-        return l_rc;
+	return l_rc;
 }
 
 
@@ -415,7 +463,7 @@ ReturnCode mss_draminit_training_cloned(Target& i_target)
 
     uint8_t l_nwell_misplacement = 0;
     uint8_t dram_rtt_nom_original = 0;
-    uint8_t training_success = 0;
+    uint8_t training_success = 0; 
 
     fapi::Target l_target_centaur;
     rc = fapiGetParentChip(i_target, l_target_centaur);
@@ -470,7 +518,7 @@ ReturnCode mss_draminit_training_cloned(Target& i_target)
     rc_num = rc_num | cal_steps_8.insert(cal_steps, 0, 8, 0);
 
     /*
-    Disabling spare CKE bit modify for SW275629.  This bit will be modified via initfile.
+    Disabling spare CKE bit modify for SW275629.  This bit will be modified via initfile. 
 
 
     //Setup SPARE CKE enable bit
@@ -503,30 +551,30 @@ ReturnCode mss_draminit_training_cloned(Target& i_target)
     rc = mss_set_bbm_regs (i_target);
     if(rc)
     {
-        FAPI_ERR( "Error Moving bad bit information to the Phy regs. Exiting.");
-        return rc;
+   	FAPI_ERR( "Error Moving bad bit information to the Phy regs. Exiting.");
+   	return rc;
     }
 
 
 
     if ( ( cal_steps_8.isBitSet(0) ) ||
-         ( (cal_steps_8.isBitClear(0)) && (cal_steps_8.isBitClear(1)) &&
-           (cal_steps_8.isBitClear(2)) && (cal_steps_8.isBitClear(3)) &&
-           (cal_steps_8.isBitClear(4)) && (cal_steps_8.isBitClear(5)) &&
-           (cal_steps_8.isBitClear(6)) && (cal_steps_8.isBitClear(7)) ))
+	 ( (cal_steps_8.isBitClear(0)) && (cal_steps_8.isBitClear(1)) &&
+	   (cal_steps_8.isBitClear(2)) && (cal_steps_8.isBitClear(3)) &&
+	   (cal_steps_8.isBitClear(4)) && (cal_steps_8.isBitClear(5)) &&
+	   (cal_steps_8.isBitClear(6)) && (cal_steps_8.isBitClear(7)) ))
     {
-        FAPI_INF( "Performing External ZQ Calibration on %s.", i_target.toEcmdString());
+	FAPI_INF( "Performing External ZQ Calibration on %s.", i_target.toEcmdString());
 
         //Execute ZQ_CAL
-        for(port = 0; port < MAX_NUM_PORT; port++)
-        {
-            rc = mss_execute_zq_cal(i_target, port);
-            if(rc) return rc;
+	for(port = 0; port < MAX_NUM_PORT; port++)
+	{
+	    rc = mss_execute_zq_cal(i_target, port);
+	    if(rc) return rc;
 
-        }
+	}
 
-        if ( (dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR3) &&
-                                (dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) )
+        if ( (dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR3) && 
+				(dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) )
         {
             FAPI_INF("Performing LRDIMM MB-DRAM training");
 
@@ -534,214 +582,228 @@ ReturnCode mss_draminit_training_cloned(Target& i_target)
             rc = mss_execute_lrdimm_mb_dram_training(i_target);
             if (rc) return rc;
         }
-        //executes the following to ensure that DRAMS have a good intial WR VREF DQ
-        //1) enter training mode w/ old value (nominal VREF DQ)
-        //2) set value in training mode (nominal VREF DQ)
-        //3) exit training mode (nominal VREF DQ)
-        else if(dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR4) {
-           FAPI_INF("For DDR4, setting VREFDQ to have an initial value!!!!");
-           uint8_t train_enable[2][2][4];
-           uint8_t train_enable_override_on[2][2][4] ={{{ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_ENABLE},{ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_ENABLE}},{{ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_ENABLE},{ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_ENABLE}}};
-
-           rc = FAPI_ATTR_GET( ATTR_VREF_DQ_TRAIN_ENABLE, &i_target, train_enable);
-           if(rc) return rc;
-
-           rc = FAPI_ATTR_SET(ATTR_VREF_DQ_TRAIN_ENABLE, &i_target, train_enable_override_on);
-           if(rc) return rc;
-
-           //runs new values w/ train enable forces on
-           FAPI_INF("RUN MRS6 1ST");
-           rc = mss_mrs6_DDR4(  i_target);
-           if(rc) return rc;
-           FAPI_INF("RUN MRS6 2ND");
-           rc = mss_mrs6_DDR4( i_target);
-           if(rc) return rc;
-
-           //set old train enable value
-           rc = FAPI_ATTR_SET(ATTR_VREF_DQ_TRAIN_ENABLE, &i_target, train_enable);
-           if(rc) return rc;
-
-           FAPI_INF("RUN MRS6 3RD");
-           rc = mss_mrs6_DDR4( i_target);
+	//executes the following to ensure that DRAMS have a good intial WR VREF DQ
+	//1) enter training mode w/ old value (nominal VREF DQ)
+	//2) set value in training mode (nominal VREF DQ)
+	//3) exit training mode (nominal VREF DQ)
+	else if(dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR4) {
+	   FAPI_INF("For DDR4, setting VREFDQ to have an initial value!!!!");
+	   uint8_t train_enable[2][2][4];
+	   uint8_t train_enable_override_on[2][2][4] ={{{ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE},{ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE}},{{ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE},{ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE,ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE}}};
+	   
+	   rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target, train_enable);
            if(rc) return rc;
-
-           //sets up the DQS offset to be 16 instead of 8
-           rc = mss_setup_dqs_offset(i_target);
-           if(rc) return rc;
-        }
-        //have to do ZQ cal, then DDR4 training mode for initial VREF setup, then do LR training
-        for(port = 0; port < MAX_NUM_PORT; port++)
-        {
+	   
+	   rc = FAPI_ATTR_SET(ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target, train_enable_override_on);
+	   if(rc) return rc;
+	   
+	   //runs new values w/ train enable forces on
+	   FAPI_INF("RUN MRS6 1ST");
+	   rc = mss_mrs6_DDR4(  i_target);
+	   if(rc) return rc;
+	   FAPI_INF("RUN MRS6 2ND");
+	   rc = mss_mrs6_DDR4( i_target);
+	   if(rc) return rc;
+	   
+	   //set old train enable value
+	   rc = FAPI_ATTR_SET(ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target, train_enable);
+	   if(rc) return rc;
+	   
+	   FAPI_INF("RUN MRS6 3RD");
+	   rc = mss_mrs6_DDR4( i_target);
+	   if(rc) return rc;
+	   
+	   //sets up the DQS offset to be 16 instead of 8
+	   rc = mss_setup_dqs_offset(i_target);
+	   if(rc) return rc;
+	}
+	//have to do ZQ cal, then DDR4 training mode for initial VREF setup, then do LR training
+	for(port = 0; port < MAX_NUM_PORT; port++)
+	{
 
             // Should only be called for DDR4 LRDIMMs, training code is in development. Does not effect any other configs
-            if ( (dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR4) &&
+	    if ( (dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR4) &&
                  (dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) )
             {
-                 rc = mss_mrep_training(i_target, port);
-                 if(rc) return rc;
-                 rc = mss_mxd_training(i_target,port,0);
-                 if(rc) return rc;
+	       FAPI_INF("\n\n --- Starting LRDIMM MREP Training \n\n\n\n\n\n\n\n\n");
+               rc = mss_mrep_training(i_target, port);
+	       if(rc) return rc;
+	       
+	       FAPI_INF("\n\n --- Starting LRDIMM MDQ  READ Coarse Training \n\n\n\n\n\n\n\n\n");
+	       rc = mss_mxd_training(i_target,port,0x00);  // READ Coarse
+	       if(rc) return rc;
+	       
+	       FAPI_INF("\n\n --- Starting LRDIMM MDQ  READ Normal Training \n\n\n\n\n\n\n\n\n");
+	       rc = mss_mxd_training(i_target,port,0x01);  // READ Normal
+	       if(rc) return rc;
+	       
+		 
             }
-        }
+	}
     }
 
     for(port = 0; port < MAX_NUM_PORT; port++)
     {
 
-        for(group = 0; group < MAX_NUM_GROUP; group++)
-        {
+	for(group = 0; group < MAX_NUM_GROUP; group++)
+	{
 
-            //Check if rank group exists
-            if(primary_ranks_array[group][port] != INVALID)
-            {
+	    //Check if rank group exists
+	    if(primary_ranks_array[group][port] != INVALID)
+	    {
 
-                //Set up for Init Cal - Done per port pair
-                rc_num = rc_num | test_buffer_4.setBit(0, 2); //Init Cal test = 11XX
-                rc_num = rc_num | wen_buffer_1.flushTo1(); //Init Cal ras/cas/we = 1/1/1
-                rc_num = rc_num | casn_buffer_1.flushTo1();
-                rc_num = rc_num | rasn_buffer_1.flushTo1();
-                rc_num = rc_num | ddr_cal_enable_buffer_1.flushTo1(); //Init cal
+	        //Set up for Init Cal - Done per port pair
+		rc_num = rc_num | test_buffer_4.setBit(0, 2); //Init Cal test = 11XX
+		rc_num = rc_num | wen_buffer_1.flushTo1(); //Init Cal ras/cas/we = 1/1/1
+		rc_num = rc_num | casn_buffer_1.flushTo1();
+		rc_num = rc_num | rasn_buffer_1.flushTo1();
+		rc_num = rc_num | ddr_cal_enable_buffer_1.flushTo1(); //Init cal
 
-                FAPI_INF( "+++ Setting up Init Cal on %s Port: %d rank group: %d cal_steps: 0x%02X +++", i_target.toEcmdString(), port, group, cal_steps);
+		FAPI_INF( "+++ Setting up Init Cal on %s Port: %d rank group: %d cal_steps: 0x%02X +++", i_target.toEcmdString(), port, group, cal_steps);
 
-                for(cur_cal_step = 1; cur_cal_step < MAX_CAL_STEPS; cur_cal_step++) //Cycle through all possible cal steps
-                {
+		for(cur_cal_step = 1; cur_cal_step < MAX_CAL_STEPS; cur_cal_step++) //Cycle through all possible cal steps
+		{
                     //DQS alignment workaround
                     max_cal_retry = 0;
 
-                    //Clearing any status or errors bits that may have occured in previous training subtest.
-                    if(port == 0)
-                    {
-                        //clear status reg
-                        rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_STATUS_P0_0x8000C0190301143F, data_buffer_64);
-                        if(rc) return rc;
-                        rc_num = rc_num | data_buffer_64.clearBit(48, 4);
-                        rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_STATUS_P0_0x8000C0190301143F, data_buffer_64);
-                        if(rc) return rc;
-
-                        //clear error reg
-                        rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_ERROR_P0_0x8000C0180301143F, data_buffer_64);
-                        if(rc) return rc;
-                        rc_num = rc_num | data_buffer_64.clearBit(48, 11);
-                        rc_num = rc_num | data_buffer_64.clearBit(60, 4);
-                        rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_ERROR_P0_0x8000C0180301143F, data_buffer_64);
-                        if(rc) return rc;
+		    //Clearing any status or errors bits that may have occured in previous training subtest.
+		    if(port == 0)
+		    {
+			//clear status reg
+			rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_STATUS_P0_0x8000C0190301143F, data_buffer_64);
+			if(rc) return rc;
+			rc_num = rc_num | data_buffer_64.clearBit(48, 4);
+			rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_STATUS_P0_0x8000C0190301143F, data_buffer_64);
+			if(rc) return rc;
+
+			//clear error reg
+			rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_ERROR_P0_0x8000C0180301143F, data_buffer_64);
+			if(rc) return rc;
+			rc_num = rc_num | data_buffer_64.clearBit(48, 11);
+			rc_num = rc_num | data_buffer_64.clearBit(60, 4);
+			rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_ERROR_P0_0x8000C0180301143F, data_buffer_64);
+			if(rc) return rc;
 
                         //clear other port
-                        rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P1_0x8001C0160301143F, data_buffer_64);
-                        if(rc) return rc;
-                        rc_num = rc_num | data_buffer_64.clearBit(48);
-                        rc_num = rc_num | data_buffer_64.clearBit(50);
-                        rc_num = rc_num | data_buffer_64.clearBit(51);
-                        rc_num = rc_num | data_buffer_64.clearBit(52);
-                        rc_num = rc_num | data_buffer_64.clearBit(53);
-                        rc_num = rc_num | data_buffer_64.clearBit(54);
-                        rc_num = rc_num | data_buffer_64.clearBit(55);
-                        rc_num = rc_num | data_buffer_64.clearBit(58);
-                        rc_num = rc_num | data_buffer_64.clearBit(60);
-                        rc_num = rc_num | data_buffer_64.clearBit(61);
-                        rc_num = rc_num | data_buffer_64.clearBit(62);
-                        rc_num = rc_num | data_buffer_64.clearBit(63);
-                        rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P1_0x8001C0160301143F, data_buffer_64);
-                        if(rc) return rc;
-
-                        //Setup the Config Reg bit for the only cal step we want
-                        rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P0_0x8000C0160301143F, data_buffer_64);
-                        if(rc) return rc;
-
-                    }
-                    else
-                    {
-                        //clear status reg
-                        rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_STATUS_P1_0x8001C0190301143F, data_buffer_64);
-                        if(rc) return rc;
-                        rc_num = rc_num | data_buffer_64.clearBit(48, 4);
-                        rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_STATUS_P1_0x8001C0190301143F, data_buffer_64);
-                        if(rc) return rc;
-
-                        //clear error reg
-                        rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_ERROR_P1_0x8001C0180301143F, data_buffer_64);
-                        if(rc) return rc;
-                        rc_num = rc_num | data_buffer_64.clearBit(48, 11);
-                        rc_num = rc_num | data_buffer_64.clearBit(60, 4);
-                        rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_ERROR_P1_0x8001C0180301143F, data_buffer_64);
-                        if(rc) return rc;
+			rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P1_0x8001C0160301143F, data_buffer_64);
+			if(rc) return rc;
+			rc_num = rc_num | data_buffer_64.clearBit(48);
+			rc_num = rc_num | data_buffer_64.clearBit(50);
+			rc_num = rc_num | data_buffer_64.clearBit(51);
+			rc_num = rc_num | data_buffer_64.clearBit(52);
+			rc_num = rc_num | data_buffer_64.clearBit(53);
+			rc_num = rc_num | data_buffer_64.clearBit(54);
+			rc_num = rc_num | data_buffer_64.clearBit(55);
+			rc_num = rc_num | data_buffer_64.clearBit(58);
+			rc_num = rc_num | data_buffer_64.clearBit(60);
+			rc_num = rc_num | data_buffer_64.clearBit(61);
+			rc_num = rc_num | data_buffer_64.clearBit(62);
+			rc_num = rc_num | data_buffer_64.clearBit(63);
+			rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P1_0x8001C0160301143F, data_buffer_64);
+			if(rc) return rc;
+
+		        //Setup the Config Reg bit for the only cal step we want
+			rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P0_0x8000C0160301143F, data_buffer_64);
+			if(rc) return rc;
+
+		    }
+		    else
+		    {
+			//clear status reg
+			rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_STATUS_P1_0x8001C0190301143F, data_buffer_64);
+			if(rc) return rc;
+			rc_num = rc_num | data_buffer_64.clearBit(48, 4);
+			rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_STATUS_P1_0x8001C0190301143F, data_buffer_64);
+			if(rc) return rc;
+
+			//clear error reg
+			rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_ERROR_P1_0x8001C0180301143F, data_buffer_64);
+			if(rc) return rc;
+			rc_num = rc_num | data_buffer_64.clearBit(48, 11);
+			rc_num = rc_num | data_buffer_64.clearBit(60, 4);
+			rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_ERROR_P1_0x8001C0180301143F, data_buffer_64);
+			if(rc) return rc;
 
                         //clear other port
-                        rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P0_0x8000C0160301143F, data_buffer_64);
-                        if(rc) return rc;
-                        rc_num = rc_num | data_buffer_64.clearBit(48);
-                        rc_num = rc_num | data_buffer_64.clearBit(50);
-                        rc_num = rc_num | data_buffer_64.clearBit(51);
-                        rc_num = rc_num | data_buffer_64.clearBit(52);
-                        rc_num = rc_num | data_buffer_64.clearBit(53);
-                        rc_num = rc_num | data_buffer_64.clearBit(54);
-                        rc_num = rc_num | data_buffer_64.clearBit(55);
-                        rc_num = rc_num | data_buffer_64.clearBit(58);
-                        rc_num = rc_num | data_buffer_64.clearBit(60);
-                        rc_num = rc_num | data_buffer_64.clearBit(61);
-                        rc_num = rc_num | data_buffer_64.clearBit(62);
-                        rc_num = rc_num | data_buffer_64.clearBit(63);
-                        rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P0_0x8000C0160301143F, data_buffer_64);
-                        if(rc) return rc;
-
-                        //Setup the Config Reg bit for the only cal step we want
-                        rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P1_0x8001C0160301143F, data_buffer_64);
-                        if(rc) return rc;
-
-                    }
-
-                    //Clear training cnfg
-                    rc_num = rc_num | data_buffer_64.clearBit(48);
-                    rc_num = rc_num | data_buffer_64.clearBit(50);
-                    rc_num = rc_num | data_buffer_64.clearBit(51);
-                    rc_num = rc_num | data_buffer_64.clearBit(52);
-                    rc_num = rc_num | data_buffer_64.clearBit(53);
-                    rc_num = rc_num | data_buffer_64.clearBit(54);
-                    rc_num = rc_num | data_buffer_64.clearBit(55);
-                    rc_num = rc_num | data_buffer_64.clearBit(60);
-                    rc_num = rc_num | data_buffer_64.clearBit(61);
-                    rc_num = rc_num | data_buffer_64.clearBit(62);
-                    rc_num = rc_num | data_buffer_64.clearBit(63);
-
-                    //Set stop on error
-                    rc_num = rc_num | data_buffer_64.setBit(58);
-
-                    //cnfg rank groups
-                    if(group == 0){
-                        rc_num = rc_num | data_buffer_64.setBit(60);
-                    }
-                    else if(group == 1){
-                        rc_num = rc_num | data_buffer_64.setBit(61);
-                    }
-                    else if(group == 2){
-                        rc_num = rc_num | data_buffer_64.setBit(62);
-                    }
-                    else if(group == 3){
-                        rc_num = rc_num | data_buffer_64.setBit(63);
-                    }
-
-                    if ( (cur_cal_step == 1) && (cal_steps_8.isBitClear(0)) && (cal_steps_8.isBitClear(1)) &&
-                         (cal_steps_8.isBitClear(2)) && (cal_steps_8.isBitClear(3)) &&
-                         (cal_steps_8.isBitClear(4)) && (cal_steps_8.isBitClear(5)) &&
-                         (cal_steps_8.isBitClear(6)) && (cal_steps_8.isBitClear(7)) )
-                    {
-                        FAPI_INF( "+++ Executing ALL Cal Steps at the same time on %s Port: %d rank group: %d +++", i_target.toEcmdString(), port, group);
-                        rc_num = rc_num | data_buffer_64.setBit(48);
-                        rc_num = rc_num | data_buffer_64.setBit(50);
-                        rc_num = rc_num | data_buffer_64.setBit(51);
-                        rc_num = rc_num | data_buffer_64.setBit(52);
-                        rc_num = rc_num | data_buffer_64.setBit(53);
-                        rc_num = rc_num | data_buffer_64.setBit(54);
-                        rc_num = rc_num | data_buffer_64.setBit(55);
-                    }
-                    else if ( (cur_cal_step == 1) && (cal_steps_8.isBitSet(1)) )
-                    {
-                        FAPI_INF( "+++ Write Leveling (WR_LVL) on %s Port %d rank group: %d +++", i_target.toEcmdString(), port, group);
-                        rc_num = rc_num | data_buffer_64.setBit(48);
-                    }
-                    else if ( (cur_cal_step == 2) && (cal_steps_8.isBitSet(2)) )
-                    {
+			rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P0_0x8000C0160301143F, data_buffer_64);
+			if(rc) return rc;
+			rc_num = rc_num | data_buffer_64.clearBit(48);
+			rc_num = rc_num | data_buffer_64.clearBit(50);
+			rc_num = rc_num | data_buffer_64.clearBit(51);
+			rc_num = rc_num | data_buffer_64.clearBit(52);
+			rc_num = rc_num | data_buffer_64.clearBit(53);
+			rc_num = rc_num | data_buffer_64.clearBit(54);
+			rc_num = rc_num | data_buffer_64.clearBit(55);
+			rc_num = rc_num | data_buffer_64.clearBit(58);
+			rc_num = rc_num | data_buffer_64.clearBit(60);
+			rc_num = rc_num | data_buffer_64.clearBit(61);
+			rc_num = rc_num | data_buffer_64.clearBit(62);
+			rc_num = rc_num | data_buffer_64.clearBit(63);
+			rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P0_0x8000C0160301143F, data_buffer_64);
+			if(rc) return rc;
+
+		        //Setup the Config Reg bit for the only cal step we want
+			rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P1_0x8001C0160301143F, data_buffer_64);
+			if(rc) return rc;
+
+		    }
+
+		    //Clear training cnfg
+		    rc_num = rc_num | data_buffer_64.clearBit(48);
+		    rc_num = rc_num | data_buffer_64.clearBit(50);
+		    rc_num = rc_num | data_buffer_64.clearBit(51);
+		    rc_num = rc_num | data_buffer_64.clearBit(52);
+		    rc_num = rc_num | data_buffer_64.clearBit(53);
+		    rc_num = rc_num | data_buffer_64.clearBit(54);
+		    rc_num = rc_num | data_buffer_64.clearBit(55);
+		    rc_num = rc_num | data_buffer_64.clearBit(60);
+		    rc_num = rc_num | data_buffer_64.clearBit(61);
+		    rc_num = rc_num | data_buffer_64.clearBit(62);
+		    rc_num = rc_num | data_buffer_64.clearBit(63);
+
+		    //Set stop on error
+		    rc_num = rc_num | data_buffer_64.setBit(58);
+
+		    //cnfg rank groups
+		    if(group == 0){
+			rc_num = rc_num | data_buffer_64.setBit(60);
+		    }
+		    else if(group == 1){
+			rc_num = rc_num | data_buffer_64.setBit(61);
+		    }
+		    else if(group == 2){
+			rc_num = rc_num | data_buffer_64.setBit(62);
+		    }
+		    else if(group == 3){
+			rc_num = rc_num | data_buffer_64.setBit(63);
+		    }
+
+		    if ( (cur_cal_step == 1) && (cal_steps_8.isBitClear(0)) && (cal_steps_8.isBitClear(1)) &&
+			 (cal_steps_8.isBitClear(2)) && (cal_steps_8.isBitClear(3)) &&
+			 (cal_steps_8.isBitClear(4)) && (cal_steps_8.isBitClear(5)) &&
+			 (cal_steps_8.isBitClear(6)) && (cal_steps_8.isBitClear(7)) )
+		    {
+			FAPI_INF( "+++ Executing ALL Cal Steps at the same time on %s Port: %d rank group: %d +++", i_target.toEcmdString(), port, group);
+			rc_num = rc_num | data_buffer_64.setBit(48);
+			rc_num = rc_num | data_buffer_64.setBit(50);
+			rc_num = rc_num | data_buffer_64.setBit(51);
+			rc_num = rc_num | data_buffer_64.setBit(52);
+			rc_num = rc_num | data_buffer_64.setBit(53);
+			rc_num = rc_num | data_buffer_64.setBit(54);
+			rc_num = rc_num | data_buffer_64.setBit(55);
+                        if ( (dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR4) && (dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) )
+                        {
+			   FAPI_ERR("DDR4 LRDIMM training must be run individually to allow FW changes between HW training steps");
+			}
+
+		    }
+		    else if ( (cur_cal_step == 1) && (cal_steps_8.isBitSet(1)) )
+		    {
+			FAPI_INF( "+++ Write Leveling (WR_LVL) on %s Port %d rank group: %d +++", i_target.toEcmdString(), port, group);
+			rc_num = rc_num | data_buffer_64.setBit(48);
+		    }
+		    else if ( (cur_cal_step == 2) && (cal_steps_8.isBitSet(2)) )
+		    {
                         max_cal_retry = 0;
                         dqs_try = dqs_retry_num + 1;
                         FAPI_INF( "+++ DQS Align (DQS_ALIGN) attempt %d on %s Port: %d rank group: %d +++", dqs_try,i_target.toEcmdString(), port, group);
@@ -752,172 +814,258 @@ ReturnCode mss_draminit_training_cloned(Target& i_target)
 
                         }
                         rc_num = rc_num | data_buffer_64.setBit(50);
-                    }
-                    else if ( (cur_cal_step == 3) && (cal_steps_8.isBitSet(3)) )
-                    {
-                        FAPI_INF( "+++ RD CLK Align (RDCLK_ALIGN) on %s Port: %d rank group: %d +++", i_target.toEcmdString(), port, group);
-                        rc_num = rc_num | data_buffer_64.setBit(51);
-                    }
-                    else if ( (cur_cal_step == 4) && (cal_steps_8.isBitSet(4)) )
-                    {
-                        FAPI_INF( "+++ Read Centering (READ_CTR) on %s Port: %d rank group: %d +++", i_target.toEcmdString(), port, group);
-                        rc_num = rc_num | data_buffer_64.setBit(52);
-                    }
-                    else if ( (cur_cal_step == 5) && (cal_steps_8.isBitSet(5)) )
-                    {
-                        FAPI_INF( "+++ Write Centering (WRITE_CTR) on %s Port: %d rank group: %d +++", i_target.toEcmdString(), port, group);
-                        rc_num = rc_num | data_buffer_64.setBit(53);
-                    }
-                    else if ( (cur_cal_step == 6) && (cal_steps_8.isBitSet(6)) && (cal_steps_8.isBitClear(7)) )
-                    {
-                        FAPI_INF( "+++ Initial Course Write (COURSE_WR) on %s Port: %d rank group: %d +++", i_target.toEcmdString(), port, group);
-                        rc_num = rc_num | data_buffer_64.setBit(54);
-                    }
-                    else if ( (cur_cal_step == 6) && (cal_steps_8.isBitClear(6)) && (cal_steps_8.isBitSet(7)) )
-                    {
-                        FAPI_INF( "+++ Course Read (COURSE_RD) on %s Port: %d rank group: %d +++", i_target.toEcmdString(), port, group);
-                        rc_num = rc_num | data_buffer_64.setBit(55);
-                    }
-                    else if ( (cur_cal_step == 6) && (cal_steps_8.isBitSet(6)) && (cal_steps_8.isBitSet(7)) )
-                    {
-                        FAPI_INF( "+++ Initial Course Write (COURSE_WR) and Course Read (COURSE_RD) simultaneously on %s Port: %d rank group: %d +++", i_target.toEcmdString(), port, group);
-                        rc_num = rc_num | data_buffer_64.setBit(54);
-                        rc_num = rc_num | data_buffer_64.setBit(55);
-                    }
-
-                    if(rc_num)
-                    {
-                        rc.setEcmdError(rc_num);
-                        return rc;
-                    }
-
-                    if ( !( data_buffer_64.isBitClear(48, 8) ) ) // Only execute if we are doing a Cal Step
-                    {
-
-                        // Before WR_LVL --- Change the RTT_NOM to RTT_WR pre-WR_LVL
-                        if ( (cur_cal_step == 1) && (dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR3))
-                        {
+		    }
+		    else if ( (cur_cal_step == 3) && (cal_steps_8.isBitSet(3)) )
+		    {
+			FAPI_INF( "+++ RD CLK Align (RDCLK_ALIGN) on %s Port: %d rank group: %d +++", i_target.toEcmdString(), port, group);
+			rc_num = rc_num | data_buffer_64.setBit(51);
+		    }
+		    else if ( (cur_cal_step == 4) && (cal_steps_8.isBitSet(4)) )
+		    {
+			FAPI_INF( "+++ Read Centering (READ_CTR) on %s Port: %d rank group: %d +++", i_target.toEcmdString(), port, group);
+			rc_num = rc_num | data_buffer_64.setBit(52);
+		    }
+		    else if ( (cur_cal_step == 5) && (cal_steps_8.isBitSet(5)) )
+		    {
+			FAPI_INF( "+++ Write Centering (WRITE_CTR) on %s Port: %d rank group: %d +++", i_target.toEcmdString(), port, group);
+			rc_num = rc_num | data_buffer_64.setBit(53);
+		    }
+		    else if ( (cur_cal_step == 6) && (cal_steps_8.isBitSet(6)) && (cal_steps_8.isBitClear(7)) )
+		    {
+			FAPI_INF( "+++ Initial Course Write (COURSE_WR) on %s Port: %d rank group: %d +++", i_target.toEcmdString(), port, group);
+			rc_num = rc_num | data_buffer_64.setBit(54);
+		    }
+		    else if ( (cur_cal_step == 6) && (cal_steps_8.isBitClear(6)) && (cal_steps_8.isBitSet(7)) )
+		    {
+			FAPI_INF( "+++ Course Read (COURSE_RD) on %s Port: %d rank group: %d +++", i_target.toEcmdString(), port, group);
+			rc_num = rc_num | data_buffer_64.setBit(55);
+		    }
+		    else if ( (cur_cal_step == 6) && (cal_steps_8.isBitSet(6)) && (cal_steps_8.isBitSet(7)) )
+		    {
+			FAPI_INF( "+++ Initial Course Write (COURSE_WR) and Course Read (COURSE_RD) simultaneously on %s Port: %d rank group: %d +++", i_target.toEcmdString(), port, group);
+			rc_num = rc_num | data_buffer_64.setBit(54);
+			rc_num = rc_num | data_buffer_64.setBit(55);
+		    }
+
+		    if(rc_num)
+		    {
+			rc.setEcmdError(rc_num);
+			return rc;
+		    }
+
+		    if ( !( data_buffer_64.isBitClear(48, 8) ) ) // Only execute if we are doing a Cal Step
+		    {
+
+		        // Before WR_LVL --- Change the RTT_NOM to RTT_WR pre-WR_LVL
+			if ( (cur_cal_step == 1) && (dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR3))
+			{
                             if ( dimm_type != fapi::ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM )
                             {
 
-                               dram_rtt_nom_original = 0xFF;
-                               rc = mss_rtt_nom_rtt_wr_swap(i_target,
-                                                         mbaPosition,
-                                                         port,
-                                                         primary_ranks_array[group][port],
-                                                         group,
-                                                         instruction_number,
-                                                         dram_rtt_nom_original);
-                               if(rc) return rc;
+			       dram_rtt_nom_original = 0xFF;
+			       rc = mss_rtt_nom_rtt_wr_swap(i_target,
+			           			 mbaPosition,
+			           			 port,
+			           			 primary_ranks_array[group][port],
+			           			 group,
+			           			 instruction_number,
+			           			 dram_rtt_nom_original);
+			       if(rc) return rc;
                             }
-                        }
+			}
+			//DDR4 RDIMM, do the swap of the RTT_WR to RTT_NOM
+			/*if ( (cur_cal_step == 1) && (dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR4) && dimm_type != fapi::ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM)
+			{
+
+			   dram_rtt_nom_original = 0xFF;
+			   FAPI_ERR("SWAPPING RTT_WR VALUE INTO RTT_NOM!!!!!");
+			   rc = mss_ddr4_rtt_nom_rtt_wr_swap(i_target,
+			   			     mbaPosition,
+			   			     port,
+			   			     primary_ranks_array[group][port],
+			   			     group,
+			   			     instruction_number,
+			   			     dram_rtt_nom_original);
+                           if(rc) return rc;
+			   FAPI_ERR("SWAPPING RTT_WR VALUE INTO RTT_NOM!!!!!");
+			}
                         // Should only be called for DDR4 LRDIMMs, training code is in development. Does not effect any other configs
-                        else if ( (group == 0) && (cur_cal_step == 1)
+                        else */
+			if ( (group == 0) && (cur_cal_step == 1)
                                   && (dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR4)
                                   && (dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) )
                         {
-                           rc = mss_dram_write_leveling(i_target, port);
+			   FAPI_INF("\n\n --- Starting DB to Dram Write leveling \n\n\n\n\n\n\n\n\n");
+                           rc = mss_dram_write_leveling(i_target, port);			   
                            if(rc) return rc;
+			   
+			   FAPI_INF("\n\n --- Starting Write Coarse \n\n\n\n\n\n\n\n\n");
+                           rc = mss_mxd_training(i_target, port, 0x80); // Write Coarse
+                           if(rc) return rc;
+			   
+			   FAPI_INF("\n\n --- Starting Write Normal \n\n\n\n\n\n\n\n\n");
+                           rc = mss_mxd_training(i_target, port, 0x81); // Write Normal
+                           if(rc) return rc;
+			   
+			   //
+                           
+			   FAPI_INF("\n\n --- Starting Put DB in Host Interface Write Leveling (HWL) mode\n");
+                           rc = mss_hwl_training_enable(i_target, port); // Host Interface Write Leveling
+                           if(rc) return rc;
+                           
                         }
-
-                        //Set the config register
-                        if(port == 0)
-                        {
-                            rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P0_0x8000C0160301143F, data_buffer_64);
-                            if(rc) return rc;
-                        }
-                        else
+                        else if ( (group == 0) && (cur_cal_step == 2)
+                                  && (dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR4)
+                                  && (dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) )
                         {
-                            rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P1_0x8001C0160301143F, data_buffer_64);
-                            if(rc) return rc;
-                        }
-
-                        rc = mss_ccs_inst_arry_0(i_target,
-                                                 instruction_number,
-                                                 address_buffer_16,
-                                                 bank_buffer_8,
-                                                 activate_buffer_1,
-                                                 rasn_buffer_1,
-                                                 casn_buffer_1,
-                                                 wen_buffer_1,
-                                                 cke_buffer_8,
-                                                 csn_buffer_8,
-                                                 odt_buffer_8,
-                                                 test_buffer_4,
-                                                 port);
-
-                        if(rc) return rc; //Error handling for mss_ccs_inst built into mss_funcs
-
-                        FAPI_INF( "primary_ranks_array[%d][0]: %d [%d][1]: %d", group, primary_ranks_array[group][0], group, primary_ranks_array[group][1]);
 
-
-                        rc_num = rc_num | rank_cal_buffer_4.insert(primary_ranks_array[group][port], 0, 4, 4); // 8 bit storage, need last 4 bits
-                        if(rc_num)
-                        {
-                                rc.setEcmdError(rc_num);
-                                return rc;
+			   FAPI_INF("\n\n take the DB out of Host Interface Write Leveling (HWL) mode\n");
+                           rc = mss_hwl_training_disable(i_target, port); // disable Host Interface Write Leveling
+                           if(rc) return rc;
+			   
+                           
+                           
+			   FAPI_INF("\n\n Put a custom MPR pattern DB \n");
+                           rc = mss_custom_DB_MPR_pattern(i_target, port); 
+                           if(rc) return rc;
+			   
+			   FAPI_INF("\n\n Put the DB into Host Interface to Data Buffer read training  (DB MPR)\n");
+                           rc = mss_hostside_read_training_enable(i_target, port); // enable Host Interface to Data Buffer read training
+                           if(rc) return rc;
+			   
+			   
+			   
                         }
-
-                        rc = mss_ccs_inst_arry_1(i_target,
-                                                 instruction_number,
-                                                 num_idles_buffer_16,
-                                                 num_repeat_buffer_16,
-                                                 data_buffer_20,
-                                                 read_compare_buffer_1,
-                                                 rank_cal_buffer_4,
-                                                 ddr_cal_enable_buffer_1,
-                                                 ccs_end_buffer_1);
-
-                        if(rc) return rc; //Error handling for mss_ccs_inst built into mss_funcs
-
-
-                        rc = mss_execute_ccs_inst_array( i_target, NUM_POLL, 60);
-                        if(rc) return rc; //Error handling for mss_ccs_inst built into mss_funcs
-
-                        //Check to see if the training completes
-                        rc = mss_check_cal_status(i_target, mbaPosition, port, group, cur_complete_status);
-                        if(rc) return rc;
-
-                        if (cur_complete_status == MSS_INIT_CAL_STALL)
+                        else if ( (group == 0) && (cur_cal_step == 5)
+                                  && (dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR4)
+                                  && (dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) )
                         {
-                            complete_status = cur_complete_status;
+
+			   
+			   FAPI_INF("\n\n Take DB out of Host Interface to Data Buffer read training  (DB MPR)\n");
+                           rc = mss_hostside_read_training_disable(i_target, port); // disable Host Interface to Data Buffer read training
+                           if(rc) return rc;
+			   			   
+			   
                         }
 
-                        //Check to see if the training errored out
+		        //Set the config register
+			if(port == 0)
+			{
+			    rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P0_0x8000C0160301143F, data_buffer_64);
+			    if(rc) return rc;
+			}
+			else
+			{
+			    rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P1_0x8001C0160301143F, data_buffer_64);
+			    if(rc) return rc;
+			}
+
+			rc = mss_ccs_inst_arry_0(i_target,
+						 instruction_number,
+						 address_buffer_16,
+						 bank_buffer_8,
+						 activate_buffer_1,
+						 rasn_buffer_1,
+						 casn_buffer_1,
+						 wen_buffer_1,
+						 cke_buffer_8,
+						 csn_buffer_8,
+						 odt_buffer_8,
+						 test_buffer_4,
+						 port);
+
+			if(rc) return rc; //Error handling for mss_ccs_inst built into mss_funcs
+
+			FAPI_INF( "primary_ranks_array[%d][0]: %d [%d][1]: %d", group, primary_ranks_array[group][0], group, primary_ranks_array[group][1]);
+
+
+			rc_num = rc_num | rank_cal_buffer_4.insert(primary_ranks_array[group][port], 0, 4, 4); // 8 bit storage, need last 4 bits
+			if(rc_num)
+			{
+				rc.setEcmdError(rc_num);
+				return rc;
+			}
+
+			rc = mss_ccs_inst_arry_1(i_target,
+						 instruction_number,
+						 num_idles_buffer_16,
+						 num_repeat_buffer_16,
+						 data_buffer_20,
+						 read_compare_buffer_1,
+						 rank_cal_buffer_4,
+						 ddr_cal_enable_buffer_1,
+						 ccs_end_buffer_1);
+
+			if(rc) return rc; //Error handling for mss_ccs_inst built into mss_funcs
+
+
+			rc = mss_execute_ccs_inst_array( i_target, NUM_POLL, 60);
+			if(rc) return rc; //Error handling for mss_ccs_inst built into mss_funcs
+
+			//Check to see if the training completes
+			rc = mss_check_cal_status(i_target, mbaPosition, port, group, cur_complete_status);
+			if(rc) return rc;
+
+			if (cur_complete_status == MSS_INIT_CAL_STALL)
+			{
+			    complete_status = cur_complete_status;
+			}
+
+			//Check to see if the training errored out
                         rc = mss_check_error_status(i_target, mbaPosition, port, group, cur_cal_step, cur_error_status, max_cal_retry);
-                        if(rc) return rc;
-
-                        if (cur_error_status == MSS_INIT_CAL_FAIL)
-                        {
-                            error_status = cur_error_status;
+			if(rc) return rc;
 
-                        }
+			if (cur_error_status == MSS_INIT_CAL_FAIL)
+			{
+			    error_status = cur_error_status;
+                            
+			}
 
-                        // Following WR_LVL -- Restore RTT_NOM to orignal value post-wr_lvl
-                        if ((cur_cal_step == 1) && (dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR3))
-                        {
+			// Following WR_LVL -- Restore RTT_NOM to orignal value post-wr_lvl
+			if ((cur_cal_step == 1) && (dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR3))
+			{
                             if ( dimm_type != fapi::ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM )
                             {
 
-                               rc = mss_rtt_nom_rtt_wr_swap(i_target,
-                                                         mbaPosition,
-                                                         port,
-                                                         primary_ranks_array[group][port],
-                                                         group,
-                                                         instruction_number,
-                                                         dram_rtt_nom_original);
-                               if(rc) return rc;
+			       rc = mss_rtt_nom_rtt_wr_swap(i_target,
+			           			 mbaPosition,
+			           			 port,
+			           			 primary_ranks_array[group][port],
+			           			 group,
+			           			 instruction_number,
+			           			 dram_rtt_nom_original);
+			       if(rc) return rc;
                             }
-                        }
-
-                        // Following Read Centering -- Enter into READ CENTERING WORKAROUND
-                        if  ( (cur_cal_step == 4) &&
-                            ( waterfall_broken == fapi::ENUM_ATTR_MSS_BLUEWATERFALL_BROKEN_TRUE  ) )
-                        {
-                                rc = mss_read_center_workaround(i_target, mbaPosition, port, group);
-                                if(rc) return rc;
-                        }
+			}
+			
+			// Following WR_LVL -- Restore RTT_NOM to orignal value post-wr_lvl
+			/*if ((cur_cal_step == 1) && (dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR4))
+			{
+                            if ( dimm_type != fapi::ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM )
+                            {
 
+			        FAPI_ERR("SWAPPING RTT_WR VALUE OUT OF RTT_NOM!!!!!");
+			       rc = mss_ddr4_rtt_nom_rtt_wr_swap(i_target,
+			           			 mbaPosition,
+			           			 port,
+			           			 primary_ranks_array[group][port],
+			           			 group,
+			           			 instruction_number,
+			           			 dram_rtt_nom_original);
+							 FAPI_ERR("SWAPPING RTT_WR VALUE OUT OF RTT_NOM!!!!!");
+			       if(rc) return rc;
+                            }
+			}*/
+
+			// Following Read Centering -- Enter into READ CENTERING WORKAROUND
+			if  ( (cur_cal_step == 4) &&
+			    ( waterfall_broken == fapi::ENUM_ATTR_MSS_BLUEWATERFALL_BROKEN_TRUE  ) )
+			{
+				rc = mss_read_center_workaround(i_target, mbaPosition, port, group);
+      		                if(rc) return rc;
+			}
+                                                
                         // DQS Alignment workaround
                         if (cur_cal_step == 2)
                         {
@@ -957,69 +1105,69 @@ ReturnCode mss_draminit_training_cloned(Target& i_target)
                         }
 
 
-                    }
-                }//end of step loop
-            }
-        }//end of group loop
+		    }
+		}//end of step loop
+	    }
+	}//end of group loop
     }//end of port loop
 
     // Make sure the DQS_CLK values of each byte have matching nibble values, using the lowest
     if ( waterfall_broken == fapi::ENUM_ATTR_MSS_BLUEWATERFALL_BROKEN_TRUE )
     {
-                rc = mss_read_center_second_workaround(i_target);
-                if(rc) return rc;
+		rc = mss_read_center_second_workaround(i_target);
+		if(rc) return rc;
     }
 
     if ((error_status != MSS_INIT_CAL_FAIL) && (error_status != MSS_INIT_CAL_STALL))
     {
-        training_success = 0xFF;
+	training_success = 0xFF; 
     }
 
     rc = mss_get_bbm_regs(i_target, training_success);
     if(rc)
     {
-        FAPI_ERR( "Error Moving bad bit information from the Phy regs. Exiting.");
-        return rc;
+	FAPI_ERR( "Error Moving bad bit information from the Phy regs. Exiting.");
+	return rc;
     }
 
     //Executes if we do "all at once" or on the last cal steps
     //Must be a successful run.
-    if (error_status == MSS_INIT_CAL_PASS &&
-        ((cal_steps_8.isBitSet(6) && cal_steps_8.isBitSet(7)) ||
-         (cal_steps_8.isBitClear(0) && cal_steps_8.isBitClear(1) &&
-          cal_steps_8.isBitClear(2) && cal_steps_8.isBitClear(3) &&
-          cal_steps_8.isBitClear(4) && cal_steps_8.isBitClear(5) &&
-          cal_steps_8.isBitClear(6) && cal_steps_8.isBitClear(7) ) ) )
+    if (error_status == MSS_INIT_CAL_PASS && 
+	((cal_steps_8.isBitSet(6) && cal_steps_8.isBitSet(7)) ||
+	 (cal_steps_8.isBitClear(0) && cal_steps_8.isBitClear(1) &&
+	  cal_steps_8.isBitClear(2) && cal_steps_8.isBitClear(3) &&
+	  cal_steps_8.isBitClear(4) && cal_steps_8.isBitClear(5) &&
+	  cal_steps_8.isBitClear(6) && cal_steps_8.isBitClear(7) ) ) )
     {
 
-        FAPI_INF( "WR LVL DISABLE WORKAROUND: Running wr_lvl workaround on %s", i_target.toEcmdString());
-        rc = mss_wr_lvl_disable_workaround(i_target);
-        if(rc) return rc;
+	FAPI_INF( "WR LVL DISABLE WORKAROUND: Running wr_lvl workaround on %s", i_target.toEcmdString());
+    	rc = mss_wr_lvl_disable_workaround(i_target);
+      	if(rc) return rc;
     }
 
 
-    // If we hit either of these States, the error callout originates from Mike Jones Bad Bit code.
+    // If we hit either of these States, the error callout originates from Mike Jones Bad Bit code. 
     if (complete_status == MSS_INIT_CAL_STALL)
     {
-        FAPI_ERR( "+++ Partial/Full calibration stall. Check Debug trace. +++");
+	FAPI_ERR( "+++ Partial/Full calibration stall. Check Debug trace. +++");
     }
     else if (error_status == MSS_INIT_CAL_FAIL)
     {
-        FAPI_ERR( "+++ Partial/Full calibration fail. Check Debug trace. +++");
+	FAPI_ERR( "+++ Partial/Full calibration fail. Check Debug trace. +++");
     }
     else
     {
-        FAPI_INF( "+++ Full calibration successful. +++");
+	FAPI_INF( "+++ Full calibration successful. +++");
     }
 
     return rc;
 }
 
 ReturnCode mss_check_cal_status( Target& i_target,
-                                 uint8_t i_mbaPosition,
+				 uint8_t i_mbaPosition,
                                  uint8_t i_port,
                                  uint8_t i_group,
-                                 mss_draminit_training_result& io_status
+				 mss_draminit_training_result& io_status
                                )
 {
     ecmdDataBufferBase cal_status_buffer_64(64);
@@ -1063,13 +1211,13 @@ ReturnCode mss_check_cal_status( Target& i_target,
 
     if(cal_status_buffer_64.isBitSet(cal_status_reg_offset))
     {
-        FAPI_INF( "+++ Calibration on %s port: %d rank group: %d finished. +++", i_target.toEcmdString(), i_port, i_group);
-        io_status = MSS_INIT_CAL_COMPLETE;
+	FAPI_INF( "+++ Calibration on %s port: %d rank group: %d finished. +++", i_target.toEcmdString(), i_port, i_group);
+	io_status = MSS_INIT_CAL_COMPLETE;
     }
     else
     {
-        FAPI_ERR( "+++ Calibration on %s port: %d rank group: %d has stalled! +++", i_target.toEcmdString(), i_port, i_group);
-        io_status = MSS_INIT_CAL_STALL;
+	FAPI_ERR( "+++ Calibration on %s port: %d rank group: %d has stalled! +++", i_target.toEcmdString(), i_port, i_group);
+	io_status = MSS_INIT_CAL_STALL;
     }
 
     return rc;
@@ -1107,18 +1255,18 @@ ReturnCode mss_check_error_status( Target& i_target,
 
     if((cal_error_buffer_64.isBitSet(60)) || (cal_error_buffer_64.isBitSet(61)) || (cal_error_buffer_64.isBitSet(62)) || (cal_error_buffer_64.isBitSet(63)))
     {
-        io_status = MSS_INIT_CAL_FAIL;
+	io_status = MSS_INIT_CAL_FAIL;
 
         if(cal_error_buffer_64.isBitSet(48))
         {
             FAPI_ERR( "+++ Write leveling error occured on %s port: %d rank group: %d! +++", i_target.toEcmdString(), i_port, i_group);
-            const fapi::Target & TARGET_MBA_ERROR = i_target;
-            MBA_POSITION = i_mbaPosition;
-            PORT_POSITION = i_port;
-            RANKGROUP_POSITION = i_group;
-            FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_WR_LVL_ERROR);
-            fapiLogError(rc, FAPI_ERRL_SEV_RECOVERED);
-            rc = FAPI_RC_SUCCESS;
+	    const fapi::Target & TARGET_MBA_ERROR = i_target;
+	    MBA_POSITION = i_mbaPosition;
+	    PORT_POSITION = i_port;
+	    RANKGROUP_POSITION = i_group;
+	    FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_WR_LVL_ERROR);
+	    fapiLogError(rc, FAPI_ERRL_SEV_RECOVERED);
+	    rc = FAPI_RC_SUCCESS;
         }
         if(cal_error_buffer_64.isBitSet(50))
         {
@@ -1226,125 +1374,119 @@ ReturnCode mss_check_error_status( Target& i_target,
         if(cal_error_buffer_64.isBitSet(51))
         {
             FAPI_ERR( "+++ RDCLK to SysClk alignment error occured on %s port: %d rank group: %d! +++", i_target.toEcmdString(), i_port, i_group);
-            const fapi::Target & TARGET_MBA_ERROR = i_target;
-            MBA_POSITION = i_mbaPosition;
-            PORT_POSITION = i_port;
-            RANKGROUP_POSITION = i_group;
-            FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_RD_CLK_SYS_CLK_ALIGNMENT_ERROR);
-            fapiLogError(rc, FAPI_ERRL_SEV_RECOVERED);
-            rc = FAPI_RC_SUCCESS;
+	    const fapi::Target & TARGET_MBA_ERROR = i_target;
+	    MBA_POSITION = i_mbaPosition;
+	    PORT_POSITION = i_port;
+	    RANKGROUP_POSITION = i_group;
+	    FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_RD_CLK_SYS_CLK_ALIGNMENT_ERROR);
+	    fapiLogError(rc, FAPI_ERRL_SEV_RECOVERED);
+	    rc = FAPI_RC_SUCCESS;
         }
         if(cal_error_buffer_64.isBitSet(52))
         {
             FAPI_ERR( "+++ Read centering error occured on %s port: %d rank group: %d! +++", i_target.toEcmdString(), i_port, i_group);
-            const fapi::Target & TARGET_MBA_ERROR = i_target;
-            MBA_POSITION = i_mbaPosition;
-            PORT_POSITION = i_port;
-            RANKGROUP_POSITION = i_group;
-            FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_RD_CENTERING_ERROR);
-            fapiLogError(rc, FAPI_ERRL_SEV_RECOVERED);
-            rc = FAPI_RC_SUCCESS;
+	    const fapi::Target & TARGET_MBA_ERROR = i_target;
+	    MBA_POSITION = i_mbaPosition;
+	    PORT_POSITION = i_port;
+	    RANKGROUP_POSITION = i_group;
+	    FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_RD_CENTERING_ERROR);
+	    fapiLogError(rc, FAPI_ERRL_SEV_RECOVERED);
+	    rc = FAPI_RC_SUCCESS;
         }
         if(cal_error_buffer_64.isBitSet(53))
         {
             FAPI_ERR( "+++ Write centering error occured on %s port: %d rank group: %d! +++", i_target.toEcmdString(), i_port, i_group);
-            const fapi::Target & TARGET_MBA_ERROR = i_target;
-            MBA_POSITION = i_mbaPosition;
-            PORT_POSITION = i_port;
-            RANKGROUP_POSITION = i_group;
-            FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_WR_CENTERING_ERROR);
-            fapiLogError(rc, FAPI_ERRL_SEV_RECOVERED);
-            rc = FAPI_RC_SUCCESS;
+	    const fapi::Target & TARGET_MBA_ERROR = i_target;
+	    MBA_POSITION = i_mbaPosition;
+	    PORT_POSITION = i_port;
+	    RANKGROUP_POSITION = i_group;
+	    FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_WR_CENTERING_ERROR);
+	    fapiLogError(rc, FAPI_ERRL_SEV_RECOVERED);
+	    rc = FAPI_RC_SUCCESS;
         }
         if(cal_error_buffer_64.isBitSet(55))
         {
             FAPI_ERR( "+++ Coarse read centering error occured on %s port: %d rank group: %d! +++", i_target.toEcmdString(), i_port, i_group);
-            const fapi::Target & TARGET_MBA_ERROR = i_target;
-            MBA_POSITION = i_mbaPosition;
-            PORT_POSITION = i_port;
-            RANKGROUP_POSITION = i_group;
-            FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_COURSE_RD_CENTERING_ERROR);
-            fapiLogError(rc, FAPI_ERRL_SEV_RECOVERED);
-            rc = FAPI_RC_SUCCESS;
+	    const fapi::Target & TARGET_MBA_ERROR = i_target;
+	    MBA_POSITION = i_mbaPosition;
+	    PORT_POSITION = i_port;
+	    RANKGROUP_POSITION = i_group;
+	    FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_COURSE_RD_CENTERING_ERROR);
+	    fapiLogError(rc, FAPI_ERRL_SEV_RECOVERED);
+	    rc = FAPI_RC_SUCCESS;
         }
         if(cal_error_buffer_64.isBitSet(56))
         {
             FAPI_ERR( "+++ Custom pattern read centering error occured on %s port: %d rank group: %d! +++", i_target.toEcmdString(), i_port, i_group);
-            const fapi::Target & TARGET_MBA_ERROR = i_target;
-            MBA_POSITION = i_mbaPosition;
-            PORT_POSITION = i_port;
-            RANKGROUP_POSITION = i_group;
-            FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_CUSTOM_PATTERN_RD_CENTERING_ERROR);
-            fapiLogError(rc, FAPI_ERRL_SEV_RECOVERED);
-            rc = FAPI_RC_SUCCESS;
+	    const fapi::Target & TARGET_MBA_ERROR = i_target;
+	    MBA_POSITION = i_mbaPosition;
+	    PORT_POSITION = i_port;
+	    RANKGROUP_POSITION = i_group;
+	    FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_CUSTOM_PATTERN_RD_CENTERING_ERROR);
+	    fapiLogError(rc, FAPI_ERRL_SEV_RECOVERED);
+	    rc = FAPI_RC_SUCCESS;
         }
         if(cal_error_buffer_64.isBitSet(57))
         {
             FAPI_ERR( "+++ Custom pattern write centering error occured on %s port: %d rank group: %d! +++", i_target.toEcmdString(), i_port, i_group);
-            const fapi::Target & TARGET_MBA_ERROR = i_target;
-            MBA_POSITION = i_mbaPosition;
-            PORT_POSITION = i_port;
-            RANKGROUP_POSITION = i_group;
-            FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_CUSTOM_PATTERN_WR_CENTERING_ERROR);
-            fapiLogError(rc, FAPI_ERRL_SEV_RECOVERED);
-            rc = FAPI_RC_SUCCESS;
+	    const fapi::Target & TARGET_MBA_ERROR = i_target;
+	    MBA_POSITION = i_mbaPosition;
+	    PORT_POSITION = i_port;
+	    RANKGROUP_POSITION = i_group;
+	    FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_CUSTOM_PATTERN_WR_CENTERING_ERROR);
+	    fapiLogError(rc, FAPI_ERRL_SEV_RECOVERED);
+	    rc = FAPI_RC_SUCCESS;
         }
         if(cal_error_buffer_64.isBitSet(58))
         {
             FAPI_ERR( "+++ Digital eye error occured on %s port: %d rank group: %d! +++", i_target.toEcmdString(), i_port, i_group);
-            const fapi::Target & TARGET_MBA_ERROR = i_target;
-            MBA_POSITION = i_mbaPosition;
-            PORT_POSITION = i_port;
-            RANKGROUP_POSITION = i_group;
-            FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_DIGITAL_EYE_ERROR);
-            fapiLogError(rc, FAPI_ERRL_SEV_RECOVERED);
-            rc = FAPI_RC_SUCCESS;
+	    const fapi::Target & TARGET_MBA_ERROR = i_target;
+	    MBA_POSITION = i_mbaPosition;
+	    PORT_POSITION = i_port;
+	    RANKGROUP_POSITION = i_group;
+	    FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_DIGITAL_EYE_ERROR);
+	    fapiLogError(rc, FAPI_ERRL_SEV_RECOVERED);
+	    rc = FAPI_RC_SUCCESS;
         }
     }
     else
     {
-        if (cur_cal_step == 1)
-        {
-            FAPI_INF( "+++ Write_leveling on %s port: %d rank group: %d was successful. +++", i_target.toEcmdString(), i_port, i_group);
-        }
-        else if (cur_cal_step == 2)
-        {
-            FAPI_INF( "+++ DQS Alignment on %s port: %d rank group: %d was successful. +++", i_target.toEcmdString(), i_port, i_group);
-        }
-        else if (cur_cal_step == 3)
-        {
-            FAPI_INF( "+++ RDCLK to SysClk alignment on %s port: %d rank group: %d was successful. +++", i_target.toEcmdString(), i_port, i_group);
-        }
-        else if (cur_cal_step == 4)
-        {
-            FAPI_INF( "+++ Read Centering on %s port: %d rank group: %d was successful. +++", i_target.toEcmdString(), i_port, i_group);
-        }
-        else if (cur_cal_step == 5)
-        {
-            FAPI_INF( "+++ Write Centering on %s port: %d rank group: %d was successful. +++", i_target.toEcmdString(), i_port, i_group);
-        }
-        else if (cur_cal_step == 6)
-        {
-            FAPI_INF( "+++ Course Read and/or Course Write on %s port: %d rank group: %d was successful. +++", i_target.toEcmdString(), i_port, i_group);
-        }
-
-        io_status = MSS_INIT_CAL_PASS;
+  	if (cur_cal_step == 1)
+	{
+	    FAPI_INF( "+++ Write_leveling on %s port: %d rank group: %d was successful. +++", i_target.toEcmdString(), i_port, i_group);
+	}
+	else if (cur_cal_step == 2)
+	{
+	    FAPI_INF( "+++ DQS Alignment on %s port: %d rank group: %d was successful. +++", i_target.toEcmdString(), i_port, i_group);
+	}
+	else if (cur_cal_step == 3)
+	{
+	    FAPI_INF( "+++ RDCLK to SysClk alignment on %s port: %d rank group: %d was successful. +++", i_target.toEcmdString(), i_port, i_group);
+	}
+	else if (cur_cal_step == 4)
+	{
+	    FAPI_INF( "+++ Read Centering on %s port: %d rank group: %d was successful. +++", i_target.toEcmdString(), i_port, i_group);
+	}
+	else if (cur_cal_step == 5)
+	{
+	    FAPI_INF( "+++ Write Centering on %s port: %d rank group: %d was successful. +++", i_target.toEcmdString(), i_port, i_group);
+	}
+	else if (cur_cal_step == 6)
+	{
+	    FAPI_INF( "+++ Course Read and/or Course Write on %s port: %d rank group: %d was successful. +++", i_target.toEcmdString(), i_port, i_group);
+	}
+
+	io_status = MSS_INIT_CAL_PASS;
     }
 
     return rc;
 }
 
-
-
-
-
-
-
 ReturnCode mss_read_center_workaround(
             Target& i_target,
             uint8_t i_mbaPosition,
             uint32_t i_port,
-            uint32_t i_rank_group
+	    uint32_t i_rank_group
             )
 {
 
@@ -1400,105 +1542,105 @@ ReturnCode mss_read_center_workaround(
     if ( i_port == 0 )
     {
 
-        RD_TIMING_REF0_ADDR_0 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE0_P0_0_0x800000700301143F;
-        RD_TIMING_REF0_ADDR_1 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE0_P0_1_0x800004700301143F;
-        RD_TIMING_REF0_ADDR_2 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE0_P0_2_0x800008700301143F;
-        RD_TIMING_REF0_ADDR_3 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE0_P0_3_0x80000C700301143F;
-        RD_TIMING_REF0_ADDR_4 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE0_P0_4_0x800010700301143F;
-        RD_TIMING_REF1_ADDR_0 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE1_P0_0_0x800000710301143F;
-        RD_TIMING_REF1_ADDR_1 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE1_P0_1_0x800004710301143F;
-        RD_TIMING_REF1_ADDR_2 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE1_P0_2_0x800008710301143F;
-        RD_TIMING_REF1_ADDR_3 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE1_P0_3_0x80000C710301143F;
-        RD_TIMING_REF1_ADDR_4 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE1_P0_4_0x800010710301143F;
-
-        if ( i_rank_group == 0 )
-        {
-            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_0_0x800000090301143F;
-            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_1_0x800004090301143F;
-            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_2_0x800008090301143F;
-            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_3_0x80000C090301143F;
-            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_4_0x800010090301143F;
-
-        }
-        else if ( i_rank_group == 1 )
-        {
-            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_0_0x800001090301143F;
-            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_1_0x800005090301143F;
-            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_2_0x800009090301143F;
-            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_3_0x80000D090301143F;
-            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_4_0x800011090301143F;
-
-        }
-        else if ( i_rank_group == 2 )
-        {
-            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_0_0x800002090301143F;
-            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_1_0x800006090301143F;
-            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_2_0x80000A090301143F;
-            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_3_0x80000E090301143F;
-            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_4_0x800012090301143F;
-
-        }
-        else if ( i_rank_group == 3 )
-        {
-            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_0_0x800003090301143F;
-            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_1_0x800007090301143F;
-            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_2_0x80000B090301143F;
-            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_3_0x80000F090301143F;
-            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_4_0x800013090301143F;
-
-        }
+	RD_TIMING_REF0_ADDR_0 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE0_P0_0_0x800000700301143F;
+	RD_TIMING_REF0_ADDR_1 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE0_P0_1_0x800004700301143F;
+	RD_TIMING_REF0_ADDR_2 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE0_P0_2_0x800008700301143F;
+	RD_TIMING_REF0_ADDR_3 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE0_P0_3_0x80000C700301143F;
+	RD_TIMING_REF0_ADDR_4 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE0_P0_4_0x800010700301143F;
+	RD_TIMING_REF1_ADDR_0 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE1_P0_0_0x800000710301143F;
+	RD_TIMING_REF1_ADDR_1 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE1_P0_1_0x800004710301143F;
+	RD_TIMING_REF1_ADDR_2 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE1_P0_2_0x800008710301143F;
+	RD_TIMING_REF1_ADDR_3 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE1_P0_3_0x80000C710301143F;
+	RD_TIMING_REF1_ADDR_4 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE1_P0_4_0x800010710301143F;
+
+	if ( i_rank_group == 0 )
+	{
+	    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_0_0x800000090301143F;
+	    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_1_0x800004090301143F;
+	    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_2_0x800008090301143F;
+	    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_3_0x80000C090301143F;
+	    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_4_0x800010090301143F;
+
+	}
+	else if ( i_rank_group == 1 )
+	{
+	    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_0_0x800001090301143F;
+	    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_1_0x800005090301143F;
+	    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_2_0x800009090301143F;
+	    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_3_0x80000D090301143F;
+	    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_4_0x800011090301143F;
+
+	}
+	else if ( i_rank_group == 2 )
+	{
+	    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_0_0x800002090301143F;
+	    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_1_0x800006090301143F;
+	    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_2_0x80000A090301143F;
+	    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_3_0x80000E090301143F;
+	    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_4_0x800012090301143F;
+
+	}
+	else if ( i_rank_group == 3 )
+	{
+	    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_0_0x800003090301143F;
+	    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_1_0x800007090301143F;
+	    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_2_0x80000B090301143F;
+	    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_3_0x80000F090301143F;
+	    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_4_0x800013090301143F;
+
+	}
     }
     else if (i_port == 1 )
     {
 
-        RD_TIMING_REF0_ADDR_0 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE0_P1_0_0x800100700301143F;
-        RD_TIMING_REF0_ADDR_1 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE0_P1_1_0x800104700301143F;
-        RD_TIMING_REF0_ADDR_2 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE0_P1_2_0x800108700301143F;
-        RD_TIMING_REF0_ADDR_3 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE0_P1_3_0x80010C700301143F;
-        RD_TIMING_REF0_ADDR_4 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE0_P1_4_0x800110700301143F;
-        RD_TIMING_REF1_ADDR_0 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE1_P1_0_0x800100710301143F;
-        RD_TIMING_REF1_ADDR_1 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE1_P1_1_0x800104710301143F;
-        RD_TIMING_REF1_ADDR_2 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE1_P1_2_0x800108710301143F;
-        RD_TIMING_REF1_ADDR_3 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE1_P1_3_0x80010C710301143F;
-        RD_TIMING_REF1_ADDR_4 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE1_P1_4_0x800110710301143F;
-
-        if ( i_rank_group == 0 )
-        {
-            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_0_0x800100090301143F;
-            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_1_0x800104090301143F;
-            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_2_0x800108090301143F;
-            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_3_0x80010C090301143F;
-            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_4_0x800110090301143F;
-
-        }
-        else if ( i_rank_group == 1 )
-        {
-            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_0_0x800101090301143F;
-            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_1_0x800105090301143F;
-            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_2_0x800109090301143F;
-            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_3_0x80010D090301143F;
-            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_4_0x800111090301143F;
-
-
-        }
-        else if ( i_rank_group == 2 )
-        {
-            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_0_0x800102090301143F;
-            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_1_0x800106090301143F;
-            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_2_0x80010A090301143F;
-            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_3_0x80010E090301143F;
-            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_4_0x800112090301143F;
-
-        }
-        else if ( i_rank_group == 3 )
-        {
-            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_0_0x800103090301143F;
-            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_1_0x800107090301143F;
-            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_2_0x80010B090301143F;
-            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_3_0x80010F090301143F;
-            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_4_0x800113090301143F;
-
-        }
+	RD_TIMING_REF0_ADDR_0 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE0_P1_0_0x800100700301143F;
+	RD_TIMING_REF0_ADDR_1 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE0_P1_1_0x800104700301143F;
+	RD_TIMING_REF0_ADDR_2 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE0_P1_2_0x800108700301143F;
+	RD_TIMING_REF0_ADDR_3 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE0_P1_3_0x80010C700301143F;
+	RD_TIMING_REF0_ADDR_4 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE0_P1_4_0x800110700301143F;
+	RD_TIMING_REF1_ADDR_0 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE1_P1_0_0x800100710301143F;
+	RD_TIMING_REF1_ADDR_1 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE1_P1_1_0x800104710301143F;
+	RD_TIMING_REF1_ADDR_2 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE1_P1_2_0x800108710301143F;
+	RD_TIMING_REF1_ADDR_3 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE1_P1_3_0x80010C710301143F;
+	RD_TIMING_REF1_ADDR_4 = DPHY01_DDRPHY_DP18_READ_TIMING_REFERENCE1_P1_4_0x800110710301143F;
+
+	if ( i_rank_group == 0 )
+	{
+	    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_0_0x800100090301143F;
+	    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_1_0x800104090301143F;
+	    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_2_0x800108090301143F;
+	    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_3_0x80010C090301143F;
+	    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_4_0x800110090301143F;
+
+	}
+	else if ( i_rank_group == 1 )
+	{
+	    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_0_0x800101090301143F;
+	    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_1_0x800105090301143F;
+	    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_2_0x800109090301143F;
+	    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_3_0x80010D090301143F;
+	    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_4_0x800111090301143F;
+
+
+	}
+	else if ( i_rank_group == 2 )
+	{
+	    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_0_0x800102090301143F;
+	    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_1_0x800106090301143F;
+	    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_2_0x80010A090301143F;
+	    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_3_0x80010E090301143F;
+	    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_4_0x800112090301143F;
+
+	}
+	else if ( i_rank_group == 3 )
+	{
+	    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_0_0x800103090301143F;
+	    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_1_0x800107090301143F;
+	    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_2_0x80010B090301143F;
+	    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_3_0x80010F090301143F;
+	    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_4_0x800113090301143F;
+
+	}
     }
 
     //Block 0
@@ -1511,75 +1653,75 @@ ReturnCode mss_read_center_workaround(
     rc_num = rc_num | data_buffer_64.extractToRight(&l_timing_ref_quad2, 49, 7);
     rc_num = rc_num | data_buffer_64.extractToRight(&l_timing_ref_quad3, 57, 7);
 
-        if(rc_num)
-        {
-        rc.setEcmdError(rc_num);
-        return rc;
-        }
+	if(rc_num)
+	{
+	rc.setEcmdError(rc_num);
+	return rc;
+	}
 
     if ( quad0_workaround_type == 0 )
     {
-        dqs_clk_increment_quad0 = dqs_clk_increment_wa0;
-        read_phase_value_quad0 = read_phase_value_wa0;
+	dqs_clk_increment_quad0 = dqs_clk_increment_wa0;
+	read_phase_value_quad0 = read_phase_value_wa0;
     }
     else if ( quad0_workaround_type == 1 )
     {
-        dqs_clk_increment_quad0 = dqs_clk_increment_wa1;
-        read_phase_value_quad0 = read_phase_value_wa1;
+	dqs_clk_increment_quad0 = dqs_clk_increment_wa1;
+	read_phase_value_quad0 = read_phase_value_wa1;
     }
     else if ( quad0_workaround_type == 2 )
     {
-        dqs_clk_increment_quad0 = dqs_clk_increment_wa2;
-        read_phase_value_quad0 = read_phase_value_wa2;
+	dqs_clk_increment_quad0 = dqs_clk_increment_wa2;
+	read_phase_value_quad0 = read_phase_value_wa2;
     }
     FAPI_INF( "+++ ALL Blocks ALL Quads using workaround number %d with dqs_clk_increment: %d read_phase_value: %d +++", quad0_workaround_type, dqs_clk_increment_quad0, read_phase_value_quad0);
 
     if ( quad1_workaround_type == 0 )
     {
-        dqs_clk_increment_quad1 = dqs_clk_increment_wa0;
-        read_phase_value_quad1 = read_phase_value_wa0;
+	dqs_clk_increment_quad1 = dqs_clk_increment_wa0;
+	read_phase_value_quad1 = read_phase_value_wa0;
     }
     else if ( quad1_workaround_type == 1 )
     {
-        dqs_clk_increment_quad1 = dqs_clk_increment_wa1;
-        read_phase_value_quad1 = read_phase_value_wa1;
+	dqs_clk_increment_quad1 = dqs_clk_increment_wa1;
+	read_phase_value_quad1 = read_phase_value_wa1;
     }
     else if ( quad1_workaround_type == 2 )
     {
-        dqs_clk_increment_quad1 = dqs_clk_increment_wa2;
-        read_phase_value_quad1 = read_phase_value_wa2;
+	dqs_clk_increment_quad1 = dqs_clk_increment_wa2;
+	read_phase_value_quad1 = read_phase_value_wa2;
     }
 
     if ( quad2_workaround_type == 0 )
     {
-        dqs_clk_increment_quad2 = dqs_clk_increment_wa0;
-        read_phase_value_quad2 = read_phase_value_wa0;
+	dqs_clk_increment_quad2 = dqs_clk_increment_wa0;
+	read_phase_value_quad2 = read_phase_value_wa0;
     }
     else if ( quad2_workaround_type == 1 )
     {
-        dqs_clk_increment_quad2 = dqs_clk_increment_wa1;
-        read_phase_value_quad2 = read_phase_value_wa1;
+	dqs_clk_increment_quad2 = dqs_clk_increment_wa1;
+	read_phase_value_quad2 = read_phase_value_wa1;
     }
     else if ( quad2_workaround_type == 2 )
     {
-        dqs_clk_increment_quad2 = dqs_clk_increment_wa2;
-        read_phase_value_quad2 = read_phase_value_wa2;
+	dqs_clk_increment_quad2 = dqs_clk_increment_wa2;
+	read_phase_value_quad2 = read_phase_value_wa2;
     }
 
     if ( quad3_workaround_type == 0 )
     {
-        dqs_clk_increment_quad3 = dqs_clk_increment_wa0;
-        read_phase_value_quad3 = read_phase_value_wa0;
+	dqs_clk_increment_quad3 = dqs_clk_increment_wa0;
+	read_phase_value_quad3 = read_phase_value_wa0;
     }
     else if ( quad3_workaround_type == 1 )
     {
-        dqs_clk_increment_quad3 = dqs_clk_increment_wa1;
-        read_phase_value_quad3 = read_phase_value_wa1;
+	dqs_clk_increment_quad3 = dqs_clk_increment_wa1;
+	read_phase_value_quad3 = read_phase_value_wa1;
     }
     else if ( quad3_workaround_type == 2 )
     {
-        dqs_clk_increment_quad3 = dqs_clk_increment_wa2;
-        read_phase_value_quad3 = read_phase_value_wa2;
+	dqs_clk_increment_quad3 = dqs_clk_increment_wa2;
+	read_phase_value_quad3 = read_phase_value_wa2;
     }
 
     rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_0, data_buffer_64);
@@ -1624,72 +1766,72 @@ ReturnCode mss_read_center_workaround(
 
     if(rc_num)
     {
-        rc.setEcmdError(rc_num);
-        return rc;
+	rc.setEcmdError(rc_num);
+	return rc;
     }
 
     if ( quad0_workaround_type == 0 )
     {
-        dqs_clk_increment_quad0 = dqs_clk_increment_wa0;
-        read_phase_value_quad0 = read_phase_value_wa0;
+	dqs_clk_increment_quad0 = dqs_clk_increment_wa0;
+	read_phase_value_quad0 = read_phase_value_wa0;
     }
     else if ( quad0_workaround_type == 1 )
     {
-        dqs_clk_increment_quad0 = dqs_clk_increment_wa1;
-        read_phase_value_quad0 = read_phase_value_wa1;
+	dqs_clk_increment_quad0 = dqs_clk_increment_wa1;
+	read_phase_value_quad0 = read_phase_value_wa1;
     }
     else if ( quad0_workaround_type == 2 )
     {
-        dqs_clk_increment_quad0 = dqs_clk_increment_wa2;
-        read_phase_value_quad0 = read_phase_value_wa2;
+	dqs_clk_increment_quad0 = dqs_clk_increment_wa2;
+	read_phase_value_quad0 = read_phase_value_wa2;
     }
 
     if ( quad1_workaround_type == 0 )
     {
-        dqs_clk_increment_quad1 = dqs_clk_increment_wa0;
-        read_phase_value_quad1 = read_phase_value_wa0;
+	dqs_clk_increment_quad1 = dqs_clk_increment_wa0;
+	read_phase_value_quad1 = read_phase_value_wa0;
     }
     else if ( quad1_workaround_type == 1 )
     {
-        dqs_clk_increment_quad1 = dqs_clk_increment_wa1;
-        read_phase_value_quad1 = read_phase_value_wa1;
+	dqs_clk_increment_quad1 = dqs_clk_increment_wa1;
+	read_phase_value_quad1 = read_phase_value_wa1;
     }
     else if ( quad1_workaround_type == 2 )
     {
-        dqs_clk_increment_quad1 = dqs_clk_increment_wa2;
-        read_phase_value_quad1 = read_phase_value_wa2;
+	dqs_clk_increment_quad1 = dqs_clk_increment_wa2;
+	read_phase_value_quad1 = read_phase_value_wa2;
     }
 
     if ( quad2_workaround_type == 0 )
     {
-        dqs_clk_increment_quad2 = dqs_clk_increment_wa0;
-        read_phase_value_quad2 = read_phase_value_wa0;
+	dqs_clk_increment_quad2 = dqs_clk_increment_wa0;
+	read_phase_value_quad2 = read_phase_value_wa0;
     }
     else if ( quad2_workaround_type == 1 )
     {
-        dqs_clk_increment_quad2 = dqs_clk_increment_wa1;
-        read_phase_value_quad2 = read_phase_value_wa1;
+	dqs_clk_increment_quad2 = dqs_clk_increment_wa1;
+	read_phase_value_quad2 = read_phase_value_wa1;
     }
     else if ( quad2_workaround_type == 2 )
     {
-        dqs_clk_increment_quad2 = dqs_clk_increment_wa2;
-        read_phase_value_quad2 = read_phase_value_wa2;
+	dqs_clk_increment_quad2 = dqs_clk_increment_wa2;
+	read_phase_value_quad2 = read_phase_value_wa2;
     }
 
     if ( quad3_workaround_type == 0 )
     {
-        dqs_clk_increment_quad3 = dqs_clk_increment_wa0;
-        read_phase_value_quad3 = read_phase_value_wa0;
+	dqs_clk_increment_quad3 = dqs_clk_increment_wa0;
+	read_phase_value_quad3 = read_phase_value_wa0;
     }
     else if ( quad3_workaround_type == 1 )
     {
-        dqs_clk_increment_quad3 = dqs_clk_increment_wa1;
-        read_phase_value_quad3 = read_phase_value_wa1;
+	dqs_clk_increment_quad3 = dqs_clk_increment_wa1;
+	read_phase_value_quad3 = read_phase_value_wa1;
     }
     else if ( quad3_workaround_type == 2 )
     {
-        dqs_clk_increment_quad3 = dqs_clk_increment_wa2;
-        read_phase_value_quad3 = read_phase_value_wa2;
+	dqs_clk_increment_quad3 = dqs_clk_increment_wa2;
+	read_phase_value_quad3 = read_phase_value_wa2;
     }
 
 
@@ -1735,72 +1877,72 @@ ReturnCode mss_read_center_workaround(
 
     if(rc_num)
     {
-        rc.setEcmdError(rc_num);
-        return rc;
+	rc.setEcmdError(rc_num);
+	return rc;
     }
 
     if ( quad0_workaround_type == 0 )
     {
-        dqs_clk_increment_quad0 = dqs_clk_increment_wa0;
-        read_phase_value_quad0 = read_phase_value_wa0;
+	dqs_clk_increment_quad0 = dqs_clk_increment_wa0;
+	read_phase_value_quad0 = read_phase_value_wa0;
     }
     else if ( quad0_workaround_type == 1 )
     {
-        dqs_clk_increment_quad0 = dqs_clk_increment_wa1;
-        read_phase_value_quad0 = read_phase_value_wa1;
+	dqs_clk_increment_quad0 = dqs_clk_increment_wa1;
+	read_phase_value_quad0 = read_phase_value_wa1;
     }
     else if ( quad0_workaround_type == 2 )
     {
-        dqs_clk_increment_quad0 = dqs_clk_increment_wa2;
-        read_phase_value_quad0 = read_phase_value_wa2;
+	dqs_clk_increment_quad0 = dqs_clk_increment_wa2;
+	read_phase_value_quad0 = read_phase_value_wa2;
     }
 
     if ( quad1_workaround_type == 0 )
     {
-        dqs_clk_increment_quad1 = dqs_clk_increment_wa0;
-        read_phase_value_quad1 = read_phase_value_wa0;
+	dqs_clk_increment_quad1 = dqs_clk_increment_wa0;
+	read_phase_value_quad1 = read_phase_value_wa0;
     }
     else if ( quad1_workaround_type == 1 )
     {
-        dqs_clk_increment_quad1 = dqs_clk_increment_wa1;
-        read_phase_value_quad1 = read_phase_value_wa1;
+	dqs_clk_increment_quad1 = dqs_clk_increment_wa1;
+	read_phase_value_quad1 = read_phase_value_wa1;
     }
     else if ( quad1_workaround_type == 2 )
     {
-        dqs_clk_increment_quad1 = dqs_clk_increment_wa2;
-        read_phase_value_quad1 = read_phase_value_wa2;
+	dqs_clk_increment_quad1 = dqs_clk_increment_wa2;
+	read_phase_value_quad1 = read_phase_value_wa2;
     }
 
     if ( quad2_workaround_type == 0 )
     {
-        dqs_clk_increment_quad2 = dqs_clk_increment_wa0;
-        read_phase_value_quad2 = read_phase_value_wa0;
+	dqs_clk_increment_quad2 = dqs_clk_increment_wa0;
+	read_phase_value_quad2 = read_phase_value_wa0;
     }
     else if ( quad2_workaround_type == 1 )
     {
-        dqs_clk_increment_quad2 = dqs_clk_increment_wa1;
-        read_phase_value_quad2 = read_phase_value_wa1;
+	dqs_clk_increment_quad2 = dqs_clk_increment_wa1;
+	read_phase_value_quad2 = read_phase_value_wa1;
     }
     else if ( quad2_workaround_type == 2 )
     {
-        dqs_clk_increment_quad2 = dqs_clk_increment_wa2;
-        read_phase_value_quad2 = read_phase_value_wa2;
+	dqs_clk_increment_quad2 = dqs_clk_increment_wa2;
+	read_phase_value_quad2 = read_phase_value_wa2;
     }
 
     if ( quad3_workaround_type == 0 )
     {
-        dqs_clk_increment_quad3 = dqs_clk_increment_wa0;
-        read_phase_value_quad3 = read_phase_value_wa0;
+	dqs_clk_increment_quad3 = dqs_clk_increment_wa0;
+	read_phase_value_quad3 = read_phase_value_wa0;
     }
     else if ( quad3_workaround_type == 1 )
     {
-        dqs_clk_increment_quad3 = dqs_clk_increment_wa1;
-        read_phase_value_quad3 = read_phase_value_wa1;
+	dqs_clk_increment_quad3 = dqs_clk_increment_wa1;
+	read_phase_value_quad3 = read_phase_value_wa1;
     }
     else if ( quad3_workaround_type == 2 )
     {
-        dqs_clk_increment_quad3 = dqs_clk_increment_wa2;
-        read_phase_value_quad3 = read_phase_value_wa2;
+	dqs_clk_increment_quad3 = dqs_clk_increment_wa2;
+	read_phase_value_quad3 = read_phase_value_wa2;
     }
 
 
@@ -1846,72 +1988,72 @@ ReturnCode mss_read_center_workaround(
 
     if(rc_num)
     {
-        rc.setEcmdError(rc_num);
-        return rc;
+	rc.setEcmdError(rc_num);
+	return rc;
     }
 
     if ( quad0_workaround_type == 0 )
     {
-        dqs_clk_increment_quad0 = dqs_clk_increment_wa0;
-        read_phase_value_quad0 = read_phase_value_wa0;
+	dqs_clk_increment_quad0 = dqs_clk_increment_wa0;
+	read_phase_value_quad0 = read_phase_value_wa0;
     }
     else if ( quad0_workaround_type == 1 )
     {
-        dqs_clk_increment_quad0 = dqs_clk_increment_wa1;
-        read_phase_value_quad0 = read_phase_value_wa1;
+	dqs_clk_increment_quad0 = dqs_clk_increment_wa1;
+	read_phase_value_quad0 = read_phase_value_wa1;
     }
     else if ( quad0_workaround_type == 2 )
     {
-        dqs_clk_increment_quad0 = dqs_clk_increment_wa2;
-        read_phase_value_quad0 = read_phase_value_wa2;
+	dqs_clk_increment_quad0 = dqs_clk_increment_wa2;
+	read_phase_value_quad0 = read_phase_value_wa2;
     }
 
     if ( quad1_workaround_type == 0 )
     {
-        dqs_clk_increment_quad1 = dqs_clk_increment_wa0;
-        read_phase_value_quad1 = read_phase_value_wa0;
+	dqs_clk_increment_quad1 = dqs_clk_increment_wa0;
+	read_phase_value_quad1 = read_phase_value_wa0;
     }
     else if ( quad1_workaround_type == 1 )
     {
-        dqs_clk_increment_quad1 = dqs_clk_increment_wa1;
-        read_phase_value_quad1 = read_phase_value_wa1;
+	dqs_clk_increment_quad1 = dqs_clk_increment_wa1;
+	read_phase_value_quad1 = read_phase_value_wa1;
     }
     else if ( quad1_workaround_type == 2 )
     {
-        dqs_clk_increment_quad1 = dqs_clk_increment_wa2;
-        read_phase_value_quad1 = read_phase_value_wa2;
+	dqs_clk_increment_quad1 = dqs_clk_increment_wa2;
+	read_phase_value_quad1 = read_phase_value_wa2;
     }
 
     if ( quad2_workaround_type == 0 )
     {
-        dqs_clk_increment_quad2 = dqs_clk_increment_wa0;
-        read_phase_value_quad2 = read_phase_value_wa0;
+	dqs_clk_increment_quad2 = dqs_clk_increment_wa0;
+	read_phase_value_quad2 = read_phase_value_wa0;
     }
     else if ( quad2_workaround_type == 1 )
     {
-        dqs_clk_increment_quad2 = dqs_clk_increment_wa1;
-        read_phase_value_quad2 = read_phase_value_wa1;
+	dqs_clk_increment_quad2 = dqs_clk_increment_wa1;
+	read_phase_value_quad2 = read_phase_value_wa1;
     }
     else if ( quad2_workaround_type == 2 )
     {
-        dqs_clk_increment_quad2 = dqs_clk_increment_wa2;
-        read_phase_value_quad2 = read_phase_value_wa2;
+	dqs_clk_increment_quad2 = dqs_clk_increment_wa2;
+	read_phase_value_quad2 = read_phase_value_wa2;
     }
 
     if ( quad3_workaround_type == 0 )
     {
-        dqs_clk_increment_quad3 = dqs_clk_increment_wa0;
-        read_phase_value_quad3 = read_phase_value_wa0;
+	dqs_clk_increment_quad3 = dqs_clk_increment_wa0;
+	read_phase_value_quad3 = read_phase_value_wa0;
     }
     else if ( quad3_workaround_type == 1 )
     {
-        dqs_clk_increment_quad3 = dqs_clk_increment_wa1;
-        read_phase_value_quad3 = read_phase_value_wa1;
+	dqs_clk_increment_quad3 = dqs_clk_increment_wa1;
+	read_phase_value_quad3 = read_phase_value_wa1;
     }
     else if ( quad3_workaround_type == 2 )
     {
-        dqs_clk_increment_quad3 = dqs_clk_increment_wa2;
-        read_phase_value_quad3 = read_phase_value_wa2;
+	dqs_clk_increment_quad3 = dqs_clk_increment_wa2;
+	read_phase_value_quad3 = read_phase_value_wa2;
     }
 
 
@@ -1957,72 +2099,72 @@ ReturnCode mss_read_center_workaround(
 
     if(rc_num)
     {
-        rc.setEcmdError(rc_num);
-        return rc;
+	rc.setEcmdError(rc_num);
+	return rc;
     }
 
     if ( quad0_workaround_type == 0 )
     {
-        dqs_clk_increment_quad0 = dqs_clk_increment_wa0;
-        read_phase_value_quad0 = read_phase_value_wa0;
+	dqs_clk_increment_quad0 = dqs_clk_increment_wa0;
+	read_phase_value_quad0 = read_phase_value_wa0;
     }
     else if ( quad0_workaround_type == 1 )
     {
-        dqs_clk_increment_quad0 = dqs_clk_increment_wa1;
-        read_phase_value_quad0 = read_phase_value_wa1;
+	dqs_clk_increment_quad0 = dqs_clk_increment_wa1;
+	read_phase_value_quad0 = read_phase_value_wa1;
     }
     else if ( quad0_workaround_type == 2 )
     {
-        dqs_clk_increment_quad0 = dqs_clk_increment_wa2;
-        read_phase_value_quad0 = read_phase_value_wa2;
+	dqs_clk_increment_quad0 = dqs_clk_increment_wa2;
+	read_phase_value_quad0 = read_phase_value_wa2;
     }
 
     if ( quad1_workaround_type == 0 )
     {
-        dqs_clk_increment_quad1 = dqs_clk_increment_wa0;
-        read_phase_value_quad1 = read_phase_value_wa0;
+	dqs_clk_increment_quad1 = dqs_clk_increment_wa0;
+	read_phase_value_quad1 = read_phase_value_wa0;
     }
     else if ( quad1_workaround_type == 1 )
     {
-        dqs_clk_increment_quad1 = dqs_clk_increment_wa1;
-        read_phase_value_quad1 = read_phase_value_wa1;
+	dqs_clk_increment_quad1 = dqs_clk_increment_wa1;
+	read_phase_value_quad1 = read_phase_value_wa1;
     }
     else if ( quad1_workaround_type == 2 )
     {
-        dqs_clk_increment_quad1 = dqs_clk_increment_wa2;
-        read_phase_value_quad1 = read_phase_value_wa2;
+	dqs_clk_increment_quad1 = dqs_clk_increment_wa2;
+	read_phase_value_quad1 = read_phase_value_wa2;
     }
 
     if ( quad2_workaround_type == 0 )
     {
-        dqs_clk_increment_quad2 = dqs_clk_increment_wa0;
-        read_phase_value_quad2 = read_phase_value_wa0;
+	dqs_clk_increment_quad2 = dqs_clk_increment_wa0;
+	read_phase_value_quad2 = read_phase_value_wa0;
     }
     else if ( quad2_workaround_type == 1 )
     {
-        dqs_clk_increment_quad2 = dqs_clk_increment_wa1;
-        read_phase_value_quad2 = read_phase_value_wa1;
+	dqs_clk_increment_quad2 = dqs_clk_increment_wa1;
+	read_phase_value_quad2 = read_phase_value_wa1;
     }
     else if ( quad2_workaround_type == 2 )
     {
-        dqs_clk_increment_quad2 = dqs_clk_increment_wa2;
-        read_phase_value_quad2 = read_phase_value_wa2;
+	dqs_clk_increment_quad2 = dqs_clk_increment_wa2;
+	read_phase_value_quad2 = read_phase_value_wa2;
     }
 
     if ( quad3_workaround_type == 0 )
     {
-        dqs_clk_increment_quad3 = dqs_clk_increment_wa0;
-        read_phase_value_quad3 = read_phase_value_wa0;
+	dqs_clk_increment_quad3 = dqs_clk_increment_wa0;
+	read_phase_value_quad3 = read_phase_value_wa0;
     }
     else if ( quad3_workaround_type == 1 )
     {
-        dqs_clk_increment_quad3 = dqs_clk_increment_wa1;
-        read_phase_value_quad3 = read_phase_value_wa1;
+	dqs_clk_increment_quad3 = dqs_clk_increment_wa1;
+	read_phase_value_quad3 = read_phase_value_wa1;
     }
     else if ( quad3_workaround_type == 2 )
     {
-        dqs_clk_increment_quad3 = dqs_clk_increment_wa2;
-        read_phase_value_quad3 = read_phase_value_wa2;
+	dqs_clk_increment_quad3 = dqs_clk_increment_wa2;
+	read_phase_value_quad3 = read_phase_value_wa2;
     }
 
 
@@ -2119,661 +2261,661 @@ ReturnCode mss_read_center_second_workaround(
     {
 
 
-        //FAPI_INF( "DQS_CLK Byte matching Workaround being applied on  %s  PORT: %d RP: %d", i_target.toEcmdString(), port, rank_group);
+	//FAPI_INF( "DQS_CLK Byte matching Workaround being applied on  %s  PORT: %d RP: %d", i_target.toEcmdString(), port, rank_group);
 
-        //Gather all the byte information
+	//Gather all the byte information
         for(rank_group = 0; rank_group < MAX_PRI_RANKS; rank_group++)
-        {
-
-             //Initialize values
-             for(block = 0; block < maxblocks; block++)
-             {
-                for (byte = 0; byte < maxbytes; byte++)
-                {
-                        for (nibble = 0; nibble < maxnibbles; nibble++)
-                        {
-                                l_lowest_value_u8[rank_group][block][byte][nibble] = 255;
-                                l_gate_delay_value_u8[rank_group][block][byte][nibble] = 255;
-                        }
-                }
-             }
-
-            //Check if rank group exists
-            if(primary_ranks_array[rank_group][port] != 255)
-            {
-                FAPI_INF( "DQS_CLK Byte matching Workaround being applied on  %s  PORT: %d RP: %d", i_target.toEcmdString(), port, rank_group);
-                if ( port == 0 )
-                {
+	{
+
+	     //Initialize values
+	     for(block = 0; block < maxblocks; block++)
+	     {
+		for (byte = 0; byte < maxbytes; byte++)
+		{
+			for (nibble = 0; nibble < maxnibbles; nibble++)
+			{
+				l_lowest_value_u8[rank_group][block][byte][nibble] = 255;
+				l_gate_delay_value_u8[rank_group][block][byte][nibble] = 255;
+			}
+		}
+	     }
+
+	    //Check if rank group exists
+	    if(primary_ranks_array[rank_group][port] != 255)
+	    {
+	        FAPI_INF( "DQS_CLK Byte matching Workaround being applied on  %s  PORT: %d RP: %d", i_target.toEcmdString(), port, rank_group);
+    		if ( port == 0 )
+    		{
+
+			if ( rank_group == 0 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_0_0x800000090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_1_0x800004090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_2_0x800008090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_3_0x80000C090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_4_0x800010090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_0_0x800000130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_1_0x800004130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_2_0x800008130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_3_0x80000C130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_4_0x800010130301143F;
+
+			}
+			else if ( rank_group == 1 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_0_0x800001090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_1_0x800005090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_2_0x800009090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_3_0x80000D090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_4_0x800011090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_0_0x800001130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_1_0x800005130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_2_0x800009130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_3_0x80000D130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_4_0x800011130301143F;
+
+			}
+			else if ( rank_group == 2 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_0_0x800002090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_1_0x800006090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_2_0x80000A090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_3_0x80000E090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_4_0x800012090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_0_0x800002130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_1_0x800006130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_2_0x80000A130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_3_0x80000E130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_4_0x800012130301143F;
+
+			}
+			else if ( rank_group == 3 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_0_0x800003090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_1_0x800007090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_2_0x80000B090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_3_0x80000F090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_4_0x800013090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_0_0x800003130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_1_0x800007130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_2_0x80000B130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_3_0x80000F130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_4_0x800013130301143F;
+
+			}
+		    }
+		    else if (port == 1 )
+		    {
+
+			if ( rank_group == 0 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_0_0x800100090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_1_0x800104090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_2_0x800108090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_3_0x80010C090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_4_0x800110090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_0_0x800100130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_1_0x800104130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_2_0x800108130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_3_0x80010C130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_4_0x800110130301143F;
+
+			}
+			else if ( rank_group == 1 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_0_0x800101090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_1_0x800105090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_2_0x800109090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_3_0x80010D090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_4_0x800111090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_0_0x800101130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_1_0x800105130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_2_0x800109130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_3_0x80010D130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_4_0x800111130301143F;
+
+			}
+			else if ( rank_group == 2 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_0_0x800102090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_1_0x800106090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_2_0x80010A090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_3_0x80010E090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_4_0x800112090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_0_0x800102130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_1_0x800106130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_2_0x80010A130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_3_0x80010E130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_4_0x800112130301143F;
+
+			}
+			else if ( rank_group == 3 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_0_0x800103090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_1_0x800107090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_2_0x80010B090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_3_0x80010F090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_4_0x800113090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_0_0x800103130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_1_0x800107130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_2_0x80010B130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_3_0x80010F130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_4_0x800113130301143F;
+
+			}
+		    }
+
+
+		    // PHY BLOCK 0
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_0, data_buffer_64);
+		    if (rc) return rc;
+		    // Grabbing 2 nibbles of the same byte and making them equal to the same lowest value
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 2);
+		    l_lowest_value_u8[rank_group][0][0][0] = l_value_n0_u8;
+		    l_lowest_value_u8[rank_group][0][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 2);
+		    l_lowest_value_u8[rank_group][0][1][0] = l_value_n0_u8;
+		    l_lowest_value_u8[rank_group][0][1][1] = l_value_n1_u8;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_0, data_buffer_64);
+		    if (rc) return rc;
+		    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
+		    l_gate_delay_value_u8[rank_group][0][0][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][0][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
+		    l_gate_delay_value_u8[rank_group][0][1][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][0][1][1] = l_value_n1_u8;
+
+		    // PHY BLOCK 1
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_1, data_buffer_64);
+		    if (rc) return rc;
+		    // Grabbing 2 nibbles of the same byte and making them equal to the same lowest value
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 2);
+		    l_lowest_value_u8[rank_group][1][0][0] = l_value_n0_u8;
+		    l_lowest_value_u8[rank_group][1][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 2);
+		    l_lowest_value_u8[rank_group][1][1][0] = l_value_n0_u8;
+		    l_lowest_value_u8[rank_group][1][1][1] = l_value_n1_u8;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_1, data_buffer_64);
+		    if (rc) return rc;
+		    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
+		    l_gate_delay_value_u8[rank_group][1][0][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][1][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
+		    l_gate_delay_value_u8[rank_group][1][1][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][1][1][1] = l_value_n1_u8;
+
+		    // PHY BLOCK 2
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_2, data_buffer_64);
+		    if (rc) return rc;
+		    // Grabbing 2 nibbles of the same byte and making them equal to the same lowest value
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 2);
+		    l_lowest_value_u8[rank_group][2][0][0] = l_value_n0_u8;
+		    l_lowest_value_u8[rank_group][2][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 2);
+		    l_lowest_value_u8[rank_group][2][1][0] = l_value_n0_u8;
+		    l_lowest_value_u8[rank_group][2][1][1] = l_value_n1_u8;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_2, data_buffer_64);
+		    if (rc) return rc;
+		    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
+		    l_gate_delay_value_u8[rank_group][2][0][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][2][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
+		    l_gate_delay_value_u8[rank_group][2][1][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][2][1][1] = l_value_n1_u8;
+
+		    // PHY BLOCK 3
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_3, data_buffer_64);
+		    if (rc) return rc;
+		    // Grabbing 2 nibbles of the same byte and making them equal to the same lowest value
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 2);
+		    l_lowest_value_u8[rank_group][3][0][0] = l_value_n0_u8;
+		    l_lowest_value_u8[rank_group][3][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 2);
+		    l_lowest_value_u8[rank_group][3][1][0] = l_value_n0_u8;
+		    l_lowest_value_u8[rank_group][3][1][1] = l_value_n1_u8;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_3, data_buffer_64);
+		    if (rc) return rc;
+		    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
+		    l_gate_delay_value_u8[rank_group][3][0][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][3][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
+		    l_gate_delay_value_u8[rank_group][3][1][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][3][1][1] = l_value_n1_u8;
+
+		    // PHY BLOCK 4
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_4, data_buffer_64);
+		    if (rc) return rc;
+		    // Grabbing 2 nibbles of the same byte and making them equal to the same lowest value
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 2);
+		    l_lowest_value_u8[rank_group][4][0][0] = l_value_n0_u8;
+		    l_lowest_value_u8[rank_group][4][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 2);
+		    l_lowest_value_u8[rank_group][4][1][0] = l_value_n0_u8;
+		    l_lowest_value_u8[rank_group][4][1][1] = l_value_n1_u8;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_4, data_buffer_64);
+		    if (rc) return rc;
+		    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
+		    l_gate_delay_value_u8[rank_group][4][0][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][4][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
+		    l_gate_delay_value_u8[rank_group][4][1][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][4][1][1] = l_value_n1_u8;
+
+		    if(rc_num)
+		    {
+			rc.setEcmdError(rc_num);
+			return rc;
+		    }
+
+		}
+	}
+
+	//Finding the lowest Value
+        for(block = 0; block < maxblocks; block++)
+	{
+		for (byte = 0; byte < maxbytes; byte++)
+		{
+
+			for (nibble = 0; nibble < maxnibbles; nibble++)
+			{
+
+			    if ( (l_lowest_value_u8[0][block][byte][nibble] == 0) ||
+				 (l_lowest_value_u8[1][block][byte][nibble] == 0) ||
+				 (l_lowest_value_u8[2][block][byte][nibble] == 0) ||
+				 (l_lowest_value_u8[3][block][byte][nibble] == 0) )
+			    {
+				    if ( (l_lowest_value_u8[0][block][byte][nibble] == 3) ||
+					 (l_lowest_value_u8[1][block][byte][nibble] == 3) ||
+					 (l_lowest_value_u8[2][block][byte][nibble] == 3) ||
+					 (l_lowest_value_u8[3][block][byte][nibble] == 3) )
+				    {
+
+					//In this case alone we make all gate values equal the gate of the lowest DQSCLK
+					if (l_lowest_value_u8[0][block][byte][nibble] == 3)
+					{
+						l_gate_delay_value_u8[1][block][byte][nibble] = l_gate_delay_value_u8[0][block][byte][nibble];
+						l_gate_delay_value_u8[2][block][byte][nibble] = l_gate_delay_value_u8[0][block][byte][nibble];
+						l_gate_delay_value_u8[3][block][byte][nibble] = l_gate_delay_value_u8[0][block][byte][nibble];
+					}
+					else if (l_lowest_value_u8[1][block][byte][nibble] == 3)
+					{
+						l_gate_delay_value_u8[0][block][byte][nibble] = l_gate_delay_value_u8[1][block][byte][nibble];
+						l_gate_delay_value_u8[2][block][byte][nibble] = l_gate_delay_value_u8[1][block][byte][nibble];
+						l_gate_delay_value_u8[3][block][byte][nibble] = l_gate_delay_value_u8[1][block][byte][nibble];
+					}
+					else if (l_lowest_value_u8[2][block][byte][nibble] == 3)
+					{
+						l_gate_delay_value_u8[0][block][byte][nibble] = l_gate_delay_value_u8[2][block][byte][nibble];
+						l_gate_delay_value_u8[1][block][byte][nibble] = l_gate_delay_value_u8[2][block][byte][nibble];
+						l_gate_delay_value_u8[3][block][byte][nibble] = l_gate_delay_value_u8[2][block][byte][nibble];
+					}
+					else if (l_lowest_value_u8[3][block][byte][nibble] == 3)
+					{
+						l_gate_delay_value_u8[0][block][byte][nibble] = l_gate_delay_value_u8[3][block][byte][nibble];
+						l_gate_delay_value_u8[1][block][byte][nibble] = l_gate_delay_value_u8[3][block][byte][nibble];
+						l_gate_delay_value_u8[2][block][byte][nibble] = l_gate_delay_value_u8[3][block][byte][nibble];
+					}
+
+					l_lowest_value_u8[0][block][byte][nibble] = 3;
+					l_lowest_value_u8[1][block][byte][nibble] = 3;
+					l_lowest_value_u8[2][block][byte][nibble] = 3;
+					l_lowest_value_u8[3][block][byte][nibble] = 3;
+				    }
+				    else
+				    {
+					l_lowest_value_u8[0][block][byte][nibble] = 0;
+					l_lowest_value_u8[1][block][byte][nibble] = 0;
+					l_lowest_value_u8[2][block][byte][nibble] = 0;
+					l_lowest_value_u8[3][block][byte][nibble] = 0;
+
+				    }
+			    }
+			    else if ( (l_lowest_value_u8[0][block][byte][nibble] == 2) ||
+				    (l_lowest_value_u8[1][block][byte][nibble] == 2) ||
+				    (l_lowest_value_u8[2][block][byte][nibble] == 2) ||
+				    (l_lowest_value_u8[3][block][byte][nibble] == 2) )
+			    {
+				    if ( (l_lowest_value_u8[0][block][byte][nibble] == 1) ||
+					 (l_lowest_value_u8[1][block][byte][nibble] == 1) ||
+					 (l_lowest_value_u8[2][block][byte][nibble] == 1) ||
+					 (l_lowest_value_u8[3][block][byte][nibble] == 1) )
+				    {
+					l_lowest_value_u8[0][block][byte][nibble] = 1;
+					l_lowest_value_u8[1][block][byte][nibble] = 1;
+					l_lowest_value_u8[2][block][byte][nibble] = 1;
+					l_lowest_value_u8[3][block][byte][nibble] = 1;
+
+				    }
+				    else
+				    {
+					l_lowest_value_u8[0][block][byte][nibble] = 2;
+					l_lowest_value_u8[1][block][byte][nibble] = 2;
+					l_lowest_value_u8[2][block][byte][nibble] = 2;
+					l_lowest_value_u8[3][block][byte][nibble] = 2;
+
+				    }
+			    }
+
+			}
+		}
+
+	}
+
+
+	//Scoming in the New Values
+        for(rank_group = 0; rank_group < MAX_PRI_RANKS; rank_group++)
+	{
+
+	    //Check if rank group exists
+	    if(primary_ranks_array[rank_group][port] != 255)
+	    {
+
+    		if ( port == 0 )
+    		{
+
+			if ( rank_group == 0 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_0_0x800000090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_1_0x800004090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_2_0x800008090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_3_0x80000C090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_4_0x800010090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_0_0x800000130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_1_0x800004130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_2_0x800008130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_3_0x80000C130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_4_0x800010130301143F;
+
+			}
+			else if ( rank_group == 1 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_0_0x800001090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_1_0x800005090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_2_0x800009090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_3_0x80000D090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_4_0x800011090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_0_0x800001130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_1_0x800005130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_2_0x800009130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_3_0x80000D130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_4_0x800011130301143F;
+
+			}
+			else if ( rank_group == 2 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_0_0x800002090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_1_0x800006090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_2_0x80000A090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_3_0x80000E090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_4_0x800012090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_0_0x800002130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_1_0x800006130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_2_0x80000A130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_3_0x80000E130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_4_0x800012130301143F;
+
+			}
+			else if ( rank_group == 3 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_0_0x800003090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_1_0x800007090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_2_0x80000B090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_3_0x80000F090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_4_0x800013090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_0_0x800003130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_1_0x800007130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_2_0x80000B130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_3_0x80000F130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_4_0x800013130301143F;
+
+			}
+		    }
+		    else if (port == 1 )
+		    {
+
+			if ( rank_group == 0 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_0_0x800100090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_1_0x800104090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_2_0x800108090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_3_0x80010C090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_4_0x800110090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_0_0x800100130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_1_0x800104130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_2_0x800108130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_3_0x80010C130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_4_0x800110130301143F;
+
+			}
+			else if ( rank_group == 1 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_0_0x800101090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_1_0x800105090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_2_0x800109090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_3_0x80010D090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_4_0x800111090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_0_0x800101130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_1_0x800105130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_2_0x800109130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_3_0x80010D130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_4_0x800111130301143F;
+
+			}
+			else if ( rank_group == 2 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_0_0x800102090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_1_0x800106090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_2_0x80010A090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_3_0x80010E090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_4_0x800112090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_0_0x800102130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_1_0x800106130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_2_0x80010A130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_3_0x80010E130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_4_0x800112130301143F;
+
+			}
+			else if ( rank_group == 3 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_0_0x800103090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_1_0x800107090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_2_0x80010B090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_3_0x80010F090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_4_0x800113090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_0_0x800103130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_1_0x800107130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_2_0x80010B130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_3_0x80010F130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_4_0x800113130301143F;
+
+			}
+		    }
+
+		    //BLOCK 0
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_0, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][0][0][0], 48, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][0][0][1], 52, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][0][1][0], 56, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][0][1][1], 60, 2);
+		    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_0, data_buffer_64);
+		    if (rc) return rc;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_0, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][0][0], 49, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][0][1], 53, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][1][0], 57, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][1][1], 61, 3);
+		    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_0, data_buffer_64);
+		    if (rc) return rc;
+
+		    //BLOCK 1
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_1, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][1][0][0], 48, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][1][0][1], 52, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][1][1][0], 56, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][1][1][1], 60, 2);
+		    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_1, data_buffer_64);
+		    if (rc) return rc;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_1, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][0][0], 49, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][0][1], 53, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][1][0], 57, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][1][1], 61, 3);
+		    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_1, data_buffer_64);
+		    if (rc) return rc;
+
+		    //BLOCK 2
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_2, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][2][0][0], 48, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][2][0][1], 52, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][2][1][0], 56, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][2][1][1], 60, 2);
+		    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_2, data_buffer_64);
+		    if (rc) return rc;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_2, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][0][0], 49, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][0][1], 53, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][1][0], 57, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][1][1], 61, 3);
+		    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_2, data_buffer_64);
+		    if (rc) return rc;
+
+		    //BLOCK 3
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_3, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][3][0][0], 48, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][3][0][1], 52, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][3][1][0], 56, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][3][1][1], 60, 2);
+		    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_3, data_buffer_64);
+		    if (rc) return rc;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_3, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][0][0], 49, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][0][1], 53, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][1][0], 57, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][1][1], 61, 3);
+		    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_3, data_buffer_64);
+		    if (rc) return rc;
+
+		    //Block 4
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_4, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][4][0][0], 48, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][4][0][1], 52, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][4][1][0], 56, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][4][1][1], 60, 2);
+		    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_4, data_buffer_64);
+		    if (rc) return rc;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_4, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][0][0], 49, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][0][1], 53, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][1][0], 57, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][1][1], 61, 3);
+
+		    if(rc_num)
+		    {
+			rc.setEcmdError(rc_num);
+			return rc;
+		    }
+
+		    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_4, data_buffer_64);
+		    if (rc) return rc;
+
+		}
+	}
+    }
 
-                        if ( rank_group == 0 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_0_0x800000090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_1_0x800004090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_2_0x800008090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_3_0x80000C090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_4_0x800010090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_0_0x800000130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_1_0x800004130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_2_0x800008130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_3_0x80000C130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_4_0x800010130301143F;
+    return rc;
+}
 
-                        }
-                        else if ( rank_group == 1 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_0_0x800001090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_1_0x800005090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_2_0x800009090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_3_0x80000D090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_4_0x800011090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_0_0x800001130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_1_0x800005130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_2_0x800009130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_3_0x80000D130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_4_0x800011130301143F;
 
-                        }
-                        else if ( rank_group == 2 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_0_0x800002090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_1_0x800006090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_2_0x80000A090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_3_0x80000E090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_4_0x800012090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_0_0x800002130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_1_0x800006130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_2_0x80000A130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_3_0x80000E130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_4_0x800012130301143F;
+ReturnCode mss_disable_workaround(
+            Target& i_target
+            )
+{
+    //MBA target level
+    //DQS_CLK for each nibble of a byte is being adjusted to the lowest value for the given byte
+    //Across all byte lanes
 
-                        }
-                        else if ( rank_group == 3 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_0_0x800003090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_1_0x800007090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_2_0x80000B090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_3_0x80000F090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_4_0x800013090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_0_0x800003130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_1_0x800007130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_2_0x80000B130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_3_0x80000F130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_4_0x800013130301143F;
+    uint8_t primary_ranks_array[4][2]; //primary_ranks_array[group][port]
+    ecmdDataBufferBase data_buffer_64(64);
+    uint64_t DQSCLK_RD_PHASE_ADDR_0 = 0;
+    uint64_t DQSCLK_RD_PHASE_ADDR_1 = 0;
+    uint64_t DQSCLK_RD_PHASE_ADDR_2 = 0;
+    uint64_t DQSCLK_RD_PHASE_ADDR_3 = 0;
+    uint64_t DQSCLK_RD_PHASE_ADDR_4 = 0;
+    uint64_t DISABLE_ADDR_0 = 0;
+    uint64_t DISABLE_ADDR_1 = 0;
+    uint64_t DISABLE_ADDR_2 = 0;
+    uint64_t DISABLE_ADDR_3 = 0;
+    uint64_t DISABLE_ADDR_4 = 0;
+    uint64_t GATE_DELAY_ADDR_0 = 0;
+    uint64_t GATE_DELAY_ADDR_1 = 0;
+    uint64_t GATE_DELAY_ADDR_2 = 0;
+    uint64_t GATE_DELAY_ADDR_3 = 0;
+    uint64_t GATE_DELAY_ADDR_4 = 0;
+    uint8_t port = 0;
+    uint8_t rank_group = 0;
+    uint8_t l_value_n0_u8 = 0;
+    uint8_t l_value_n1_u8 = 0;
+    //uint8_t l_lowest_value_u8 = 0;
+    ReturnCode rc;
+    uint32_t rc_num = 0;
 
-                        }
-                    }
-                    else if (port == 1 )
-                    {
+    uint32_t block;
+    uint32_t maxblocks = 5;
+    uint32_t byte;
+    uint32_t maxbytes = 2;
+    uint32_t nibble;
+    uint32_t maxnibbles = 2;
+    uint8_t l_min_gate_delay = 255; 
+    uint8_t l_min_dqs_clk = 255; 
 
-                        if ( rank_group == 0 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_0_0x800100090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_1_0x800104090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_2_0x800108090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_3_0x80010C090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_4_0x800110090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_0_0x800100130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_1_0x800104130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_2_0x800108130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_3_0x80010C130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_4_0x800110130301143F;
-
-                        }
-                        else if ( rank_group == 1 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_0_0x800101090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_1_0x800105090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_2_0x800109090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_3_0x80010D090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_4_0x800111090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_0_0x800101130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_1_0x800105130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_2_0x800109130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_3_0x80010D130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_4_0x800111130301143F;
-
-                        }
-                        else if ( rank_group == 2 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_0_0x800102090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_1_0x800106090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_2_0x80010A090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_3_0x80010E090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_4_0x800112090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_0_0x800102130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_1_0x800106130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_2_0x80010A130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_3_0x80010E130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_4_0x800112130301143F;
-
-                        }
-                        else if ( rank_group == 3 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_0_0x800103090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_1_0x800107090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_2_0x80010B090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_3_0x80010F090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_4_0x800113090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_0_0x800103130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_1_0x800107130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_2_0x80010B130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_3_0x80010F130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_4_0x800113130301143F;
-
-                        }
-                    }
-
-
-                    // PHY BLOCK 0
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_0, data_buffer_64);
-                    if (rc) return rc;
-                    // Grabbing 2 nibbles of the same byte and making them equal to the same lowest value
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 2);
-                    l_lowest_value_u8[rank_group][0][0][0] = l_value_n0_u8;
-                    l_lowest_value_u8[rank_group][0][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 2);
-                    l_lowest_value_u8[rank_group][0][1][0] = l_value_n0_u8;
-                    l_lowest_value_u8[rank_group][0][1][1] = l_value_n1_u8;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_0, data_buffer_64);
-                    if (rc) return rc;
-                    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
-                    l_gate_delay_value_u8[rank_group][0][0][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][0][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
-                    l_gate_delay_value_u8[rank_group][0][1][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][0][1][1] = l_value_n1_u8;
-
-                    // PHY BLOCK 1
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_1, data_buffer_64);
-                    if (rc) return rc;
-                    // Grabbing 2 nibbles of the same byte and making them equal to the same lowest value
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 2);
-                    l_lowest_value_u8[rank_group][1][0][0] = l_value_n0_u8;
-                    l_lowest_value_u8[rank_group][1][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 2);
-                    l_lowest_value_u8[rank_group][1][1][0] = l_value_n0_u8;
-                    l_lowest_value_u8[rank_group][1][1][1] = l_value_n1_u8;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_1, data_buffer_64);
-                    if (rc) return rc;
-                    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
-                    l_gate_delay_value_u8[rank_group][1][0][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][1][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
-                    l_gate_delay_value_u8[rank_group][1][1][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][1][1][1] = l_value_n1_u8;
-
-                    // PHY BLOCK 2
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_2, data_buffer_64);
-                    if (rc) return rc;
-                    // Grabbing 2 nibbles of the same byte and making them equal to the same lowest value
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 2);
-                    l_lowest_value_u8[rank_group][2][0][0] = l_value_n0_u8;
-                    l_lowest_value_u8[rank_group][2][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 2);
-                    l_lowest_value_u8[rank_group][2][1][0] = l_value_n0_u8;
-                    l_lowest_value_u8[rank_group][2][1][1] = l_value_n1_u8;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_2, data_buffer_64);
-                    if (rc) return rc;
-                    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
-                    l_gate_delay_value_u8[rank_group][2][0][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][2][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
-                    l_gate_delay_value_u8[rank_group][2][1][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][2][1][1] = l_value_n1_u8;
-
-                    // PHY BLOCK 3
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_3, data_buffer_64);
-                    if (rc) return rc;
-                    // Grabbing 2 nibbles of the same byte and making them equal to the same lowest value
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 2);
-                    l_lowest_value_u8[rank_group][3][0][0] = l_value_n0_u8;
-                    l_lowest_value_u8[rank_group][3][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 2);
-                    l_lowest_value_u8[rank_group][3][1][0] = l_value_n0_u8;
-                    l_lowest_value_u8[rank_group][3][1][1] = l_value_n1_u8;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_3, data_buffer_64);
-                    if (rc) return rc;
-                    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
-                    l_gate_delay_value_u8[rank_group][3][0][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][3][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
-                    l_gate_delay_value_u8[rank_group][3][1][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][3][1][1] = l_value_n1_u8;
-
-                    // PHY BLOCK 4
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_4, data_buffer_64);
-                    if (rc) return rc;
-                    // Grabbing 2 nibbles of the same byte and making them equal to the same lowest value
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 2);
-                    l_lowest_value_u8[rank_group][4][0][0] = l_value_n0_u8;
-                    l_lowest_value_u8[rank_group][4][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 2);
-                    l_lowest_value_u8[rank_group][4][1][0] = l_value_n0_u8;
-                    l_lowest_value_u8[rank_group][4][1][1] = l_value_n1_u8;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_4, data_buffer_64);
-                    if (rc) return rc;
-                    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
-                    l_gate_delay_value_u8[rank_group][4][0][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][4][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
-                    l_gate_delay_value_u8[rank_group][4][1][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][4][1][1] = l_value_n1_u8;
-
-                    if(rc_num)
-                    {
-                        rc.setEcmdError(rc_num);
-                        return rc;
-                    }
-
-                }
-        }
-
-        //Finding the lowest Value
-        for(block = 0; block < maxblocks; block++)
-        {
-                for (byte = 0; byte < maxbytes; byte++)
-                {
-
-                        for (nibble = 0; nibble < maxnibbles; nibble++)
-                        {
-
-                            if ( (l_lowest_value_u8[0][block][byte][nibble] == 0) ||
-                                 (l_lowest_value_u8[1][block][byte][nibble] == 0) ||
-                                 (l_lowest_value_u8[2][block][byte][nibble] == 0) ||
-                                 (l_lowest_value_u8[3][block][byte][nibble] == 0) )
-                            {
-                                    if ( (l_lowest_value_u8[0][block][byte][nibble] == 3) ||
-                                         (l_lowest_value_u8[1][block][byte][nibble] == 3) ||
-                                         (l_lowest_value_u8[2][block][byte][nibble] == 3) ||
-                                         (l_lowest_value_u8[3][block][byte][nibble] == 3) )
-                                    {
-
-                                        //In this case alone we make all gate values equal the gate of the lowest DQSCLK
-                                        if (l_lowest_value_u8[0][block][byte][nibble] == 3)
-                                        {
-                                                l_gate_delay_value_u8[1][block][byte][nibble] = l_gate_delay_value_u8[0][block][byte][nibble];
-                                                l_gate_delay_value_u8[2][block][byte][nibble] = l_gate_delay_value_u8[0][block][byte][nibble];
-                                                l_gate_delay_value_u8[3][block][byte][nibble] = l_gate_delay_value_u8[0][block][byte][nibble];
-                                        }
-                                        else if (l_lowest_value_u8[1][block][byte][nibble] == 3)
-                                        {
-                                                l_gate_delay_value_u8[0][block][byte][nibble] = l_gate_delay_value_u8[1][block][byte][nibble];
-                                                l_gate_delay_value_u8[2][block][byte][nibble] = l_gate_delay_value_u8[1][block][byte][nibble];
-                                                l_gate_delay_value_u8[3][block][byte][nibble] = l_gate_delay_value_u8[1][block][byte][nibble];
-                                        }
-                                        else if (l_lowest_value_u8[2][block][byte][nibble] == 3)
-                                        {
-                                                l_gate_delay_value_u8[0][block][byte][nibble] = l_gate_delay_value_u8[2][block][byte][nibble];
-                                                l_gate_delay_value_u8[1][block][byte][nibble] = l_gate_delay_value_u8[2][block][byte][nibble];
-                                                l_gate_delay_value_u8[3][block][byte][nibble] = l_gate_delay_value_u8[2][block][byte][nibble];
-                                        }
-                                        else if (l_lowest_value_u8[3][block][byte][nibble] == 3)
-                                        {
-                                                l_gate_delay_value_u8[0][block][byte][nibble] = l_gate_delay_value_u8[3][block][byte][nibble];
-                                                l_gate_delay_value_u8[1][block][byte][nibble] = l_gate_delay_value_u8[3][block][byte][nibble];
-                                                l_gate_delay_value_u8[2][block][byte][nibble] = l_gate_delay_value_u8[3][block][byte][nibble];
-                                        }
-
-                                        l_lowest_value_u8[0][block][byte][nibble] = 3;
-                                        l_lowest_value_u8[1][block][byte][nibble] = 3;
-                                        l_lowest_value_u8[2][block][byte][nibble] = 3;
-                                        l_lowest_value_u8[3][block][byte][nibble] = 3;
-                                    }
-                                    else
-                                    {
-                                        l_lowest_value_u8[0][block][byte][nibble] = 0;
-                                        l_lowest_value_u8[1][block][byte][nibble] = 0;
-                                        l_lowest_value_u8[2][block][byte][nibble] = 0;
-                                        l_lowest_value_u8[3][block][byte][nibble] = 0;
-
-                                    }
-                            }
-                            else if ( (l_lowest_value_u8[0][block][byte][nibble] == 2) ||
-                                    (l_lowest_value_u8[1][block][byte][nibble] == 2) ||
-                                    (l_lowest_value_u8[2][block][byte][nibble] == 2) ||
-                                    (l_lowest_value_u8[3][block][byte][nibble] == 2) )
-                            {
-                                    if ( (l_lowest_value_u8[0][block][byte][nibble] == 1) ||
-                                         (l_lowest_value_u8[1][block][byte][nibble] == 1) ||
-                                         (l_lowest_value_u8[2][block][byte][nibble] == 1) ||
-                                         (l_lowest_value_u8[3][block][byte][nibble] == 1) )
-                                    {
-                                        l_lowest_value_u8[0][block][byte][nibble] = 1;
-                                        l_lowest_value_u8[1][block][byte][nibble] = 1;
-                                        l_lowest_value_u8[2][block][byte][nibble] = 1;
-                                        l_lowest_value_u8[3][block][byte][nibble] = 1;
-
-                                    }
-                                    else
-                                    {
-                                        l_lowest_value_u8[0][block][byte][nibble] = 2;
-                                        l_lowest_value_u8[1][block][byte][nibble] = 2;
-                                        l_lowest_value_u8[2][block][byte][nibble] = 2;
-                                        l_lowest_value_u8[3][block][byte][nibble] = 2;
-
-                                    }
-                            }
-
-                        }
-                }
-
-        }
-
-
-        //Scoming in the New Values
-        for(rank_group = 0; rank_group < MAX_PRI_RANKS; rank_group++)
-        {
-
-            //Check if rank group exists
-            if(primary_ranks_array[rank_group][port] != 255)
-            {
-
-                if ( port == 0 )
-                {
-
-                        if ( rank_group == 0 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_0_0x800000090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_1_0x800004090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_2_0x800008090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_3_0x80000C090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_4_0x800010090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_0_0x800000130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_1_0x800004130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_2_0x800008130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_3_0x80000C130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_4_0x800010130301143F;
-
-                        }
-                        else if ( rank_group == 1 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_0_0x800001090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_1_0x800005090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_2_0x800009090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_3_0x80000D090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_4_0x800011090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_0_0x800001130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_1_0x800005130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_2_0x800009130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_3_0x80000D130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_4_0x800011130301143F;
-
-                        }
-                        else if ( rank_group == 2 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_0_0x800002090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_1_0x800006090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_2_0x80000A090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_3_0x80000E090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_4_0x800012090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_0_0x800002130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_1_0x800006130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_2_0x80000A130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_3_0x80000E130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_4_0x800012130301143F;
-
-                        }
-                        else if ( rank_group == 3 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_0_0x800003090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_1_0x800007090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_2_0x80000B090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_3_0x80000F090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_4_0x800013090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_0_0x800003130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_1_0x800007130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_2_0x80000B130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_3_0x80000F130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_4_0x800013130301143F;
-
-                        }
-                    }
-                    else if (port == 1 )
-                    {
-
-                        if ( rank_group == 0 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_0_0x800100090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_1_0x800104090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_2_0x800108090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_3_0x80010C090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_4_0x800110090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_0_0x800100130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_1_0x800104130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_2_0x800108130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_3_0x80010C130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_4_0x800110130301143F;
-
-                        }
-                        else if ( rank_group == 1 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_0_0x800101090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_1_0x800105090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_2_0x800109090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_3_0x80010D090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_4_0x800111090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_0_0x800101130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_1_0x800105130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_2_0x800109130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_3_0x80010D130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_4_0x800111130301143F;
-
-                        }
-                        else if ( rank_group == 2 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_0_0x800102090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_1_0x800106090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_2_0x80010A090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_3_0x80010E090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_4_0x800112090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_0_0x800102130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_1_0x800106130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_2_0x80010A130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_3_0x80010E130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_4_0x800112130301143F;
-
-                        }
-                        else if ( rank_group == 3 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_0_0x800103090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_1_0x800107090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_2_0x80010B090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_3_0x80010F090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_4_0x800113090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_0_0x800103130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_1_0x800107130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_2_0x80010B130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_3_0x80010F130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_4_0x800113130301143F;
-
-                        }
-                    }
-
-                    //BLOCK 0
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_0, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][0][0][0], 48, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][0][0][1], 52, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][0][1][0], 56, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][0][1][1], 60, 2);
-                    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_0, data_buffer_64);
-                    if (rc) return rc;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_0, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][0][0], 49, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][0][1], 53, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][1][0], 57, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][1][1], 61, 3);
-                    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_0, data_buffer_64);
-                    if (rc) return rc;
-
-                    //BLOCK 1
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_1, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][1][0][0], 48, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][1][0][1], 52, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][1][1][0], 56, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][1][1][1], 60, 2);
-                    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_1, data_buffer_64);
-                    if (rc) return rc;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_1, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][0][0], 49, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][0][1], 53, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][1][0], 57, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][1][1], 61, 3);
-                    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_1, data_buffer_64);
-                    if (rc) return rc;
-
-                    //BLOCK 2
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_2, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][2][0][0], 48, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][2][0][1], 52, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][2][1][0], 56, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][2][1][1], 60, 2);
-                    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_2, data_buffer_64);
-                    if (rc) return rc;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_2, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][0][0], 49, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][0][1], 53, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][1][0], 57, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][1][1], 61, 3);
-                    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_2, data_buffer_64);
-                    if (rc) return rc;
-
-                    //BLOCK 3
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_3, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][3][0][0], 48, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][3][0][1], 52, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][3][1][0], 56, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][3][1][1], 60, 2);
-                    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_3, data_buffer_64);
-                    if (rc) return rc;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_3, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][0][0], 49, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][0][1], 53, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][1][0], 57, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][1][1], 61, 3);
-                    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_3, data_buffer_64);
-                    if (rc) return rc;
-
-                    //Block 4
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_4, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][4][0][0], 48, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][4][0][1], 52, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][4][1][0], 56, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][4][1][1], 60, 2);
-                    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_4, data_buffer_64);
-                    if (rc) return rc;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_4, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][0][0], 49, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][0][1], 53, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][1][0], 57, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][1][1], 61, 3);
-
-                    if(rc_num)
-                    {
-                        rc.setEcmdError(rc_num);
-                        return rc;
-                    }
-
-                    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_4, data_buffer_64);
-                    if (rc) return rc;
-
-                }
-        }
-    }
-
-    return rc;
-}
-
-
-ReturnCode mss_disable_workaround(
-            Target& i_target
-            )
-{
-    //MBA target level
-    //DQS_CLK for each nibble of a byte is being adjusted to the lowest value for the given byte
-    //Across all byte lanes
-
-    uint8_t primary_ranks_array[4][2]; //primary_ranks_array[group][port]
-    ecmdDataBufferBase data_buffer_64(64);
-    uint64_t DQSCLK_RD_PHASE_ADDR_0 = 0;
-    uint64_t DQSCLK_RD_PHASE_ADDR_1 = 0;
-    uint64_t DQSCLK_RD_PHASE_ADDR_2 = 0;
-    uint64_t DQSCLK_RD_PHASE_ADDR_3 = 0;
-    uint64_t DQSCLK_RD_PHASE_ADDR_4 = 0;
-    uint64_t DISABLE_ADDR_0 = 0;
-    uint64_t DISABLE_ADDR_1 = 0;
-    uint64_t DISABLE_ADDR_2 = 0;
-    uint64_t DISABLE_ADDR_3 = 0;
-    uint64_t DISABLE_ADDR_4 = 0;
-    uint64_t GATE_DELAY_ADDR_0 = 0;
-    uint64_t GATE_DELAY_ADDR_1 = 0;
-    uint64_t GATE_DELAY_ADDR_2 = 0;
-    uint64_t GATE_DELAY_ADDR_3 = 0;
-    uint64_t GATE_DELAY_ADDR_4 = 0;
-    uint8_t port = 0;
-    uint8_t rank_group = 0;
-    uint8_t l_value_n0_u8 = 0;
-    uint8_t l_value_n1_u8 = 0;
-    //uint8_t l_lowest_value_u8 = 0;
-    ReturnCode rc;
-    uint32_t rc_num = 0;
-
-    uint32_t block;
-    uint32_t maxblocks = 5;
-    uint32_t byte;
-    uint32_t maxbytes = 2;
-    uint32_t nibble;
-    uint32_t maxnibbles = 2;
-    uint8_t l_min_gate_delay = 255;
-    uint8_t l_min_dqs_clk = 255;
-
-    uint8_t l_lowest_value_u8[4][5][2][2]; // l_lowest_value_u8[group][block][byte_of_reg][nibble_of_byte]
-    uint8_t l_gate_delay_value_u8[4][5][2][2]; // l_lowest_value_u8[group][block][byte_of_reg][nibble_of_byte]
-    uint8_t l_disable_value_u8[4][5][2][2];
+    uint8_t l_lowest_value_u8[4][5][2][2]; // l_lowest_value_u8[group][block][byte_of_reg][nibble_of_byte]
+    uint8_t l_gate_delay_value_u8[4][5][2][2]; // l_lowest_value_u8[group][block][byte_of_reg][nibble_of_byte]
+    uint8_t l_disable_value_u8[4][5][2][2];
 
 
     //populate primary_ranks_arrays_array
@@ -2791,705 +2933,705 @@ ReturnCode mss_disable_workaround(
     {
 
 
-        //FAPI_INF( "DQS_CLK Byte matching Workaround being applied on  %s  PORT: %d RP: %d", i_target.toEcmdString(), port, rank_group);
+	//FAPI_INF( "DQS_CLK Byte matching Workaround being applied on  %s  PORT: %d RP: %d", i_target.toEcmdString(), port, rank_group);
 
-        //Gather all the byte information
+	//Gather all the byte information
         for(rank_group = 0; rank_group < MAX_PRI_RANKS; rank_group++)
-        {
-
-             //Initialize values
-             for(block = 0; block < maxblocks; block++)
-             {
-                for (byte = 0; byte < maxbytes; byte++)
-                {
-                        for (nibble = 0; nibble < maxnibbles; nibble++)
-                        {
-                                l_lowest_value_u8[rank_group][block][byte][nibble] = 255;
-                                l_gate_delay_value_u8[rank_group][block][byte][nibble] = 255;
-                                l_disable_value_u8[rank_group][block][byte][nibble] = 0;
-                        }
-                }
-             }
-
-            //Check if rank group exists
-            if(primary_ranks_array[rank_group][port] != 255)
-            {
-                FAPI_INF( "DISABLE Workaround being applied on  %s  PORT: %d RP: %d", i_target.toEcmdString(), port, rank_group);
-                if ( port == 0 )
-                {
-
-                        if ( rank_group == 0 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_0_0x800000090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_1_0x800004090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_2_0x800008090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_3_0x80000C090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_4_0x800010090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_0_0x800000130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_1_0x800004130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_2_0x800008130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_3_0x80000C130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_4_0x800010130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_0_0x8000007c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_1_0x8000047c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_2_0x8000087c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_3_0x80000c7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_4_0x8000107c0301143F;
-
-
-                        }
-                        else if ( rank_group == 1 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_0_0x800001090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_1_0x800005090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_2_0x800009090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_3_0x80000D090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_4_0x800011090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_0_0x800001130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_1_0x800005130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_2_0x800009130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_3_0x80000D130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_4_0x800011130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_0_0x8000017c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_1_0x8000057c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_2_0x8000097c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_3_0x80000d7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_4_0x8000117c0301143F;
-
-                        }
-                        else if ( rank_group == 2 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_0_0x800002090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_1_0x800006090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_2_0x80000A090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_3_0x80000E090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_4_0x800012090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_0_0x800002130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_1_0x800006130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_2_0x80000A130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_3_0x80000E130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_4_0x800012130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_0_0x8000027c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_1_0x8000067c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_2_0x80000a7c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_3_0x80000e7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_4_0x8000127c0301143F;
-
-                        }
-                        else if ( rank_group == 3 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_0_0x800003090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_1_0x800007090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_2_0x80000B090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_3_0x80000F090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_4_0x800013090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_0_0x800003130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_1_0x800007130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_2_0x80000B130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_3_0x80000F130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_4_0x800013130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_0_0x8000037c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_1_0x8000077c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_2_0x80000b7c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_3_0x80000f7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_4_0x8000137c0301143F;
-
-                        }
-                    }
-                    else if (port == 1 )
-                    {
-
-                        if ( rank_group == 0 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_0_0x800100090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_1_0x800104090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_2_0x800108090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_3_0x80010C090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_4_0x800110090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_0_0x800100130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_1_0x800104130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_2_0x800108130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_3_0x80010C130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_4_0x800110130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_0_0x8001007c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_1_0x8001047c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_2_0x8001087c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_3_0x80010c7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_4_0x8001107c0301143F;
-
-                        }
-                        else if ( rank_group == 1 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_0_0x800101090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_1_0x800105090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_2_0x800109090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_3_0x80010D090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_4_0x800111090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_0_0x800101130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_1_0x800105130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_2_0x800109130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_3_0x80010D130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_4_0x800111130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_0_0x8001017c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_1_0x8001057c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_2_0x8001097c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_3_0x80010d7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_4_0x8001117c0301143F;
-
-                        }
-                        else if ( rank_group == 2 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_0_0x800102090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_1_0x800106090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_2_0x80010A090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_3_0x80010E090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_4_0x800112090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_0_0x800102130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_1_0x800106130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_2_0x80010A130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_3_0x80010E130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_4_0x800112130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_0_0x8001027c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_1_0x8001067c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_2_0x80010a7c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_3_0x80010e7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_4_0x8001127c0301143F;
-
-                        }
-                        else if ( rank_group == 3 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_0_0x800103090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_1_0x800107090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_2_0x80010B090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_3_0x80010F090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_4_0x800113090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_0_0x800103130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_1_0x800107130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_2_0x80010B130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_3_0x80010F130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_4_0x800113130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_0_0x8001037c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_1_0x8001077c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_2_0x80010b7c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_3_0x80010f7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_4_0x8001137c0301143F;
-
-                        }
-                    }
-
-
-                    // PHY BLOCK 0
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_0, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 50, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 54, 2);
-                    l_lowest_value_u8[rank_group][0][0][0] = l_value_n0_u8;
-                    l_lowest_value_u8[rank_group][0][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 58, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 62, 2);
-                    l_lowest_value_u8[rank_group][0][1][0] = l_value_n0_u8;
-                    l_lowest_value_u8[rank_group][0][1][1] = l_value_n1_u8;
-
-                    rc = fapiGetScom(i_target, DISABLE_ADDR_0, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 4);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 4);
-                    l_disable_value_u8[rank_group][0][0][0] = l_value_n0_u8;
-                    l_disable_value_u8[rank_group][0][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 4);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 4);
-                    l_disable_value_u8[rank_group][0][1][0] = l_value_n0_u8;
-                    l_disable_value_u8[rank_group][0][1][1] = l_value_n1_u8;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_0, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
-                    l_gate_delay_value_u8[rank_group][0][0][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][0][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
-                    l_gate_delay_value_u8[rank_group][0][1][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][0][1][1] = l_value_n1_u8;
-
-                    // PHY BLOCK 1
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_1, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 50, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 54, 2);
-                    l_lowest_value_u8[rank_group][1][0][0] = l_value_n0_u8;
-                    l_lowest_value_u8[rank_group][1][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 58, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 62, 2);
-                    l_lowest_value_u8[rank_group][1][1][0] = l_value_n0_u8;
-                    l_lowest_value_u8[rank_group][1][1][1] = l_value_n1_u8;
-
-                    rc = fapiGetScom(i_target, DISABLE_ADDR_1, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 4);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 4);
-                    l_disable_value_u8[rank_group][1][0][0] = l_value_n0_u8;
-                    l_disable_value_u8[rank_group][1][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 4);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 4);
-                    l_disable_value_u8[rank_group][1][1][0] = l_value_n0_u8;
-                    l_disable_value_u8[rank_group][1][1][1] = l_value_n1_u8;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_1, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
-                    l_gate_delay_value_u8[rank_group][1][0][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][1][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
-                    l_gate_delay_value_u8[rank_group][1][1][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][1][1][1] = l_value_n1_u8;
-
-                    // PHY BLOCK 2
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_2, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 50, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 54, 2);
-                    l_lowest_value_u8[rank_group][2][0][0] = l_value_n0_u8;
-                    l_lowest_value_u8[rank_group][2][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 58, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 62, 2);
-                    l_lowest_value_u8[rank_group][2][1][0] = l_value_n0_u8;
-                    l_lowest_value_u8[rank_group][2][1][1] = l_value_n1_u8;
-
-                    rc = fapiGetScom(i_target, DISABLE_ADDR_2, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 4);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 4);
-                    l_disable_value_u8[rank_group][2][0][0] = l_value_n0_u8;
-                    l_disable_value_u8[rank_group][2][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 4);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 4);
-                    l_disable_value_u8[rank_group][2][1][0] = l_value_n0_u8;
-                    l_disable_value_u8[rank_group][2][1][1] = l_value_n1_u8;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_2, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
-                    l_gate_delay_value_u8[rank_group][2][0][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][2][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
-                    l_gate_delay_value_u8[rank_group][2][1][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][2][1][1] = l_value_n1_u8;
-
-                    // PHY BLOCK 3
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_3, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 50, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 54, 2);
-                    l_lowest_value_u8[rank_group][3][0][0] = l_value_n0_u8;
-                    l_lowest_value_u8[rank_group][3][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 58, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 62, 2);
-                    l_lowest_value_u8[rank_group][3][1][0] = l_value_n0_u8;
-                    l_lowest_value_u8[rank_group][3][1][1] = l_value_n1_u8;
-
-                    rc = fapiGetScom(i_target, DISABLE_ADDR_3, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 4);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 4);
-                    l_disable_value_u8[rank_group][3][0][0] = l_value_n0_u8;
-                    l_disable_value_u8[rank_group][3][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 4);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 4);
-                    l_disable_value_u8[rank_group][3][1][0] = l_value_n0_u8;
-                    l_disable_value_u8[rank_group][3][1][1] = l_value_n1_u8;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_3, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
-                    l_gate_delay_value_u8[rank_group][3][0][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][3][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
-                    l_gate_delay_value_u8[rank_group][3][1][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][3][1][1] = l_value_n1_u8;
-
-                    // PHY BLOCK 4
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_4, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 50, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 54, 2);
-                    l_lowest_value_u8[rank_group][4][0][0] = l_value_n0_u8;
-                    l_lowest_value_u8[rank_group][4][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 58, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 62, 2);
-                    l_lowest_value_u8[rank_group][4][1][0] = l_value_n0_u8;
-                    l_lowest_value_u8[rank_group][4][1][1] = l_value_n1_u8;
-
-                    rc = fapiGetScom(i_target, DISABLE_ADDR_4, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 4);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 4);
-                    l_disable_value_u8[rank_group][4][0][0] = l_value_n0_u8;
-                    l_disable_value_u8[rank_group][4][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 4);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 4);
-                    l_disable_value_u8[rank_group][4][1][0] = l_value_n0_u8;
-                    l_disable_value_u8[rank_group][4][1][1] = l_value_n1_u8;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_4, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
-                    l_gate_delay_value_u8[rank_group][4][0][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][4][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
-                    l_gate_delay_value_u8[rank_group][4][1][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][4][1][1] = l_value_n1_u8;
-
-                    if(rc_num)
-                    {
-                        rc.setEcmdError(rc_num);
-                        return rc;
-                    }
-
-                }
-        }
-
-
-
-
-        //Finding the lowest Values on disabled bytes, then resetting mask.
-        for(block = 0; block < maxblocks; block++)
-        {
-                for (byte = 0; byte < maxbytes; byte++)
-                {
-
-                        for (nibble = 0; nibble < maxnibbles; nibble++)
-                        {
-                                if ( (l_disable_value_u8[0][block][byte][nibble] != 0) || (l_disable_value_u8[1][block][byte][nibble] != 0)
-                                  || (l_disable_value_u8[2][block][byte][nibble] != 0) || (l_disable_value_u8[3][block][byte][nibble] != 0) )
-                                {
-
-                                        FAPI_INF( "Located disabled block %d byte %d nibble %d", block, byte, nibble);
-
-                                        l_min_gate_delay = 255;
-                                        for(rank_group = 0; rank_group < MAX_PRI_RANKS; rank_group++)
-                                        {
-                                                if ( (l_gate_delay_value_u8[rank_group][block][byte][nibble] < l_min_gate_delay)
-                                                  && (l_disable_value_u8[rank_group][block][byte][nibble] == 0) )
-                                                {
-                                                        l_min_gate_delay = l_gate_delay_value_u8[rank_group][block][byte][nibble];
-                                                }
-                                        }
-
-                                        FAPI_INF( "Lowest gate_delay %d", l_min_gate_delay);
-
-                                        l_min_dqs_clk = 255;
-                                        for(rank_group = 0; rank_group < MAX_PRI_RANKS; rank_group++)
-                                        {
-                                                if ( (l_lowest_value_u8[rank_group][block][byte][nibble] < l_min_dqs_clk)
-                                                  && (l_disable_value_u8[rank_group][block][byte][nibble] == 0) )
-                                                {
-                                                        l_min_dqs_clk = l_lowest_value_u8[rank_group][block][byte][nibble];
-                                                }
-                                        }
-
-
-                                        FAPI_INF( "Lowest rdclk phase %d", l_min_dqs_clk);
-
-                                        for(rank_group = 0; rank_group < MAX_PRI_RANKS; rank_group++)
-                                        {
-                                                if (l_disable_value_u8[rank_group][block][byte][nibble] != 0)
-                                                {
-                                                        l_gate_delay_value_u8[rank_group][block][byte][nibble] = l_min_gate_delay;
-                                                        l_lowest_value_u8[rank_group][block][byte][nibble] = l_min_dqs_clk;
-                                                        //l_disable_value_u8[rank_group][block][byte][nibble] = 0;
-                                                }
-                                        }
-
-                                }
-                        }
-                }
-
-        }
-
-
-        //Scoming in the New Values
+	{
+
+	     //Initialize values
+	     for(block = 0; block < maxblocks; block++)
+	     {
+		for (byte = 0; byte < maxbytes; byte++)
+		{
+			for (nibble = 0; nibble < maxnibbles; nibble++)
+			{
+				l_lowest_value_u8[rank_group][block][byte][nibble] = 255;
+				l_gate_delay_value_u8[rank_group][block][byte][nibble] = 255;
+				l_disable_value_u8[rank_group][block][byte][nibble] = 0;
+			}
+		}
+	     }
+
+	    //Check if rank group exists
+	    if(primary_ranks_array[rank_group][port] != 255)
+	    {
+	        FAPI_INF( "DISABLE Workaround being applied on  %s  PORT: %d RP: %d", i_target.toEcmdString(), port, rank_group);
+    		if ( port == 0 )
+    		{
+
+			if ( rank_group == 0 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_0_0x800000090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_1_0x800004090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_2_0x800008090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_3_0x80000C090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_4_0x800010090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_0_0x800000130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_1_0x800004130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_2_0x800008130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_3_0x80000C130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_4_0x800010130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_0_0x8000007c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_1_0x8000047c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_2_0x8000087c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_3_0x80000c7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_4_0x8000107c0301143F;
+
+
+			}
+			else if ( rank_group == 1 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_0_0x800001090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_1_0x800005090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_2_0x800009090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_3_0x80000D090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_4_0x800011090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_0_0x800001130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_1_0x800005130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_2_0x800009130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_3_0x80000D130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_4_0x800011130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_0_0x8000017c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_1_0x8000057c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_2_0x8000097c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_3_0x80000d7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_4_0x8000117c0301143F;
+
+			}
+			else if ( rank_group == 2 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_0_0x800002090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_1_0x800006090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_2_0x80000A090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_3_0x80000E090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_4_0x800012090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_0_0x800002130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_1_0x800006130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_2_0x80000A130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_3_0x80000E130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_4_0x800012130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_0_0x8000027c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_1_0x8000067c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_2_0x80000a7c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_3_0x80000e7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_4_0x8000127c0301143F;
+
+			}
+			else if ( rank_group == 3 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_0_0x800003090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_1_0x800007090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_2_0x80000B090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_3_0x80000F090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_4_0x800013090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_0_0x800003130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_1_0x800007130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_2_0x80000B130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_3_0x80000F130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_4_0x800013130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_0_0x8000037c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_1_0x8000077c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_2_0x80000b7c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_3_0x80000f7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_4_0x8000137c0301143F;
+
+			}
+		    }
+		    else if (port == 1 )
+		    {
+
+			if ( rank_group == 0 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_0_0x800100090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_1_0x800104090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_2_0x800108090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_3_0x80010C090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_4_0x800110090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_0_0x800100130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_1_0x800104130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_2_0x800108130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_3_0x80010C130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_4_0x800110130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_0_0x8001007c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_1_0x8001047c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_2_0x8001087c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_3_0x80010c7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_4_0x8001107c0301143F;
+
+			}
+			else if ( rank_group == 1 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_0_0x800101090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_1_0x800105090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_2_0x800109090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_3_0x80010D090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_4_0x800111090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_0_0x800101130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_1_0x800105130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_2_0x800109130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_3_0x80010D130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_4_0x800111130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_0_0x8001017c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_1_0x8001057c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_2_0x8001097c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_3_0x80010d7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_4_0x8001117c0301143F;
+
+			}
+			else if ( rank_group == 2 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_0_0x800102090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_1_0x800106090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_2_0x80010A090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_3_0x80010E090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_4_0x800112090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_0_0x800102130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_1_0x800106130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_2_0x80010A130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_3_0x80010E130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_4_0x800112130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_0_0x8001027c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_1_0x8001067c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_2_0x80010a7c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_3_0x80010e7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_4_0x8001127c0301143F;
+
+			}
+			else if ( rank_group == 3 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_0_0x800103090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_1_0x800107090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_2_0x80010B090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_3_0x80010F090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_4_0x800113090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_0_0x800103130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_1_0x800107130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_2_0x80010B130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_3_0x80010F130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_4_0x800113130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_0_0x8001037c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_1_0x8001077c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_2_0x80010b7c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_3_0x80010f7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_4_0x8001137c0301143F;
+
+			}
+		    }
+
+
+		    // PHY BLOCK 0
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_0, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 50, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 54, 2);
+		    l_lowest_value_u8[rank_group][0][0][0] = l_value_n0_u8;
+		    l_lowest_value_u8[rank_group][0][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 58, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 62, 2);
+		    l_lowest_value_u8[rank_group][0][1][0] = l_value_n0_u8;
+		    l_lowest_value_u8[rank_group][0][1][1] = l_value_n1_u8;
+
+		    rc = fapiGetScom(i_target, DISABLE_ADDR_0, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 4);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 4);
+		    l_disable_value_u8[rank_group][0][0][0] = l_value_n0_u8;
+		    l_disable_value_u8[rank_group][0][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 4);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 4);
+		    l_disable_value_u8[rank_group][0][1][0] = l_value_n0_u8;
+		    l_disable_value_u8[rank_group][0][1][1] = l_value_n1_u8;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_0, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
+		    l_gate_delay_value_u8[rank_group][0][0][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][0][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
+		    l_gate_delay_value_u8[rank_group][0][1][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][0][1][1] = l_value_n1_u8;
+
+		    // PHY BLOCK 1
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_1, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 50, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 54, 2);
+		    l_lowest_value_u8[rank_group][1][0][0] = l_value_n0_u8;
+		    l_lowest_value_u8[rank_group][1][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 58, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 62, 2);
+		    l_lowest_value_u8[rank_group][1][1][0] = l_value_n0_u8;
+		    l_lowest_value_u8[rank_group][1][1][1] = l_value_n1_u8;
+
+		    rc = fapiGetScom(i_target, DISABLE_ADDR_1, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 4);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 4);
+		    l_disable_value_u8[rank_group][1][0][0] = l_value_n0_u8;
+		    l_disable_value_u8[rank_group][1][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 4);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 4);
+		    l_disable_value_u8[rank_group][1][1][0] = l_value_n0_u8;
+		    l_disable_value_u8[rank_group][1][1][1] = l_value_n1_u8;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_1, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
+		    l_gate_delay_value_u8[rank_group][1][0][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][1][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
+		    l_gate_delay_value_u8[rank_group][1][1][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][1][1][1] = l_value_n1_u8;
+
+		    // PHY BLOCK 2
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_2, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 50, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 54, 2);
+		    l_lowest_value_u8[rank_group][2][0][0] = l_value_n0_u8;
+		    l_lowest_value_u8[rank_group][2][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 58, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 62, 2);
+		    l_lowest_value_u8[rank_group][2][1][0] = l_value_n0_u8;
+		    l_lowest_value_u8[rank_group][2][1][1] = l_value_n1_u8;
+
+		    rc = fapiGetScom(i_target, DISABLE_ADDR_2, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 4);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 4);
+		    l_disable_value_u8[rank_group][2][0][0] = l_value_n0_u8;
+		    l_disable_value_u8[rank_group][2][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 4);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 4);
+		    l_disable_value_u8[rank_group][2][1][0] = l_value_n0_u8;
+		    l_disable_value_u8[rank_group][2][1][1] = l_value_n1_u8;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_2, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
+		    l_gate_delay_value_u8[rank_group][2][0][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][2][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
+		    l_gate_delay_value_u8[rank_group][2][1][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][2][1][1] = l_value_n1_u8;
+
+		    // PHY BLOCK 3
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_3, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 50, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 54, 2);
+		    l_lowest_value_u8[rank_group][3][0][0] = l_value_n0_u8;
+		    l_lowest_value_u8[rank_group][3][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 58, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 62, 2);
+		    l_lowest_value_u8[rank_group][3][1][0] = l_value_n0_u8;
+		    l_lowest_value_u8[rank_group][3][1][1] = l_value_n1_u8;
+
+		    rc = fapiGetScom(i_target, DISABLE_ADDR_3, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 4);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 4);
+		    l_disable_value_u8[rank_group][3][0][0] = l_value_n0_u8;
+		    l_disable_value_u8[rank_group][3][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 4);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 4);
+		    l_disable_value_u8[rank_group][3][1][0] = l_value_n0_u8;
+		    l_disable_value_u8[rank_group][3][1][1] = l_value_n1_u8;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_3, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
+		    l_gate_delay_value_u8[rank_group][3][0][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][3][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
+		    l_gate_delay_value_u8[rank_group][3][1][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][3][1][1] = l_value_n1_u8;
+
+		    // PHY BLOCK 4
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_4, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 50, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 54, 2);
+		    l_lowest_value_u8[rank_group][4][0][0] = l_value_n0_u8;
+		    l_lowest_value_u8[rank_group][4][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 58, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 62, 2);
+		    l_lowest_value_u8[rank_group][4][1][0] = l_value_n0_u8;
+		    l_lowest_value_u8[rank_group][4][1][1] = l_value_n1_u8;
+
+		    rc = fapiGetScom(i_target, DISABLE_ADDR_4, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 4);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 4);
+		    l_disable_value_u8[rank_group][4][0][0] = l_value_n0_u8;
+		    l_disable_value_u8[rank_group][4][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 4);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 4);
+		    l_disable_value_u8[rank_group][4][1][0] = l_value_n0_u8;
+		    l_disable_value_u8[rank_group][4][1][1] = l_value_n1_u8;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_4, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
+		    l_gate_delay_value_u8[rank_group][4][0][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][4][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
+		    l_gate_delay_value_u8[rank_group][4][1][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][4][1][1] = l_value_n1_u8;
+
+		    if(rc_num)
+		    {
+			rc.setEcmdError(rc_num);
+			return rc;
+		    }
+
+		}
+	}
+
+
+
+
+	//Finding the lowest Values on disabled bytes, then resetting mask.
+	for(block = 0; block < maxblocks; block++)
+	{
+		for (byte = 0; byte < maxbytes; byte++)
+		{
+
+			for (nibble = 0; nibble < maxnibbles; nibble++)
+			{
+				if ( (l_disable_value_u8[0][block][byte][nibble] != 0) || (l_disable_value_u8[1][block][byte][nibble] != 0) 
+				  || (l_disable_value_u8[2][block][byte][nibble] != 0) || (l_disable_value_u8[3][block][byte][nibble] != 0) )
+				{
+
+					FAPI_INF( "Located disabled block %d byte %d nibble %d", block, byte, nibble);
+
+					l_min_gate_delay = 255; 
+					for(rank_group = 0; rank_group < MAX_PRI_RANKS; rank_group++)
+					{						
+						if ( (l_gate_delay_value_u8[rank_group][block][byte][nibble] < l_min_gate_delay) 
+						  && (l_disable_value_u8[rank_group][block][byte][nibble] == 0) )
+						{
+							l_min_gate_delay = l_gate_delay_value_u8[rank_group][block][byte][nibble];
+						}
+					}
+
+					FAPI_INF( "Lowest gate_delay %d", l_min_gate_delay);
+
+					l_min_dqs_clk = 255; 
+					for(rank_group = 0; rank_group < MAX_PRI_RANKS; rank_group++)
+					{						
+						if ( (l_lowest_value_u8[rank_group][block][byte][nibble] < l_min_dqs_clk) 
+						  && (l_disable_value_u8[rank_group][block][byte][nibble] == 0) )
+						{
+							l_min_dqs_clk = l_lowest_value_u8[rank_group][block][byte][nibble];
+						}
+					}
+
+
+					FAPI_INF( "Lowest rdclk phase %d", l_min_dqs_clk);
+					
+					for(rank_group = 0; rank_group < MAX_PRI_RANKS; rank_group++)
+					{						
+						if (l_disable_value_u8[rank_group][block][byte][nibble] != 0)
+						{
+							l_gate_delay_value_u8[rank_group][block][byte][nibble] = l_min_gate_delay;
+							l_lowest_value_u8[rank_group][block][byte][nibble] = l_min_dqs_clk;
+							//l_disable_value_u8[rank_group][block][byte][nibble] = 0; 
+						}
+					}
+					
+				}
+			}
+		}
+
+	}
+
+
+	//Scoming in the New Values
         for(rank_group = 0; rank_group < MAX_PRI_RANKS; rank_group++)
-        {
-
-            //Check if rank group exists
-            if(primary_ranks_array[rank_group][port] != 255)
-            {
-
-                if ( port == 0 )
-                {
-
-                        if ( rank_group == 0 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_0_0x800000090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_1_0x800004090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_2_0x800008090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_3_0x80000C090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_4_0x800010090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_0_0x800000130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_1_0x800004130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_2_0x800008130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_3_0x80000C130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_4_0x800010130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_0_0x8000007c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_1_0x8000047c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_2_0x8000087c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_3_0x80000c7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_4_0x8000107c0301143F;
-
-
-                        }
-                        else if ( rank_group == 1 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_0_0x800001090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_1_0x800005090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_2_0x800009090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_3_0x80000D090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_4_0x800011090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_0_0x800001130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_1_0x800005130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_2_0x800009130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_3_0x80000D130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_4_0x800011130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_0_0x8000017c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_1_0x8000057c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_2_0x8000097c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_3_0x80000d7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_4_0x8000117c0301143F;
-
-                        }
-                        else if ( rank_group == 2 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_0_0x800002090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_1_0x800006090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_2_0x80000A090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_3_0x80000E090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_4_0x800012090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_0_0x800002130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_1_0x800006130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_2_0x80000A130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_3_0x80000E130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_4_0x800012130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_0_0x8000027c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_1_0x8000067c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_2_0x80000a7c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_3_0x80000e7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_4_0x8000127c0301143F;
-
-                        }
-                        else if ( rank_group == 3 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_0_0x800003090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_1_0x800007090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_2_0x80000B090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_3_0x80000F090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_4_0x800013090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_0_0x800003130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_1_0x800007130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_2_0x80000B130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_3_0x80000F130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_4_0x800013130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_0_0x8000037c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_1_0x8000077c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_2_0x80000b7c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_3_0x80000f7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_4_0x8000137c0301143F;
-
-                        }
-                    }
-                    else if (port == 1 )
-                    {
-
-                        if ( rank_group == 0 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_0_0x800100090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_1_0x800104090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_2_0x800108090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_3_0x80010C090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_4_0x800110090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_0_0x800100130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_1_0x800104130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_2_0x800108130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_3_0x80010C130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_4_0x800110130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_0_0x8001007c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_1_0x8001047c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_2_0x8001087c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_3_0x80010c7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_4_0x8001107c0301143F;
-
-                        }
-                        else if ( rank_group == 1 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_0_0x800101090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_1_0x800105090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_2_0x800109090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_3_0x80010D090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_4_0x800111090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_0_0x800101130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_1_0x800105130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_2_0x800109130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_3_0x80010D130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_4_0x800111130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_0_0x8001017c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_1_0x8001057c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_2_0x8001097c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_3_0x80010d7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_4_0x8001117c0301143F;
-
-                        }
-                        else if ( rank_group == 2 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_0_0x800102090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_1_0x800106090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_2_0x80010A090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_3_0x80010E090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_4_0x800112090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_0_0x800102130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_1_0x800106130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_2_0x80010A130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_3_0x80010E130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_4_0x800112130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_0_0x8001027c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_1_0x8001067c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_2_0x80010a7c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_3_0x80010e7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_4_0x8001127c0301143F;
-
-                        }
-                        else if ( rank_group == 3 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_0_0x800103090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_1_0x800107090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_2_0x80010B090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_3_0x80010F090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_4_0x800113090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_0_0x800103130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_1_0x800107130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_2_0x80010B130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_3_0x80010F130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_4_0x800113130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_0_0x8001037c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_1_0x8001077c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_2_0x80010b7c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_3_0x80010f7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_4_0x8001137c0301143F;
-
-                        }
-                    }
-
-                    //BLOCK 0
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_0, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][0][0][0], 50, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][0][0][1], 54, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][0][1][0], 58, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][0][1][1], 62, 2);
-                    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_0, data_buffer_64);
-                    if (rc) return rc;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_0, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][0][0], 49, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][0][1], 53, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][1][0], 57, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][1][1], 61, 3);
-                    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_0, data_buffer_64);
-                    if (rc) return rc;
-
-                    //BLOCK 1
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_1, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][1][0][0], 50, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][1][0][1], 54, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][1][1][0], 58, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][1][1][1], 62, 2);
-                    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_1, data_buffer_64);
-                    if (rc) return rc;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_1, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][0][0], 49, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][0][1], 53, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][1][0], 57, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][1][1], 61, 3);
-                    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_1, data_buffer_64);
-                    if (rc) return rc;
-
-                    //BLOCK 2
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_2, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][2][0][0], 50, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][2][0][1], 54, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][2][1][0], 58, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][2][1][1], 62, 2);
-                    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_2, data_buffer_64);
-                    if (rc) return rc;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_2, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][0][0], 49, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][0][1], 53, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][1][0], 57, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][1][1], 61, 3);
-                    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_2, data_buffer_64);
-                    if (rc) return rc;
-
-                    //BLOCK 3
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_3, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][3][0][0], 50, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][3][0][1], 54, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][3][1][0], 58, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][3][1][1], 62, 2);
-                    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_3, data_buffer_64);
-                    if (rc) return rc;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_3, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][0][0], 49, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][0][1], 53, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][1][0], 57, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][1][1], 61, 3);
-                    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_3, data_buffer_64);
-                    if (rc) return rc;
-
-                    //Block 4
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_4, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][4][0][0], 50, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][4][0][1], 54, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][4][1][0], 58, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][4][1][1], 62, 2);
-                    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_4, data_buffer_64);
-                    if (rc) return rc;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_4, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][0][0], 49, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][0][1], 53, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][1][0], 57, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][1][1], 61, 3);
-                    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_4, data_buffer_64);
-                    if (rc) return rc;
-
-                    if(rc_num)
-                    {
-                        rc.setEcmdError(rc_num);
-                        return rc;
-                    }
-
-
-                }
-        }
+	{
+
+	    //Check if rank group exists
+	    if(primary_ranks_array[rank_group][port] != 255)
+	    {
+
+    		if ( port == 0 )
+    		{
+
+			if ( rank_group == 0 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_0_0x800000090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_1_0x800004090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_2_0x800008090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_3_0x80000C090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_4_0x800010090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_0_0x800000130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_1_0x800004130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_2_0x800008130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_3_0x80000C130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_4_0x800010130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_0_0x8000007c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_1_0x8000047c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_2_0x8000087c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_3_0x80000c7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_4_0x8000107c0301143F;
+
+
+			}
+			else if ( rank_group == 1 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_0_0x800001090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_1_0x800005090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_2_0x800009090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_3_0x80000D090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_4_0x800011090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_0_0x800001130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_1_0x800005130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_2_0x800009130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_3_0x80000D130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_4_0x800011130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_0_0x8000017c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_1_0x8000057c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_2_0x8000097c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_3_0x80000d7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_4_0x8000117c0301143F;
+
+			}
+			else if ( rank_group == 2 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_0_0x800002090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_1_0x800006090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_2_0x80000A090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_3_0x80000E090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_4_0x800012090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_0_0x800002130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_1_0x800006130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_2_0x80000A130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_3_0x80000E130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_4_0x800012130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_0_0x8000027c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_1_0x8000067c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_2_0x80000a7c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_3_0x80000e7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_4_0x8000127c0301143F;
+
+			}
+			else if ( rank_group == 3 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_0_0x800003090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_1_0x800007090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_2_0x80000B090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_3_0x80000F090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_4_0x800013090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_0_0x800003130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_1_0x800007130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_2_0x80000B130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_3_0x80000F130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_4_0x800013130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_0_0x8000037c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_1_0x8000077c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_2_0x80000b7c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_3_0x80000f7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_4_0x8000137c0301143F;
+
+			}
+		    }
+		    else if (port == 1 )
+		    {
+
+			if ( rank_group == 0 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_0_0x800100090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_1_0x800104090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_2_0x800108090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_3_0x80010C090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_4_0x800110090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_0_0x800100130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_1_0x800104130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_2_0x800108130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_3_0x80010C130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_4_0x800110130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_0_0x8001007c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_1_0x8001047c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_2_0x8001087c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_3_0x80010c7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_4_0x8001107c0301143F;
+
+			}
+			else if ( rank_group == 1 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_0_0x800101090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_1_0x800105090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_2_0x800109090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_3_0x80010D090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_4_0x800111090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_0_0x800101130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_1_0x800105130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_2_0x800109130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_3_0x80010D130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_4_0x800111130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_0_0x8001017c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_1_0x8001057c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_2_0x8001097c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_3_0x80010d7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_4_0x8001117c0301143F;
+
+			}
+			else if ( rank_group == 2 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_0_0x800102090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_1_0x800106090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_2_0x80010A090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_3_0x80010E090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_4_0x800112090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_0_0x800102130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_1_0x800106130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_2_0x80010A130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_3_0x80010E130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_4_0x800112130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_0_0x8001027c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_1_0x8001067c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_2_0x80010a7c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_3_0x80010e7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_4_0x8001127c0301143F;
+
+			}
+			else if ( rank_group == 3 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_0_0x800103090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_1_0x800107090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_2_0x80010B090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_3_0x80010F090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_4_0x800113090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_0_0x800103130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_1_0x800107130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_2_0x80010B130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_3_0x80010F130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_4_0x800113130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_0_0x8001037c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_1_0x8001077c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_2_0x80010b7c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_3_0x80010f7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_4_0x8001137c0301143F;
+
+			}
+		    }
+
+		    //BLOCK 0
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_0, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][0][0][0], 50, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][0][0][1], 54, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][0][1][0], 58, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][0][1][1], 62, 2);
+		    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_0, data_buffer_64);
+		    if (rc) return rc;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_0, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][0][0], 49, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][0][1], 53, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][1][0], 57, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][1][1], 61, 3);
+		    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_0, data_buffer_64);
+		    if (rc) return rc;
+
+		    //BLOCK 1
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_1, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][1][0][0], 50, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][1][0][1], 54, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][1][1][0], 58, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][1][1][1], 62, 2);
+		    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_1, data_buffer_64);
+		    if (rc) return rc;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_1, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][0][0], 49, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][0][1], 53, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][1][0], 57, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][1][1], 61, 3);
+		    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_1, data_buffer_64);
+		    if (rc) return rc;
+
+		    //BLOCK 2
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_2, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][2][0][0], 50, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][2][0][1], 54, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][2][1][0], 58, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][2][1][1], 62, 2);
+		    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_2, data_buffer_64);
+		    if (rc) return rc;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_2, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][0][0], 49, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][0][1], 53, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][1][0], 57, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][1][1], 61, 3);
+		    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_2, data_buffer_64);
+		    if (rc) return rc;
+
+		    //BLOCK 3
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_3, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][3][0][0], 50, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][3][0][1], 54, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][3][1][0], 58, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][3][1][1], 62, 2);
+		    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_3, data_buffer_64);
+		    if (rc) return rc;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_3, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][0][0], 49, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][0][1], 53, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][1][0], 57, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][1][1], 61, 3);
+		    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_3, data_buffer_64);
+		    if (rc) return rc;
+
+		    //Block 4
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_4, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][4][0][0], 50, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][4][0][1], 54, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][4][1][0], 58, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_lowest_value_u8[rank_group][4][1][1], 62, 2);
+		    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_4, data_buffer_64);
+		    if (rc) return rc;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_4, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][0][0], 49, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][0][1], 53, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][1][0], 57, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][1][1], 61, 3);
+		    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_4, data_buffer_64);
+		    if (rc) return rc;
+
+		    if(rc_num)
+		    {
+			rc.setEcmdError(rc_num);
+			return rc;
+		    }
+
+
+		}
+	}
     }
 
     return rc;
@@ -3559,1423 +3701,1423 @@ ReturnCode mss_wr_lvl_disable_workaround(
 
     for(port = 0; port < MAX_PORTS; port++)
     {
-        //Gather all the byte information
+	//Gather all the byte information
         for(rank_group = 0; rank_group < MAX_PRI_RANKS; rank_group++)
-        {
-
-             //Initialize values
-             for(block = 0; block < maxblocks; block++)
-             {
-                for (byte = 0; byte < maxbytes; byte++)
-                {
-                        for (nibble = 0; nibble < maxnibbles; nibble++)
-                        {
-                                l_dqsclk_phase_value_u8[rank_group][block][byte][nibble] = 255;
-                                l_gate_delay_value_u8[rank_group][block][byte][nibble] = 255;
-                                l_rdclk_phase_value_u8[rank_group][block][byte][nibble] = 255;
-                                l_disable_value_u8[rank_group][block][byte][nibble] = 0;
-                                l_disable_old_value_u8[rank_group][block][byte][nibble] = 0;
-
-                        }
-                }
-             }
-
-            //Check if rank group exists
-            if(primary_ranks_array[rank_group][port] != 255)
-            {
-                FAPI_DBG("WR LVL DISABLE WORKAROUND: DISABLE Workaround being applied on  %s  PORT: %d RP: %d", i_target.toEcmdString(), port, rank_group);
-
-                if ( port == 0 )
-                {
-
-                        if ( rank_group == 0 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_0_0x800000090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_1_0x800004090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_2_0x800008090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_3_0x80000C090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_4_0x800010090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_0_0x800000130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_1_0x800004130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_2_0x800008130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_3_0x80000C130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_4_0x800010130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_0_0x8000007c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_1_0x8000047c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_2_0x8000087c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_3_0x80000c7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_4_0x8000107c0301143F;
-
-
-                        }
-                        else if ( rank_group == 1 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_0_0x800001090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_1_0x800005090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_2_0x800009090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_3_0x80000D090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_4_0x800011090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_0_0x800001130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_1_0x800005130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_2_0x800009130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_3_0x80000D130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_4_0x800011130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_0_0x8000017c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_1_0x8000057c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_2_0x8000097c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_3_0x80000d7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_4_0x8000117c0301143F;
-
-                        }
-                        else if ( rank_group == 2 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_0_0x800002090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_1_0x800006090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_2_0x80000A090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_3_0x80000E090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_4_0x800012090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_0_0x800002130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_1_0x800006130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_2_0x80000A130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_3_0x80000E130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_4_0x800012130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_0_0x8000027c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_1_0x8000067c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_2_0x80000a7c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_3_0x80000e7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_4_0x8000127c0301143F;
-
-                        }
-                        else if ( rank_group == 3 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_0_0x800003090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_1_0x800007090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_2_0x80000B090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_3_0x80000F090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_4_0x800013090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_0_0x800003130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_1_0x800007130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_2_0x80000B130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_3_0x80000F130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_4_0x800013130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_0_0x8000037c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_1_0x8000077c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_2_0x80000b7c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_3_0x80000f7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_4_0x8000137c0301143F;
-
-                        }
-                    }
-                    else if (port == 1 )
-                    {
-
-                        if ( rank_group == 0 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_0_0x800100090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_1_0x800104090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_2_0x800108090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_3_0x80010C090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_4_0x800110090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_0_0x800100130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_1_0x800104130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_2_0x800108130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_3_0x80010C130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_4_0x800110130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_0_0x8001007c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_1_0x8001047c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_2_0x8001087c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_3_0x80010c7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_4_0x8001107c0301143F;
-
-                        }
-                        else if ( rank_group == 1 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_0_0x800101090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_1_0x800105090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_2_0x800109090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_3_0x80010D090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_4_0x800111090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_0_0x800101130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_1_0x800105130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_2_0x800109130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_3_0x80010D130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_4_0x800111130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_0_0x8001017c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_1_0x8001057c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_2_0x8001097c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_3_0x80010d7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_4_0x8001117c0301143F;
-
-                        }
-                        else if ( rank_group == 2 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_0_0x800102090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_1_0x800106090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_2_0x80010A090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_3_0x80010E090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_4_0x800112090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_0_0x800102130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_1_0x800106130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_2_0x80010A130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_3_0x80010E130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_4_0x800112130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_0_0x8001027c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_1_0x8001067c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_2_0x80010a7c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_3_0x80010e7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_4_0x8001127c0301143F;
-
-                        }
-                        else if ( rank_group == 3 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_0_0x800103090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_1_0x800107090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_2_0x80010B090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_3_0x80010F090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_4_0x800113090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_0_0x800103130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_1_0x800107130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_2_0x80010B130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_3_0x80010F130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_4_0x800113130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_0_0x8001037c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_1_0x8001077c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_2_0x80010b7c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_3_0x80010f7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_4_0x8001137c0301143F;
-
-                        }
-                    }
-
-
-                    // PHY BLOCK 0
-
-                    rc = fapiGetScom(i_target, DISABLE_ADDR_0, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 4);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 4);
-                    l_disable_value_u8[rank_group][0][0][0] = l_value_n0_u8;
-                    l_disable_value_u8[rank_group][0][0][1] = l_value_n1_u8;
-                    l_disable_old_value_u8[rank_group][0][0][0] = l_value_n0_u8;
-                    l_disable_old_value_u8[rank_group][0][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 4);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 4);
-                    l_disable_value_u8[rank_group][0][1][0] = l_value_n0_u8;
-                    l_disable_value_u8[rank_group][0][1][1] = l_value_n1_u8;
-                    l_disable_old_value_u8[rank_group][0][1][0] = l_value_n0_u8;
-                    l_disable_old_value_u8[rank_group][0][1][1] = l_value_n1_u8;
-
-
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_0, data_buffer_64);
-                    if (rc) return rc;
-                    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 2);
-                    l_dqsclk_phase_value_u8[rank_group][0][0][0] = l_value_n0_u8;
-                    l_dqsclk_phase_value_u8[rank_group][0][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 2);
-                    l_dqsclk_phase_value_u8[rank_group][0][1][0] = l_value_n0_u8;
-                    l_dqsclk_phase_value_u8[rank_group][0][1][1] = l_value_n1_u8;
-
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 50, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 54, 2);
-                    l_rdclk_phase_value_u8[rank_group][0][0][0] = l_value_n0_u8;
-                    l_rdclk_phase_value_u8[rank_group][0][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 58, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 62, 2);
-                    l_rdclk_phase_value_u8[rank_group][0][1][0] = l_value_n0_u8;
-                    l_rdclk_phase_value_u8[rank_group][0][1][1] = l_value_n1_u8;
-
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_0, data_buffer_64);
-                    if (rc) return rc;
-                    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
-                    l_gate_delay_value_u8[rank_group][0][0][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][0][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
-                    l_gate_delay_value_u8[rank_group][0][1][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][0][1][1] = l_value_n1_u8;
-
-
-                    // PHY BLOCK 1
-
-                    rc = fapiGetScom(i_target, DISABLE_ADDR_1, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 4);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 4);
-                    l_disable_value_u8[rank_group][1][0][0] = l_value_n0_u8;
-                    l_disable_value_u8[rank_group][1][0][1] = l_value_n1_u8;
-                    l_disable_old_value_u8[rank_group][1][0][0] = l_value_n0_u8;
-                    l_disable_old_value_u8[rank_group][1][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 4);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 4);
-                    l_disable_value_u8[rank_group][1][1][0] = l_value_n0_u8;
-                    l_disable_value_u8[rank_group][1][1][1] = l_value_n1_u8;
-                    l_disable_old_value_u8[rank_group][1][1][0] = l_value_n0_u8;
-                    l_disable_old_value_u8[rank_group][1][1][1] = l_value_n1_u8;
-
-
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_1, data_buffer_64);
-                    if (rc) return rc;
-                    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 2);
-                    l_dqsclk_phase_value_u8[rank_group][1][0][0] = l_value_n0_u8;
-                    l_dqsclk_phase_value_u8[rank_group][1][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 2);
-                    l_dqsclk_phase_value_u8[rank_group][1][1][0] = l_value_n0_u8;
-                    l_dqsclk_phase_value_u8[rank_group][1][1][1] = l_value_n1_u8;
-
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 50, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 54, 2);
-                    l_rdclk_phase_value_u8[rank_group][1][0][0] = l_value_n0_u8;
-                    l_rdclk_phase_value_u8[rank_group][1][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 58, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 62, 2);
-                    l_rdclk_phase_value_u8[rank_group][1][1][0] = l_value_n0_u8;
-                    l_rdclk_phase_value_u8[rank_group][1][1][1] = l_value_n1_u8;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_1, data_buffer_64);
-                    if (rc) return rc;
-                    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
-                    l_gate_delay_value_u8[rank_group][1][0][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][1][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
-                    l_gate_delay_value_u8[rank_group][1][1][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][1][1][1] = l_value_n1_u8;
-
-                    // PHY BLOCK 2
-
-                    rc = fapiGetScom(i_target, DISABLE_ADDR_2, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 4);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 4);
-                    l_disable_value_u8[rank_group][2][0][0] = l_value_n0_u8;
-                    l_disable_value_u8[rank_group][2][0][1] = l_value_n1_u8;
-                    l_disable_old_value_u8[rank_group][2][0][0] = l_value_n0_u8;
-                    l_disable_old_value_u8[rank_group][2][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 4);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 4);
-                    l_disable_value_u8[rank_group][2][1][0] = l_value_n0_u8;
-                    l_disable_value_u8[rank_group][2][1][1] = l_value_n1_u8;
-                    l_disable_old_value_u8[rank_group][2][1][0] = l_value_n0_u8;
-                    l_disable_old_value_u8[rank_group][2][1][1] = l_value_n1_u8;
-
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_2, data_buffer_64);
-                    if (rc) return rc;
-                    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 2);
-                    l_dqsclk_phase_value_u8[rank_group][2][0][0] = l_value_n0_u8;
-                    l_dqsclk_phase_value_u8[rank_group][2][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 2);
-                    l_dqsclk_phase_value_u8[rank_group][2][1][0] = l_value_n0_u8;
-                    l_dqsclk_phase_value_u8[rank_group][2][1][1] = l_value_n1_u8;
-
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 50, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 54, 2);
-                    l_rdclk_phase_value_u8[rank_group][2][0][0] = l_value_n0_u8;
-                    l_rdclk_phase_value_u8[rank_group][2][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 58, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 62, 2);
-                    l_rdclk_phase_value_u8[rank_group][2][1][0] = l_value_n0_u8;
-                    l_rdclk_phase_value_u8[rank_group][2][1][1] = l_value_n1_u8;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_2, data_buffer_64);
-                    if (rc) return rc;
-                    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
-                    l_gate_delay_value_u8[rank_group][2][0][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][2][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
-                    l_gate_delay_value_u8[rank_group][2][1][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][2][1][1] = l_value_n1_u8;
-
-                    // PHY BLOCK 3
-
-                    rc = fapiGetScom(i_target, DISABLE_ADDR_3, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 4);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 4);
-                    l_disable_value_u8[rank_group][3][0][0] = l_value_n0_u8;
-                    l_disable_value_u8[rank_group][3][0][1] = l_value_n1_u8;
-                    l_disable_old_value_u8[rank_group][3][0][0] = l_value_n0_u8;
-                    l_disable_old_value_u8[rank_group][3][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 4);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 4);
-                    l_disable_value_u8[rank_group][3][1][0] = l_value_n0_u8;
-                    l_disable_value_u8[rank_group][3][1][1] = l_value_n1_u8;
-                    l_disable_old_value_u8[rank_group][3][1][0] = l_value_n0_u8;
-                    l_disable_old_value_u8[rank_group][3][1][1] = l_value_n1_u8;
-
-
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_3, data_buffer_64);
-                    if (rc) return rc;
-                    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 2);
-                    l_dqsclk_phase_value_u8[rank_group][3][0][0] = l_value_n0_u8;
-                    l_dqsclk_phase_value_u8[rank_group][3][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 2);
-                    l_dqsclk_phase_value_u8[rank_group][3][1][0] = l_value_n0_u8;
-                    l_dqsclk_phase_value_u8[rank_group][3][1][1] = l_value_n1_u8;
-
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 50, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 54, 2);
-                    l_rdclk_phase_value_u8[rank_group][3][0][0] = l_value_n0_u8;
-                    l_rdclk_phase_value_u8[rank_group][3][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 58, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 62, 2);
-                    l_rdclk_phase_value_u8[rank_group][3][1][0] = l_value_n0_u8;
-                    l_rdclk_phase_value_u8[rank_group][3][1][1] = l_value_n1_u8;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_3, data_buffer_64);
-                    if (rc) return rc;
-                    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
-                    l_gate_delay_value_u8[rank_group][3][0][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][3][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
-                    l_gate_delay_value_u8[rank_group][3][1][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][3][1][1] = l_value_n1_u8;
-
-                    // PHY BLOCK 4
-
-                    rc = fapiGetScom(i_target, DISABLE_ADDR_4, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 4);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 4);
-                    l_disable_value_u8[rank_group][4][0][0] = l_value_n0_u8;
-                    l_disable_value_u8[rank_group][4][0][1] = l_value_n1_u8;
-                    l_disable_old_value_u8[rank_group][4][0][0] = l_value_n0_u8;
-                    l_disable_old_value_u8[rank_group][4][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 4);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 4);
-                    l_disable_value_u8[rank_group][4][1][0] = l_value_n0_u8;
-                    l_disable_value_u8[rank_group][4][1][1] = l_value_n1_u8;
-                    l_disable_old_value_u8[rank_group][4][1][0] = l_value_n0_u8;
-                    l_disable_old_value_u8[rank_group][4][1][1] = l_value_n1_u8;
-
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_4, data_buffer_64);
-                    if (rc) return rc;
-                    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 2);
-                    l_dqsclk_phase_value_u8[rank_group][4][0][0] = l_value_n0_u8;
-                    l_dqsclk_phase_value_u8[rank_group][4][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 2);
-                    l_dqsclk_phase_value_u8[rank_group][4][1][0] = l_value_n0_u8;
-                    l_dqsclk_phase_value_u8[rank_group][4][1][1] = l_value_n1_u8;
-
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 50, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 54, 2);
-                    l_rdclk_phase_value_u8[rank_group][4][0][0] = l_value_n0_u8;
-                    l_rdclk_phase_value_u8[rank_group][4][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 58, 2);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 62, 2);
-                    l_rdclk_phase_value_u8[rank_group][4][1][0] = l_value_n0_u8;
-                    l_rdclk_phase_value_u8[rank_group][4][1][1] = l_value_n1_u8;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_4, data_buffer_64);
-                    if (rc) return rc;
-                    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
-                    l_gate_delay_value_u8[rank_group][4][0][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][4][0][1] = l_value_n1_u8;
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
-                    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
-                    l_gate_delay_value_u8[rank_group][4][1][0] = l_value_n0_u8;
-                    l_gate_delay_value_u8[rank_group][4][1][1] = l_value_n1_u8;
-
-                    if(rc_num)
-                    {
-                        rc.setEcmdError(rc_num);
-                        return rc;
-                    }
-
-                }
-        }
-
-        uint8_t ranks_array[4][4][2]; //[group][rank_group position][port]
+	{
+
+	     //Initialize values
+	     for(block = 0; block < maxblocks; block++)
+	     {
+		for (byte = 0; byte < maxbytes; byte++)
+		{
+			for (nibble = 0; nibble < maxnibbles; nibble++)
+			{
+				l_dqsclk_phase_value_u8[rank_group][block][byte][nibble] = 255;
+				l_gate_delay_value_u8[rank_group][block][byte][nibble] = 255;
+				l_rdclk_phase_value_u8[rank_group][block][byte][nibble] = 255;
+				l_disable_value_u8[rank_group][block][byte][nibble] = 0;
+				l_disable_old_value_u8[rank_group][block][byte][nibble] = 0;
+
+			}
+		}
+	     }
+
+	    //Check if rank group exists
+	    if(primary_ranks_array[rank_group][port] != 255)
+	    {
+	        FAPI_DBG("WR LVL DISABLE WORKAROUND: DISABLE Workaround being applied on  %s  PORT: %d RP: %d", i_target.toEcmdString(), port, rank_group);
+ 
+    		if ( port == 0 )
+    		{
+
+			if ( rank_group == 0 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_0_0x800000090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_1_0x800004090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_2_0x800008090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_3_0x80000C090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_4_0x800010090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_0_0x800000130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_1_0x800004130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_2_0x800008130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_3_0x80000C130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_4_0x800010130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_0_0x8000007c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_1_0x8000047c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_2_0x8000087c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_3_0x80000c7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_4_0x8000107c0301143F;
+
+
+			}
+			else if ( rank_group == 1 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_0_0x800001090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_1_0x800005090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_2_0x800009090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_3_0x80000D090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_4_0x800011090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_0_0x800001130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_1_0x800005130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_2_0x800009130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_3_0x80000D130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_4_0x800011130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_0_0x8000017c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_1_0x8000057c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_2_0x8000097c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_3_0x80000d7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_4_0x8000117c0301143F;
+
+			}
+			else if ( rank_group == 2 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_0_0x800002090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_1_0x800006090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_2_0x80000A090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_3_0x80000E090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_4_0x800012090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_0_0x800002130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_1_0x800006130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_2_0x80000A130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_3_0x80000E130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_4_0x800012130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_0_0x8000027c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_1_0x8000067c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_2_0x80000a7c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_3_0x80000e7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_4_0x8000127c0301143F;
+
+			}
+			else if ( rank_group == 3 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_0_0x800003090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_1_0x800007090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_2_0x80000B090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_3_0x80000F090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_4_0x800013090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_0_0x800003130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_1_0x800007130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_2_0x80000B130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_3_0x80000F130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_4_0x800013130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_0_0x8000037c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_1_0x8000077c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_2_0x80000b7c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_3_0x80000f7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_4_0x8000137c0301143F;
+
+			}
+		    }
+		    else if (port == 1 )
+		    {
+
+			if ( rank_group == 0 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_0_0x800100090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_1_0x800104090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_2_0x800108090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_3_0x80010C090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_4_0x800110090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_0_0x800100130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_1_0x800104130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_2_0x800108130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_3_0x80010C130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_4_0x800110130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_0_0x8001007c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_1_0x8001047c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_2_0x8001087c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_3_0x80010c7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_4_0x8001107c0301143F;
+
+			}
+			else if ( rank_group == 1 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_0_0x800101090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_1_0x800105090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_2_0x800109090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_3_0x80010D090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_4_0x800111090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_0_0x800101130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_1_0x800105130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_2_0x800109130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_3_0x80010D130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_4_0x800111130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_0_0x8001017c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_1_0x8001057c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_2_0x8001097c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_3_0x80010d7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_4_0x8001117c0301143F;
+
+			}
+			else if ( rank_group == 2 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_0_0x800102090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_1_0x800106090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_2_0x80010A090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_3_0x80010E090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_4_0x800112090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_0_0x800102130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_1_0x800106130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_2_0x80010A130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_3_0x80010E130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_4_0x800112130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_0_0x8001027c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_1_0x8001067c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_2_0x80010a7c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_3_0x80010e7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_4_0x8001127c0301143F;
+
+			}
+			else if ( rank_group == 3 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_0_0x800103090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_1_0x800107090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_2_0x80010B090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_3_0x80010F090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_4_0x800113090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_0_0x800103130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_1_0x800107130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_2_0x80010B130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_3_0x80010F130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_4_0x800113130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_0_0x8001037c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_1_0x8001077c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_2_0x80010b7c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_3_0x80010f7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_4_0x8001137c0301143F;
+
+			}
+		    }
+
+
+		    // PHY BLOCK 0
+
+		    rc = fapiGetScom(i_target, DISABLE_ADDR_0, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 4);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 4);
+		    l_disable_value_u8[rank_group][0][0][0] = l_value_n0_u8;
+		    l_disable_value_u8[rank_group][0][0][1] = l_value_n1_u8;
+		    l_disable_old_value_u8[rank_group][0][0][0] = l_value_n0_u8;
+		    l_disable_old_value_u8[rank_group][0][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 4);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 4);
+		    l_disable_value_u8[rank_group][0][1][0] = l_value_n0_u8;
+		    l_disable_value_u8[rank_group][0][1][1] = l_value_n1_u8;
+		    l_disable_old_value_u8[rank_group][0][1][0] = l_value_n0_u8;
+		    l_disable_old_value_u8[rank_group][0][1][1] = l_value_n1_u8;
+
+
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_0, data_buffer_64);
+		    if (rc) return rc;
+		    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 2);
+		    l_dqsclk_phase_value_u8[rank_group][0][0][0] = l_value_n0_u8;
+		    l_dqsclk_phase_value_u8[rank_group][0][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 2);
+		    l_dqsclk_phase_value_u8[rank_group][0][1][0] = l_value_n0_u8;
+		    l_dqsclk_phase_value_u8[rank_group][0][1][1] = l_value_n1_u8;
+
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 50, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 54, 2);
+		    l_rdclk_phase_value_u8[rank_group][0][0][0] = l_value_n0_u8;
+		    l_rdclk_phase_value_u8[rank_group][0][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 58, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 62, 2);
+		    l_rdclk_phase_value_u8[rank_group][0][1][0] = l_value_n0_u8;
+		    l_rdclk_phase_value_u8[rank_group][0][1][1] = l_value_n1_u8;
+
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_0, data_buffer_64);
+		    if (rc) return rc;
+		    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
+		    l_gate_delay_value_u8[rank_group][0][0][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][0][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
+		    l_gate_delay_value_u8[rank_group][0][1][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][0][1][1] = l_value_n1_u8;
+
+
+		    // PHY BLOCK 1
+
+		    rc = fapiGetScom(i_target, DISABLE_ADDR_1, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 4);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 4);
+		    l_disable_value_u8[rank_group][1][0][0] = l_value_n0_u8;
+		    l_disable_value_u8[rank_group][1][0][1] = l_value_n1_u8;
+		    l_disable_old_value_u8[rank_group][1][0][0] = l_value_n0_u8;
+		    l_disable_old_value_u8[rank_group][1][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 4);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 4);
+		    l_disable_value_u8[rank_group][1][1][0] = l_value_n0_u8;
+		    l_disable_value_u8[rank_group][1][1][1] = l_value_n1_u8;
+		    l_disable_old_value_u8[rank_group][1][1][0] = l_value_n0_u8;
+		    l_disable_old_value_u8[rank_group][1][1][1] = l_value_n1_u8;
+
+
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_1, data_buffer_64);
+		    if (rc) return rc;
+		    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 2);
+		    l_dqsclk_phase_value_u8[rank_group][1][0][0] = l_value_n0_u8;
+		    l_dqsclk_phase_value_u8[rank_group][1][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 2);
+		    l_dqsclk_phase_value_u8[rank_group][1][1][0] = l_value_n0_u8;
+		    l_dqsclk_phase_value_u8[rank_group][1][1][1] = l_value_n1_u8;
+
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 50, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 54, 2);
+		    l_rdclk_phase_value_u8[rank_group][1][0][0] = l_value_n0_u8;
+		    l_rdclk_phase_value_u8[rank_group][1][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 58, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 62, 2);
+		    l_rdclk_phase_value_u8[rank_group][1][1][0] = l_value_n0_u8;
+		    l_rdclk_phase_value_u8[rank_group][1][1][1] = l_value_n1_u8;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_1, data_buffer_64);
+		    if (rc) return rc;
+		    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
+		    l_gate_delay_value_u8[rank_group][1][0][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][1][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
+		    l_gate_delay_value_u8[rank_group][1][1][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][1][1][1] = l_value_n1_u8;
+
+		    // PHY BLOCK 2
+
+		    rc = fapiGetScom(i_target, DISABLE_ADDR_2, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 4);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 4);
+		    l_disable_value_u8[rank_group][2][0][0] = l_value_n0_u8;
+		    l_disable_value_u8[rank_group][2][0][1] = l_value_n1_u8;
+		    l_disable_old_value_u8[rank_group][2][0][0] = l_value_n0_u8;
+		    l_disable_old_value_u8[rank_group][2][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 4);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 4);
+		    l_disable_value_u8[rank_group][2][1][0] = l_value_n0_u8;
+		    l_disable_value_u8[rank_group][2][1][1] = l_value_n1_u8;
+		    l_disable_old_value_u8[rank_group][2][1][0] = l_value_n0_u8;
+		    l_disable_old_value_u8[rank_group][2][1][1] = l_value_n1_u8;
+
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_2, data_buffer_64);
+		    if (rc) return rc;
+		    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 2);
+		    l_dqsclk_phase_value_u8[rank_group][2][0][0] = l_value_n0_u8;
+		    l_dqsclk_phase_value_u8[rank_group][2][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 2);
+		    l_dqsclk_phase_value_u8[rank_group][2][1][0] = l_value_n0_u8;
+		    l_dqsclk_phase_value_u8[rank_group][2][1][1] = l_value_n1_u8;
+
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 50, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 54, 2);
+		    l_rdclk_phase_value_u8[rank_group][2][0][0] = l_value_n0_u8;
+		    l_rdclk_phase_value_u8[rank_group][2][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 58, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 62, 2);
+		    l_rdclk_phase_value_u8[rank_group][2][1][0] = l_value_n0_u8;
+		    l_rdclk_phase_value_u8[rank_group][2][1][1] = l_value_n1_u8;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_2, data_buffer_64);
+		    if (rc) return rc;
+		    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
+		    l_gate_delay_value_u8[rank_group][2][0][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][2][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
+		    l_gate_delay_value_u8[rank_group][2][1][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][2][1][1] = l_value_n1_u8;
+
+		    // PHY BLOCK 3
+
+		    rc = fapiGetScom(i_target, DISABLE_ADDR_3, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 4);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 4);
+		    l_disable_value_u8[rank_group][3][0][0] = l_value_n0_u8;
+		    l_disable_value_u8[rank_group][3][0][1] = l_value_n1_u8;
+		    l_disable_old_value_u8[rank_group][3][0][0] = l_value_n0_u8;
+		    l_disable_old_value_u8[rank_group][3][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 4);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 4);
+		    l_disable_value_u8[rank_group][3][1][0] = l_value_n0_u8;
+		    l_disable_value_u8[rank_group][3][1][1] = l_value_n1_u8;
+		    l_disable_old_value_u8[rank_group][3][1][0] = l_value_n0_u8;
+		    l_disable_old_value_u8[rank_group][3][1][1] = l_value_n1_u8;
+
+
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_3, data_buffer_64);
+		    if (rc) return rc;
+		    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 2);
+		    l_dqsclk_phase_value_u8[rank_group][3][0][0] = l_value_n0_u8;
+		    l_dqsclk_phase_value_u8[rank_group][3][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 2);
+		    l_dqsclk_phase_value_u8[rank_group][3][1][0] = l_value_n0_u8;
+		    l_dqsclk_phase_value_u8[rank_group][3][1][1] = l_value_n1_u8;
+
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 50, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 54, 2);
+		    l_rdclk_phase_value_u8[rank_group][3][0][0] = l_value_n0_u8;
+		    l_rdclk_phase_value_u8[rank_group][3][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 58, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 62, 2);
+		    l_rdclk_phase_value_u8[rank_group][3][1][0] = l_value_n0_u8;
+		    l_rdclk_phase_value_u8[rank_group][3][1][1] = l_value_n1_u8;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_3, data_buffer_64);
+		    if (rc) return rc;
+		    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
+		    l_gate_delay_value_u8[rank_group][3][0][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][3][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
+		    l_gate_delay_value_u8[rank_group][3][1][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][3][1][1] = l_value_n1_u8;
+
+		    // PHY BLOCK 4
+
+		    rc = fapiGetScom(i_target, DISABLE_ADDR_4, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 4);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 4);
+		    l_disable_value_u8[rank_group][4][0][0] = l_value_n0_u8;
+		    l_disable_value_u8[rank_group][4][0][1] = l_value_n1_u8;
+		    l_disable_old_value_u8[rank_group][4][0][0] = l_value_n0_u8;
+		    l_disable_old_value_u8[rank_group][4][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 4);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 4);
+		    l_disable_value_u8[rank_group][4][1][0] = l_value_n0_u8;
+		    l_disable_value_u8[rank_group][4][1][1] = l_value_n1_u8;
+		    l_disable_old_value_u8[rank_group][4][1][0] = l_value_n0_u8;
+		    l_disable_old_value_u8[rank_group][4][1][1] = l_value_n1_u8;
+
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_4, data_buffer_64);
+		    if (rc) return rc;
+		    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 48, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 52, 2);
+		    l_dqsclk_phase_value_u8[rank_group][4][0][0] = l_value_n0_u8;
+		    l_dqsclk_phase_value_u8[rank_group][4][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 56, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 60, 2);
+		    l_dqsclk_phase_value_u8[rank_group][4][1][0] = l_value_n0_u8;
+		    l_dqsclk_phase_value_u8[rank_group][4][1][1] = l_value_n1_u8;
+
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 50, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 54, 2);
+		    l_rdclk_phase_value_u8[rank_group][4][0][0] = l_value_n0_u8;
+		    l_rdclk_phase_value_u8[rank_group][4][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 58, 2);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 62, 2);
+		    l_rdclk_phase_value_u8[rank_group][4][1][0] = l_value_n0_u8;
+		    l_rdclk_phase_value_u8[rank_group][4][1][1] = l_value_n1_u8;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_4, data_buffer_64);
+		    if (rc) return rc;
+		    // Grabbing 2 nibbles of the same byte and making them equal the same lowest value
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 49, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 53, 3);
+		    l_gate_delay_value_u8[rank_group][4][0][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][4][0][1] = l_value_n1_u8;
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n0_u8, 57, 3);
+		    rc_num = rc_num | data_buffer_64.extractToRight(&l_value_n1_u8, 61, 3);
+		    l_gate_delay_value_u8[rank_group][4][1][0] = l_value_n0_u8;
+		    l_gate_delay_value_u8[rank_group][4][1][1] = l_value_n1_u8;
+
+		    if(rc_num)
+		    {
+			rc.setEcmdError(rc_num);
+			return rc;
+		    }
+
+		}
+	}
+
+	uint8_t ranks_array[4][4][2]; //[group][rank_group position][port]
         // Determine rank and rank group matching
         rc = FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP0, &i_target, ranks_array[0][0]); if(rc) return rc;
-        rc = FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP1, &i_target, ranks_array[1][0]); if(rc) return rc;
-        rc = FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP2, &i_target, ranks_array[2][0]); if(rc) return rc;
-        rc = FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP3, &i_target, ranks_array[3][0]); if(rc) return rc;
-        rc = FAPI_ATTR_GET(ATTR_EFF_SECONDARY_RANK_GROUP0, &i_target, ranks_array[0][1]); if(rc) return rc;
-        rc = FAPI_ATTR_GET(ATTR_EFF_SECONDARY_RANK_GROUP1, &i_target, ranks_array[1][1]); if(rc) return rc;
-        rc = FAPI_ATTR_GET(ATTR_EFF_SECONDARY_RANK_GROUP2, &i_target, ranks_array[2][1]); if(rc) return rc;
-        rc = FAPI_ATTR_GET(ATTR_EFF_SECONDARY_RANK_GROUP3, &i_target, ranks_array[3][1]); if(rc) return rc;
-        rc = FAPI_ATTR_GET(ATTR_EFF_TERTIARY_RANK_GROUP0, &i_target, ranks_array[0][2]); if(rc) return rc;
-        rc = FAPI_ATTR_GET(ATTR_EFF_TERTIARY_RANK_GROUP1, &i_target, ranks_array[1][2]); if(rc) return rc;
-        rc = FAPI_ATTR_GET(ATTR_EFF_TERTIARY_RANK_GROUP2, &i_target, ranks_array[2][2]); if(rc) return rc;
-        rc = FAPI_ATTR_GET(ATTR_EFF_TERTIARY_RANK_GROUP3, &i_target, ranks_array[3][2]); if(rc) return rc;
-        rc = FAPI_ATTR_GET(ATTR_EFF_QUATERNARY_RANK_GROUP0, &i_target, ranks_array[0][3]); if(rc) return rc;
-        rc = FAPI_ATTR_GET(ATTR_EFF_QUATERNARY_RANK_GROUP1, &i_target, ranks_array[1][3]); if(rc) return rc;
-        rc = FAPI_ATTR_GET(ATTR_EFF_QUATERNARY_RANK_GROUP2, &i_target, ranks_array[2][3]); if(rc) return rc;
-        rc = FAPI_ATTR_GET(ATTR_EFF_QUATERNARY_RANK_GROUP3, &i_target, ranks_array[3][3]); if(rc) return rc;
+      	rc = FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP1, &i_target, ranks_array[1][0]); if(rc) return rc;
+      	rc = FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP2, &i_target, ranks_array[2][0]); if(rc) return rc;
+	rc = FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP3, &i_target, ranks_array[3][0]); if(rc) return rc;
+	rc = FAPI_ATTR_GET(ATTR_EFF_SECONDARY_RANK_GROUP0, &i_target, ranks_array[0][1]); if(rc) return rc;
+	rc = FAPI_ATTR_GET(ATTR_EFF_SECONDARY_RANK_GROUP1, &i_target, ranks_array[1][1]); if(rc) return rc;
+	rc = FAPI_ATTR_GET(ATTR_EFF_SECONDARY_RANK_GROUP2, &i_target, ranks_array[2][1]); if(rc) return rc;
+	rc = FAPI_ATTR_GET(ATTR_EFF_SECONDARY_RANK_GROUP3, &i_target, ranks_array[3][1]); if(rc) return rc;
+	rc = FAPI_ATTR_GET(ATTR_EFF_TERTIARY_RANK_GROUP0, &i_target, ranks_array[0][2]); if(rc) return rc;
+	rc = FAPI_ATTR_GET(ATTR_EFF_TERTIARY_RANK_GROUP1, &i_target, ranks_array[1][2]); if(rc) return rc;
+	rc = FAPI_ATTR_GET(ATTR_EFF_TERTIARY_RANK_GROUP2, &i_target, ranks_array[2][2]); if(rc) return rc;
+	rc = FAPI_ATTR_GET(ATTR_EFF_TERTIARY_RANK_GROUP3, &i_target, ranks_array[3][2]); if(rc) return rc;
+	rc = FAPI_ATTR_GET(ATTR_EFF_QUATERNARY_RANK_GROUP0, &i_target, ranks_array[0][3]); if(rc) return rc;
+	rc = FAPI_ATTR_GET(ATTR_EFF_QUATERNARY_RANK_GROUP1, &i_target, ranks_array[1][3]); if(rc) return rc;
+	rc = FAPI_ATTR_GET(ATTR_EFF_QUATERNARY_RANK_GROUP2, &i_target, ranks_array[2][3]); if(rc) return rc;
+	rc = FAPI_ATTR_GET(ATTR_EFF_QUATERNARY_RANK_GROUP3, &i_target, ranks_array[3][3]); if(rc) return rc;
 
 
         access_type_t l_access_type_e = READ;
-        //READ
-        //WRITE
+	//READ
+	//WRITE
         input_type_t l_input_type_e = WR_DQS;
         //WR_DQ_t,
         //RAW_WR_DQ,
         //WR_DQS_t,
         //RAW_WR_DQS,
-        uint8_t l_flag = 0;
-        uint8_t l_verbose = 0;
-        uint8_t l_rank_u8;
-        uint32_t l_old_delay_value_u32 = 0;
-        uint32_t l_old_DQS_delay_value_u32 = 0;
-        uint32_t l_delay_value_u32 = 0;
-        uint32_t l_DQS_delay_value_u32 = 0;
-        uint8_t l_index_u8 = 0;
-        uint8_t mask;
-        uint8_t nibble_dq;
+	uint8_t l_flag = 0;
+	uint8_t l_verbose = 0;
+	uint8_t l_rank_u8;
+	uint32_t l_old_delay_value_u32 = 0;
+	uint32_t l_old_DQS_delay_value_u32 = 0;
+	uint32_t l_delay_value_u32 = 0;
+	uint32_t l_DQS_delay_value_u32 = 0;
+	uint8_t l_index_u8 = 0;
+	uint8_t mask;
+	uint8_t nibble_dq;
         uint8_t lane;
-        uint8_t rg;
+	uint8_t rg;
         uint8_t rank_2;
-        uint8_t width;
-        uint8_t dqs_index;
-
-        rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_WIDTH, &i_target, width);
-
-            uint32_t instruction_number = 0;
-            ecmdDataBufferBase address_buffer_16(16);
-            rc_num = rc_num | address_buffer_16.flushTo0();
-            ecmdDataBufferBase bank_buffer_8(8);
-            rc_num = rc_num | bank_buffer_8.flushTo0();
-            ecmdDataBufferBase activate_buffer_1(1);
-            rc_num = rc_num | activate_buffer_1.flushTo0();
-            ecmdDataBufferBase rasn_buffer_1(1);
-            ecmdDataBufferBase casn_buffer_1(1);
-            ecmdDataBufferBase wen_buffer_1(1);
-            ecmdDataBufferBase cke_buffer_8(8);
-            rc_num = rc_num | cke_buffer_8.flushTo1();
-            ecmdDataBufferBase csn_buffer_8(8);
-            rc_num = rc_num | csn_buffer_8.flushTo1();
-            ecmdDataBufferBase odt_buffer_8(8);
-            rc_num = rc_num | odt_buffer_8.flushTo0();
-            ecmdDataBufferBase test_buffer_4(4);
-            rc_num = rc_num | test_buffer_4.setBit(0,4);
-
-            ecmdDataBufferBase num_idles_buffer_16(16);
-            rc_num = rc_num | num_idles_buffer_16.flushTo1();
-            ecmdDataBufferBase num_repeat_buffer_16(16);
-            rc_num = rc_num | num_repeat_buffer_16.flushTo0();
-            ecmdDataBufferBase data_buffer_20(20);
-            rc_num = rc_num | data_buffer_20.flushTo0();
-            ecmdDataBufferBase read_compare_buffer_1(1);
-            rc_num = rc_num | read_compare_buffer_1.flushTo0();
-            ecmdDataBufferBase rank_cal_buffer_4(4);
-            rc_num = rc_num | rank_cal_buffer_4.flushTo0();
-            ecmdDataBufferBase ddr_cal_enable_buffer_1(1);
-            rc_num = rc_num | ddr_cal_enable_buffer_1.flushTo1();
-            ecmdDataBufferBase ccs_end_buffer_1(1);
-            rc_num = rc_num | ccs_end_buffer_1.flushTo1();
-            uint8_t group = 255;
-            const uint32_t NUM_POLL = 10000;
-
-
-            uint8_t cur_cal_step = 2;
-            enum mss_draminit_training_result cur_error_status = MSS_INIT_CAL_PASS;
-            uint8_t mbaPosition;
-            // Get MBA position: 0 = mba01, 1 = mba23
-            rc = FAPI_ATTR_GET(ATTR_CHIP_UNIT_POS, &i_target, mbaPosition);
-            if(rc)
-            {
-                FAPI_ERR("Error getting MBA position");
-                return rc;
-            }
-
-
-
-        //Resetting Disable mask.  Avoid spares.
-        for(block = 0; block < maxblocks; block++)
-        {
-                for (byte = 0; byte < 2; byte++)
-                {
-
-                        for (nibble = 0; nibble < maxnibbles; nibble++)
-                        {
-
-                                for(rank_group = 0; rank_group < MAX_PRI_RANKS; rank_group++)
-                                {
-
-                                    //Check if rank group exists
-                                    if(primary_ranks_array[rank_group][port] != 255)
-                                    {
-
-
-                                        if ( port == 0 )
-                                        {
-
-                                                if ( rank_group == 0 )
-                                                {
-
-                                                    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_0_0x8000007c0301143F;
-                                                    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_1_0x8000047c0301143F;
-                                                    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_2_0x8000087c0301143F;
-                                                    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_3_0x80000c7c0301143F;
-                                                    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_4_0x8000107c0301143F;
-
-                                                }
-                                                else if ( rank_group == 1 )
-                                                {
-
-                                                    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_0_0x8000017c0301143F;
-                                                    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_1_0x8000057c0301143F;
-                                                    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_2_0x8000097c0301143F;
-                                                    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_3_0x80000d7c0301143F;
-                                                    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_4_0x8000117c0301143F;
-
-                                                }
-                                                else if ( rank_group == 2 )
-                                                {
-
-                                                    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_0_0x8000027c0301143F;
-                                                    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_1_0x8000067c0301143F;
-                                                    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_2_0x80000a7c0301143F;
-                                                    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_3_0x80000e7c0301143F;
-                                                    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_4_0x8000127c0301143F;
-
-                                                }
-                                                else if ( rank_group == 3 )
-                                                {
-
-                                                    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_0_0x8000037c0301143F;
-                                                    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_1_0x8000077c0301143F;
-                                                    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_2_0x80000b7c0301143F;
-                                                    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_3_0x80000f7c0301143F;
-                                                    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_4_0x8000137c0301143F;
-
-                                                }
-                                            }
-                                            else if (port == 1 )
-                                            {
-
-                                                if ( rank_group == 0 )
-                                                {
-
-                                                    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_0_0x8001007c0301143F;
-                                                    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_1_0x8001047c0301143F;
-                                                    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_2_0x8001087c0301143F;
-                                                    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_3_0x80010c7c0301143F;
-                                                    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_4_0x8001107c0301143F;
-
-                                                }
-                                                else if ( rank_group == 1 )
-                                                {
-
-                                                    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_0_0x8001017c0301143F;
-                                                    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_1_0x8001057c0301143F;
-                                                    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_2_0x8001097c0301143F;
-                                                    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_3_0x80010d7c0301143F;
-                                                    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_4_0x8001117c0301143F;
-
-
-                                                }
-                                                else if ( rank_group == 2 )
-                                                {
-
-                                                    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_0_0x8001027c0301143F;
-                                                    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_1_0x8001067c0301143F;
-                                                    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_2_0x80010a7c0301143F;
-                                                    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_3_0x80010e7c0301143F;
-                                                    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_4_0x8001127c0301143F;
-
-
-                                                }
-                                                else if ( rank_group == 3 )
-                                                {
-
-                                                    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_0_0x8001037c0301143F;
-                                                    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_1_0x8001077c0301143F;
-                                                    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_2_0x80010b7c0301143F;
-                                                    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_3_0x80010f7c0301143F;
-                                                    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_4_0x8001137c0301143F;
-
-                                                }
-                                            }
-
-                                        lane = byte * 8 + nibble*4;
-                                        l_input_type_e = WR_DQ;
-                                        l_flag = 1;
-                                        // C4 DQ to lane/block (flag = 0) in PHY or lane/block to C4 DQ (flag = 1)
-                                        // In this case moving from  lane/block to C4 DQ to determine spare
-                                        rc = mss_c4_phy(i_target, port, rank_group, l_input_type_e, l_index_u8, l_verbose, lane, block, l_flag);
-                                        if (rc) return rc;
-
-                                        dqs_index = l_index_u8 / 8;
-
-
-                                        if ( ((dqs_index % 9 == 0)&&(dqs_index/9 > 0)) && (l_disable_value_u8[rank_group][block][byte][nibble] != 0x0))
-                                        {
-                                                //This is a spare.  Unmark it in the old map for the rest of the workaround to not operate on a spare
-                                                FAPI_DBG("WR LVL DISABLE WORKAROUND: Denoting Spare that is disabled for block: %d byte: %d nibble: %d Previous Value: 0x%02X", block, byte, nibble, l_disable_value_u8[rank_group][block][byte][nibble]);
-                                                l_disable_old_value_u8[rank_group][block][byte][nibble] = 0x00;
-
-                                        }
-                                        else if (l_disable_value_u8[rank_group][block][byte][nibble] != 0x00)
-                                        {
-                                                //This is not a spare.  Unmark into what will be scommed back in; to be able to reset the disable mask.
-                                                FAPI_DBG("WR LVL DISABLE WORKAROUND: Unmasking disable for block: %d byte: %d nibble: %d Previous Value: 0x%02X", block, byte, nibble, l_disable_value_u8[rank_group][block][byte][nibble]);
-                                                l_disable_value_u8[rank_group][block][byte][nibble] = 0x00;
-
-                                        }
-
-
-                                            //BLOCK 0
-                                            rc = fapiGetScom(i_target, DISABLE_ADDR_0, data_buffer_64);
-                                            if (rc) return rc;
-                                            rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][0][0][0], 48, 4);
-                                            rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][0][0][1], 52, 4);
-                                            rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][0][1][0], 56, 4);
-                                            rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][0][1][1], 60, 4);
-                                            rc = fapiPutScom(i_target, DISABLE_ADDR_0, data_buffer_64);
-                                            if (rc) return rc;
-
-                                            //BLOCK 1
-
-                                            rc = fapiGetScom(i_target, DISABLE_ADDR_1, data_buffer_64);
-                                            if (rc) return rc;
-                                            rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][1][0][0], 48, 4);
-                                            rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][1][0][1], 52, 4);
-                                            rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][1][1][0], 56, 4);
-                                            rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][1][1][1], 60, 4);
-                                            rc = fapiPutScom(i_target, DISABLE_ADDR_1, data_buffer_64);
-                                            if (rc) return rc;
-
-                                            //BLOCK 2
-
-                                            rc = fapiGetScom(i_target, DISABLE_ADDR_2, data_buffer_64);
-                                            if (rc) return rc;
-                                            rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][2][0][0], 48, 4);
-                                            rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][2][0][1], 52, 4);
-                                            rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][2][1][0], 56, 4);
-                                            rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][2][1][1], 60, 4);
-                                            rc = fapiPutScom(i_target, DISABLE_ADDR_2, data_buffer_64);
-                                            if (rc) return rc;
-
-
-                                            //BLOCK 3
-
-                                            rc = fapiGetScom(i_target, DISABLE_ADDR_3, data_buffer_64);
-                                            if (rc) return rc;
-                                            rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][3][0][0], 48, 4);
-                                            rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][3][0][1], 52, 4);
-                                            rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][3][1][0], 56, 4);
-                                            rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][3][1][1], 60, 4);
-                                            rc = fapiPutScom(i_target, DISABLE_ADDR_3, data_buffer_64);
-                                            if (rc) return rc;
-
-
-                                            //Block 4
-                                            rc = fapiGetScom(i_target, DISABLE_ADDR_4, data_buffer_64);
-                                            if (rc) return rc;
-                                            rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][4][0][0], 48, 4);
-                                            rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][4][0][1], 52, 4);
-                                            rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][4][1][0], 56, 4);
-                                            rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][4][1][1], 60, 4);
-                                            rc = fapiPutScom(i_target, DISABLE_ADDR_4, data_buffer_64);
-                                            if (rc) return rc;
-
-
-                                    }
-                              }
-                        }
-                }
-        }
-
-
-        //Re-run DQS ALIGN for only rank_group/ports that had a disable.
-
-        for(rank_group = 0; rank_group < MAX_PRI_RANKS; rank_group++)
-        {
-                group = 255;
-                for(block = 0; block < maxblocks; block++)
-                {
-                        for (byte = 0; byte < maxbytes; byte++)
-                        {
-
-                                for (nibble = 0; nibble < maxnibbles; nibble++)
-                                {
-                                    //Check if rank group exists
-                                    if(primary_ranks_array[rank_group][port] != 255)
-                                    {
-                                        if (l_disable_old_value_u8[rank_group][block][byte][nibble] != 0x0)
-                                        {
-                                                group = rank_group;
-                                        }
-                                    }
-
-                                }
-                        }
-                }
-                FAPI_DBG("WR LVL DISABLE WORKAROUND: DQS ALIGN LOOP on group: %d rank_group: %d port: %d", group, rank_group, port);
-                if (group != 255)
-                {
-
-                     FAPI_DBG("WR LVL DISABLE WORKAROUND: Re-Running DQS ALIGN on rank_group: %d port: %d", group, port);
-                    //Clearing any status or errors bits that may have occured in previous training subtest.
-                    if(port == 0)
-                    {
-                        //clear status reg
-                        rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_STATUS_P0_0x8000C0190301143F, data_buffer_64);
-                        if(rc) return rc;
-                        rc_num = rc_num | data_buffer_64.clearBit(48, 4);
-                        rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_STATUS_P0_0x8000C0190301143F, data_buffer_64);
-                        if(rc) return rc;
-
-                        //clear error reg
-                        rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_ERROR_P0_0x8000C0180301143F, data_buffer_64);
-                        if(rc) return rc;
-                        rc_num = rc_num | data_buffer_64.clearBit(48, 11);
-                        rc_num = rc_num | data_buffer_64.clearBit(60, 4);
-                        rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_ERROR_P0_0x8000C0180301143F, data_buffer_64);
-                        if(rc) return rc;
+	uint8_t width;
+	uint8_t dqs_index;
+
+	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_WIDTH, &i_target, width);
+
+	    uint32_t instruction_number = 0;
+	    ecmdDataBufferBase address_buffer_16(16);
+	    rc_num = rc_num | address_buffer_16.flushTo0();
+	    ecmdDataBufferBase bank_buffer_8(8);
+	    rc_num = rc_num | bank_buffer_8.flushTo0();
+	    ecmdDataBufferBase activate_buffer_1(1);
+	    rc_num = rc_num | activate_buffer_1.flushTo0();
+	    ecmdDataBufferBase rasn_buffer_1(1);
+	    ecmdDataBufferBase casn_buffer_1(1);
+	    ecmdDataBufferBase wen_buffer_1(1);
+	    ecmdDataBufferBase cke_buffer_8(8);
+	    rc_num = rc_num | cke_buffer_8.flushTo1();
+	    ecmdDataBufferBase csn_buffer_8(8);
+	    rc_num = rc_num | csn_buffer_8.flushTo1();
+	    ecmdDataBufferBase odt_buffer_8(8);
+	    rc_num = rc_num | odt_buffer_8.flushTo0();
+	    ecmdDataBufferBase test_buffer_4(4);
+	    rc_num = rc_num | test_buffer_4.setBit(0,4);
+
+	    ecmdDataBufferBase num_idles_buffer_16(16);
+	    rc_num = rc_num | num_idles_buffer_16.flushTo1();
+	    ecmdDataBufferBase num_repeat_buffer_16(16);
+	    rc_num = rc_num | num_repeat_buffer_16.flushTo0();
+	    ecmdDataBufferBase data_buffer_20(20);
+	    rc_num = rc_num | data_buffer_20.flushTo0();
+	    ecmdDataBufferBase read_compare_buffer_1(1);
+	    rc_num = rc_num | read_compare_buffer_1.flushTo0();
+	    ecmdDataBufferBase rank_cal_buffer_4(4);
+	    rc_num = rc_num | rank_cal_buffer_4.flushTo0();
+	    ecmdDataBufferBase ddr_cal_enable_buffer_1(1);
+	    rc_num = rc_num | ddr_cal_enable_buffer_1.flushTo1();
+	    ecmdDataBufferBase ccs_end_buffer_1(1);
+	    rc_num = rc_num | ccs_end_buffer_1.flushTo1();
+	    uint8_t group = 255; 
+	    const uint32_t NUM_POLL = 10000;
+
+
+	    uint8_t cur_cal_step = 2;
+	    enum mss_draminit_training_result cur_error_status = MSS_INIT_CAL_PASS;
+	    uint8_t mbaPosition;
+	    // Get MBA position: 0 = mba01, 1 = mba23
+	    rc = FAPI_ATTR_GET(ATTR_CHIP_UNIT_POS, &i_target, mbaPosition);
+	    if(rc)
+	    {
+		FAPI_ERR("Error getting MBA position");
+		return rc;
+	    }
+
+
+
+	//Resetting Disable mask.  Avoid spares.
+	for(block = 0; block < maxblocks; block++)
+	{
+		for (byte = 0; byte < 2; byte++)
+		{
+
+			for (nibble = 0; nibble < maxnibbles; nibble++)
+			{
+
+				for(rank_group = 0; rank_group < MAX_PRI_RANKS; rank_group++)
+				{	
+				
+				    //Check if rank group exists
+				    if(primary_ranks_array[rank_group][port] != 255)
+				    {
+
+			 
+			    		if ( port == 0 )
+			    		{
+
+						if ( rank_group == 0 )
+						{
+
+						    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_0_0x8000007c0301143F;
+						    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_1_0x8000047c0301143F;
+						    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_2_0x8000087c0301143F;
+						    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_3_0x80000c7c0301143F;
+						    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_4_0x8000107c0301143F;
+
+						}
+						else if ( rank_group == 1 )
+						{
+
+						    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_0_0x8000017c0301143F;
+						    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_1_0x8000057c0301143F;
+						    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_2_0x8000097c0301143F;
+						    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_3_0x80000d7c0301143F;
+						    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_4_0x8000117c0301143F;
+
+						}
+						else if ( rank_group == 2 )
+						{
+
+						    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_0_0x8000027c0301143F;
+						    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_1_0x8000067c0301143F;
+						    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_2_0x80000a7c0301143F;
+						    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_3_0x80000e7c0301143F;
+						    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_4_0x8000127c0301143F;
+
+						}
+						else if ( rank_group == 3 )
+						{
+
+						    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_0_0x8000037c0301143F;
+						    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_1_0x8000077c0301143F;
+						    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_2_0x80000b7c0301143F;
+						    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_3_0x80000f7c0301143F;
+						    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_4_0x8000137c0301143F;
+
+						}
+					    }
+					    else if (port == 1 )
+					    {
+
+						if ( rank_group == 0 )
+						{
+
+						    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_0_0x8001007c0301143F;
+						    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_1_0x8001047c0301143F;
+						    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_2_0x8001087c0301143F;
+						    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_3_0x80010c7c0301143F;
+						    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_4_0x8001107c0301143F;
+
+						}
+						else if ( rank_group == 1 )
+						{
+
+						    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_0_0x8001017c0301143F;
+						    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_1_0x8001057c0301143F;
+						    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_2_0x8001097c0301143F;
+						    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_3_0x80010d7c0301143F;
+						    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_4_0x8001117c0301143F;
+
+
+						}
+						else if ( rank_group == 2 )
+						{
+
+						    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_0_0x8001027c0301143F;
+						    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_1_0x8001067c0301143F;
+						    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_2_0x80010a7c0301143F;
+						    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_3_0x80010e7c0301143F;
+						    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_4_0x8001127c0301143F;
+
+
+						}
+						else if ( rank_group == 3 )
+						{
+
+						    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_0_0x8001037c0301143F;
+						    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_1_0x8001077c0301143F;
+						    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_2_0x80010b7c0301143F;
+						    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_3_0x80010f7c0301143F;
+						    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_4_0x8001137c0301143F;
+
+						}
+					    }
+
+					lane = byte * 8 + nibble*4; 
+					l_input_type_e = WR_DQ;
+					l_flag = 1;
+					// C4 DQ to lane/block (flag = 0) in PHY or lane/block to C4 DQ (flag = 1) 
+					// In this case moving from  lane/block to C4 DQ to determine spare
+					rc = mss_c4_phy(i_target, port, rank_group, l_input_type_e, l_index_u8, l_verbose, lane, block, l_flag);
+					if (rc) return rc;
+
+					dqs_index = l_index_u8 / 8;
+
+
+					if ( ((dqs_index % 9 == 0)&&(dqs_index/9 > 0)) && (l_disable_value_u8[rank_group][block][byte][nibble] != 0x0))
+					{
+				                //This is a spare.  Unmark it in the old map for the rest of the workaround to not operate on a spare
+						FAPI_DBG("WR LVL DISABLE WORKAROUND: Denoting Spare that is disabled for block: %d byte: %d nibble: %d Previous Value: 0x%02X", block, byte, nibble, l_disable_value_u8[rank_group][block][byte][nibble]);
+						l_disable_old_value_u8[rank_group][block][byte][nibble] = 0x00;
+
+					}
+					else if (l_disable_value_u8[rank_group][block][byte][nibble] != 0x00)
+					{
+						//This is not a spare.  Unmark into what will be scommed back in; to be able to reset the disable mask.
+						FAPI_DBG("WR LVL DISABLE WORKAROUND: Unmasking disable for block: %d byte: %d nibble: %d Previous Value: 0x%02X", block, byte, nibble, l_disable_value_u8[rank_group][block][byte][nibble]);
+						l_disable_value_u8[rank_group][block][byte][nibble] = 0x00;
+
+					}
+
+
+					    //BLOCK 0
+					    rc = fapiGetScom(i_target, DISABLE_ADDR_0, data_buffer_64);
+					    if (rc) return rc;
+					    rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][0][0][0], 48, 4);
+					    rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][0][0][1], 52, 4);
+					    rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][0][1][0], 56, 4);
+					    rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][0][1][1], 60, 4);
+					    rc = fapiPutScom(i_target, DISABLE_ADDR_0, data_buffer_64);
+					    if (rc) return rc;
+
+					    //BLOCK 1
+
+					    rc = fapiGetScom(i_target, DISABLE_ADDR_1, data_buffer_64);
+					    if (rc) return rc;
+					    rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][1][0][0], 48, 4);
+					    rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][1][0][1], 52, 4);
+					    rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][1][1][0], 56, 4);
+					    rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][1][1][1], 60, 4);
+					    rc = fapiPutScom(i_target, DISABLE_ADDR_1, data_buffer_64);
+					    if (rc) return rc;
+
+					    //BLOCK 2
+
+					    rc = fapiGetScom(i_target, DISABLE_ADDR_2, data_buffer_64);
+					    if (rc) return rc;
+					    rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][2][0][0], 48, 4);
+					    rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][2][0][1], 52, 4);
+					    rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][2][1][0], 56, 4);
+					    rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][2][1][1], 60, 4);
+					    rc = fapiPutScom(i_target, DISABLE_ADDR_2, data_buffer_64);
+					    if (rc) return rc;
+
+
+					    //BLOCK 3
+
+					    rc = fapiGetScom(i_target, DISABLE_ADDR_3, data_buffer_64);
+					    if (rc) return rc;
+					    rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][3][0][0], 48, 4);
+					    rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][3][0][1], 52, 4);
+					    rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][3][1][0], 56, 4);
+					    rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][3][1][1], 60, 4);
+					    rc = fapiPutScom(i_target, DISABLE_ADDR_3, data_buffer_64);
+					    if (rc) return rc;
+
+
+					    //Block 4
+					    rc = fapiGetScom(i_target, DISABLE_ADDR_4, data_buffer_64);
+					    if (rc) return rc;
+					    rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][4][0][0], 48, 4);
+					    rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][4][0][1], 52, 4);
+					    rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][4][1][0], 56, 4);
+					    rc_num = rc_num | data_buffer_64.insertFromRight(&l_disable_value_u8[rank_group][4][1][1], 60, 4);
+					    rc = fapiPutScom(i_target, DISABLE_ADDR_4, data_buffer_64);
+					    if (rc) return rc;
+
+
+				    }
+			      }
+			}
+		}
+	}
+
+
+	//Re-run DQS ALIGN for only rank_group/ports that had a disable.
+
+	for(rank_group = 0; rank_group < MAX_PRI_RANKS; rank_group++)
+	{	
+		group = 255;
+		for(block = 0; block < maxblocks; block++)
+		{
+			for (byte = 0; byte < maxbytes; byte++)
+			{
+
+				for (nibble = 0; nibble < maxnibbles; nibble++)
+				{
+				    //Check if rank group exists
+				    if(primary_ranks_array[rank_group][port] != 255)
+				    {
+					if (l_disable_old_value_u8[rank_group][block][byte][nibble] != 0x0)
+					{ 
+						group = rank_group;
+					}
+				    }
+
+				}
+			}
+		}
+		FAPI_DBG("WR LVL DISABLE WORKAROUND: DQS ALIGN LOOP on group: %d rank_group: %d port: %d", group, rank_group, port);
+		if (group != 255)
+		{
+
+		     FAPI_DBG("WR LVL DISABLE WORKAROUND: Re-Running DQS ALIGN on rank_group: %d port: %d", group, port);
+		    //Clearing any status or errors bits that may have occured in previous training subtest.
+		    if(port == 0)
+		    {
+			//clear status reg
+			rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_STATUS_P0_0x8000C0190301143F, data_buffer_64);
+			if(rc) return rc;
+			rc_num = rc_num | data_buffer_64.clearBit(48, 4);
+			rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_STATUS_P0_0x8000C0190301143F, data_buffer_64);
+			if(rc) return rc;
+
+			//clear error reg
+			rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_ERROR_P0_0x8000C0180301143F, data_buffer_64);
+			if(rc) return rc;
+			rc_num = rc_num | data_buffer_64.clearBit(48, 11);
+			rc_num = rc_num | data_buffer_64.clearBit(60, 4);
+			rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_ERROR_P0_0x8000C0180301143F, data_buffer_64);
+			if(rc) return rc;
 
                         //clear other port
-                        rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P1_0x8001C0160301143F, data_buffer_64);
-                        if(rc) return rc;
-                        rc_num = rc_num | data_buffer_64.clearBit(48);
-                        rc_num = rc_num | data_buffer_64.clearBit(50);
-                        rc_num = rc_num | data_buffer_64.clearBit(51);
-                        rc_num = rc_num | data_buffer_64.clearBit(52);
-                        rc_num = rc_num | data_buffer_64.clearBit(53);
-                        rc_num = rc_num | data_buffer_64.clearBit(54);
-                        rc_num = rc_num | data_buffer_64.clearBit(55);
-                        rc_num = rc_num | data_buffer_64.clearBit(58);
-                        rc_num = rc_num | data_buffer_64.clearBit(60);
-                        rc_num = rc_num | data_buffer_64.clearBit(61);
-                        rc_num = rc_num | data_buffer_64.clearBit(62);
-                        rc_num = rc_num | data_buffer_64.clearBit(63);
-                        rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P1_0x8001C0160301143F, data_buffer_64);
-                        if(rc) return rc;
-
-                        //Setup the Config Reg bit for the only cal step we want
-                        rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P0_0x8000C0160301143F, data_buffer_64);
-                        if(rc) return rc;
-
-                    }
-                    else
-                    {
-                        //clear status reg
-                        rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_STATUS_P1_0x8001C0190301143F, data_buffer_64);
-                        if(rc) return rc;
-                        rc_num = rc_num | data_buffer_64.clearBit(48, 4);
-                        rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_STATUS_P1_0x8001C0190301143F, data_buffer_64);
-                        if(rc) return rc;
-
-                        //clear error reg
-                        rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_ERROR_P1_0x8001C0180301143F, data_buffer_64);
-                        if(rc) return rc;
-                        rc_num = rc_num | data_buffer_64.clearBit(48, 11);
-                        rc_num = rc_num | data_buffer_64.clearBit(60, 4);
-                        rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_ERROR_P1_0x8001C0180301143F, data_buffer_64);
-                        if(rc) return rc;
+			rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P1_0x8001C0160301143F, data_buffer_64);
+			if(rc) return rc;
+			rc_num = rc_num | data_buffer_64.clearBit(48);
+			rc_num = rc_num | data_buffer_64.clearBit(50);
+			rc_num = rc_num | data_buffer_64.clearBit(51);
+			rc_num = rc_num | data_buffer_64.clearBit(52);
+			rc_num = rc_num | data_buffer_64.clearBit(53);
+			rc_num = rc_num | data_buffer_64.clearBit(54);
+			rc_num = rc_num | data_buffer_64.clearBit(55);
+			rc_num = rc_num | data_buffer_64.clearBit(58);
+			rc_num = rc_num | data_buffer_64.clearBit(60);
+			rc_num = rc_num | data_buffer_64.clearBit(61);
+			rc_num = rc_num | data_buffer_64.clearBit(62);
+			rc_num = rc_num | data_buffer_64.clearBit(63);
+			rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P1_0x8001C0160301143F, data_buffer_64);
+			if(rc) return rc;
+
+		        //Setup the Config Reg bit for the only cal step we want
+			rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P0_0x8000C0160301143F, data_buffer_64);
+			if(rc) return rc;
+
+		    }
+		    else
+		    {
+			//clear status reg
+			rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_STATUS_P1_0x8001C0190301143F, data_buffer_64);
+			if(rc) return rc;
+			rc_num = rc_num | data_buffer_64.clearBit(48, 4);
+			rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_STATUS_P1_0x8001C0190301143F, data_buffer_64);
+			if(rc) return rc;
+
+			//clear error reg
+			rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_ERROR_P1_0x8001C0180301143F, data_buffer_64);
+			if(rc) return rc;
+			rc_num = rc_num | data_buffer_64.clearBit(48, 11);
+			rc_num = rc_num | data_buffer_64.clearBit(60, 4);
+			rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_ERROR_P1_0x8001C0180301143F, data_buffer_64);
+			if(rc) return rc;
 
                         //clear other port
-                        rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P0_0x8000C0160301143F, data_buffer_64);
-                        if(rc) return rc;
-                        rc_num = rc_num | data_buffer_64.clearBit(48);
-                        rc_num = rc_num | data_buffer_64.clearBit(50);
-                        rc_num = rc_num | data_buffer_64.clearBit(51);
-                        rc_num = rc_num | data_buffer_64.clearBit(52);
-                        rc_num = rc_num | data_buffer_64.clearBit(53);
-                        rc_num = rc_num | data_buffer_64.clearBit(54);
-                        rc_num = rc_num | data_buffer_64.clearBit(55);
-                        rc_num = rc_num | data_buffer_64.clearBit(58);
-                        rc_num = rc_num | data_buffer_64.clearBit(60);
-                        rc_num = rc_num | data_buffer_64.clearBit(61);
-                        rc_num = rc_num | data_buffer_64.clearBit(62);
-                        rc_num = rc_num | data_buffer_64.clearBit(63);
-                        rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P0_0x8000C0160301143F, data_buffer_64);
-                        if(rc) return rc;
-
-                        //Setup the Config Reg bit for the only cal step we want
-                        rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P1_0x8001C0160301143F, data_buffer_64);
-                        if(rc) return rc;
-
-                    }
-
-                    //Clear training cnfg
-                    rc_num = rc_num | data_buffer_64.clearBit(48);
-                    rc_num = rc_num | data_buffer_64.setBit(50);
-                    rc_num = rc_num | data_buffer_64.clearBit(51);
-                    rc_num = rc_num | data_buffer_64.clearBit(52);
-                    rc_num = rc_num | data_buffer_64.clearBit(53);
-                    rc_num = rc_num | data_buffer_64.clearBit(54);
-                    rc_num = rc_num | data_buffer_64.clearBit(55);
-                    rc_num = rc_num | data_buffer_64.clearBit(60);
-                    rc_num = rc_num | data_buffer_64.clearBit(61);
-                    rc_num = rc_num | data_buffer_64.clearBit(62);
-                    rc_num = rc_num | data_buffer_64.clearBit(63);
-
-                    if(group == 0){
-                        rc_num = rc_num | data_buffer_64.setBit(60);
-                    }
-                    else if(group == 1){
-                        rc_num = rc_num | data_buffer_64.setBit(61);
-                    }
-                    else if(group == 2){
-                        rc_num = rc_num | data_buffer_64.setBit(62);
-                    }
-                    else if(group == 3){
-                        rc_num = rc_num | data_buffer_64.setBit(63);
-                    }
-
-                        //Set the config register
-                        if(port == 0)
-                        {
-                            rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P0_0x8000C0160301143F, data_buffer_64);
-                            if(rc) return rc;
-                        }
-                        else
-                        {
-                            rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P1_0x8001C0160301143F, data_buffer_64);
-                            if(rc) return rc;
-                        }
-
-                        rc = mss_ccs_inst_arry_0(i_target,
-                                                 instruction_number,
-                                                 address_buffer_16,
-                                                 bank_buffer_8,
-                                                 activate_buffer_1,
-                                                 rasn_buffer_1,
-                                                 casn_buffer_1,
-                                                 wen_buffer_1,
-                                                 cke_buffer_8,
-                                                 csn_buffer_8,
-                                                 odt_buffer_8,
-                                                 test_buffer_4,
-                                                 port);
-
-                        if(rc) return rc;
-                        rc_num = rc_num | rank_cal_buffer_4.insert(primary_ranks_array[rank_group][port], 0, 4, 4); // 8 bit storage, need last 4 bits
-                        if(rc_num)
-                        {
-                                rc.setEcmdError(rc_num);
-                                return rc;
-                        }
-
-                        rc = mss_ccs_inst_arry_1(i_target,
-                                                 instruction_number,
-                                                 num_idles_buffer_16,
-                                                 num_repeat_buffer_16,
-                                                 data_buffer_20,
-                                                 read_compare_buffer_1,
-                                                 rank_cal_buffer_4,
-                                                 ddr_cal_enable_buffer_1,
-                                                 ccs_end_buffer_1);
-                        if(rc) return rc; //Error handling for mss_ccs_inst built into mss_funcs
-
-                        rc = mss_execute_ccs_inst_array( i_target, NUM_POLL, 60);
-                        if(rc) return rc; //Error handling for mss_ccs_inst built into mss_funcs
-
-                        //Check to see if the training errored out
+			rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P0_0x8000C0160301143F, data_buffer_64);
+			if(rc) return rc;
+			rc_num = rc_num | data_buffer_64.clearBit(48);
+			rc_num = rc_num | data_buffer_64.clearBit(50);
+			rc_num = rc_num | data_buffer_64.clearBit(51);
+			rc_num = rc_num | data_buffer_64.clearBit(52);
+			rc_num = rc_num | data_buffer_64.clearBit(53);
+			rc_num = rc_num | data_buffer_64.clearBit(54);
+			rc_num = rc_num | data_buffer_64.clearBit(55);
+			rc_num = rc_num | data_buffer_64.clearBit(58);
+			rc_num = rc_num | data_buffer_64.clearBit(60);
+			rc_num = rc_num | data_buffer_64.clearBit(61);
+			rc_num = rc_num | data_buffer_64.clearBit(62);
+			rc_num = rc_num | data_buffer_64.clearBit(63);
+			rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P0_0x8000C0160301143F, data_buffer_64);
+			if(rc) return rc;
+
+		        //Setup the Config Reg bit for the only cal step we want
+			rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P1_0x8001C0160301143F, data_buffer_64);
+			if(rc) return rc;
+
+		    }
+
+		    //Clear training cnfg
+		    rc_num = rc_num | data_buffer_64.clearBit(48);
+		    rc_num = rc_num | data_buffer_64.setBit(50);
+		    rc_num = rc_num | data_buffer_64.clearBit(51);
+		    rc_num = rc_num | data_buffer_64.clearBit(52);
+		    rc_num = rc_num | data_buffer_64.clearBit(53);
+		    rc_num = rc_num | data_buffer_64.clearBit(54);
+		    rc_num = rc_num | data_buffer_64.clearBit(55);
+		    rc_num = rc_num | data_buffer_64.clearBit(60);
+		    rc_num = rc_num | data_buffer_64.clearBit(61);
+		    rc_num = rc_num | data_buffer_64.clearBit(62);
+		    rc_num = rc_num | data_buffer_64.clearBit(63);
+
+		    if(group == 0){
+			rc_num = rc_num | data_buffer_64.setBit(60);
+		    }
+		    else if(group == 1){
+			rc_num = rc_num | data_buffer_64.setBit(61);
+		    }
+		    else if(group == 2){
+			rc_num = rc_num | data_buffer_64.setBit(62);
+		    }
+		    else if(group == 3){
+			rc_num = rc_num | data_buffer_64.setBit(63);
+		    }
+
+		        //Set the config register
+			if(port == 0)
+			{
+			    rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P0_0x8000C0160301143F, data_buffer_64);
+			    if(rc) return rc;
+			}
+			else
+			{
+			    rc = fapiPutScom(i_target, DPHY01_DDRPHY_PC_INIT_CAL_CONFIG0_P1_0x8001C0160301143F, data_buffer_64);
+			    if(rc) return rc;
+			}
+
+			rc = mss_ccs_inst_arry_0(i_target,
+						 instruction_number,
+						 address_buffer_16,
+						 bank_buffer_8,
+						 activate_buffer_1,
+						 rasn_buffer_1,
+						 casn_buffer_1,
+						 wen_buffer_1,
+						 cke_buffer_8,
+						 csn_buffer_8,
+						 odt_buffer_8,
+						 test_buffer_4,
+						 port);
+
+			if(rc) return rc; 
+			rc_num = rc_num | rank_cal_buffer_4.insert(primary_ranks_array[rank_group][port], 0, 4, 4); // 8 bit storage, need last 4 bits
+			if(rc_num)
+			{
+				rc.setEcmdError(rc_num);
+				return rc;
+			}
+
+			rc = mss_ccs_inst_arry_1(i_target,
+						 instruction_number,
+						 num_idles_buffer_16,
+						 num_repeat_buffer_16,
+						 data_buffer_20,
+						 read_compare_buffer_1,
+						 rank_cal_buffer_4,
+						 ddr_cal_enable_buffer_1,
+						 ccs_end_buffer_1);
+			if(rc) return rc; //Error handling for mss_ccs_inst built into mss_funcs
+
+			rc = mss_execute_ccs_inst_array( i_target, NUM_POLL, 60);
+			if(rc) return rc; //Error handling for mss_ccs_inst built into mss_funcs
+
+			//Check to see if the training errored out
                         rc = mss_check_error_status(i_target, mbaPosition, port, group, cur_cal_step, cur_error_status, 1);
-                        if(rc) return rc;
-
-                        if (cur_error_status == MSS_INIT_CAL_FAIL)
-                        {
-                                //RC/Log is generated in mss_check_error_status
-                                FAPI_ERR("Error returned on workaround Re-run of DQS_ALIGN on %s  PORT: %d RP: %d", i_target.toEcmdString(), port, group);
-                        }
-
-                }
-        }
-
-        uint8_t curr_bit;
-
-        //Finding the lowest Values on disabled bytes, then resetting mask.
-        for(block = 0; block < maxblocks; block++)
-        {
-                for (byte = 0; byte < maxbytes; byte++)
-                {
-
-                        for (nibble = 0; nibble < maxnibbles; nibble++)
-                        {
-
-                                for(rank_group = 0; rank_group < MAX_PRI_RANKS; rank_group++)
-                                {
-                                        for (nibble_dq = 0; nibble_dq < 4; nibble_dq++)
-                                        {
-
-
-                                                if (l_disable_old_value_u8[rank_group][block][byte][nibble] != 0x00)
-                                                {
-
-                                                        FAPI_DBG("WR LVL DISABLE WORKAROUND: DISABLED block: %d byte: %d nibble: %d disable value: 0x%02X", block, byte, nibble, l_disable_old_value_u8[rank_group][block][byte][nibble]);
-                                                        FAPI_DBG("WR LVL DISABLE WORKAROUND: DQSCLK replacement: block: %d byte: %d nibble: %d current value: %d", block, byte, nibble, l_dqsclk_phase_value_u8[rank_group][block][byte][nibble]);
-                                                        //SWAPPING DQSCLK PHASE SELECT
-                                                        for (rg = 0; rg < MAX_PRI_RANKS; rg++)
-                                                        {
-                                                                FAPI_DBG("WR LVL DISABLE WORKAROUND: DQSCLK possible replacement value: %d", l_dqsclk_phase_value_u8[rg][block][byte][nibble]);
-
-                                                                if ( (l_disable_old_value_u8[rg][block][byte][nibble] == 0) && (l_dqsclk_phase_value_u8[rg][block][byte][nibble] < l_dqsclk_phase_value_u8[rank_group][block][byte][nibble]) )
-                                                                {
-                                                                        FAPI_DBG("WR LVL DISABLE WORKAROUND: DQSCLK replacement: block: %d byte: %d nibble: %d", block, byte, nibble);
-                                                                        FAPI_DBG("WR LVL DISABLE WORKAROUND: DQSCLK replacement value: %d", l_dqsclk_phase_value_u8[rg][block][byte][nibble]);
-                                                                        l_dqsclk_phase_value_u8[rank_group][block][byte][nibble] = l_dqsclk_phase_value_u8[rg][block][byte][nibble];
-                                                                }
-                                                        }
-
-                                                        FAPI_DBG("WR LVL DISABLE WORKAROUND: RDCLK replacement: block: %d byte: %d nibble: %d current value: %d", block, byte, nibble, l_dqsclk_phase_value_u8[rank_group][block][byte][nibble]);
-                                                        //SWAPPING RDCLK PHASE SELECT
-                                                        for (rg = 0; rg < MAX_PRI_RANKS; rg++)
-                                                        {
-                                                                FAPI_DBG("WR LVL DISABLE WORKAROUND: RDCLK possible replacement value: %d", l_rdclk_phase_value_u8[rg][block][byte][nibble]);
-
-                                                                if ( (l_disable_old_value_u8[rg][block][byte][nibble] == 0) && (l_rdclk_phase_value_u8[rg][block][byte][nibble] < l_rdclk_phase_value_u8[rank_group][block][byte][nibble]) )
-                                                                {
-                                                                        FAPI_DBG("WR LVL DISABLE WORKAROUND: RDCLK replacement: block: %d byte: %d nibble: %d", block, byte, nibble);
-                                                                        FAPI_DBG("WR LVL DISABLE WORKAROUND: RDCLK replacement value: %d", l_rdclk_phase_value_u8[rg][block][byte][nibble]);
-                                                                        l_rdclk_phase_value_u8[rank_group][block][byte][nibble] = l_rdclk_phase_value_u8[rg][block][byte][nibble];
-                                                                }
-                                                        }
-
-                                                        FAPI_DBG("WR LVL DISABLE WORKAROUND: GATE DELAY replacement: block: %d byte: %d nibble: %d current value: %d", block, byte, nibble, l_dqsclk_phase_value_u8[rank_group][block][byte][nibble]);
-                                                        //SWAPPING RDCLK PHASE SELECT
-                                                        for (rg = 0; rg < MAX_PRI_RANKS; rg++)
-                                                        {
-                                                                FAPI_DBG("WR LVL DISABLE WORKAROUND: GATE DELAY possible replacement value: %d", l_gate_delay_value_u8[rg][block][byte][nibble]);
-
-                                                                if ( (l_disable_old_value_u8[rg][block][byte][nibble] == 0) && (l_gate_delay_value_u8[rg][block][byte][nibble] < l_gate_delay_value_u8[rank_group][block][byte][nibble]) )
-                                                                {
-                                                                        FAPI_DBG("WR LVL DISABLE WORKAROUND: GATE DELAY replacement: block: %d byte: %d nibble: %d", block, byte, nibble);
-                                                                        FAPI_DBG("WR LVL DISABLE WORKAROUND: GATE DELAY replacement value: %d", l_gate_delay_value_u8[rg][block][byte][nibble]);
-                                                                        l_gate_delay_value_u8[rank_group][block][byte][nibble] = l_gate_delay_value_u8[rg][block][byte][nibble];
-                                                                }
-                                                        }
-
-                                                        //SWAPPING DQ AND DQS
-                                                        mask = 0x8 >> nibble_dq;
-                                                        curr_bit = l_disable_old_value_u8[rank_group][block][byte][nibble] & mask;
-                                                        FAPI_DBG("WR LVL DISABLE WORKAROUND: DQ/DQS SWAP MASK: 0x%02X DISABLE BIT: 0x%02X CURR BIT: 0x%02X", mask, l_disable_old_value_u8[rank_group][block][byte][nibble] & mask, curr_bit);
-
-                                                        if (curr_bit)
-                                                        {
-
-                                                        FAPI_DBG("WR LVL DISABLE WORKAROUND: DQ/DQS SWAP RANK_GROUP: %d BLOCK: %d BYTE: %d NIBBLE: %d DISABLE VALUE: 0x%02X", rank_group, block, byte, nibble, l_disable_old_value_u8[rank_group][block][byte][nibble]);
-
-                                                        //Figure out which lane to investigate
-                                                        l_index_u8 = nibble_dq + 4 * nibble + 8 * byte;
-                                                        lane = l_index_u8;
-
-                                                        l_input_type_e = WR_DQ;
-                                                        l_flag = 1;
-                                                        // C4 DQ to lane/block (flag = 0) in PHY or lane/block to C4 DQ (flag = 1)
-                                                        // In this case moving from lane/block to C4 DQ to use access_delay_reg
-                                                        rc = mss_c4_phy(i_target, port, rank_group, l_input_type_e, l_index_u8, l_verbose, lane, block, l_flag);
-
-
-                                                        l_access_type_e = READ;
-                                                        l_rank_u8 = ranks_array[rank_group][0][0];
-                                                        if (l_rank_u8 == 255)
-                                                        continue;
-
-                                                        // Getting old DQ Value
-                                                        l_input_type_e = WR_DQ;
-                                                        rc = mss_access_delay_reg(i_target, l_access_type_e, port, ranks_array[rank_group][0][0], l_input_type_e, l_index_u8, l_verbose, l_old_delay_value_u32);
-                                                        if(rc) return rc;
-
-
-                                                        if (width == fapi::ENUM_ATTR_EFF_DRAM_WIDTH_X8)
-                                                        {
-                                                                dqs_index = l_index_u8 / 8;
-                                                        }
-                                                        else
-                                                        {
-                                                                dqs_index = l_index_u8 / 4;
-                                                        }
-
-                                                        // Getting old DQS Value
-                                                        l_input_type_e = WR_DQS;
-                                                        rc = mss_access_delay_reg(i_target, l_access_type_e, port, ranks_array[rank_group][0][0], l_input_type_e, dqs_index, l_verbose, l_old_DQS_delay_value_u32);
-                                                        if(rc) return rc;
-
-                                                        FAPI_DBG("WR LVL DISABLE WORKAROUND: Value being replaced C4: %d C4 DQS: %d Rank:%d DQ DELAY VALUE: 0x%03X DQS DELAY VALUE: 0x%03X ", l_index_u8, dqs_index, ranks_array[rank_group][0][0], l_old_delay_value_u32, l_old_DQS_delay_value_u32);
-
-                                                        for (rg = 0; rg < MAX_PRI_RANKS; rg++)
-                                                        {
-                                                                l_access_type_e = READ;
-                                                                rank_2 = ranks_array[rg][0][0];
-                                                                FAPI_DBG("WR LVL DISABLE WORKAROUND: RANK: %d DISABLE VALUE: 0x%02X MASKED: 0x%02X", rank_2, l_disable_old_value_u8[rg][block][byte][nibble], l_disable_old_value_u8[rg][block][byte][nibble] & mask);
-                                                                if ( (rank_2 != 255) && (l_disable_old_value_u8[rg][block][byte][nibble] == 0 ) )
-                                                                {
-                                                                        // Getting New DQ Value
-                                                                        l_input_type_e = WR_DQ;
-                                                                        rc = mss_access_delay_reg(i_target, l_access_type_e, port, rank_2, l_input_type_e, l_index_u8, l_verbose, l_delay_value_u32);
-                                                                        if(rc) return rc;
-
-                                                                        // Getting New DQS Value
-                                                                        l_input_type_e = WR_DQS;
-                                                                        rc = mss_access_delay_reg(i_target, l_access_type_e, port, rank_2, l_input_type_e, dqs_index, l_verbose, l_DQS_delay_value_u32);
-                                                                        if(rc) return rc;
-
-                                                                        FAPI_DBG("WR LVL DISABLE WORKAROUND: Possible Replacement Value C4: %d C4 DQS: %d Rank:%d DQ DELAY VALUE: 0x%03X DQS DELAY VALUE: 0x%03X", l_index_u8, dqs_index, rank_2, l_delay_value_u32, l_DQS_delay_value_u32);
-
-                                                                        if ( l_delay_value_u32 < l_old_delay_value_u32)
-                                                                        {
-                                                                                l_old_delay_value_u32 = l_delay_value_u32;
-                                                                                // Writing DQ Value
-                                                                                l_access_type_e = WRITE;
-                                                                                l_rank_u8 = ranks_array[rank_group][0][0];
-                                                                                l_input_type_e = WR_DQ;
-                                                                                rc = mss_access_delay_reg(i_target, l_access_type_e, port, ranks_array[rank_group][0][0], l_input_type_e, l_index_u8, l_verbose, l_delay_value_u32);
-                                                                                if(rc) return rc;
-
-                                                                                FAPI_DBG("WR LVL DISABLE WORKAROUND: Replacing DQ: Value C4: %d C4 DQS: %d Rank:%d DELAY VALUE: 0x%03X", l_index_u8, dqs_index, ranks_array[rank_group][0][0], l_delay_value_u32);
-                                                                        }
-                                                                        if ( l_DQS_delay_value_u32 < l_old_DQS_delay_value_u32)
-                                                                        {
-                                                                                l_old_DQS_delay_value_u32 = l_DQS_delay_value_u32;
-                                                                                // Writing DQS Value
-                                                                                l_access_type_e = WRITE;
-                                                                                l_rank_u8 = ranks_array[rank_group][0][0];
-                                                                                l_input_type_e = WR_DQS;
-                                                                                rc = mss_access_delay_reg(i_target, l_access_type_e, port, ranks_array[rank_group][0][0], l_input_type_e, dqs_index, l_verbose, l_DQS_delay_value_u32);
-                                                                                if(rc) return rc;
-
-                                                                                FAPI_DBG("WR LVL DISABLE WORKAROUND: Replacing DQS: Value C4: %d C4 DQS: %d Rank:%d DQS DELAY VALUE: 0x%03X", l_index_u8, dqs_index, ranks_array[rank_group][0][0], l_DQS_delay_value_u32);
-                                                                        }
-
-                                                                 }
-
-                                                          }
-
-
-                                                          }
-                                                }
-                                        }
-
-                                }
-                        }
-
-                }
-        }
-
-
-        //Scoming in the New Values
+			if(rc) return rc;
+
+			if (cur_error_status == MSS_INIT_CAL_FAIL)
+			{
+				//RC/Log is generated in mss_check_error_status
+				FAPI_ERR("Error returned on workaround Re-run of DQS_ALIGN on %s  PORT: %d RP: %d", i_target.toEcmdString(), port, group);
+			}
+
+		}
+	}
+
+	uint8_t curr_bit;
+
+	//Finding the lowest Values on disabled bytes, then resetting mask.
+	for(block = 0; block < maxblocks; block++)
+	{
+		for (byte = 0; byte < maxbytes; byte++)
+		{
+
+			for (nibble = 0; nibble < maxnibbles; nibble++)
+			{
+
+				for(rank_group = 0; rank_group < MAX_PRI_RANKS; rank_group++)
+				{	
+					for (nibble_dq = 0; nibble_dq < 4; nibble_dq++)
+					{	
+
+
+						if (l_disable_old_value_u8[rank_group][block][byte][nibble] != 0x00)
+						{
+
+							FAPI_DBG("WR LVL DISABLE WORKAROUND: DISABLED block: %d byte: %d nibble: %d disable value: 0x%02X", block, byte, nibble, l_disable_old_value_u8[rank_group][block][byte][nibble]);
+						        FAPI_DBG("WR LVL DISABLE WORKAROUND: DQSCLK replacement: block: %d byte: %d nibble: %d current value: %d", block, byte, nibble, l_dqsclk_phase_value_u8[rank_group][block][byte][nibble]);
+							//SWAPPING DQSCLK PHASE SELECT
+							for (rg = 0; rg < MAX_PRI_RANKS; rg++)
+							{
+								FAPI_DBG("WR LVL DISABLE WORKAROUND: DQSCLK possible replacement value: %d", l_dqsclk_phase_value_u8[rg][block][byte][nibble]);
+
+								if ( (l_disable_old_value_u8[rg][block][byte][nibble] == 0) && (l_dqsclk_phase_value_u8[rg][block][byte][nibble] < l_dqsclk_phase_value_u8[rank_group][block][byte][nibble]) ) 
+								{
+								        FAPI_DBG("WR LVL DISABLE WORKAROUND: DQSCLK replacement: block: %d byte: %d nibble: %d", block, byte, nibble);
+									FAPI_DBG("WR LVL DISABLE WORKAROUND: DQSCLK replacement value: %d", l_dqsclk_phase_value_u8[rg][block][byte][nibble]);
+									l_dqsclk_phase_value_u8[rank_group][block][byte][nibble] = l_dqsclk_phase_value_u8[rg][block][byte][nibble];
+								}
+							}
+
+						        FAPI_DBG("WR LVL DISABLE WORKAROUND: RDCLK replacement: block: %d byte: %d nibble: %d current value: %d", block, byte, nibble, l_dqsclk_phase_value_u8[rank_group][block][byte][nibble]);
+							//SWAPPING RDCLK PHASE SELECT
+							for (rg = 0; rg < MAX_PRI_RANKS; rg++)
+							{
+								FAPI_DBG("WR LVL DISABLE WORKAROUND: RDCLK possible replacement value: %d", l_rdclk_phase_value_u8[rg][block][byte][nibble]);
+
+								if ( (l_disable_old_value_u8[rg][block][byte][nibble] == 0) && (l_rdclk_phase_value_u8[rg][block][byte][nibble] < l_rdclk_phase_value_u8[rank_group][block][byte][nibble]) ) 
+								{
+								        FAPI_DBG("WR LVL DISABLE WORKAROUND: RDCLK replacement: block: %d byte: %d nibble: %d", block, byte, nibble);
+									FAPI_DBG("WR LVL DISABLE WORKAROUND: RDCLK replacement value: %d", l_rdclk_phase_value_u8[rg][block][byte][nibble]);
+									l_rdclk_phase_value_u8[rank_group][block][byte][nibble] = l_rdclk_phase_value_u8[rg][block][byte][nibble];
+								}
+							}
+
+						        FAPI_DBG("WR LVL DISABLE WORKAROUND: GATE DELAY replacement: block: %d byte: %d nibble: %d current value: %d", block, byte, nibble, l_dqsclk_phase_value_u8[rank_group][block][byte][nibble]);
+							//SWAPPING RDCLK PHASE SELECT
+							for (rg = 0; rg < MAX_PRI_RANKS; rg++)
+							{
+								FAPI_DBG("WR LVL DISABLE WORKAROUND: GATE DELAY possible replacement value: %d", l_gate_delay_value_u8[rg][block][byte][nibble]);
+
+								if ( (l_disable_old_value_u8[rg][block][byte][nibble] == 0) && (l_gate_delay_value_u8[rg][block][byte][nibble] < l_gate_delay_value_u8[rank_group][block][byte][nibble]) ) 
+								{
+								        FAPI_DBG("WR LVL DISABLE WORKAROUND: GATE DELAY replacement: block: %d byte: %d nibble: %d", block, byte, nibble);
+									FAPI_DBG("WR LVL DISABLE WORKAROUND: GATE DELAY replacement value: %d", l_gate_delay_value_u8[rg][block][byte][nibble]);
+									l_gate_delay_value_u8[rank_group][block][byte][nibble] = l_gate_delay_value_u8[rg][block][byte][nibble];
+								}
+							}
+
+							//SWAPPING DQ AND DQS
+							mask = 0x8 >> nibble_dq;
+							curr_bit = l_disable_old_value_u8[rank_group][block][byte][nibble] & mask;
+							FAPI_DBG("WR LVL DISABLE WORKAROUND: DQ/DQS SWAP MASK: 0x%02X DISABLE BIT: 0x%02X CURR BIT: 0x%02X", mask, l_disable_old_value_u8[rank_group][block][byte][nibble] & mask, curr_bit);
+
+							if (curr_bit)
+							{
+						
+							FAPI_DBG("WR LVL DISABLE WORKAROUND: DQ/DQS SWAP RANK_GROUP: %d BLOCK: %d BYTE: %d NIBBLE: %d DISABLE VALUE: 0x%02X", rank_group, block, byte, nibble, l_disable_old_value_u8[rank_group][block][byte][nibble]);
+					
+							//Figure out which lane to investigate
+						    	l_index_u8 = nibble_dq + 4 * nibble + 8 * byte;
+							lane = l_index_u8;
+						
+							l_input_type_e = WR_DQ;
+							l_flag = 1;
+							// C4 DQ to lane/block (flag = 0) in PHY or lane/block to C4 DQ (flag = 1) 
+							// In this case moving from lane/block to C4 DQ to use access_delay_reg
+							rc = mss_c4_phy(i_target, port, rank_group, l_input_type_e, l_index_u8, l_verbose, lane, block, l_flag);
+
+						
+							l_access_type_e = READ;
+							l_rank_u8 = ranks_array[rank_group][0][0];
+							if (l_rank_u8 == 255) 
+							continue;
+
+							// Getting old DQ Value
+							l_input_type_e = WR_DQ;
+							rc = mss_access_delay_reg(i_target, l_access_type_e, port, ranks_array[rank_group][0][0], l_input_type_e, l_index_u8, l_verbose, l_old_delay_value_u32); 
+							if(rc) return rc;
+
+	
+							if (width == fapi::ENUM_ATTR_EFF_DRAM_WIDTH_X8)
+							{
+								dqs_index = l_index_u8 / 8;
+							}
+							else 
+							{
+								dqs_index = l_index_u8 / 4;
+							} 
+
+							// Getting old DQS Value
+							l_input_type_e = WR_DQS;
+							rc = mss_access_delay_reg(i_target, l_access_type_e, port, ranks_array[rank_group][0][0], l_input_type_e, dqs_index, l_verbose, l_old_DQS_delay_value_u32); 
+							if(rc) return rc;
+
+							FAPI_DBG("WR LVL DISABLE WORKAROUND: Value being replaced C4: %d C4 DQS: %d Rank:%d DQ DELAY VALUE: 0x%03X DQS DELAY VALUE: 0x%03X ", l_index_u8, dqs_index, ranks_array[rank_group][0][0], l_old_delay_value_u32, l_old_DQS_delay_value_u32);
+
+							for (rg = 0; rg < MAX_PRI_RANKS; rg++)
+							{
+								l_access_type_e = READ;
+								rank_2 = ranks_array[rg][0][0];
+								FAPI_DBG("WR LVL DISABLE WORKAROUND: RANK: %d DISABLE VALUE: 0x%02X MASKED: 0x%02X", rank_2, l_disable_old_value_u8[rg][block][byte][nibble], l_disable_old_value_u8[rg][block][byte][nibble] & mask);
+								if ( (rank_2 != 255) && (l_disable_old_value_u8[rg][block][byte][nibble] == 0 ) )
+								{
+									// Getting New DQ Value
+									l_input_type_e = WR_DQ;
+									rc = mss_access_delay_reg(i_target, l_access_type_e, port, rank_2, l_input_type_e, l_index_u8, l_verbose, l_delay_value_u32); 
+									if(rc) return rc;
+
+									// Getting New DQS Value
+									l_input_type_e = WR_DQS;
+									rc = mss_access_delay_reg(i_target, l_access_type_e, port, rank_2, l_input_type_e, dqs_index, l_verbose, l_DQS_delay_value_u32); 
+									if(rc) return rc;
+
+									FAPI_DBG("WR LVL DISABLE WORKAROUND: Possible Replacement Value C4: %d C4 DQS: %d Rank:%d DQ DELAY VALUE: 0x%03X DQS DELAY VALUE: 0x%03X", l_index_u8, dqs_index, rank_2, l_delay_value_u32, l_DQS_delay_value_u32);
+									
+									if ( l_delay_value_u32 < l_old_delay_value_u32)
+									{
+										l_old_delay_value_u32 = l_delay_value_u32;
+										// Writing DQ Value
+										l_access_type_e = WRITE;
+										l_rank_u8 = ranks_array[rank_group][0][0];
+										l_input_type_e = WR_DQ;
+										rc = mss_access_delay_reg(i_target, l_access_type_e, port, ranks_array[rank_group][0][0], l_input_type_e, l_index_u8, l_verbose, l_delay_value_u32); 
+										if(rc) return rc;
+
+										FAPI_DBG("WR LVL DISABLE WORKAROUND: Replacing DQ: Value C4: %d C4 DQS: %d Rank:%d DELAY VALUE: 0x%03X", l_index_u8, dqs_index, ranks_array[rank_group][0][0], l_delay_value_u32);
+									}
+									if ( l_DQS_delay_value_u32 < l_old_DQS_delay_value_u32)
+									{
+										l_old_DQS_delay_value_u32 = l_DQS_delay_value_u32;
+										// Writing DQS Value
+										l_access_type_e = WRITE;
+										l_rank_u8 = ranks_array[rank_group][0][0];
+										l_input_type_e = WR_DQS;
+										rc = mss_access_delay_reg(i_target, l_access_type_e, port, ranks_array[rank_group][0][0], l_input_type_e, dqs_index, l_verbose, l_DQS_delay_value_u32); 
+										if(rc) return rc;
+
+										FAPI_DBG("WR LVL DISABLE WORKAROUND: Replacing DQS: Value C4: %d C4 DQS: %d Rank:%d DQS DELAY VALUE: 0x%03X", l_index_u8, dqs_index, ranks_array[rank_group][0][0], l_DQS_delay_value_u32);
+									}
+
+								 }
+
+							  }
+
+
+							  }
+						}
+					}
+
+				}
+			}
+
+		}
+	}	
+
+
+	//Scoming in the New Values
         for(rank_group = 0; rank_group < MAX_PRI_RANKS; rank_group++)
-        {
-
-            //Check if rank group exists
-            if(primary_ranks_array[rank_group][port] != 255)
-            {
-
-
-                if ( port == 0 )
-                {
-
-                        if ( rank_group == 0 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_0_0x800000090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_1_0x800004090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_2_0x800008090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_3_0x80000C090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_4_0x800010090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_0_0x800000130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_1_0x800004130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_2_0x800008130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_3_0x80000C130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_4_0x800010130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_0_0x8000007c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_1_0x8000047c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_2_0x8000087c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_3_0x80000c7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_4_0x8000107c0301143F;
-
-
-                        }
-                        else if ( rank_group == 1 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_0_0x800001090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_1_0x800005090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_2_0x800009090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_3_0x80000D090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_4_0x800011090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_0_0x800001130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_1_0x800005130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_2_0x800009130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_3_0x80000D130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_4_0x800011130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_0_0x8000017c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_1_0x8000057c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_2_0x8000097c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_3_0x80000d7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_4_0x8000117c0301143F;
-
-                        }
-                        else if ( rank_group == 2 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_0_0x800002090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_1_0x800006090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_2_0x80000A090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_3_0x80000E090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_4_0x800012090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_0_0x800002130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_1_0x800006130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_2_0x80000A130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_3_0x80000E130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_4_0x800012130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_0_0x8000027c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_1_0x8000067c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_2_0x80000a7c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_3_0x80000e7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_4_0x8000127c0301143F;
-
-                        }
-                        else if ( rank_group == 3 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_0_0x800003090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_1_0x800007090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_2_0x80000B090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_3_0x80000F090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_4_0x800013090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_0_0x800003130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_1_0x800007130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_2_0x80000B130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_3_0x80000F130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_4_0x800013130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_0_0x8000037c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_1_0x8000077c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_2_0x80000b7c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_3_0x80000f7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_4_0x8000137c0301143F;
-
-                        }
-                    }
-                    else if (port == 1 )
-                    {
-
-                        if ( rank_group == 0 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_0_0x800100090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_1_0x800104090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_2_0x800108090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_3_0x80010C090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_4_0x800110090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_0_0x800100130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_1_0x800104130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_2_0x800108130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_3_0x80010C130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_4_0x800110130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_0_0x8001007c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_1_0x8001047c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_2_0x8001087c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_3_0x80010c7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_4_0x8001107c0301143F;
-
-                        }
-                        else if ( rank_group == 1 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_0_0x800101090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_1_0x800105090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_2_0x800109090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_3_0x80010D090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_4_0x800111090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_0_0x800101130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_1_0x800105130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_2_0x800109130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_3_0x80010D130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_4_0x800111130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_0_0x8001017c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_1_0x8001057c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_2_0x8001097c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_3_0x80010d7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_4_0x8001117c0301143F;
-
-                        }
-                        else if ( rank_group == 2 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_0_0x800102090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_1_0x800106090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_2_0x80010A090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_3_0x80010E090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_4_0x800112090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_0_0x800102130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_1_0x800106130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_2_0x80010A130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_3_0x80010E130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_4_0x800112130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_0_0x8001027c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_1_0x8001067c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_2_0x80010a7c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_3_0x80010e7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_4_0x8001127c0301143F;
-
-                        }
-                        else if ( rank_group == 3 )
-                        {
-                            DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_0_0x800103090301143F;
-                            DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_1_0x800107090301143F;
-                            DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_2_0x80010B090301143F;
-                            DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_3_0x80010F090301143F;
-                            DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_4_0x800113090301143F;
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_0_0x800103130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_1_0x800107130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_2_0x80010B130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_3_0x80010F130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_4_0x800113130301143F;
-                            DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_0_0x8001037c0301143F;
-                            DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_1_0x8001077c0301143F;
-                            DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_2_0x80010b7c0301143F;
-                            DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_3_0x80010f7c0301143F;
-                            DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_4_0x8001137c0301143F;
-
-                        }
-                    }
-
-                    //Block 0
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_0, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][0][0][0], 48, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][0][0][1], 52, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][0][1][0], 56, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][0][1][1], 60, 2);
-
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][0][0][0], 50, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][0][0][1], 54, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][0][1][0], 58, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][0][1][1], 62, 2);
-                    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_0, data_buffer_64);
-                    if (rc) return rc;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_0, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][0][0], 49, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][0][1], 53, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][1][0], 57, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][1][1], 61, 3);
-                    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_0, data_buffer_64);
-                    if (rc) return rc;
-
-                    //Block 1
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_1, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][1][0][0], 48, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][1][0][1], 52, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][1][1][0], 56, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][1][1][1], 60, 2);
-
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][1][0][0], 50, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][1][0][1], 54, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][1][1][0], 58, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][1][1][1], 62, 2);
-                    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_1, data_buffer_64);
-                    if (rc) return rc;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_1, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][0][0], 49, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][0][1], 53, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][1][0], 57, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][1][1], 61, 3);
-                    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_1, data_buffer_64);
-                    if (rc) return rc;
-
-                    //Block 2
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_2, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][2][0][0], 48, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][2][0][1], 52, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][2][1][0], 56, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][2][1][1], 60, 2);
-
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][2][0][0], 50, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][2][0][1], 54, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][2][1][0], 58, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][2][1][1], 62, 2);
-                    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_2, data_buffer_64);
-                    if (rc) return rc;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_2, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][0][0], 49, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][0][1], 53, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][1][0], 57, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][1][1], 61, 3);
-                    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_2, data_buffer_64);
-                    if (rc) return rc;
-
-                    //Block 3
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_3, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][3][0][0], 48, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][3][0][1], 52, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][3][1][0], 56, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][3][1][1], 60, 2);
-
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][3][0][0], 50, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][3][0][1], 54, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][3][1][0], 58, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][3][1][1], 62, 2);
-                    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_3, data_buffer_64);
-                    if (rc) return rc;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_3, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][0][0], 49, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][0][1], 53, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][1][0], 57, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][1][1], 61, 3);
-                    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_3, data_buffer_64);
-                    if (rc) return rc;
-
-
-                    //Block 4
-                    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_4, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][4][0][0], 48, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][4][0][1], 52, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][4][1][0], 56, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][4][1][1], 60, 2);
-
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][4][0][0], 50, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][4][0][1], 54, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][4][1][0], 58, 2);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][4][1][1], 62, 2);
-                    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_4, data_buffer_64);
-                    if (rc) return rc;
-
-                    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_4, data_buffer_64);
-                    if (rc) return rc;
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][0][0], 49, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][0][1], 53, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][1][0], 57, 3);
-                    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][1][1], 61, 3);
-                    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_4, data_buffer_64);
-                    if (rc) return rc;
-
-                    if(rc_num)
-                    {
-                        rc.setEcmdError(rc_num);
-                        return rc;
-                    }
-
-
-                }
-        }
+	{
+
+	    //Check if rank group exists
+	    if(primary_ranks_array[rank_group][port] != 255)
+	    {
+
+ 
+    		if ( port == 0 )
+    		{
+
+			if ( rank_group == 0 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_0_0x800000090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_1_0x800004090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_2_0x800008090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_3_0x80000C090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P0_4_0x800010090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_0_0x800000130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_1_0x800004130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_2_0x800008130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_3_0x80000C130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_4_0x800010130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_0_0x8000007c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_1_0x8000047c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_2_0x8000087c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_3_0x80000c7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_4_0x8000107c0301143F;
+
+
+			}
+			else if ( rank_group == 1 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_0_0x800001090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_1_0x800005090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_2_0x800009090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_3_0x80000D090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P0_4_0x800011090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_0_0x800001130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_1_0x800005130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_2_0x800009130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_3_0x80000D130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_4_0x800011130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_0_0x8000017c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_1_0x8000057c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_2_0x8000097c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_3_0x80000d7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_4_0x8000117c0301143F;
+
+			}
+			else if ( rank_group == 2 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_0_0x800002090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_1_0x800006090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_2_0x80000A090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_3_0x80000E090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P0_4_0x800012090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_0_0x800002130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_1_0x800006130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_2_0x80000A130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_3_0x80000E130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_4_0x800012130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_0_0x8000027c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_1_0x8000067c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_2_0x80000a7c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_3_0x80000e7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_4_0x8000127c0301143F;
+
+			}
+			else if ( rank_group == 3 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_0_0x800003090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_1_0x800007090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_2_0x80000B090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_3_0x80000F090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P0_4_0x800013090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_0_0x800003130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_1_0x800007130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_2_0x80000B130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_3_0x80000F130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_4_0x800013130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_0_0x8000037c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_1_0x8000077c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_2_0x80000b7c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_3_0x80000f7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_4_0x8000137c0301143F;
+
+			}
+		    }
+		    else if (port == 1 )
+		    {
+
+			if ( rank_group == 0 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_0_0x800100090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_1_0x800104090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_2_0x800108090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_3_0x80010C090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR0_P1_4_0x800110090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_0_0x800100130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_1_0x800104130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_2_0x800108130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_3_0x80010C130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_4_0x800110130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_0_0x8001007c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_1_0x8001047c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_2_0x8001087c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_3_0x80010c7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_4_0x8001107c0301143F;
+
+			}
+			else if ( rank_group == 1 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_0_0x800101090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_1_0x800105090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_2_0x800109090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_3_0x80010D090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR1_P1_4_0x800111090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_0_0x800101130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_1_0x800105130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_2_0x800109130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_3_0x80010D130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_4_0x800111130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_0_0x8001017c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_1_0x8001057c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_2_0x8001097c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_3_0x80010d7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_4_0x8001117c0301143F;
+
+			}
+			else if ( rank_group == 2 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_0_0x800102090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_1_0x800106090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_2_0x80010A090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_3_0x80010E090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR2_P1_4_0x800112090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_0_0x800102130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_1_0x800106130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_2_0x80010A130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_3_0x80010E130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_4_0x800112130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_0_0x8001027c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_1_0x8001067c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_2_0x80010a7c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_3_0x80010e7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_4_0x8001127c0301143F;
+
+			}
+			else if ( rank_group == 3 )
+			{
+			    DQSCLK_RD_PHASE_ADDR_0 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_0_0x800103090301143F;
+			    DQSCLK_RD_PHASE_ADDR_1 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_1_0x800107090301143F;
+			    DQSCLK_RD_PHASE_ADDR_2 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_2_0x80010B090301143F;
+			    DQSCLK_RD_PHASE_ADDR_3 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_3_0x80010F090301143F;
+			    DQSCLK_RD_PHASE_ADDR_4 = DPHY01_DDRPHY_DP18_DQS_RD_PHASE_SELECT_RANK_PAIR3_P1_4_0x800113090301143F;
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_0_0x800103130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_1_0x800107130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_2_0x80010B130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_3_0x80010F130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_4_0x800113130301143F;
+			    DISABLE_ADDR_0 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_0_0x8001037c0301143F;
+			    DISABLE_ADDR_1 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_1_0x8001077c0301143F;
+			    DISABLE_ADDR_2 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_2_0x80010b7c0301143F;
+			    DISABLE_ADDR_3 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_3_0x80010f7c0301143F;
+			    DISABLE_ADDR_4 = DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_4_0x8001137c0301143F;
+
+			}
+		    }
+
+		    //Block 0
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_0, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][0][0][0], 48, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][0][0][1], 52, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][0][1][0], 56, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][0][1][1], 60, 2);
+
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][0][0][0], 50, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][0][0][1], 54, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][0][1][0], 58, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][0][1][1], 62, 2);
+		    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_0, data_buffer_64);
+		    if (rc) return rc;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_0, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][0][0], 49, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][0][1], 53, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][1][0], 57, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][0][1][1], 61, 3);
+		    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_0, data_buffer_64);
+		    if (rc) return rc;
+			
+		    //Block 1
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_1, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][1][0][0], 48, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][1][0][1], 52, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][1][1][0], 56, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][1][1][1], 60, 2);
+
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][1][0][0], 50, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][1][0][1], 54, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][1][1][0], 58, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][1][1][1], 62, 2);
+		    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_1, data_buffer_64);
+		    if (rc) return rc;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_1, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][0][0], 49, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][0][1], 53, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][1][0], 57, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][1][1][1], 61, 3);
+		    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_1, data_buffer_64);
+		    if (rc) return rc;
+			
+		    //Block 2
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_2, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][2][0][0], 48, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][2][0][1], 52, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][2][1][0], 56, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][2][1][1], 60, 2);
+
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][2][0][0], 50, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][2][0][1], 54, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][2][1][0], 58, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][2][1][1], 62, 2);
+		    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_2, data_buffer_64);
+		    if (rc) return rc;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_2, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][0][0], 49, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][0][1], 53, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][1][0], 57, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][2][1][1], 61, 3);
+		    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_2, data_buffer_64);
+		    if (rc) return rc;
+
+		    //Block 3
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_3, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][3][0][0], 48, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][3][0][1], 52, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][3][1][0], 56, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][3][1][1], 60, 2);
+
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][3][0][0], 50, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][3][0][1], 54, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][3][1][0], 58, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][3][1][1], 62, 2);
+		    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_3, data_buffer_64);
+		    if (rc) return rc;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_3, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][0][0], 49, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][0][1], 53, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][1][0], 57, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][3][1][1], 61, 3);
+		    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_3, data_buffer_64);
+		    if (rc) return rc;
+
+
+		    //Block 4
+		    rc = fapiGetScom(i_target, DQSCLK_RD_PHASE_ADDR_4, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][4][0][0], 48, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][4][0][1], 52, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][4][1][0], 56, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_dqsclk_phase_value_u8[rank_group][4][1][1], 60, 2);
+
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][4][0][0], 50, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][4][0][1], 54, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][4][1][0], 58, 2);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_rdclk_phase_value_u8[rank_group][4][1][1], 62, 2);
+		    rc = fapiPutScom(i_target, DQSCLK_RD_PHASE_ADDR_4, data_buffer_64);
+		    if (rc) return rc;
+
+		    rc = fapiGetScom(i_target, GATE_DELAY_ADDR_4, data_buffer_64);
+		    if (rc) return rc;
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][0][0], 49, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][0][1], 53, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][1][0], 57, 3);
+		    rc_num = rc_num | data_buffer_64.insertFromRight(&l_gate_delay_value_u8[rank_group][4][1][1], 61, 3);
+		    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_4, data_buffer_64);
+		    if (rc) return rc;
+
+		    if(rc_num)
+		    {
+			rc.setEcmdError(rc_num);
+			return rc;
+		    }
+
+
+		}
+	}
     }
 
     return rc;
@@ -5031,138 +5173,138 @@ ReturnCode mss_reset_delay_values(
 
     if(rc_num)
     {
-        rc.setEcmdError(rc_num);
-        return rc;
+	rc.setEcmdError(rc_num);
+	return rc;
     }
 
     //Scoming in zeros into the Gate delay registers.
     for(port = 0; port < MAX_PORTS; port++)
     {
 
-        for(rank_group = 0; rank_group < MAX_PRI_RANKS; rank_group++)
-        {
-
-            //Check if rank group exists
-            if(primary_ranks_array[rank_group][port] != 255)
-            {
-
-                   if ( port == 0 )
-                   {
-
-                        if ( rank_group == 0 )
-                        {
-
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_0_0x800000130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_1_0x800004130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_2_0x800008130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_3_0x80000C130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_4_0x800010130301143F;
-
-                        }
-                        else if ( rank_group == 1 )
-                        {
-
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_0_0x800001130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_1_0x800005130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_2_0x800009130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_3_0x80000D130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_4_0x800011130301143F;
-
-                        }
-                        else if ( rank_group == 2 )
-                        {
-
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_0_0x800002130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_1_0x800006130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_2_0x80000A130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_3_0x80000E130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_4_0x800012130301143F;
-
-                        }
-                        else if ( rank_group == 3 )
-                        {
-
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_0_0x800003130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_1_0x800007130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_2_0x80000B130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_3_0x80000F130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_4_0x800013130301143F;
-
-                        }
-                    }
-                    else if (port == 1 )
-                    {
-
-                        if ( rank_group == 0 )
-                        {
-
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_0_0x800100130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_1_0x800104130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_2_0x800108130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_3_0x80010C130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_4_0x800110130301143F;
-
-                        }
-                        else if ( rank_group == 1 )
-                        {
-
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_0_0x800101130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_1_0x800105130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_2_0x800109130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_3_0x80010D130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_4_0x800111130301143F;
-
-                        }
-                        else if ( rank_group == 2 )
-                        {
-
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_0_0x800102130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_1_0x800106130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_2_0x80010A130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_3_0x80010E130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_4_0x800112130301143F;
-
-                        }
-                        else if ( rank_group == 3 )
-                        {
-
-                            GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_0_0x800103130301143F;
-                            GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_1_0x800107130301143F;
-                            GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_2_0x80010B130301143F;
-                            GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_3_0x80010F130301143F;
-                            GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_4_0x800113130301143F;
-
-                        }
-                    }
-
-                    rc_num = rc_num | data_buffer_64.flushTo0();
-                    if(rc_num)
-                    {
-                        rc.setEcmdError(rc_num);
-                        return rc;
-                    }
-
-                    //BLOCK 0
-                    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_0, data_buffer_64);
-                    if (rc) return rc;
-                    //BLOCK 1
-                    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_1, data_buffer_64);
-                    if (rc) return rc;
-                    //BLOCK 2
-                    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_2, data_buffer_64);
-                    if (rc) return rc;
-                    //BLOCK 3
-                    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_3, data_buffer_64);
-                    if (rc) return rc;
-                    //BLOCK 4
-                    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_4, data_buffer_64);
-                    if (rc) return rc;
-
-
-                }
-           }
-
-        }
+	for(rank_group = 0; rank_group < MAX_PRI_RANKS; rank_group++)
+	{
+
+	    //Check if rank group exists
+	    if(primary_ranks_array[rank_group][port] != 255)
+	    {
+
+		   if ( port == 0 )
+		   {
+
+			if ( rank_group == 0 )
+			{
+
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_0_0x800000130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_1_0x800004130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_2_0x800008130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_3_0x80000C130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P0_4_0x800010130301143F;
+
+			}
+			else if ( rank_group == 1 )
+			{
+
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_0_0x800001130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_1_0x800005130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_2_0x800009130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_3_0x80000D130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P0_4_0x800011130301143F;
+
+			}
+			else if ( rank_group == 2 )
+			{
+
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_0_0x800002130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_1_0x800006130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_2_0x80000A130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_3_0x80000E130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P0_4_0x800012130301143F;
+
+			}
+			else if ( rank_group == 3 )
+			{
+
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_0_0x800003130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_1_0x800007130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_2_0x80000B130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_3_0x80000F130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P0_4_0x800013130301143F;
+
+			}
+		    }
+		    else if (port == 1 )
+		    {
+
+			if ( rank_group == 0 )
+			{
+
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_0_0x800100130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_1_0x800104130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_2_0x800108130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_3_0x80010C130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP0_P1_4_0x800110130301143F;
+
+			}
+			else if ( rank_group == 1 )
+			{
+
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_0_0x800101130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_1_0x800105130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_2_0x800109130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_3_0x80010D130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP1_P1_4_0x800111130301143F;
+
+			}
+			else if ( rank_group == 2 )
+			{
+
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_0_0x800102130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_1_0x800106130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_2_0x80010A130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_3_0x80010E130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP2_P1_4_0x800112130301143F;
+
+			}
+			else if ( rank_group == 3 )
+			{
+
+			    GATE_DELAY_ADDR_0 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_0_0x800103130301143F;
+			    GATE_DELAY_ADDR_1 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_1_0x800107130301143F;
+			    GATE_DELAY_ADDR_2 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_2_0x80010B130301143F;
+			    GATE_DELAY_ADDR_3 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_3_0x80010F130301143F;
+			    GATE_DELAY_ADDR_4 = DPHY01_DDRPHY_DP18_GATE_DELAY_RP3_P1_4_0x800113130301143F;
+
+			}
+		    }
+
+		    rc_num = rc_num | data_buffer_64.flushTo0();
+		    if(rc_num)
+		    {
+			rc.setEcmdError(rc_num);
+			return rc;
+		    }
+
+		    //BLOCK 0
+		    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_0, data_buffer_64);
+		    if (rc) return rc;
+		    //BLOCK 1
+		    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_1, data_buffer_64);
+		    if (rc) return rc;
+		    //BLOCK 2
+		    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_2, data_buffer_64);
+		    if (rc) return rc;
+		    //BLOCK 3
+		    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_3, data_buffer_64);
+		    if (rc) return rc;
+		    //BLOCK 4
+		    rc = fapiPutScom(i_target, GATE_DELAY_ADDR_4, data_buffer_64);
+		    if (rc) return rc;
+
+
+		}
+	   }
+
+	}
 
 
     return rc;
@@ -5173,9 +5315,9 @@ ReturnCode mss_rtt_nom_rtt_wr_swap(
             uint8_t i_mbaPosition,
             uint32_t i_port_number,
             uint8_t i_rank,
-            uint32_t i_rank_pair_group,
+	    uint32_t i_rank_pair_group,
             uint32_t& io_ccs_inst_cnt,
-            uint8_t& io_dram_rtt_nom_original
+	    uint8_t& io_dram_rtt_nom_original
             )
 {
     // Target MBA level
@@ -5239,7 +5381,7 @@ ReturnCode mss_rtt_nom_rtt_wr_swap(
     if(rc) return rc;
 
     uint8_t address_mirror_map[2][2]; //address_mirror_map[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
     if(rc) return rc;
 
 
@@ -5249,8 +5391,8 @@ ReturnCode mss_rtt_nom_rtt_wr_swap(
     rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 400, 0, 16);
     if(rc_num)
     {
-        rc.setEcmdError(rc_num);
-        return rc;
+	rc.setEcmdError(rc_num);
+	return rc;
     }
     rc = mss_ccs_inst_arry_0( i_target,
                               io_ccs_inst_cnt,
@@ -5281,93 +5423,93 @@ ReturnCode mss_rtt_nom_rtt_wr_swap(
     rc_num = rc_num | csn_8.setBit(0,8);
     if (i_rank == 0)
     {
-        rc_num = rc_num | csn_8.clearBit(0);
+	rc_num = rc_num | csn_8.clearBit(0);
     }
     else if (i_rank == 1)
     {
-        rc_num = rc_num | csn_8.clearBit(1);
+	rc_num = rc_num | csn_8.clearBit(1);
     }
     else if (i_rank == 2)
     {
-        rc_num = rc_num | csn_8.clearBit(2);
+	rc_num = rc_num | csn_8.clearBit(2);
     }
     else if (i_rank == 3)
     {
-        rc_num = rc_num | csn_8.clearBit(3);
+	rc_num = rc_num | csn_8.clearBit(3);
     }
     else if (i_rank == 4)
     {
-        rc_num = rc_num | csn_8.clearBit(4);
+	rc_num = rc_num | csn_8.clearBit(4);
     }
     else if (i_rank == 5)
     {
-        rc_num = rc_num | csn_8.clearBit(5);
+	rc_num = rc_num | csn_8.clearBit(5);
     }
     else if (i_rank == 6)
     {
-        rc_num = rc_num | csn_8.clearBit(6);
+	rc_num = rc_num | csn_8.clearBit(6);
     }
     else if (i_rank == 7)
     {
-        rc_num = rc_num | csn_8.clearBit(7);
+	rc_num = rc_num | csn_8.clearBit(7);
     }
 
     // MRS CMD to CMD spacing = 12 cycles
     rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 12, 0, 16);
     if(rc_num)
     {
-        rc.setEcmdError(rc_num);
-        return rc;
+	rc.setEcmdError(rc_num);
+	return rc;
     }
 
     FAPI_INF( "Editing RTT_NOM during wr_lvl for %s PORT: %d RP: %d", i_target.toEcmdString(), i_port_number, i_rank_pair_group);
 
     //MRS1
-    // Get contents of MRS 1 Shadow Reg
-
-    if (i_port_number == 0){
-        if (i_rank_pair_group == 0)
-        {
-                rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR1_PRI_RP0_P0_0x8000C01D0301143F, data_buffer_64);
-                if(rc) return rc;
-        }
-        else if (i_rank_pair_group == 1)
-        {
-                rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR1_PRI_RP1_P0_0x8000C11D0301143F, data_buffer_64);
-                if(rc) return rc;
-        }
-        else if (i_rank_pair_group == 2)
-        {
-                rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR1_PRI_RP2_P0_0x8000C21D0301143F, data_buffer_64);
-                if(rc) return rc;
-        }
-        else if (i_rank_pair_group == 3)
-        {
-                rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR1_PRI_RP3_P0_0x8000C31D0301143F, data_buffer_64);
-                if(rc) return rc;
-        }
+    // Get contents of MRS 1 Shadow Reg
+
+    if (i_port_number == 0){
+    	if (i_rank_pair_group == 0)
+    	{
+		rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR1_PRI_RP0_P0_0x8000C01D0301143F, data_buffer_64);
+	    	if(rc) return rc;
+    	}
+    	else if (i_rank_pair_group == 1)
+    	{
+		rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR1_PRI_RP1_P0_0x8000C11D0301143F, data_buffer_64);
+	    	if(rc) return rc;
+    	}
+    	else if (i_rank_pair_group == 2)
+    	{
+		rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR1_PRI_RP2_P0_0x8000C21D0301143F, data_buffer_64);
+	    	if(rc) return rc;
+    	}
+    	else if (i_rank_pair_group == 3)
+    	{
+		rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR1_PRI_RP3_P0_0x8000C31D0301143F, data_buffer_64);
+	    	if(rc) return rc;
+    	}
     }
     else if (i_port_number == 1){
-        if (i_rank_pair_group == 0)
-        {
-                rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR1_PRI_RP0_P1_0x8001C01D0301143F, data_buffer_64);
-                if(rc) return rc;
-        }
-        else if (i_rank_pair_group == 1)
-        {
-                rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR1_PRI_RP1_P1_0x8001C11D0301143F, data_buffer_64);
-                if(rc) return rc;
-        }
-        else if (i_rank_pair_group == 2)
-        {
-                rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR1_PRI_RP2_P1_0x8001C21D0301143F, data_buffer_64);
-                if(rc) return rc;
-        }
-        else if (i_rank_pair_group == 3)
-        {
-                rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR1_PRI_RP3_P1_0x8001C31D0301143F, data_buffer_64);
-                if(rc) return rc;
-        }
+    	if (i_rank_pair_group == 0)
+    	{
+		rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR1_PRI_RP0_P1_0x8001C01D0301143F, data_buffer_64);
+	    	if(rc) return rc;
+    	}
+    	else if (i_rank_pair_group == 1)
+    	{
+		rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR1_PRI_RP1_P1_0x8001C11D0301143F, data_buffer_64);
+	    	if(rc) return rc;
+    	}
+    	else if (i_rank_pair_group == 2)
+    	{
+		rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR1_PRI_RP2_P1_0x8001C21D0301143F, data_buffer_64);
+	    	if(rc) return rc;
+    	}
+    	else if (i_rank_pair_group == 3)
+    	{
+		rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR1_PRI_RP3_P1_0x8001C31D0301143F, data_buffer_64);
+	    	if(rc) return rc;
+    	}
     }
 
     rc_num = rc_num | data_buffer_64.reverse();
@@ -5375,171 +5517,171 @@ ReturnCode mss_rtt_nom_rtt_wr_swap(
     rc_num = rc_num | mrs1_16.extractPreserve(&MRS1, 0, 16, 0);
     if(rc_num)
     {
-        rc.setEcmdError(rc_num);
-        return rc;
+	rc.setEcmdError(rc_num);
+	return rc;
     }
     FAPI_INF( "CURRENT MRS 1: 0x%04X", MRS1);
 
     uint8_t dll_enable = 0x00; //DLL Enable
     if (mrs1_16.isBitSet(0))
     {
-        // DLL disabled
-        dll_enable = 0xFF;
+	// DLL disabled
+	dll_enable = 0xFF;
     }
     else if (mrs1_16.isBitClear(0))
     {
-        // DLL enabled
-        dll_enable = 0x00;
+	// DLL enabled
+	dll_enable = 0x00;
     }
 
     uint8_t out_drv_imp_cntl = 0x00;
     if ( (mrs1_16.isBitClear(1)) && (mrs1_16.isBitClear(5)) )
     {
-        // out_drv_imp_ctrl set to 40 (Rzq/6)
-        out_drv_imp_cntl = 0x00;
+	// out_drv_imp_ctrl set to 40 (Rzq/6)
+	out_drv_imp_cntl = 0x00;
     }
     else if ( (mrs1_16.isBitSet(1)) && (mrs1_16.isBitClear(5)) )
     {
-        // out_drv_imp_ctrl set to 34 (Rzq/7)
-        out_drv_imp_cntl = 0x80;
+	// out_drv_imp_ctrl set to 34 (Rzq/7)
+	out_drv_imp_cntl = 0x80;
     }
 
     uint8_t dram_rtt_nom = 0x00;
     if ( (mrs1_16.isBitClear(2)) && (mrs1_16.isBitClear(6)) && (mrs1_16.isBitClear(9)) )
     {
-        // RTT_NOM set to disabled
-        FAPI_INF( "DRAM_RTT_NOM orignally set to Disabled.");
-        dram_rtt_nom = 0x00;
+	// RTT_NOM set to disabled
+	FAPI_INF( "DRAM_RTT_NOM orignally set to Disabled.");
+	dram_rtt_nom = 0x00;
 
     }
     else if ( (mrs1_16.isBitClear(2)) && (mrs1_16.isBitClear(6)) && (mrs1_16.isBitSet(9)) )
     {
-        // RTT_NOM set to 20
-        FAPI_INF( "DRAM_RTT_NOM orignally set to 20 Ohm.");
-        dram_rtt_nom = 0x20;
+	// RTT_NOM set to 20
+	FAPI_INF( "DRAM_RTT_NOM orignally set to 20 Ohm.");
+	dram_rtt_nom = 0x20;
     }
     else if ( (mrs1_16.isBitSet(2)) && (mrs1_16.isBitClear(6)) && (mrs1_16.isBitSet(9)) )
     {
-        // RTT_NOM set to 30
-        FAPI_INF( "DRAM_RTT_NOM orignally set to 30 Ohm.");
-        dram_rtt_nom = 0xA0;
+	// RTT_NOM set to 30
+	FAPI_INF( "DRAM_RTT_NOM orignally set to 30 Ohm.");
+	dram_rtt_nom = 0xA0;
     }
     else if ( (mrs1_16.isBitSet(2)) && (mrs1_16.isBitSet(6)) && (mrs1_16.isBitClear(9)) )
     {
-        // RTT_NOM set to 40
-        FAPI_INF( "DRAM_RTT_NOM orignally set to 40 Ohm.");
-        dram_rtt_nom = 0xC0;
+	// RTT_NOM set to 40
+	FAPI_INF( "DRAM_RTT_NOM orignally set to 40 Ohm.");
+	dram_rtt_nom = 0xC0;
     }
     else if ( (mrs1_16.isBitSet(2)) && (mrs1_16.isBitSet(6)) && (mrs1_16.isBitClear(9)) )
     {
         // RTT_NOM set to 60
-        FAPI_INF( "DRAM_RTT_NOM orignally set to 60 Ohm.");
-        dram_rtt_nom = 0x80;
+	FAPI_INF( "DRAM_RTT_NOM orignally set to 60 Ohm.");
+	dram_rtt_nom = 0x80;
     }
     else if ( (mrs1_16.isBitClear(2)) && (mrs1_16.isBitSet(6)) && (mrs1_16.isBitClear(9)) )
     {
-        // RTT_NOM set to 120
-        FAPI_INF( "DRAM_RTT_NOM orignally set to 120 Ohm.");
-        dram_rtt_nom = 0x40;
+	// RTT_NOM set to 120
+	FAPI_INF( "DRAM_RTT_NOM orignally set to 120 Ohm.");
+	dram_rtt_nom = 0x40;
     }
 
     uint8_t dram_al = 0x00;
     if ( (mrs1_16.isBitClear(3)) && (mrs1_16.isBitClear(4)) )
     {
-        //AL DISABLED
+	//AL DISABLED
         dram_al = 0x00;
     }
     else if ( (mrs1_16.isBitSet(3)) && (mrs1_16.isBitClear(4)) )
     {
-        // AL = CL -1
+	// AL = CL -1
         dram_al = 0x80;
     }
     else if ( (mrs1_16.isBitClear(3)) && (mrs1_16.isBitSet(4)) )
     {
-        // AL = CL -2
+	// AL = CL -2
         dram_al = 0x40;
     }
 
     uint8_t wr_lvl = 0x00; //write leveling enable
     if (mrs1_16.isBitClear(7))
     {
-        // WR_LVL DISABLED
+	// WR_LVL DISABLED
         wr_lvl = 0x00;
     }
     else if (mrs1_16.isBitSet(7))
     {
-        // WR_LVL ENABLED
+	// WR_LVL ENABLED
         wr_lvl = 0xFF;
     }
 
     uint8_t tdqs_enable = 0x00; //TDQS Enable
     if (mrs1_16.isBitClear(11))
     {
-        //TDQS DISABLED
+	//TDQS DISABLED
         tdqs_enable = 0x00;
     }
     else if (mrs1_16.isBitSet(11))
     {
-        //TDQS ENABLED
+	//TDQS ENABLED
         tdqs_enable = 0xFF;
     }
 
     uint8_t q_off = 0x00; //Qoff - Output buffer Enable
     if (mrs1_16.isBitSet(12))
     {
-        //Output Buffer Disabled
+	//Output Buffer Disabled
         q_off = 0xFF;
     }
     else if (mrs1_16.isBitClear(12))
     {
-        //Output Buffer Enabled
+	//Output Buffer Enabled
         q_off = 0x00;
     }
 
 
     // Get contents of MRS 2 Shadow Reg
     if (i_port_number == 0){
-        if (i_rank_pair_group == 0)
-        {
-                rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR2_PRI_RP0_P0_0x8000C01E0301143F, data_buffer_64);
-                if(rc) return rc;
-        }
-        else if (i_rank_pair_group == 1)
-        {
-                rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR2_PRI_RP1_P0_0x8000C11E0301143F, data_buffer_64);
-                if(rc) return rc;
+    	if (i_rank_pair_group == 0)
+    	{
+		rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR2_PRI_RP0_P0_0x8000C01E0301143F, data_buffer_64);
+	    	if(rc) return rc;
+	}
+	else if (i_rank_pair_group == 1)
+	{
+		rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR2_PRI_RP1_P0_0x8000C11E0301143F, data_buffer_64);
+	    	if(rc) return rc;
         }
         else if (i_rank_pair_group == 2)
         {
-                rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR2_PRI_RP2_P0_0x8000C21E0301143F, data_buffer_64);
-                if(rc) return rc;
+	        rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR2_PRI_RP2_P0_0x8000C21E0301143F, data_buffer_64);
+	    	if(rc) return rc;
         }
         else if (i_rank_pair_group == 3)
         {
-                rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR2_PRI_RP3_P0_0x8000C31E0301143F, data_buffer_64);
-                if(rc) return rc;
+     	        rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR2_PRI_RP3_P0_0x8000C31E0301143F, data_buffer_64);
+	    	if(rc) return rc;
         }
     }
     else if (i_port_number == 1){
-        if (i_rank_pair_group == 0)
-        {
-                rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR2_PRI_RP0_P1_0x8001C01E0301143F, data_buffer_64);
-                if(rc) return rc;
-        }
-        else if (i_rank_pair_group == 1)
-        {
-                rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR2_PRI_RP1_P1_0x8001C11E0301143F, data_buffer_64);
-                if(rc) return rc;
+    	if (i_rank_pair_group == 0)
+    	{
+		rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR2_PRI_RP0_P1_0x8001C01E0301143F, data_buffer_64);
+	    	if(rc) return rc;
+	}
+	else if (i_rank_pair_group == 1)
+	{
+		rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR2_PRI_RP1_P1_0x8001C11E0301143F, data_buffer_64);
+	    	if(rc) return rc;
         }
         else if (i_rank_pair_group == 2)
         {
-                rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR2_PRI_RP2_P1_0x8001C21E0301143F, data_buffer_64);
-                if(rc) return rc;
+	        rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR2_PRI_RP2_P1_0x8001C21E0301143F, data_buffer_64);
+	    	if(rc) return rc;
         }
         else if (i_rank_pair_group == 3)
         {
-                rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR2_PRI_RP3_P1_0x8001C31E0301143F, data_buffer_64);
-                if(rc) return rc;
+     	        rc = fapiGetScom(i_target, DPHY01_DDRPHY_PC_MR2_PRI_RP3_P1_0x8001C31E0301143F, data_buffer_64);
+	    	if(rc) return rc;
         }
     }
 
@@ -5548,40 +5690,40 @@ ReturnCode mss_rtt_nom_rtt_wr_swap(
     rc_num = rc_num | mrs2_16.extractPreserve(&MRS2, 0, 16, 0);
     if(rc_num)
     {
-        rc.setEcmdError(rc_num);
-        return rc;
+	rc.setEcmdError(rc_num);
+	return rc;
     }
     FAPI_INF( "MRS 2: 0x%04X", MRS2);
 
     uint8_t dram_rtt_wr = 0x00;
     if ( (mrs2_16.isBitClear(9)) && (mrs2_16.isBitClear(10)) )
     {
-        //RTT WR DISABLE
-        FAPI_INF( "DRAM_RTT_WR currently set to Disable.");
-        dram_rtt_wr = 0x00;
+	//RTT WR DISABLE
+	FAPI_INF( "DRAM_RTT_WR currently set to Disable.");
+	dram_rtt_wr = 0x00;
 
-        //RTT NOM CODE FOR THIS VALUE IS
-        // dram_rtt_nom = 0x00
+	//RTT NOM CODE FOR THIS VALUE IS
+	// dram_rtt_nom = 0x00
 
     }
     else if ( (mrs2_16.isBitSet(9)) && (mrs2_16.isBitClear(10)) )
     {
-        //RTT WR 60 OHM
-        FAPI_INF( "DRAM_RTT_WR currently set to 60 Ohm.");
-        dram_rtt_wr = 0x80;
+	//RTT WR 60 OHM
+	FAPI_INF( "DRAM_RTT_WR currently set to 60 Ohm.");
+	dram_rtt_wr = 0x80;
 
         //RTT NOM CODE FOR THIS VALUE IS
-        // dram_rtt_nom = 0x80
+	// dram_rtt_nom = 0x80
 
     }
     else if ( (mrs2_16.isBitClear(9)) && (mrs2_16.isBitSet(10)) )
     {
-        //RTT WR 120 OHM
-        FAPI_INF( "DRAM_RTT_WR currently set to 120 Ohm.");
-        dram_rtt_wr = 0x40;
+	//RTT WR 120 OHM
+	FAPI_INF( "DRAM_RTT_WR currently set to 120 Ohm.");
+	dram_rtt_wr = 0x40;
 
         //RTT NOM CODE FOR THIS VALUE IS
-        // dram_rtt_nom = 0x40
+	// dram_rtt_nom = 0x40
 
     }
 
@@ -5590,62 +5732,62 @@ ReturnCode mss_rtt_nom_rtt_wr_swap(
     // you will use dram_rtt_nom_original to save the original value
     if (io_dram_rtt_nom_original  == 0xFF)
     {
-        io_dram_rtt_nom_original = dram_rtt_nom;
-        dram_rtt_nom = dram_rtt_wr;
-
-        if (dram_rtt_wr == 0x00)
-        {
-            FAPI_INF( "DRAM_RTT_NOM to be set to DRAM_RTT_WR which is Disable.");
-        }
-        else if (dram_rtt_wr == 0x80)
-        {
-            FAPI_INF( "DRAM_RTT_NOM to be set to DRAM_RTT_WR which is 60 Ohm.");
-        }
-        else if (dram_rtt_wr == 0x40)
-        {
-            FAPI_INF( "DRAM_RTT_NOM to be set to DRAM_RTT_WR which is 120 Ohm.");
-        }
+	io_dram_rtt_nom_original = dram_rtt_nom;
+	dram_rtt_nom = dram_rtt_wr;
+
+	if (dram_rtt_wr == 0x00)
+	{
+	    FAPI_INF( "DRAM_RTT_NOM to be set to DRAM_RTT_WR which is Disable.");
+	}
+	else if (dram_rtt_wr == 0x80)
+	{
+	    FAPI_INF( "DRAM_RTT_NOM to be set to DRAM_RTT_WR which is 60 Ohm.");
+	}
+	else if (dram_rtt_wr == 0x40)
+	{
+	    FAPI_INF( "DRAM_RTT_NOM to be set to DRAM_RTT_WR which is 120 Ohm.");
+	}
     }
     else if (io_dram_rtt_nom_original != 0xFF)
     {
-        dram_rtt_nom = io_dram_rtt_nom_original;
-
-        if ( dram_rtt_nom == 0x00 )
-        {
-            // RTT_NOM set to disabled
-            FAPI_INF( "DRAM_RTT_NOM being set back to Disabled.");
-
-        }
-        else if ( dram_rtt_nom == 0x20 )
-        {
-            // RTT_NOM set to 20
-            FAPI_INF( "DRAM_RTT_NOM being set back to 20 Ohm.");
-        }
-        else if ( dram_rtt_nom == 0xA0 )
-        {
-            // RTT_NOM set to 30
-            FAPI_INF( "DRAM_RTT_NOM being set back to 30 Ohm.");
-        }
-        else if ( dram_rtt_nom == 0xC0 )
-        {
-            // RTT_NOM set to 40
-            FAPI_INF( "DRAM_RTT_NOM being set back to 40 Ohm.");
-        }
-        else if ( dram_rtt_nom == 0x80 )
-        {
-            // RTT_NOM set to 60
-            FAPI_INF( "DRAM_RTT_NOM being set back to 60 Ohm.");
-        }
-        else if ( dram_rtt_nom == 0x40 )
-        {
-            // RTT_NOM set to 120
-            FAPI_INF( "DRAM_RTT_NOM being set back to 120 Ohm.");
-        }
-        else
-        {
-            FAPI_INF( "Proposed DRAM_RTT_NOM value is a non-supported.  Using Disabled.");
-            dram_rtt_nom = 0x00;
-        }
+	dram_rtt_nom = io_dram_rtt_nom_original;
+
+	if ( dram_rtt_nom == 0x00 )
+	{
+	    // RTT_NOM set to disabled
+	    FAPI_INF( "DRAM_RTT_NOM being set back to Disabled.");
+
+	}
+	else if ( dram_rtt_nom == 0x20 )
+	{
+	    // RTT_NOM set to 20
+	    FAPI_INF( "DRAM_RTT_NOM being set back to 20 Ohm.");
+	}
+	else if ( dram_rtt_nom == 0xA0 )
+	{
+	    // RTT_NOM set to 30
+	    FAPI_INF( "DRAM_RTT_NOM being set back to 30 Ohm.");
+	}
+	else if ( dram_rtt_nom == 0xC0 )
+	{
+	    // RTT_NOM set to 40
+	    FAPI_INF( "DRAM_RTT_NOM being set back to 40 Ohm.");
+	}
+	else if ( dram_rtt_nom == 0x80 )
+	{
+	    // RTT_NOM set to 60
+	    FAPI_INF( "DRAM_RTT_NOM being set back to 60 Ohm.");
+	}
+	else if ( dram_rtt_nom == 0x40 )
+	{
+	    // RTT_NOM set to 120
+	    FAPI_INF( "DRAM_RTT_NOM being set back to 120 Ohm.");
+	}
+	else
+	{
+	    FAPI_INF( "Proposed DRAM_RTT_NOM value is a non-supported.  Using Disabled.");
+	    dram_rtt_nom = 0x00;
+	}
     }
 
 
@@ -5678,45 +5820,45 @@ ReturnCode mss_rtt_nom_rtt_wr_swap(
 
     if ( ( address_mirror_map[i_port_number][dimm] & (0x08 >> dimm_rank) ) && (is_sim == 0))
     {
-        //dimm and rank are only for print trace only, functionally not needed
-        rc = mss_address_mirror_swizzle(i_target, i_port_number, dimm, dimm_rank, address_16, bank_3);
-        if(rc) return rc;
+	//dimm and rank are only for print trace only, functionally not needed
+	rc = mss_address_mirror_swizzle(i_target, i_port_number, dimm, dimm_rank, address_16, bank_3);
+	if(rc) return rc;
 
     }
 
     if (rc_num)
     {
-        FAPI_ERR( "mss_mrs_load: Error setting up buffers");
-        rc_buff.setEcmdError(rc_num);
-        return rc_buff;
+	FAPI_ERR( "mss_mrs_load: Error setting up buffers");
+	rc_buff.setEcmdError(rc_num);
+	return rc_buff;
     }
 
     ccs_end_1.setBit(0);
 
     // Send out to the CCS array
     rc = mss_ccs_inst_arry_0( i_target,
-                              io_ccs_inst_cnt,
-                              address_16,
-                              bank_3,
-                              activate_1,
-                              rasn_1,
-                              casn_1,
-                              wen_1,
-                              cke_4,
-                              csn_8,
-                              odt_4,
-                              ddr_cal_type_4,
-                              i_port_number);
+			      io_ccs_inst_cnt,
+			      address_16,
+			      bank_3,
+			      activate_1,
+			      rasn_1,
+			      casn_1,
+			      wen_1,
+			      cke_4,
+			      csn_8,
+			      odt_4,
+			      ddr_cal_type_4,
+			      i_port_number);
     if(rc) return rc;
     rc = mss_ccs_inst_arry_1( i_target,
-                              io_ccs_inst_cnt,
-                              num_idles_16,
-                              num_repeat_16,
-                              data_20,
-                              read_compare_1,
-                              rank_cal_4,
-                              ddr_cal_enable_1,
-                              ccs_end_1);
+			      io_ccs_inst_cnt,
+			      num_idles_16,
+			      num_repeat_16,
+			      data_20,
+			      read_compare_1,
+			      rank_cal_4,
+			      ddr_cal_enable_1,
+			      ccs_end_1);
     if(rc) return rc;
 
     uint32_t NUM_POLL = 100;
@@ -5734,83 +5876,83 @@ ReturnCode mss_rtt_nom_rtt_wr_swap(
 fapi::ReturnCode mss_set_bbm_regs (const fapi::Target & mba_target)
 {
     // Flash to registers.
-        // disable0=dq bits, disable1=dqs(+,-)
-        // wrclk_en=dqs follows quad, same as disable0
-
-        const uint64_t disable_reg[MAX_PORTS][MAX_PRI_RANKS][DP18_INSTANCES] = {
-        /* port 0 */
-        {       // primary rank pair 0
-           {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_0_0x8000007c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_1_0x8000047c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_2_0x8000087c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_3_0x80000c7c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_4_0x8000107c0301143F},
-                // primary rank pair 1
-           {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_0_0x8000017c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_1_0x8000057c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_2_0x8000097c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_3_0x80000d7c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_4_0x8000117c0301143F},
-                // primary rank pair 2
-           {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_0_0x8000027c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_1_0x8000067c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_2_0x80000a7c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_3_0x80000e7c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_4_0x8000127c0301143F},
-                // primary rank pair 3
-           {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_0_0x8000037c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_1_0x8000077c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_2_0x80000b7c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_3_0x80000f7c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_4_0x8000137c0301143F}
-        },
-        /* port 1 */
-        {
-           // primary rank pair 0
-           {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_0_0x8001007c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_1_0x8001047c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_2_0x8001087c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_3_0x80010c7c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_4_0x8001107c0301143F},
+	// disable0=dq bits, disable1=dqs(+,-)
+	// wrclk_en=dqs follows quad, same as disable0
+
+	const uint64_t disable_reg[MAX_PORTS][MAX_PRI_RANKS][DP18_INSTANCES] = {
+	/* port 0 */
+	{	// primary rank pair 0
+	   {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_0_0x8000007c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_1_0x8000047c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_2_0x8000087c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_3_0x80000c7c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_4_0x8000107c0301143F},
+		// primary rank pair 1
+	   {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_0_0x8000017c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_1_0x8000057c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_2_0x8000097c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_3_0x80000d7c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_4_0x8000117c0301143F},
+		// primary rank pair 2
+	   {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_0_0x8000027c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_1_0x8000067c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_2_0x80000a7c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_3_0x80000e7c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_4_0x8000127c0301143F},
+		// primary rank pair 3
+	   {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_0_0x8000037c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_1_0x8000077c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_2_0x80000b7c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_3_0x80000f7c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_4_0x8000137c0301143F}
+	},
+	/* port 1 */
+	{
+	   // primary rank pair 0
+	   {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_0_0x8001007c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_1_0x8001047c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_2_0x8001087c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_3_0x80010c7c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_4_0x8001107c0301143F},
            // primary rank p1
-           {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_0_0x8001017c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_1_0x8001057c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_2_0x8001097c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_3_0x80010d7c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_4_0x8001117c0301143F},
+	   {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_0_0x8001017c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_1_0x8001057c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_2_0x8001097c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_3_0x80010d7c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_4_0x8001117c0301143F},
            // primary rank pair 2
-           {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_0_0x8001027c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_1_0x8001067c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_2_0x80010a7c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_3_0x80010e7c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_4_0x8001127c0301143F},
+	   {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_0_0x8001027c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_1_0x8001067c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_2_0x80010a7c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_3_0x80010e7c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_4_0x8001127c0301143F},
            // primary rank pair 3
-           {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_0_0x8001037c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_1_0x8001077c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_2_0x80010b7c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_3_0x80010f7c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_4_0x8001137c0301143F}
-        }};
-        const uint8_t rg_invalid[] = {
-                ENUM_ATTR_EFF_PRIMARY_RANK_GROUP0_INVALID,
-                ENUM_ATTR_EFF_PRIMARY_RANK_GROUP1_INVALID,
-                ENUM_ATTR_EFF_PRIMARY_RANK_GROUP2_INVALID,
-                ENUM_ATTR_EFF_PRIMARY_RANK_GROUP3_INVALID,
-        };
-
-        const uint16_t wrclk_disable_mask[] = {         // by quads
-                0x8800, 0x4400, 0x2280, 0x1140
-        };
-
-        uint8_t l_dram_width, l_disable1_fixed, l_disable1_rdclk_fixed;
-        uint64_t l_addr;
-        // 0x8000007d0301143f    from disable0 register
-        const uint64_t l_disable1_addr_offset = 0x0000000100000000ull;
-        // 0x800000050301143f    from disable1 register
-        const uint64_t l_wrclk_en_addr_mask   = 0xFFFFFF07FFFFFFFFull;
-
-        ReturnCode rc;
-        ecmdDataBufferBase data_buffer(64);
+	   {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_0_0x8001037c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_1_0x8001077c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_2_0x80010b7c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_3_0x80010f7c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_4_0x8001137c0301143F}
+	}};
+	const uint8_t rg_invalid[] = {
+		ENUM_ATTR_EFF_PRIMARY_RANK_GROUP0_INVALID,
+		ENUM_ATTR_EFF_PRIMARY_RANK_GROUP1_INVALID,
+		ENUM_ATTR_EFF_PRIMARY_RANK_GROUP2_INVALID,
+		ENUM_ATTR_EFF_PRIMARY_RANK_GROUP3_INVALID,
+	};
+
+	const uint16_t wrclk_disable_mask[] = {		// by quads
+		0x8800, 0x4400, 0x2280, 0x1140
+	};
+
+	uint8_t l_dram_width, l_disable1_fixed, l_disable1_rdclk_fixed;
+	uint64_t l_addr;
+	// 0x8000007d0301143f	 from disable0 register
+	const uint64_t l_disable1_addr_offset = 0x0000000100000000ull;
+	// 0x800000050301143f	 from disable1 register
+	const uint64_t l_wrclk_en_addr_mask   = 0xFFFFFF07FFFFFFFFull;
+
+	ReturnCode rc;
+	ecmdDataBufferBase data_buffer(64);
         ecmdDataBufferBase db_reg(BITS_PER_PORT);
         ecmdDataBufferBase db_reg_rank0(BITS_PER_PORT);
         ecmdDataBufferBase db_reg_rank1(BITS_PER_PORT);
@@ -5820,691 +5962,691 @@ fapi::ReturnCode mss_set_bbm_regs (const fapi::Target & mba_target)
         ecmdDataBufferBase db_reg_rank5(BITS_PER_PORT);
         ecmdDataBufferBase db_reg_rank6(BITS_PER_PORT);
         ecmdDataBufferBase db_reg_rank7(BITS_PER_PORT);
-        uint32_t l_ecmdRc = ECMD_DBUF_SUCCESS;
-        uint8_t prg[MAX_PRI_RANKS][MAX_PORTS];          // primary rank group values
-
-        FAPI_INF("Running flash->registers(set)");
+	uint32_t l_ecmdRc = ECMD_DBUF_SUCCESS;
+	uint8_t prg[MAX_PRI_RANKS][MAX_PORTS];		// primary rank group values
 
-        std::vector<Target> mba_dimms;
-        rc = fapiGetAssociatedDimms(mba_target, mba_dimms);     // functional dimms
-        if(rc) return rc;
+	FAPI_INF("Running flash->registers(set)");
 
-        // ATTR_EFF_PRIMARY_RANK_GROUP0[port], GROUP1[port],
-        //                                               GROUP2[port], GROUP3[port]
-        rc=FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP0, &mba_target, prg[0]);
-        if(rc) return rc;
-        rc=FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP1, &mba_target, prg[1]);
-        if(rc) return rc;
-        rc=FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP2, &mba_target, prg[2]);
-        if(rc) return rc;
-        rc=FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP3, &mba_target, prg[3]);
-        if(rc) return rc;
+	std::vector<Target> mba_dimms;
+	rc = fapiGetAssociatedDimms(mba_target, mba_dimms);	// functional dimms
+	if(rc) return rc;
 
-        rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_WIDTH, &mba_target, l_dram_width);
-        if(rc) return rc;
+	// ATTR_EFF_PRIMARY_RANK_GROUP0[port], GROUP1[port],
+	// 						 GROUP2[port], GROUP3[port]
+	rc=FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP0, &mba_target, prg[0]);
+	if(rc) return rc;
+	rc=FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP1, &mba_target, prg[1]);
+	if(rc) return rc;
+	rc=FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP2, &mba_target, prg[2]);
+	if(rc) return rc;
+	rc=FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP3, &mba_target, prg[3]);
+	if(rc) return rc;
 
+	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_WIDTH, &mba_target, l_dram_width);
+	if(rc) return rc;
 
+	
 
         fapi::Target l_target_centaur;
         rc = fapiGetParentChip(mba_target, l_target_centaur);
         if(rc) return rc;
 
-        rc = FAPI_ATTR_GET(ATTR_MSS_DISABLE1_REG_FIXED, &l_target_centaur, l_disable1_fixed);
+	rc = FAPI_ATTR_GET(ATTR_MSS_DISABLE1_REG_FIXED, &l_target_centaur, l_disable1_fixed);
         if(rc) return rc;
 
-        rc = FAPI_ATTR_GET(ATTR_MSS_DISABLE1_RDCLK_REG_FIXED, &l_target_centaur, l_disable1_rdclk_fixed);
+	rc = FAPI_ATTR_GET(ATTR_MSS_DISABLE1_RDCLK_REG_FIXED, &l_target_centaur, l_disable1_rdclk_fixed);
         if(rc) return rc;
 
-        switch (l_dram_width)
-        {
-                case ENUM_ATTR_EFF_DRAM_WIDTH_X4:
-                        l_dram_width = 4;
-                        break;
-                case ENUM_ATTR_EFF_DRAM_WIDTH_X8:
-                        l_dram_width = 8;
-                        break;
-                case ENUM_ATTR_EFF_DRAM_WIDTH_X16:
-                        l_dram_width = 16;
-                        break;
-                case ENUM_ATTR_EFF_DRAM_WIDTH_X32:
-                        l_dram_width = 32;
-                        break;
-                default:
-                        //DECONFIG and FFDC INFO
-                        const fapi::Target & TARGET_MBA_ERROR = mba_target;
+	switch (l_dram_width)
+	{
+		case ENUM_ATTR_EFF_DRAM_WIDTH_X4:
+			l_dram_width = 4;
+			break;
+		case ENUM_ATTR_EFF_DRAM_WIDTH_X8:
+			l_dram_width = 8;
+			break;
+		case ENUM_ATTR_EFF_DRAM_WIDTH_X16:
+			l_dram_width = 16;
+			break;
+		case ENUM_ATTR_EFF_DRAM_WIDTH_X32:
+			l_dram_width = 32;
+			break;
+		default:
+			//DECONFIG and FFDC INFO
+			const fapi::Target & TARGET_MBA_ERROR = mba_target;
                         const uint8_t & WIDTH = l_dram_width;
 
-                        FAPI_ERR("ATTR_EFF_DRAM_WIDTH is invalid %u", l_dram_width);
-                        FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_DRAM_WIDTH_INPUT_ERROR_SETBBM);
-                        return rc;
-        }
-
-        l_ecmdRc = data_buffer.flushTo0();
-        if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-        {
-                 FAPI_ERR("Error from ecmdDataBuffer flushTo0() "
-                                 "- rc 0x%.8X", l_ecmdRc);
-                 rc.setEcmdError(l_ecmdRc);
-                 return rc;
-        }
-        for (uint8_t port = 0; port < MAX_PORTS; port++ )       // [0:1]
-        {
-                db_reg_rank0.flushTo0();
-                db_reg_rank1.flushTo0();
-                db_reg_rank2.flushTo0();
-                db_reg_rank3.flushTo0();
-                db_reg_rank4.flushTo0();
-                db_reg_rank5.flushTo0();
-                db_reg_rank6.flushTo0();
-                db_reg_rank7.flushTo0();
-                uint8_t is_clean = 1;
-
-                uint8_t l_rank0_invalid = 1; //0 = valid, 1 = invalid
-                uint8_t l_rank1_invalid = 1;
-                uint8_t l_rank2_invalid = 1;
-                uint8_t l_rank3_invalid = 1;
-                uint8_t l_rank4_invalid = 1;
-                uint8_t l_rank5_invalid = 1;
-                uint8_t l_rank6_invalid = 1;
-                uint8_t l_rank7_invalid = 1;
-
-                // Gather all ranks first
-                // loop through primary ranks [0:3]
-                for (uint8_t prank = 0; prank < MAX_PRI_RANKS; prank++ )
-                {
-
-                        is_clean = 1;
-                        if (prg[prank][port] == rg_invalid[prank])      // invalid rank
-                        {
-                                FAPI_DBG("BYTE DISABLE WORKAROUND  Primary rank group (prank) %i port %d rank value: %d INVALID, Marking and continuing...",
-                                                prank, port, prg[prank][port]);
-
-                                continue;
-                        }
-
-                        if ( prg[prank][port] == 0)
-                        {
-                                FAPI_DBG("BYTE DISABLE WORKAROUND  Primary rank group (prank) %i port %d rank value: %d Not INVALID, Marking and continuing...",
-                                                prank, port, prg[prank][port]);
-                                rc = getC4dq2reg(mba_target, port, 0, 0, db_reg_rank0, is_clean);
-                                if (rc)
-                                {
-                                        FAPI_ERR("Error from getting register bitmap port=%i: "
-                                                        "dimm=%i, rank=%i rc=%i", port, 0, 0,
-                                                        static_cast<uint32_t>(rc));
-                                        return rc;
-                                }
-                                l_rank0_invalid = 0;
-                        }
-
-                        if ( prg[prank][port] == 1)
-                        {
-                                FAPI_DBG("BYTE DISABLE WORKAROUND  Primary rank group (prank) %i port %d rank value: %d Not INVALID, Marking and continuing...",
-                                                prank, port, prg[prank][port]);
-                                rc = getC4dq2reg(mba_target, port, 0, 1, db_reg_rank1, is_clean);
-                                if (rc)
-                                {
-                                        FAPI_ERR("Error from getting register bitmap port=%i: "
-                                                        "dimm=%i, rank=%i rc=%i", port, 0, 1,
-                                                        static_cast<uint32_t>(rc));
-                                        return rc;
-                                }
-                                l_rank1_invalid = 0;
-                        }
-
-                        if ( prg[prank][port] == 2)
-                        {
-                                FAPI_DBG("BYTE DISABLE WORKAROUND  Primary rank group (prank) %i port %d rank value: %d Not INVALID, Marking and continuing...",
-                                                prank, port, prg[prank][port]);
-                                rc = getC4dq2reg(mba_target, port, 0, 2, db_reg_rank2, is_clean);
-                                if (rc)
-                                {
-                                        FAPI_ERR("Error from getting register bitmap port=%i: "
-                                                        "dimm=%i, rank=%i rc=%i", port, 0, 2,
-                                                        static_cast<uint32_t>(rc));
-                                        return rc;
-                                }
-                                l_rank2_invalid = 0;
-                        }
-
-
-                        if ( prg[prank][port] == 3)
-                        {
-                                FAPI_DBG("BYTE DISABLE WORKAROUND  Primary rank group (prank) %i port %d rank value: %d Not INVALID, Marking and continuing...",
-                                                prank, port, prg[prank][port]);
-                                rc = getC4dq2reg(mba_target, port, 0, 3, db_reg_rank3, is_clean);
-                                if (rc)
-                                {
-                                        FAPI_ERR("Error from getting register bitmap port=%i: "
-                                                        "dimm=%i, rank=%i rc=%i", port, 0, 3,
-                                                        static_cast<uint32_t>(rc));
-                                        return rc;
-                                }
-                                l_rank3_invalid = 0;
-                        }
-
-
-
-                        if ( prg[prank][port] == 4)
-                        {
-                                FAPI_DBG("BYTE DISABLE WORKAROUND  Primary rank group (prank) %i port %d rank value: %d Not INVALID, Marking and continuing...",
-                                                prank, port, prg[prank][port]);
-                                rc = getC4dq2reg(mba_target, port, 1, 0, db_reg_rank4, is_clean);
-                                if (rc)
-                                {
-                                        FAPI_ERR("Error from getting register bitmap port=%i: "
-                                                        "dimm=%i, rank=%i rc=%i", port, 1, 0,
-                                                        static_cast<uint32_t>(rc));
-                                        return rc;
-                                }
-                                l_rank4_invalid = 0;
-                        }
-
-
-                        if ( prg[prank][port] == 5)
-                        {
-                                FAPI_DBG("BYTE DISABLE WORKAROUND  Primary rank group (prank) %i port %d rank value: %d Not INVALID, Marking and continuing...",
-                                                prank, port, prg[prank][port]);
-                                rc = getC4dq2reg(mba_target, port, 1, 1, db_reg_rank5, is_clean);
-                                if (rc)
-                                {
-                                        FAPI_ERR("Error from getting register bitmap port=%i: "
-                                                        "dimm=%i, rank=%i rc=%i", port, 1, 1,
-                                                        static_cast<uint32_t>(rc));
-                                        return rc;
-                                }
-                                l_rank5_invalid = 0;
-                        }
-
-
-                        if ( prg[prank][port] == 6)
-                        {
-                                FAPI_DBG("BYTE DISABLE WORKAROUND  Primary rank group (prank) %i port %d rank value: %d Not INVALID, Marking and continuing...",
-                                                prank, port, prg[prank][port]);
-                                rc = getC4dq2reg(mba_target, port, 1, 2, db_reg_rank6, is_clean);
-                                if (rc)
-                                {
-                                        FAPI_ERR("Error from getting register bitmap port=%i: "
-                                                        "dimm=%i, rank=%i rc=%i", port, 1, 2,
-                                                        static_cast<uint32_t>(rc));
-                                        return rc;
-                                }
-                                l_rank6_invalid = 0;
-                        }
-
-
-                        if ( prg[prank][port] == 7)
-                        {
-                                FAPI_DBG("BYTE DISABLE WORKAROUND  Primary rank group (prank) %i port %d rank value: %d Not INVALID, Marking and continuing...",
-                                                prank, port, prg[prank][port]);
-                                rc = getC4dq2reg(mba_target, port, 1, 3, db_reg_rank7, is_clean);
-                                if (rc)
-                                {
-                                        FAPI_ERR("Error from getting register bitmap port=%i: "
-                                                        "dimm=%i, rank=%i rc=%i", port, 1, 3,
-                                                        static_cast<uint32_t>(rc));
-                                        return rc;
-                                }
-                                l_rank7_invalid = 0;
-                        }
-
-                }
-
-                // loop through primary ranks [0:3]
-                for (uint8_t prank = 0; prank < MAX_PRI_RANKS; prank++ )
-                {
-                        uint8_t dimm = prg[prank][port] >> 2;
-                        uint8_t rank = prg[prank][port] & 0x03;
-                        uint16_t l_data = 0;
-                        uint16_t l_data_rank0 = 0;
-                        uint16_t l_data_rank1 = 0;
-                        uint16_t l_data_rank2 = 0;
-                        uint16_t l_data_rank3 = 0;
-                        uint16_t l_data_rank4 = 0;
-                        uint16_t l_data_rank5 = 0;
-                        uint16_t l_data_rank6 = 0;
-                        uint16_t l_data_rank7 = 0;
-                        is_clean = 1;
-
-                        if (prg[prank][port] == rg_invalid[prank])      // invalid rank
-                        {
-                                FAPI_DBG("Primary rank group %i: INVALID, continuing...",
-                                                prank);
-                                continue;
-                        }
-
-                        rc = getC4dq2reg(mba_target, port, dimm, rank, db_reg, is_clean);
-                        if (rc)
-                        {
-                                FAPI_ERR("Error from getting register bitmap port=%i: "
-                                                "dimm=%i, rank=%i rc=%i", port, dimm, rank,
-                                                static_cast<uint32_t>(rc));
-                                return rc;
-                        }
-
-
-
-                        // quick test to move on to next rank if no bits need to be set
-                        if (is_clean == 1)                      // Note ignores spares that match attribute
-                        {
-                                FAPI_INF("Primary rank group %i: No bad bits found for "
-                                                "p%i:d%i:r%i:cs%i", prank, port, dimm, rank,
-                                                prg[prank][port]);
-                                continue;
-                        }
-                        for ( uint8_t i=0; i < DP18_INSTANCES; i++ ) // dp18 [0:4]
-                        {
-                                uint8_t disable1_data = 0;
-                                uint16_t wrclk_mask = 0;
-
-                                // check or not to check(always set register)?
-                                l_data = db_reg.getHalfWord(i);
-                                l_data_rank0 = db_reg_rank0.getHalfWord(i);
-                                l_data_rank1 = db_reg_rank1.getHalfWord(i);
-                                l_data_rank2 = db_reg_rank2.getHalfWord(i);
-                                l_data_rank3 = db_reg_rank3.getHalfWord(i);
-                                l_data_rank4 = db_reg_rank4.getHalfWord(i);
-                                l_data_rank5 = db_reg_rank5.getHalfWord(i);
-                                l_data_rank6 = db_reg_rank6.getHalfWord(i);
-                                l_data_rank7 = db_reg_rank7.getHalfWord(i);
-
-                                if (l_data == 0)
-                                {
-                                        FAPI_DBG("\tDP18_%i has no bad bits set, continuing...", i);
-                                        continue;
-                                }
-                                // clear bits 48:63
-                                l_ecmdRc = data_buffer.flushTo0();
-                                if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-                                {
-                                         FAPI_ERR("Error from ecmdDataBuffer flushTo0() "
-                                                         "- rc 0x%.8X", l_ecmdRc);
-
-                                         rc.setEcmdError(l_ecmdRc);
-                                         return rc;
-                                }
-
-                                uint16_t mask = 0xF000;
-                                // Temp 0xE removed.
-                                //uint16_t emask = 0xE000;
-                                uint8_t all_F_mask = 0;
-                                for (uint8_t n=0; n < 4; n++) { // check each nibble
-                                        uint16_t nmask = mask >> (4*n);
-                                        // Temp 0xE removed.
-                                        //uint16_t e_nmask = emask >> (4*n);
-
-
-                                        if ((nmask & l_data) == nmask) {
-                                                FAPI_DBG("BYTE DISABLE WORKAROUND  Found a 0XF on nibble=%i Port%i, dimm=%i, prg%i rank=%i data=0x%04X", n, port, dimm, prank, rank, l_data);
-                                                if ( ( ((nmask & l_data_rank0) == nmask) || (l_rank0_invalid) ) &&
-                                                     ( ((nmask & l_data_rank1) == nmask) || (l_rank1_invalid) ) &&
-                                                     ( ((nmask & l_data_rank2) == nmask) || (l_rank2_invalid) ) &&
-                                                     ( ((nmask & l_data_rank3) == nmask) || (l_rank3_invalid) ) &&
-                                                     ( ((nmask & l_data_rank4) == nmask) || (l_rank4_invalid) ) &&
-                                                     ( ((nmask & l_data_rank5) == nmask) || (l_rank5_invalid) ) &&
-                                                     ( ((nmask & l_data_rank6) == nmask) || (l_rank6_invalid) ) &&
-                                                     ( ((nmask & l_data_rank7) == nmask) || (l_rank7_invalid) )   )
-                                                {
-                                                        //Leave it an F.
-                                                        FAPI_DBG("BYTE DISABLE WORKAROUND  All ranks are a F so writing an 0xF to disable regs.");
-                                                        FAPI_DBG("BYTE DISABLE WORKAROUND  data rank 0 =0x%04X rank 1 =0x%04X rank 2 =0x%04X rank 3 =0x%04X rank 4 =0x%04X rank 5 =0x%04X rank 6 =0x%04X rank 7 =0x%04X", l_data_rank0,l_data_rank1,l_data_rank2,l_data_rank3,l_data_rank4,l_data_rank5,l_data_rank6,l_data_rank7 );
-                                                        all_F_mask = 1;
-                                                }
-                                                else
-                                                {
-                                                        //Replacing F nibble with E nibble
-                                                        FAPI_DBG("BYTE DISABLE WORKAROUND  Single rank is a 0xF so writing an 0x0 to disable regs. PRE DATA: 0x%04X", l_data);
-                                                        l_data = l_data & ~(nmask);
-                                                        FAPI_DBG("BYTE DISABLE WORKAROUND  POST DATA: 0x%04X", l_data);
-                                                }
-                                        }
-
-                                        // Temporarily removing the 0xE case
-                                        /*
-                                        if ((nmask & l_data) == e_nmask) {
-                                                FAPI_DBG("BYTE DISABLE WORKAROUND  Found a 0XE on nibble=%i Port%i, dimm=%i, prg%i rank=%i data=0x%04X", n, port, dimm, prank, rank, l_data);
-
-                                                //Leave it an E.
-                                                FAPI_DBG("BYTE DISABLE WORKAROUND  Found a 0xE so writing an 0xE to disable regs.");
-
-                                        }
-                                        */
-
-                                        uint16_t wrclk_nmask = 0xF000 >> (4*n);
-                                        if (l_dram_width != 4) // x8 only disable the wrclk
-                                        {
-
-                                                if (((wrclk_nmask & l_data)>>(4*(3-n))) == 0x0F)
-                                                {
-                                                        wrclk_mask |= wrclk_disable_mask[n];
-                                                }
-                                        }
-
-                                }
-
-
-                                if (all_F_mask ==1) {
-                                FAPI_INF("Entering into all F across all ranks case. Need to Disable WRCLK Enable as well.");
-                                for (uint8_t n=0; n < 4; n++)   // check each nibble
-                                {
-                                        uint16_t nmask = 0xF000 >> (4*n);
-                                        if (l_dram_width == 4)
-                                        {
-                                                if ((nmask & l_data) == nmask)          // bad bit(s) in nibble
-                                                {
-                                                         //     For Marc Gollub, since repair for x4 DRAM is in nibble
-                                                         //     granularity.  Also due to higher chance of hitting dq0 of
-                                                         //     Micron causing write leveling to fail for entire x4 DRAM.
-                                                         //     Will also save a re-training loop.  Complement in get_bbm_regs.
-
-
-                                                        FAPI_INF("Disabling entire nibble %i",n);
-                                                        rc = mss_get_dqs_lane(mba_target, port, i, n,
-                                                                        disable1_data);
-                                                        if (rc) return rc;
-                                                        wrclk_mask |= wrclk_disable_mask[n];
-                                                }
-                                        }  // end x4
-                                        else    // width == 8+?
-                                        {
-                                                if ((n % 2) == 0)
-                                                {
-                                                        nmask = 0xFF00 >> (4*n);
-                                                        if ((nmask & l_data) == nmask)  // entire byte bad
-                                                        {
-                                                                disable1_data |= (0xF0 >> (n*2));
-                                                        }
-                                                }
-                                                if (((nmask & l_data)>>(4*(3-n))) == 0x0F)
-                                                {
-                                                        wrclk_mask |= wrclk_disable_mask[n];
-                                                }
-                                        }
-                                }
-
-                                }
-
-
-                                FAPI_DBG("\t\tdisable1_data=0x%04X", disable1_data);
-
-                                // set disable0(dq) reg
-                                l_ecmdRc |= data_buffer.setHalfWord(3, l_data);
-
-                                if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-                                {
-                                         FAPI_ERR("Error from ecmdDataBuffer setHalfWord() "
-                                                         "- rc 0x%.8X", l_ecmdRc);
-
-                                         rc.setEcmdError(l_ecmdRc);
-                                         return rc;
-                                }
-
-                                l_addr = disable_reg[port][prank][i];
-
-                                FAPI_INF("+++ Setting Disable0 Bad Bit Mask p%i: DIMM%i PRG%i "
-                                        "Rank%i dp18_%i addr=0x%llx, data=0x%04X", port,
-                                        dimm, prank, prg[prank][port], i, l_addr , l_data);
-
-                                rc = fapiPutScomUnderMask(mba_target, l_addr, data_buffer,
-                                                data_buffer);
-
-                                if (rc)
-                                {
-                                        FAPI_ERR("Error from fapiPutScom writing disable0 reg");
-                                        return rc;
-                                }
-
-                                if (all_F_mask ==1) {
-                                        FAPI_INF("Entering into all F across ranks case. Need to Disable DQS as well.");
-                                        // set address for disable1(dqs) register
-                                        l_addr += l_disable1_addr_offset;
-                                        if (disable1_data != 0)
-                                        {
-                                                l_ecmdRc = data_buffer.flushTo0();  // clear buffer
-                                                if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-                                                {
-                                                FAPI_ERR("Error from ecmdDataBuffer flushTo0() "
-                                                                "- rc 0x%.8X", l_ecmdRc);
-
-                                                rc.setEcmdError(l_ecmdRc);
-                                                return rc;
-                                                }
-
-                                                l_ecmdRc = data_buffer.setByte(6, disable1_data);
-                                                if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-                                                {
-                                                FAPI_ERR("Error from ecmdDataBuffer setByte() "
-                                                                "- rc 0x%.8X", l_ecmdRc);
-
-                                                rc.setEcmdError(l_ecmdRc);
-                                                return rc;
-                                                }
-
-                                                // write disable1(dqs) register
-                                                rc = fapiPutScomUnderMask(mba_target, l_addr,
-                                                data_buffer, data_buffer);
-                                                if (rc)
-                                                {
-                                                FAPI_ERR("Error from PutScom writing disable1 reg");
-                                                return rc;
-                                                }
-                                        } // end disable1_data != 0
-
-
-                                        // set address for wrclk_en register
-                                        l_addr &= l_wrclk_en_addr_mask;
-
-                                        if (wrclk_mask != 0)
-                                        {
-                                                l_ecmdRc = data_buffer.flushTo0();      // clear buffer
-                                                if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-                                                {
-                                                         FAPI_ERR("Error from ecmdDataBuffer flushTo0() "
-                                                                         "- rc 0x%.8X", l_ecmdRc);
-
-                                                         rc.setEcmdError(l_ecmdRc);
-                                                         return rc;
-                                                }
-                                                ecmdDataBufferBase put_mask(64);
-                                                l_ecmdRc = put_mask.setHalfWord(3, wrclk_mask);
-                                                if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-                                                {
-                                                         FAPI_ERR("Error from ecmdDataBuffer setHalfWord()"
-                                                                         " for wrclk_mask - rc 0x%.8X", l_ecmdRc);
-
-                                                         rc.setEcmdError(l_ecmdRc);
-                                                         return rc;
-                                                }
-
-                                                if (!l_disable1_fixed)
-                                                {
-                                                        // clear(0) out the unused quads for wrclkdb_reg
-                                                        rc = fapiPutScomUnderMask(mba_target, l_addr,
-                                                                        data_buffer, put_mask);
-                                                        if (rc)
-                                                        {
-                                                                FAPI_ERR("Error from fapiPutScomUnderMask writing "
-                                                                                "wrclk_en reg");
-                                                                return rc;
-                                                        }
-                                                }
-                                                // does disabling read clocks for unused bytes cause problems?
-                                                // SW25701 Workaround - x4s will not mask out RDCLKs on Bad Bits to avoid translation issues
-                                                else if ( (!l_disable1_rdclk_fixed) && (l_dram_width != 4) )
-                                                {
-                                                        uint64_t rdclk_addr =
-                                                                disable_reg[port][prank][i] & 0xFFFFFF040FFFFFFFull;
-                                                        // clear(0) out the unused quads for rdclk
-                                                        rc = fapiPutScomUnderMask(mba_target, rdclk_addr,
-                                                                data_buffer, put_mask);
-                                                        if (rc)
-                                                        {
-                                                                FAPI_ERR("Error from fapiPutScomUnderMask writing "
-                                                                                        "rdclk_en reg");
-                                                                return rc;
-                                                        }
-
-                                                        FAPI_DBG("rdclk_addr=0x%llx, wrclk_addr=0x%llx, "
-                                                                "wrclk_mask=0x%04X", rdclk_addr, l_addr, wrclk_mask);
-                                                }
-                                        } // end wrclk_mask != 0
-                                }
-
-
-                        } // end DP18 instance loop
-                } // end primary rank loop
-        } // end port loop
+			FAPI_ERR("ATTR_EFF_DRAM_WIDTH is invalid %u", l_dram_width);
+			FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_DRAM_WIDTH_INPUT_ERROR_SETBBM);
+			return rc;
+	}
+
+	l_ecmdRc = data_buffer.flushTo0();
+	if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+	{
+		 FAPI_ERR("Error from ecmdDataBuffer flushTo0() "
+				 "- rc 0x%.8X", l_ecmdRc);
+		 rc.setEcmdError(l_ecmdRc);
+		 return rc;
+	}
+	for (uint8_t port = 0; port < MAX_PORTS; port++ )	// [0:1]
+	{
+		db_reg_rank0.flushTo0();
+		db_reg_rank1.flushTo0();
+		db_reg_rank2.flushTo0();
+		db_reg_rank3.flushTo0();
+		db_reg_rank4.flushTo0();
+		db_reg_rank5.flushTo0();
+		db_reg_rank6.flushTo0();
+		db_reg_rank7.flushTo0();
+		uint8_t is_clean = 1;
+
+		uint8_t l_rank0_invalid = 1; //0 = valid, 1 = invalid
+		uint8_t l_rank1_invalid = 1; 
+		uint8_t l_rank2_invalid = 1; 
+		uint8_t l_rank3_invalid = 1; 
+		uint8_t l_rank4_invalid = 1; 
+		uint8_t l_rank5_invalid = 1; 
+		uint8_t l_rank6_invalid = 1; 
+		uint8_t l_rank7_invalid = 1;
+
+		// Gather all ranks first
+		// loop through primary ranks [0:3]
+		for (uint8_t prank = 0; prank < MAX_PRI_RANKS; prank++ )
+		{
+
+		        is_clean = 1;
+			if (prg[prank][port] == rg_invalid[prank])	// invalid rank
+			{
+				FAPI_DBG("BYTE DISABLE WORKAROUND  Primary rank group (prank) %i port %d rank value: %d INVALID, Marking and continuing...",
+						prank, port, prg[prank][port]);
+
+				continue;
+			}
+			
+			if ( prg[prank][port] == 0)
+			{
+				FAPI_DBG("BYTE DISABLE WORKAROUND  Primary rank group (prank) %i port %d rank value: %d Not INVALID, Marking and continuing...",
+						prank, port, prg[prank][port]);
+				rc = getC4dq2reg(mba_target, port, 0, 0, db_reg_rank0, is_clean);
+				if (rc)
+				{
+					FAPI_ERR("Error from getting register bitmap port=%i: "
+							"dimm=%i, rank=%i rc=%i", port, 0, 0,
+							static_cast<uint32_t>(rc));
+					return rc;
+				}
+				l_rank0_invalid = 0;
+			}
+			
+			if ( prg[prank][port] == 1)
+			{
+				FAPI_DBG("BYTE DISABLE WORKAROUND  Primary rank group (prank) %i port %d rank value: %d Not INVALID, Marking and continuing...",
+						prank, port, prg[prank][port]);
+				rc = getC4dq2reg(mba_target, port, 0, 1, db_reg_rank1, is_clean);
+				if (rc)
+				{
+					FAPI_ERR("Error from getting register bitmap port=%i: "
+							"dimm=%i, rank=%i rc=%i", port, 0, 1,
+							static_cast<uint32_t>(rc));
+					return rc;
+				}
+				l_rank1_invalid = 0;
+			}
+			
+			if ( prg[prank][port] == 2)
+			{
+				FAPI_DBG("BYTE DISABLE WORKAROUND  Primary rank group (prank) %i port %d rank value: %d Not INVALID, Marking and continuing...",
+						prank, port, prg[prank][port]);
+				rc = getC4dq2reg(mba_target, port, 0, 2, db_reg_rank2, is_clean);
+				if (rc)
+				{
+					FAPI_ERR("Error from getting register bitmap port=%i: "
+							"dimm=%i, rank=%i rc=%i", port, 0, 2,
+							static_cast<uint32_t>(rc));
+					return rc;
+				}
+				l_rank2_invalid = 0;
+			}
+			
+			
+			if ( prg[prank][port] == 3)
+			{
+				FAPI_DBG("BYTE DISABLE WORKAROUND  Primary rank group (prank) %i port %d rank value: %d Not INVALID, Marking and continuing...",
+						prank, port, prg[prank][port]);
+				rc = getC4dq2reg(mba_target, port, 0, 3, db_reg_rank3, is_clean);
+				if (rc)
+				{
+					FAPI_ERR("Error from getting register bitmap port=%i: "
+							"dimm=%i, rank=%i rc=%i", port, 0, 3,
+							static_cast<uint32_t>(rc));
+					return rc;
+				}
+				l_rank3_invalid = 0;
+			}
+			
+
+			
+			if ( prg[prank][port] == 4)
+			{
+				FAPI_DBG("BYTE DISABLE WORKAROUND  Primary rank group (prank) %i port %d rank value: %d Not INVALID, Marking and continuing...",
+						prank, port, prg[prank][port]);
+				rc = getC4dq2reg(mba_target, port, 1, 0, db_reg_rank4, is_clean);
+				if (rc)
+				{
+					FAPI_ERR("Error from getting register bitmap port=%i: "
+							"dimm=%i, rank=%i rc=%i", port, 1, 0,
+							static_cast<uint32_t>(rc));
+					return rc;
+				}
+				l_rank4_invalid = 0;
+			}
+			
+			
+			if ( prg[prank][port] == 5)
+			{
+				FAPI_DBG("BYTE DISABLE WORKAROUND  Primary rank group (prank) %i port %d rank value: %d Not INVALID, Marking and continuing...",
+						prank, port, prg[prank][port]);
+				rc = getC4dq2reg(mba_target, port, 1, 1, db_reg_rank5, is_clean);
+				if (rc)
+				{
+					FAPI_ERR("Error from getting register bitmap port=%i: "
+							"dimm=%i, rank=%i rc=%i", port, 1, 1,
+							static_cast<uint32_t>(rc));
+					return rc;
+				}
+				l_rank5_invalid = 0;
+			}
+			
+			
+			if ( prg[prank][port] == 6)
+			{
+				FAPI_DBG("BYTE DISABLE WORKAROUND  Primary rank group (prank) %i port %d rank value: %d Not INVALID, Marking and continuing...",
+						prank, port, prg[prank][port]);
+				rc = getC4dq2reg(mba_target, port, 1, 2, db_reg_rank6, is_clean);
+				if (rc)
+				{
+					FAPI_ERR("Error from getting register bitmap port=%i: "
+							"dimm=%i, rank=%i rc=%i", port, 1, 2,
+							static_cast<uint32_t>(rc));
+					return rc;
+				}
+				l_rank6_invalid = 0;
+			}
+			
+			
+			if ( prg[prank][port] == 7)
+			{
+				FAPI_DBG("BYTE DISABLE WORKAROUND  Primary rank group (prank) %i port %d rank value: %d Not INVALID, Marking and continuing...",
+						prank, port, prg[prank][port]);
+				rc = getC4dq2reg(mba_target, port, 1, 3, db_reg_rank7, is_clean);
+				if (rc)
+				{
+					FAPI_ERR("Error from getting register bitmap port=%i: "
+							"dimm=%i, rank=%i rc=%i", port, 1, 3,
+							static_cast<uint32_t>(rc));
+					return rc;
+				}
+				l_rank7_invalid = 0;
+			}
+			
+		}
+
+		// loop through primary ranks [0:3]
+		for (uint8_t prank = 0; prank < MAX_PRI_RANKS; prank++ )
+		{
+			uint8_t dimm = prg[prank][port] >> 2;
+			uint8_t rank = prg[prank][port] & 0x03;
+			uint16_t l_data = 0;
+			uint16_t l_data_rank0 = 0; 
+			uint16_t l_data_rank1 = 0; 
+			uint16_t l_data_rank2 = 0; 
+			uint16_t l_data_rank3 = 0; 
+			uint16_t l_data_rank4 = 0; 
+			uint16_t l_data_rank5 = 0; 
+			uint16_t l_data_rank6 = 0; 
+			uint16_t l_data_rank7 = 0; 
+			is_clean = 1;
+
+			if (prg[prank][port] == rg_invalid[prank])	// invalid rank
+			{
+				FAPI_DBG("Primary rank group %i: INVALID, continuing...",
+						prank);
+				continue;
+			}
+
+			rc = getC4dq2reg(mba_target, port, dimm, rank, db_reg, is_clean);
+			if (rc)
+			{
+				FAPI_ERR("Error from getting register bitmap port=%i: "
+						"dimm=%i, rank=%i rc=%i", port, dimm, rank,
+						static_cast<uint32_t>(rc));
+				return rc;
+			}
+
+
+
+			// quick test to move on to next rank if no bits need to be set
+			if (is_clean == 1)			// Note ignores spares that match attribute
+			{
+				FAPI_INF("Primary rank group %i: No bad bits found for "
+						"p%i:d%i:r%i:cs%i", prank, port, dimm, rank,
+						prg[prank][port]);
+				continue;
+			}
+			for ( uint8_t i=0; i < DP18_INSTANCES; i++ ) // dp18 [0:4]
+			{
+				uint8_t disable1_data = 0;
+				uint16_t wrclk_mask = 0;
+
+				// check or not to check(always set register)?
+				l_data = db_reg.getHalfWord(i);
+				l_data_rank0 = db_reg_rank0.getHalfWord(i);
+				l_data_rank1 = db_reg_rank1.getHalfWord(i);
+				l_data_rank2 = db_reg_rank2.getHalfWord(i);
+				l_data_rank3 = db_reg_rank3.getHalfWord(i);
+				l_data_rank4 = db_reg_rank4.getHalfWord(i);
+				l_data_rank5 = db_reg_rank5.getHalfWord(i);
+				l_data_rank6 = db_reg_rank6.getHalfWord(i);
+				l_data_rank7 = db_reg_rank7.getHalfWord(i);
+
+				if (l_data == 0)
+				{
+					FAPI_DBG("\tDP18_%i has no bad bits set, continuing...", i);
+					continue;
+				}
+				// clear bits 48:63
+				l_ecmdRc = data_buffer.flushTo0();
+				if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+				{
+					 FAPI_ERR("Error from ecmdDataBuffer flushTo0() "
+							 "- rc 0x%.8X", l_ecmdRc);
+
+					 rc.setEcmdError(l_ecmdRc);
+					 return rc;
+				}
+
+				uint16_t mask = 0xF000;
+				// Temp 0xE removed.
+				//uint16_t emask = 0xE000;
+				uint8_t all_F_mask = 0;
+				for (uint8_t n=0; n < 4; n++) {	// check each nibble
+					uint16_t nmask = mask >> (4*n);
+					// Temp 0xE removed.
+					//uint16_t e_nmask = emask >> (4*n);
+
+
+					if ((nmask & l_data) == nmask) {
+						FAPI_DBG("BYTE DISABLE WORKAROUND  Found a 0XF on nibble=%i Port%i, dimm=%i, prg%i rank=%i data=0x%04X", n, port, dimm, prank, rank, l_data);
+						if ( ( ((nmask & l_data_rank0) == nmask) || (l_rank0_invalid) ) && 
+						     ( ((nmask & l_data_rank1) == nmask) || (l_rank1_invalid) ) && 
+						     ( ((nmask & l_data_rank2) == nmask) || (l_rank2_invalid) ) && 
+						     ( ((nmask & l_data_rank3) == nmask) || (l_rank3_invalid) ) &&
+						     ( ((nmask & l_data_rank4) == nmask) || (l_rank4_invalid) ) && 
+						     ( ((nmask & l_data_rank5) == nmask) || (l_rank5_invalid) ) && 
+						     ( ((nmask & l_data_rank6) == nmask) || (l_rank6_invalid) ) && 
+						     ( ((nmask & l_data_rank7) == nmask) || (l_rank7_invalid) )   )
+						{
+							//Leave it an F.
+							FAPI_DBG("BYTE DISABLE WORKAROUND  All ranks are a F so writing an 0xF to disable regs.");
+							FAPI_DBG("BYTE DISABLE WORKAROUND  data rank 0 =0x%04X rank 1 =0x%04X rank 2 =0x%04X rank 3 =0x%04X rank 4 =0x%04X rank 5 =0x%04X rank 6 =0x%04X rank 7 =0x%04X", l_data_rank0,l_data_rank1,l_data_rank2,l_data_rank3,l_data_rank4,l_data_rank5,l_data_rank6,l_data_rank7 );
+							all_F_mask = 1;
+						}
+						else
+						{
+							//Replacing F nibble with E nibble
+							FAPI_DBG("BYTE DISABLE WORKAROUND  Single rank is a 0xF so writing an 0x0 to disable regs. PRE DATA: 0x%04X", l_data);
+							l_data = l_data & ~(nmask); 
+						        FAPI_DBG("BYTE DISABLE WORKAROUND  POST DATA: 0x%04X", l_data);
+						}
+					}
+
+					// Temporarily removing the 0xE case
+					/*
+					if ((nmask & l_data) == e_nmask) {
+						FAPI_DBG("BYTE DISABLE WORKAROUND  Found a 0XE on nibble=%i Port%i, dimm=%i, prg%i rank=%i data=0x%04X", n, port, dimm, prank, rank, l_data);
+
+						//Leave it an E.
+						FAPI_DBG("BYTE DISABLE WORKAROUND  Found a 0xE so writing an 0xE to disable regs.");
+
+					}
+					*/
+
+	                                uint16_t wrclk_nmask = 0xF000 >> (4*n);
+					if (l_dram_width != 4) // x8 only disable the wrclk
+					{
+
+						if (((wrclk_nmask & l_data)>>(4*(3-n))) == 0x0F)
+						{
+							wrclk_mask |= wrclk_disable_mask[n];
+						}
+					}
+
+				}
+				
+				
+				if (all_F_mask ==1) {
+				FAPI_INF("Entering into all F across all ranks case. Need to Disable WRCLK Enable as well.");
+				for (uint8_t n=0; n < 4; n++)	// check each nibble
+				{
+					uint16_t nmask = 0xF000 >> (4*n);
+					if (l_dram_width == 4)
+					{
+						if ((nmask & l_data) == nmask)		// bad bit(s) in nibble
+						{
+							 //	For Marc Gollub, since repair for x4 DRAM is in nibble
+							 //	granularity.  Also due to higher chance of hitting dq0 of
+							 //	Micron causing write leveling to fail for entire x4 DRAM.
+							 //	Will also save a re-training loop.  Complement in get_bbm_regs.
+
+							
+							FAPI_INF("Disabling entire nibble %i",n);
+							rc = mss_get_dqs_lane(mba_target, port, i, n,
+									disable1_data);
+							if (rc) return rc;
+							wrclk_mask |= wrclk_disable_mask[n];
+						}
+					}  // end x4
+					else	// width == 8+?
+					{
+						if ((n % 2) == 0)
+						{
+							nmask = 0xFF00 >> (4*n);
+							if ((nmask & l_data) == nmask)	// entire byte bad
+							{
+								disable1_data |= (0xF0 >> (n*2));
+							}
+						}
+						if (((nmask & l_data)>>(4*(3-n))) == 0x0F)
+						{
+							wrclk_mask |= wrclk_disable_mask[n];
+						}
+					}
+				}
+					
+				}
+				
+
+				FAPI_DBG("\t\tdisable1_data=0x%04X", disable1_data);
+			
+				// set disable0(dq) reg
+				l_ecmdRc |= data_buffer.setHalfWord(3, l_data);
+
+				if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+				{
+					 FAPI_ERR("Error from ecmdDataBuffer setHalfWord() "
+							 "- rc 0x%.8X", l_ecmdRc);
+
+					 rc.setEcmdError(l_ecmdRc);
+					 return rc;
+				}
+
+				l_addr = disable_reg[port][prank][i];
+
+				FAPI_INF("+++ Setting Disable0 Bad Bit Mask p%i: DIMM%i PRG%i "
+					"Rank%i dp18_%i addr=0x%llx, data=0x%04X", port,
+					dimm, prank, prg[prank][port], i, l_addr , l_data);
+
+				rc = fapiPutScomUnderMask(mba_target, l_addr, data_buffer,
+						data_buffer);
+
+				if (rc)
+				{
+					FAPI_ERR("Error from fapiPutScom writing disable0 reg");
+					return rc;
+				}
+
+			        if (all_F_mask ==1) {
+					FAPI_INF("Entering into all F across ranks case. Need to Disable DQS as well.");
+					// set address for disable1(dqs) register
+					l_addr += l_disable1_addr_offset;
+					if (disable1_data != 0)
+					{
+						l_ecmdRc = data_buffer.flushTo0();  // clear buffer
+						if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+						{
+						FAPI_ERR("Error from ecmdDataBuffer flushTo0() "
+								"- rc 0x%.8X", l_ecmdRc);
+
+						rc.setEcmdError(l_ecmdRc);
+						return rc;
+						}
+
+						l_ecmdRc = data_buffer.setByte(6, disable1_data);
+						if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+						{
+						FAPI_ERR("Error from ecmdDataBuffer setByte() "
+								"- rc 0x%.8X", l_ecmdRc);
+
+						rc.setEcmdError(l_ecmdRc);
+						return rc;
+						}
+
+						// write disable1(dqs) register
+						rc = fapiPutScomUnderMask(mba_target, l_addr,
+						data_buffer, data_buffer);
+						if (rc)
+						{
+						FAPI_ERR("Error from PutScom writing disable1 reg");
+						return rc;
+						}
+					} // end disable1_data != 0
+
+
+					// set address for wrclk_en register
+					l_addr &= l_wrclk_en_addr_mask;
+
+					if (wrclk_mask != 0)
+					{
+						l_ecmdRc = data_buffer.flushTo0();	// clear buffer
+						if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+						{
+							 FAPI_ERR("Error from ecmdDataBuffer flushTo0() "
+									 "- rc 0x%.8X", l_ecmdRc);
+
+							 rc.setEcmdError(l_ecmdRc);
+							 return rc;
+						}
+						ecmdDataBufferBase put_mask(64);
+						l_ecmdRc = put_mask.setHalfWord(3, wrclk_mask);
+						if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+						{
+							 FAPI_ERR("Error from ecmdDataBuffer setHalfWord()"
+									 " for wrclk_mask - rc 0x%.8X", l_ecmdRc);
+
+							 rc.setEcmdError(l_ecmdRc);
+							 return rc;
+						}
+
+						if (!l_disable1_fixed)
+						{
+							// clear(0) out the unused quads for wrclkdb_reg
+							rc = fapiPutScomUnderMask(mba_target, l_addr,
+									data_buffer, put_mask);
+							if (rc)
+							{
+								FAPI_ERR("Error from fapiPutScomUnderMask writing "
+										"wrclk_en reg");
+								return rc;
+							}
+						}
+				                // does disabling read clocks for unused bytes cause problems?
+						// SW25701 Workaround - x4s will not mask out RDCLKs on Bad Bits to avoid translation issues
+						else if ( (!l_disable1_rdclk_fixed) && (l_dram_width != 4) )
+						{
+							uint64_t rdclk_addr =
+								disable_reg[port][prank][i] & 0xFFFFFF040FFFFFFFull;
+							// clear(0) out the unused quads for rdclk
+							rc = fapiPutScomUnderMask(mba_target, rdclk_addr,
+								data_buffer, put_mask);
+							if (rc)
+							{
+								FAPI_ERR("Error from fapiPutScomUnderMask writing "
+											"rdclk_en reg");
+								return rc;
+							}
+
+							FAPI_DBG("rdclk_addr=0x%llx, wrclk_addr=0x%llx, "
+								"wrclk_mask=0x%04X", rdclk_addr, l_addr, wrclk_mask);
+						}
+					} // end wrclk_mask != 0
+				}
+				
+
+			} // end DP18 instance loop
+		} // end primary rank loop
+	} // end port loop
     return rc;
 } // end mss_set_bbm_regs
 
 
 fapi::ReturnCode mss_get_dqs_lane (const fapi::Target & i_mba,
-                const uint8_t i_port, const uint8_t i_block, const uint8_t i_quad,
-                uint8_t &o_lane)
+		const uint8_t i_port, const uint8_t i_block, const uint8_t i_quad,
+	   	uint8_t &o_lane)
 {
 // input  = mba, port, dp18 block, quad
 // output = OR'd in lane of the dqs for the specified input
 
-        ReturnCode rc;
-        uint8_t dq, dqs;
-        uint8_t phy_lane = i_quad * 4;
-        uint8_t l_block = i_block;
-        // returns dq
-        rc=mss_c4_phy(i_mba,i_port,0,RD_DQ,dq,1,phy_lane,l_block,1);
-        if (rc) return rc;
-        FAPI_INF("DQ returning mss_c4_phy inputs port: %d input index: %d phy_lane: %d block: %d",i_port,dq,phy_lane,l_block);
-
-        dqs = dq / 4;
-        // returns phy_lane
-        rc=mss_c4_phy(i_mba,i_port,0,WR_DQS,dqs,1,phy_lane,l_block,0);
-        if (rc) return rc;
-        FAPI_INF("phy_lane returning mss_c4_phy inputs port: %d input index: %d phy_lane: %d block: %d",i_port,dqs,phy_lane,l_block);
-
-        if (l_block != i_block)
-        {
-                FAPI_ERR("\t !!!  blocks don't match from c4 to phy i_block=%i,"
-                           " o_block=%i", i_block, l_block);
-        }
-
-        switch (phy_lane)
-        {
-                case 16:
-                case 17:
-                        o_lane |= 0xC0;
-                        break;
-                case 18:
-                case 19:
-                        o_lane |= 0x30;
-                        break;
-                case 20:
-                case 21:
-                        o_lane |= 0x0C;
-                        break;
-                case 22:
-                case 23:
-                        o_lane |= 0x03;
-                        break;
-                default:
-                        //DECONFIG and FFDC INFO
-                        const fapi::Target & TARGET_MBA_ERROR = i_mba;
-                        const uint8_t & PORT = i_port;
-                        const uint8_t & BLOCK = i_block;
-                        const uint8_t & QUAD = i_quad;
-                        const uint8_t & PHYLANE = phy_lane;
-
-                        FAPI_ERR("\t!!!  (Port%i, dp18_%i, q=%i)  phy_lane(%i)"
-                                "returned from mss_c4_phy is invalid",
-                                i_port, i_block, i_quad, phy_lane);
-                        FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_C4_PHY_TRANSLATION_ERROR);
-        }
-        return rc;
+	ReturnCode rc;
+	uint8_t dq, dqs;
+	uint8_t phy_lane = i_quad * 4;
+	uint8_t l_block = i_block;
+	// returns dq
+	rc=mss_c4_phy(i_mba,i_port,0,RD_DQ,dq,1,phy_lane,l_block,1);
+	if (rc) return rc;
+	FAPI_INF("DQ returning mss_c4_phy inputs port: %d input index: %d phy_lane: %d block: %d",i_port,dq,phy_lane,l_block);
+
+	dqs = dq / 4;
+	// returns phy_lane
+	rc=mss_c4_phy(i_mba,i_port,0,WR_DQS,dqs,1,phy_lane,l_block,0);
+	if (rc) return rc;
+	FAPI_INF("phy_lane returning mss_c4_phy inputs port: %d input index: %d phy_lane: %d block: %d",i_port,dqs,phy_lane,l_block);
+
+	if (l_block != i_block)
+	{
+		FAPI_ERR("\t !!!  blocks don't match from c4 to phy i_block=%i,"
+			   " o_block=%i", i_block, l_block);
+	}
+
+	switch (phy_lane)
+	{
+		case 16:
+		case 17:
+			o_lane |= 0xC0;
+			break;
+		case 18:
+		case 19:
+			o_lane |= 0x30;
+			break;
+		case 20:
+		case 21:
+			o_lane |= 0x0C;
+			break;
+		case 22:
+		case 23:
+			o_lane |= 0x03;
+			break;
+		default:
+			//DECONFIG and FFDC INFO
+			const fapi::Target & TARGET_MBA_ERROR = i_mba;
+			const uint8_t & PORT = i_port;
+			const uint8_t & BLOCK = i_block;
+			const uint8_t & QUAD = i_quad;
+			const uint8_t & PHYLANE = phy_lane;
+
+			FAPI_ERR("\t!!!  (Port%i, dp18_%i, q=%i)  phy_lane(%i)"
+				"returned from mss_c4_phy is invalid",
+				i_port, i_block, i_quad, phy_lane);
+			FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_C4_PHY_TRANSLATION_ERROR);
+	}
+	return rc;
 } //end mss_get_dqs_lane
 
 fapi::ReturnCode mss_get_bbm_regs (const fapi::Target & mba_target, uint8_t i_training_success)
 {
 // Registers to Flash.
 
-        const uint64_t disable_reg[MAX_PORTS][MAX_PRI_RANKS][DP18_INSTANCES] = {
-        /* port 0 */
-        {       // primary rank pair 0
-           {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_0_0x8000007c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_1_0x8000047c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_2_0x8000087c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_3_0x80000c7c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_4_0x8000107c0301143F},
-                // primary rank pair 1
-           {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_0_0x8000017c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_1_0x8000057c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_2_0x8000097c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_3_0x80000d7c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_4_0x8000117c0301143F},
-                // primary rank pair 2
-           {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_0_0x8000027c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_1_0x8000067c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_2_0x80000a7c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_3_0x80000e7c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_4_0x8000127c0301143F},
-                // primary rank pair 3
-           {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_0_0x8000037c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_1_0x8000077c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_2_0x80000b7c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_3_0x80000f7c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_4_0x8000137c0301143F}
-        },
-        /* port 1 */
-        {
-           // primary rank pair 0
-           {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_0_0x8001007c0301143F,
-                DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_1_0x8001047c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_2_0x8001087c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_3_0x80010c7c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_4_0x8001107c0301143F},
+	const uint64_t disable_reg[MAX_PORTS][MAX_PRI_RANKS][DP18_INSTANCES] = {
+	/* port 0 */
+	{	// primary rank pair 0
+	   {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_0_0x8000007c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_1_0x8000047c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_2_0x8000087c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_3_0x80000c7c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P0_4_0x8000107c0301143F},
+		// primary rank pair 1
+	   {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_0_0x8000017c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_1_0x8000057c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_2_0x8000097c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_3_0x80000d7c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P0_4_0x8000117c0301143F},
+		// primary rank pair 2
+	   {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_0_0x8000027c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_1_0x8000067c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_2_0x80000a7c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_3_0x80000e7c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P0_4_0x8000127c0301143F},
+		// primary rank pair 3
+	   {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_0_0x8000037c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_1_0x8000077c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_2_0x80000b7c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_3_0x80000f7c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P0_4_0x8000137c0301143F}
+	},
+	/* port 1 */
+	{
+	   // primary rank pair 0
+	   {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_0_0x8001007c0301143F,
+		DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_1_0x8001047c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_2_0x8001087c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_3_0x80010c7c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP0_P1_4_0x8001107c0301143F},
            // primary rank pair 1
-           {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_0_0x8001017c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_1_0x8001057c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_2_0x8001097c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_3_0x80010d7c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_4_0x8001117c0301143F},
+	   {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_0_0x8001017c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_1_0x8001057c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_2_0x8001097c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_3_0x80010d7c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP1_P1_4_0x8001117c0301143F},
            // primary rank pair 2
-           {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_0_0x8001027c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_1_0x8001067c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_2_0x80010a7c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_3_0x80010e7c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_4_0x8001127c0301143F},
+	   {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_0_0x8001027c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_1_0x8001067c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_2_0x80010a7c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_3_0x80010e7c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP2_P1_4_0x8001127c0301143F},
            // primary rank pair 3
-           {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_0_0x8001037c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_1_0x8001077c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_2_0x80010b7c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_3_0x80010f7c0301143F,
-            DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_4_0x8001137c0301143F}
+	   {DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_0_0x8001037c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_1_0x8001077c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_2_0x80010b7c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_3_0x80010f7c0301143F,
+	    DPHY01_DDRPHY_DP18_DATA_BIT_DISABLE0_RP3_P1_4_0x8001137c0301143F}
 
-        }};
+	}};
 
-        const uint8_t rg_invalid[] = {
-                ENUM_ATTR_EFF_PRIMARY_RANK_GROUP0_INVALID,
-                ENUM_ATTR_EFF_PRIMARY_RANK_GROUP1_INVALID,
-                ENUM_ATTR_EFF_PRIMARY_RANK_GROUP2_INVALID,
-                ENUM_ATTR_EFF_PRIMARY_RANK_GROUP3_INVALID,
-        };
+	const uint8_t rg_invalid[] = {
+		ENUM_ATTR_EFF_PRIMARY_RANK_GROUP0_INVALID,
+		ENUM_ATTR_EFF_PRIMARY_RANK_GROUP1_INVALID,
+		ENUM_ATTR_EFF_PRIMARY_RANK_GROUP2_INVALID,
+		ENUM_ATTR_EFF_PRIMARY_RANK_GROUP3_INVALID,
+	};
 
         ReturnCode rc;
         ecmdDataBufferBase data_buffer(64);
         ecmdDataBufferBase db_reg(BITS_PER_PORT);
         ecmdDataBufferBase db_reg_vpd(BITS_PER_PORT);
-        uint32_t l_ecmdRc = ECMD_DBUF_SUCCESS;
-        uint8_t prg[MAX_PRI_RANKS][MAX_PORTS];          // primary rank group values
-        uint8_t l_dram_width;
-        uint8_t dimm;
-        uint8_t l_rank0_invalid = 1; //0 = valid, 1 = invalid
-        uint8_t l_rank1_invalid = 1;
-        uint8_t l_rank2_invalid = 1;
-        uint8_t l_rank3_invalid = 1;
-        uint8_t l_rank4_invalid = 1;
-        uint8_t l_rank5_invalid = 1;
-        uint8_t l_rank6_invalid = 1;
-        uint8_t l_rank7_invalid = 1;
-
-        //Storing all the errors across rank/eff dimm
+	uint32_t l_ecmdRc = ECMD_DBUF_SUCCESS;
+	uint8_t prg[MAX_PRI_RANKS][MAX_PORTS];		// primary rank group values
+	uint8_t l_dram_width;
+	uint8_t dimm;
+	uint8_t l_rank0_invalid = 1; //0 = valid, 1 = invalid
+	uint8_t l_rank1_invalid = 1; 
+	uint8_t l_rank2_invalid = 1; 
+	uint8_t l_rank3_invalid = 1; 
+	uint8_t l_rank4_invalid = 1; 
+	uint8_t l_rank5_invalid = 1; 
+	uint8_t l_rank6_invalid = 1; 
+	uint8_t l_rank7_invalid = 1;
+
+	//Storing all the errors across rank/eff dimm
         ecmdDataBufferBase db_reg_dimm0_rank0(BITS_PER_PORT);
         ecmdDataBufferBase db_reg_dimm0_rank1(BITS_PER_PORT);
         ecmdDataBufferBase db_reg_dimm0_rank2(BITS_PER_PORT);
@@ -6515,843 +6657,843 @@ fapi::ReturnCode mss_get_bbm_regs (const fapi::Target & mba_target, uint8_t i_tr
         ecmdDataBufferBase db_reg_dimm1_rank3(BITS_PER_PORT);
 
 
-        FAPI_INF("Running (get)registers->flash");
-
-        std::vector<Target> mba_dimms;
-        rc = fapiGetAssociatedDimms(mba_target, mba_dimms);     // functional dimms
-        if(rc) return rc;
-
-        // 4 dimms per MBA, 2 per port
-        // ATTR_EFF_PRIMARY_RANK_GROUP0[port], GROUP1[port],
-        //                                               GROUP2[port], GROUP3[port]
-        rc=FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP0, &mba_target, prg[0]);
-        if(rc) return rc;
-        rc=FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP1, &mba_target, prg[1]);
-        if(rc) return rc;
-        rc=FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP2, &mba_target, prg[2]);
-        if(rc) return rc;
-        rc=FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP3, &mba_target, prg[3]);
-        if(rc) return rc;
-
-        rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_WIDTH, &mba_target, l_dram_width);
-        if(rc) return rc;
-
-        switch (l_dram_width)
-        {
-                case ENUM_ATTR_EFF_DRAM_WIDTH_X4:
-                        l_dram_width = 4;
-                        break;
-                case ENUM_ATTR_EFF_DRAM_WIDTH_X8:
-                        l_dram_width = 8;
-                        break;
-                case ENUM_ATTR_EFF_DRAM_WIDTH_X16:
-                        l_dram_width = 16;
-                        break;
-                case ENUM_ATTR_EFF_DRAM_WIDTH_X32:
-                        l_dram_width = 32;
-                        break;
-                default:
-                        //DECONFIG and FFDC INFO
-                        const fapi::Target & TARGET_MBA_ERROR = mba_target;
+	FAPI_INF("Running (get)registers->flash");
+
+	std::vector<Target> mba_dimms;
+	rc = fapiGetAssociatedDimms(mba_target, mba_dimms);	// functional dimms
+	if(rc) return rc;
+
+	// 4 dimms per MBA, 2 per port
+	// ATTR_EFF_PRIMARY_RANK_GROUP0[port], GROUP1[port],
+	// 						 GROUP2[port], GROUP3[port]
+	rc=FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP0, &mba_target, prg[0]);
+	if(rc) return rc;
+	rc=FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP1, &mba_target, prg[1]);
+	if(rc) return rc;
+	rc=FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP2, &mba_target, prg[2]);
+	if(rc) return rc;
+	rc=FAPI_ATTR_GET(ATTR_EFF_PRIMARY_RANK_GROUP3, &mba_target, prg[3]);
+	if(rc) return rc;
+
+	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_WIDTH, &mba_target, l_dram_width);
+	if(rc) return rc;
+
+	switch (l_dram_width)
+	{
+		case ENUM_ATTR_EFF_DRAM_WIDTH_X4:
+			l_dram_width = 4;
+			break;
+		case ENUM_ATTR_EFF_DRAM_WIDTH_X8:
+			l_dram_width = 8;
+			break;
+		case ENUM_ATTR_EFF_DRAM_WIDTH_X16:
+			l_dram_width = 16;
+			break;
+		case ENUM_ATTR_EFF_DRAM_WIDTH_X32:
+			l_dram_width = 32;
+			break;
+		default:
+			//DECONFIG and FFDC INFO
+			const fapi::Target & TARGET_MBA_ERROR = mba_target;
                         const uint8_t & WIDTH = l_dram_width;
 
-                        FAPI_ERR("ATTR_EFF_DRAM_WIDTH is invalid %u", l_dram_width);
-                        FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_DRAM_WIDTH_INPUT_ERROR_GETBBM);
-                        return rc;
-        }
-
-        l_ecmdRc = data_buffer.flushTo0();
-        if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-        {
-                 FAPI_ERR("Error from ecmdDataBuffer flushTo0() "
-                                 "- rc 0x%.8X", l_ecmdRc);
-
-                 rc.setEcmdError(l_ecmdRc);
-                 return rc;
-        }
-        for (uint8_t port = 0; port < MAX_PORTS; port++ )       // [0:1]
-        {
-                // Initialize all the stored errors to 0.
-                l_ecmdRc |= db_reg_dimm0_rank0.flushTo0();
-                l_ecmdRc |= db_reg_dimm0_rank1.flushTo0();
-                l_ecmdRc |= db_reg_dimm0_rank2.flushTo0();
-                l_ecmdRc |= db_reg_dimm0_rank3.flushTo0();
-                l_ecmdRc |= db_reg_dimm1_rank0.flushTo0();
-                l_ecmdRc |= db_reg_dimm1_rank1.flushTo0();
-                l_ecmdRc |= db_reg_dimm1_rank2.flushTo0();
-                l_ecmdRc |= db_reg_dimm1_rank3.flushTo0();
-                l_rank0_invalid = 1; //0 = valid, 1 = invalid
-                l_rank1_invalid = 1;
-                l_rank2_invalid = 1;
-                l_rank3_invalid = 1;
-                l_rank4_invalid = 1;
-                l_rank5_invalid = 1;
-                l_rank6_invalid = 1;
-                l_rank7_invalid = 1;
-
-                if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-                {
-                         FAPI_ERR("Error from ecmdDataBuffer setHalfWord()"
-                                         " for wrclk_mask - rc 0x%.8X", l_ecmdRc);
-
-                         rc.setEcmdError(l_ecmdRc);
-                         return rc;
-                }
-
-                // loop through primary ranks [0:3]
-                for (uint8_t prank = 0; prank < MAX_PRI_RANKS; prank++ )
-                {
-                        dimm = prg[prank][port] >> 2;
-                        uint8_t rank = prg[prank][port] & 0x03;
-                        uint16_t l_data = 0;
-
-                        if (prg[prank][port] == rg_invalid[prank])      // invalid rank
-                        {
-                                FAPI_DBG("Primary rank group %i is INVALID, continuing...",
-                                                prank);
-                                if ( prg[prank][port] == 0)
-                                {
-                                        l_ecmdRc |= db_reg_dimm0_rank0.flushTo1();
-                                        if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-                                        {
-                                                 FAPI_ERR("Error from ecmdDataBuffer setHalfWord() "
-                                                         "- rc 0x%.8X", l_ecmdRc);
-
-                                                 rc.setEcmdError(l_ecmdRc);
-                                                 return rc;
-                                        }
-                                }
-
-                                if ( prg[prank][port] == 1)
-                                {
-                                        l_ecmdRc |= db_reg_dimm0_rank1.flushTo1();
-                                        if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-                                        {
-                                                 FAPI_ERR("Error from ecmdDataBuffer setHalfWord() "
-                                                         "- rc 0x%.8X", l_ecmdRc);
-
-                                                 rc.setEcmdError(l_ecmdRc);
-                                                 return rc;
-                                        }
-                                }
-
-                                if ( prg[prank][port] == 2)
-                                {
-                                        l_ecmdRc |= db_reg_dimm0_rank2.flushTo1();
-                                        if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-                                        {
-                                                 FAPI_ERR("Error from ecmdDataBuffer setHalfWord() "
-                                                         "- rc 0x%.8X", l_ecmdRc);
-
-                                                 rc.setEcmdError(l_ecmdRc);
-                                                 return rc;
-                                        }
-                                }
-
-
-                                if ( prg[prank][port] == 3)
-                                {
-                                        l_ecmdRc |= db_reg_dimm0_rank3.flushTo1();
-                                        if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-                                        {
-                                                 FAPI_ERR("Error from ecmdDataBuffer setHalfWord() "
-                                                         "- rc 0x%.8X", l_ecmdRc);
-
-                                                 rc.setEcmdError(l_ecmdRc);
-                                                 return rc;
-                                        }
-                                }
-
-
-
-                                if ( prg[prank][port] == 4)
-                                {
-                                        l_ecmdRc |= db_reg_dimm1_rank0.flushTo1();
-                                        if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-                                        {
-                                                 FAPI_ERR("Error from ecmdDataBuffer setHalfWord() "
-                                                         "- rc 0x%.8X", l_ecmdRc);
-
-                                                 rc.setEcmdError(l_ecmdRc);
-                                                 return rc;
-                                        }
-                                }
-
-
-                                if ( prg[prank][port] == 5)
-                                {
-                                        l_ecmdRc |= db_reg_dimm1_rank1.flushTo1();
-                                        if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-                                        {
-                                                 FAPI_ERR("Error from ecmdDataBuffer setHalfWord() "
-                                                         "- rc 0x%.8X", l_ecmdRc);
-
-                                                 rc.setEcmdError(l_ecmdRc);
-                                                 return rc;
-                                        }
-                                }
-
-
-                                if ( prg[prank][port] == 6)
-                                {
-                                        l_ecmdRc |= db_reg_dimm1_rank2.flushTo1();
-                                        if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-                                        {
-                                                 FAPI_ERR("Error from ecmdDataBuffer setHalfWord() "
-                                                         "- rc 0x%.8X", l_ecmdRc);
-
-                                                 rc.setEcmdError(l_ecmdRc);
-                                                 return rc;
-                                        }
-                                }
-
-
-                                if ( prg[prank][port] == 7)
-                                {
-                                        l_ecmdRc |= db_reg_dimm1_rank3.flushTo1();
-                                        if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-                                        {
-                                                 FAPI_ERR("Error from ecmdDataBuffer setHalfWord() "
-                                                         "- rc 0x%.8X", l_ecmdRc);
-
-                                                 rc.setEcmdError(l_ecmdRc);
-                                                 return rc;
-                                        }
-                                }
-
-                                continue;
-                        }
-
-                        // create the db_reg (all the failed bits of the port)
-                        l_ecmdRc = db_reg.flushTo0();
-                        if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-                        {
-                                 FAPI_ERR("Error from ecmdDataBuffer flushTo0() "
-                                                 "- rc 0x%.8X", l_ecmdRc);
-
-                                 rc.setEcmdError(l_ecmdRc);
-                                 return rc;
-                        }
-
-                        FAPI_DBG("Port%i, dimm=%i, prg%i rank=%i", port, dimm, prank, rank);
-                        for ( uint8_t i=0; i < DP18_INSTANCES; i++ ) // dp18 [0:4]
-                        {
-                                // clear bits 48:63
-                                l_ecmdRc = data_buffer.clearBit(48, BITS_PER_REG);
-                                if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-                                {
-                                         FAPI_ERR("Error from ecmdDataBuffer setHalfWord() "
-                                                         "- rc 0x%.8X", l_ecmdRc);
-
-                                         rc.setEcmdError(l_ecmdRc);
-                                         return rc;
-                                }
-
-                                rc = fapiGetScom(mba_target, disable_reg[port][prank][i],
-                                                data_buffer);
-                                if (rc)
-                                {
-                                        FAPI_ERR("Error from fapiPutScom writing disable reg");
-                                        return rc;
-                                }
-
-                                l_data = data_buffer.getHalfWord(3);
-
-                                FAPI_DBG("dp18_%i  0x%llx = 0x%x", i,
-                                                disable_reg[port][prank][i], l_data);
-
-                                if (l_data != 0)
-                                {
-
-                                        l_ecmdRc = db_reg.setHalfWord(i, l_data);
-                                        if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-                                        {
-                                                 FAPI_ERR("Error from ecmdDataBuffer setHalfWord() "
-                                                         "- rc 0x%.8X", l_ecmdRc);
-
-                                                 rc.setEcmdError(l_ecmdRc);
-                                                 return rc;
-                                        }
-
-                                        FAPI_INF("+++ Setting Bad Bit Mask p%i: DIMM%i PRG%i "
-                                                "Rank%i \tdp18_%i addr=0x%llx, data=0x%04X", port,
-                                                dimm, prank, prg[prank][port], i,
-                                                disable_reg[port][prank][i], l_data);
-                                }
-                        } // end DP18 instance loop
-
-                        if (prg[prank][port] == rg_invalid[prank])      // invalid rank
-                        {
-                                FAPI_DBG("Primary rank group %i: INVALID, continuing...",
-                                                prank);
-
-                                continue;
-                        }
-
-
-                        if (dimm == 0)
-                        {
-                                if (rank == 0)
-                                {
-                                        l_ecmdRc |= db_reg.copy(db_reg_dimm0_rank0);
-                                        l_rank0_invalid = 0; //0 = valid, 1 = invalid
-                                }
-                                else if (rank == 1)
-                                {
-                                        l_ecmdRc |= db_reg.copy(db_reg_dimm0_rank1);
-                                        l_rank1_invalid = 0; //0 = valid, 1 = invalid
-                                }
-                                else if (rank == 2)
-                                {
-                                        l_ecmdRc |= db_reg.copy(db_reg_dimm0_rank2);
-                                        l_rank2_invalid = 0; //0 = valid, 1 = invalid
-                                }
-                                else if (rank == 3)
-                                {
-                                        l_ecmdRc |= db_reg.copy(db_reg_dimm0_rank3);
-                                        l_rank3_invalid = 0; //0 = valid, 1 = invalid
-                                }
-                        }
-                        else if (dimm == 1)
-                        {
-                                if (rank == 0)
-                                {
-                                        l_ecmdRc |= db_reg.copy(db_reg_dimm1_rank0);
-                                        l_rank4_invalid = 0; //0 = valid, 1 = invalid
-                                }
-                                else if (rank == 1)
-                                {
-                                        l_ecmdRc |= db_reg.copy(db_reg_dimm1_rank1);
-                                        l_rank5_invalid = 0; //0 = valid, 1 = invalid
-                                }
-                                else if (rank == 2)
-                                {
-                                        l_ecmdRc |= db_reg.copy(db_reg_dimm1_rank2);
-                                        l_rank6_invalid = 0; //0 = valid, 1 = invalid
-                                }
-                                else if (rank == 3)
-                                {
-                                        l_ecmdRc |= db_reg.copy(db_reg_dimm1_rank3);
-                                        l_rank7_invalid = 0; //0 = valid, 1 = invalid
-                                }
-                        }
-
-                        if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-                        {
-                                 FAPI_ERR("Error from ecmdDataBuffer copy() "
-                                         "- rc 0x%.8X", l_ecmdRc);
-
-                                 rc.setEcmdError(l_ecmdRc);
-                                 return rc;
-                        }
-
-                } // end primary rank loop
-
-
-                // loop through primary ranks [0:3]
-                for (uint8_t prank = 0; prank < MAX_PRI_RANKS; prank++ )
-                {
-
-                        dimm = prg[prank][port] >> 2;
-                        uint8_t rank = prg[prank][port] & 0x03;
-                        uint16_t l_data = 0;
-                        uint16_t l_data_rank0 = 0;
-                        uint16_t l_data_rank1 = 0;
-                        uint16_t l_data_rank2 = 0;
-                        uint16_t l_data_rank3 = 0;
-                        uint16_t l_data_rank4 = 0;
-                        uint16_t l_data_rank5 = 0;
-                        uint16_t l_data_rank6 = 0;
-                        uint16_t l_data_rank7 = 0;
-                        uint16_t l_data_curr_vpd = 0;
-
-                        if (prg[prank][port] == rg_invalid[prank])      // invalid rank
-                        {
-                                FAPI_DBG("Primary rank group %i is INVALID, continuing...",
-                                                prank);
-                                continue;
-                        }
-
-                        FAPI_DBG("Port%i, dimm=%i, prg%i rank=%i", port, dimm, prank, rank);
-                        for ( uint8_t i=0; i < DP18_INSTANCES; i++ ) // dp18 [0:4]
-                        {
-
-
-                                l_data_rank0 = db_reg_dimm0_rank0.getHalfWord(i);
-                                l_data_rank1 = db_reg_dimm0_rank1.getHalfWord(i);
-                                l_data_rank2 = db_reg_dimm0_rank2.getHalfWord(i);
-                                l_data_rank3 = db_reg_dimm0_rank3.getHalfWord(i);
-                                l_data_rank4 = db_reg_dimm1_rank0.getHalfWord(i);
-                                l_data_rank5 = db_reg_dimm1_rank1.getHalfWord(i);
-                                l_data_rank6 = db_reg_dimm1_rank2.getHalfWord(i);
-                                l_data_rank7 = db_reg_dimm1_rank3.getHalfWord(i);
-
-
-
-                                if (dimm == 0)
-                                {
-                                        if (rank == 0)
-                                        {
-                                                l_data = l_data_rank0;
-                                        }
-                                        else if (rank == 1)
-                                        {
-                                                l_data = l_data_rank1;
-                                        }
-                                        else if (rank == 2)
-                                        {
-                                                l_data = l_data_rank2;
-                                        }
-                                        else if (rank == 3)
-                                        {
-                                                l_data = l_data_rank3;
-                                        }
-                                }
-                                else if (dimm == 1)
-                                {
-                                        if (rank == 0)
-                                        {
-                                                l_data = l_data_rank4;
-                                        }
-                                        else if (rank == 1)
-                                        {
-                                                l_data = l_data_rank5;
-                                        }
-                                        else if (rank == 2)
-                                        {
-                                                l_data = l_data_rank6;
-                                        }
-                                        else if (rank == 3)
-                                        {
-                                                l_data = l_data_rank7;
-                                        }
-                                }
-
-
-                                uint8_t is_clean = 1;
-                                rc = getC4dq2reg(mba_target, port, dimm, rank, db_reg_vpd, is_clean);
-                                l_data_curr_vpd = db_reg_vpd.getHalfWord(i);
-
-                                uint16_t mask = 0xF000;
-                                // Temp remove of 0xE case
-                                //uint16_t emask = 0xE000;
-                                for (uint8_t n=0; n < 4; n++) { // check each nibble
-                                        uint16_t nmask = mask >> (4*n);
-                                        // Temp remove of 0xE case
-                                        //uint16_t e_nmask = emask >> (4*n);
-
-
-                                        if ((nmask & l_data_curr_vpd) == nmask) {
-                                                FAPI_DBG("BYTE DISABLE WORKAROUND: Found a 0XF on nibble=%i Port%i, dimm=%i, prg%i rank=%i data= 0x%04X", n, port, dimm, prank, rank, l_data);
-                                                FAPI_DBG("BYTE DISABLE WORKAROUND: data rank 0 =0x%04X rank 1 =0x%04X rank 2 =0x%04X rank 3 =0x%04X rank 4 =0x%04X rank 5 =0x%04X rank 6 =0x%04X rank 7 =0x%04X", l_data_rank0,l_data_rank1,l_data_rank2,l_data_rank3,l_data_rank4,l_data_rank5,l_data_rank6,l_data_rank7 );
-                                                if (i_training_success)
-                                                {       //Leave it an F.
-                                                        FAPI_DBG("BYTE DISABLE WORKAROUND: Training was successful so writing an 0xF to VPD. PRE data: 0x%04X", l_data);
-                                                        l_data = l_data | nmask;
-                                                        FAPI_DBG("BYTE DISABLE WORKAROUND: POST DATA: 0x%04X", l_data);
-                                                }
-                                                else
-                                                {
-                                                        if ( ( ((nmask & l_data_rank0) == nmask) || (l_rank0_invalid) ) &&
-                                                             ( ((nmask & l_data_rank1) == nmask) || (l_rank1_invalid) ) &&
-                                                             ( ((nmask & l_data_rank2) == nmask) || (l_rank2_invalid) ) &&
-                                                             ( ((nmask & l_data_rank3) == nmask) || (l_rank3_invalid) ) &&
-                                                             ( ((nmask & l_data_rank4) == nmask) || (l_rank4_invalid) ) &&
-                                                             ( ((nmask & l_data_rank5) == nmask) || (l_rank5_invalid) ) &&
-                                                             ( ((nmask & l_data_rank6) == nmask) || (l_rank6_invalid) ) &&
-                                                             ( ((nmask & l_data_rank7) == nmask) || (l_rank7_invalid) )   )
-                                                        {
-                                                                FAPI_DBG("BYTE DISABLE WORKAROUND: All ranks were F's and training was not successful.  Uncool.");
-                                                                continue;
-                                                        }
-                                                        else
-                                                        {
-
-                                                                //Temprorarily removing 0xE version. Skipping Straight to 0xFs to all ranks.
-                                                                /*
-                                                                //Replacing F nibble with E nibble
-                                                                FAPI_DBG("BYTE DISABLE WORKAROUND: Training was not successful so writing an 0xE to VPD. PRE DATA: 0x%04X", l_data);
-                                                                l_data = (l_data & ~(nmask)) | e_nmask;
-                                                                FAPI_DBG("BYTE DISABLE WORKAROUND: POST DATA: 0x%04X", l_data);
-                                                                */
-
-                                                                //Replacing E nibble with F nibble
-                                                                FAPI_DBG("BYTE DISABLE WORKAROUND: Training failed so writing an 0xF to VPD for all ranks.");
-                                                                l_data = l_data  | nmask;
-                                                                l_data_rank0 = l_data_rank0  | nmask;
-                                                                l_data_rank1 = l_data_rank1  | nmask;
-                                                                l_data_rank2 = l_data_rank2  | nmask;
-                                                                l_data_rank3 = l_data_rank3  | nmask;
-                                                                l_data_rank4 = l_data_rank4  | nmask;
-                                                                l_data_rank5 = l_data_rank5  | nmask;
-                                                                l_data_rank6 = l_data_rank6  | nmask;
-                                                                l_data_rank7 = l_data_rank7  | nmask;
-
-                                                        }
-                                                }
-                                        }
-                                        else if ( ((nmask & l_data_curr_vpd) != nmask) && ((nmask & l_data_curr_vpd) > 0)) {
-                                                FAPI_DBG("BYTE DISABLE WORKAROUND: Found a non-zero, non-F nibble. Applying to all ranks.");
-
-                                                        if (l_dram_width == 4)
-                                                        {
-                                                                FAPI_DBG("BYTE DISABLE WORKAROUND: Its a x4 so turning it to a 0xF. PRE DATA: 0x%04X", l_data);
-                                                                l_data = l_data  | nmask;
-                                                                FAPI_DBG("BYTE DISABLE WORKAROUND: POST DATA: 0x%04X", l_data);
-
-                                                                FAPI_DBG("BYTE DISABLE WORKAROUND: PRE data rank 0 =0x%04X rank 1 =0x%04X rank 2 =0x%04X rank 3 =0x%04X rank 4 =0x%04X rank 5 =0x%04X rank 6 =0x%04X rank 7 =0x%04X", l_data_rank0,l_data_rank1,l_data_rank2,l_data_rank3,l_data_rank4,l_data_rank5,l_data_rank6,l_data_rank7 );
-                                                                l_data_rank0 = l_data_rank0  | nmask;
-                                                                l_data_rank1 = l_data_rank1  | nmask;
-                                                                l_data_rank2 = l_data_rank2  | nmask;
-                                                                l_data_rank3 = l_data_rank3  | nmask;
-                                                                l_data_rank4 = l_data_rank4  | nmask;
-                                                                l_data_rank5 = l_data_rank5  | nmask;
-                                                                l_data_rank6 = l_data_rank6  | nmask;
-                                                                l_data_rank7 = l_data_rank7  | nmask;
-                                                                FAPI_DBG("BYTE DISABLE WORKAROUND: POST data rank 0 =0x%04X rank 1 =0x%04X rank 2 =0x%04X rank 3 =0x%04X rank 4 =0x%04X rank 5 =0x%04X rank 6 =0x%04X rank 7 =0x%04X", l_data_rank0,l_data_rank1,l_data_rank2,l_data_rank3,l_data_rank4,l_data_rank5,l_data_rank6,l_data_rank7 );
-
-                                                        }
-                                                        else if (l_dram_width == 8)
-                                                        {
-                                                                FAPI_DBG("BYTE DISABLE WORKAROUND: Its a x8 so leaving it the same.");
-
-                                                                FAPI_DBG("BYTE DISABLE WORKAROUND: PRE data rank 0 =0x%04X rank 1 =0x%04X rank 2 =0x%04X rank 3 =0x%04X rank 4 =0x%04X rank 5 =0x%04X rank 6 =0x%04X rank 7 =0x%04X", l_data_rank0,l_data_rank1,l_data_rank2,l_data_rank3,l_data_rank4,l_data_rank5,l_data_rank6,l_data_rank7 );
-                                                                l_data_rank0 = (l_data_rank0) | ( l_data & nmask);
-                                                                l_data_rank1 = (l_data_rank1) | ( l_data & nmask);
-                                                                l_data_rank2 = (l_data_rank2) | ( l_data & nmask);
-                                                                l_data_rank3 = (l_data_rank3) | ( l_data & nmask);
-                                                                l_data_rank4 = (l_data_rank4) | ( l_data & nmask);
-                                                                l_data_rank5 = (l_data_rank5) | ( l_data & nmask);
-                                                                l_data_rank6 = (l_data_rank6) | ( l_data & nmask);
-                                                                l_data_rank7 = (l_data_rank7) | ( l_data & nmask);
-
-                                                                FAPI_DBG("BYTE DISABLE WORKAROUND: POST data rank 0 =0x%04X rank 1 =0x%04X rank 2 =0x%04X rank 3 =0x%04X rank 4 =0x%04X rank 5 =0x%04X rank 6 =0x%04X rank 7 =0x%04X", l_data_rank0,l_data_rank1,l_data_rank2,l_data_rank3,l_data_rank4,l_data_rank5,l_data_rank6,l_data_rank7 );
-                                                        }
-
-
-
-
-                                        }
-                                        // Temporarily Removing the 0xE case with this workaround.
-                                        /*
-                                        else if ((nmask & l_data_curr_vpd) == e_nmask) {
-                                                FAPI_DBG("BYTE DISABLE WORKAROUND: Found a 0XE on nibble=%i Port%i, dimm=%i, prg%i rank=%i data= 0x%04X", n, port, dimm, prank, rank, l_data);
-                                                if (i_training_success)
-                                                {
-                                                        //Leave it an E.
-                                                        FAPI_DBG("BYTE DISABLE WORKAROUND: Training was successful so writing an 0xE to VPD.");
-                                                }
-                                                else
-                                                {
-                                                        //Replacing E nibble with F nibble
-                                                        FAPI_DBG("BYTE DISABLE WORKAROUND: Training failed so writing an 0xF to VPD for all ranks.");
-                                                        l_data = l_data  | nmask;
-                                                        l_data_rank0 = l_data_rank0  | nmask;
-                                                        l_data_rank1 = l_data_rank1  | nmask;
-                                                        l_data_rank2 = l_data_rank2  | nmask;
-                                                        l_data_rank3 = l_data_rank3  | nmask;
-                                                        l_data_rank4 = l_data_rank4  | nmask;
-                                                        l_data_rank5 = l_data_rank5  | nmask;
-                                                        l_data_rank6 = l_data_rank6  | nmask;
-                                                        l_data_rank7 = l_data_rank7  | nmask;
-                                                }
-                                        }
-                                        */
-                                }
-
-                                if (dimm == 0)
-                                {
-                                        if (rank == 0)
-                                        {
-                                                l_data_rank0 = l_data;
-                                        }
-                                        else if (rank == 1)
-                                        {
-                                                l_data_rank1 = l_data;
-                                        }
-                                        else if (rank == 2)
-                                        {
-                                                l_data_rank2 = l_data;
-                                        }
-                                        else if (rank == 3)
-                                        {
-                                                l_data_rank3 = l_data;
-                                        }
-                                }
-                                else if (dimm == 1)
-                                {
-                                        if (rank == 0)
-                                        {
-                                                l_data_rank4 = l_data;
-                                        }
-                                        else if (rank == 1)
-                                        {
-                                                l_data_rank5 = l_data;
-                                        }
-                                        else if (rank == 2)
-                                        {
-                                                l_data_rank6 = l_data;
-                                        }
-                                        else if (rank == 3)
-                                        {
-                                                l_data_rank7 = l_data;
-                                        }
-                                }
-
-
-                                l_ecmdRc |= db_reg_dimm0_rank0.setHalfWord(i, l_data_rank0);
-                                l_ecmdRc |= db_reg_dimm0_rank1.setHalfWord(i, l_data_rank1);
-                                l_ecmdRc |= db_reg_dimm0_rank2.setHalfWord(i, l_data_rank2);
-                                l_ecmdRc |= db_reg_dimm0_rank3.setHalfWord(i, l_data_rank3);
-
-                                l_ecmdRc |= db_reg_dimm1_rank0.setHalfWord(i, l_data_rank4);
-                                l_ecmdRc |= db_reg_dimm1_rank1.setHalfWord(i, l_data_rank5);
-                                l_ecmdRc |= db_reg_dimm1_rank2.setHalfWord(i, l_data_rank6);
-                                l_ecmdRc |= db_reg_dimm1_rank3.setHalfWord(i, l_data_rank7);
-
-                                if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-                                {
-                                         FAPI_ERR("Error from ecmdDataBuffer flushTo0() "
-                                                         "- rc 0x%.8X", l_ecmdRc);
-                                         rc.setEcmdError(l_ecmdRc);
-                                         return rc;
-                                }
-
-
-                        }
-
-
-                }// end of primary rank loop
-
-
-                // loop through primary ranks [0:3]
-                for (uint8_t prank = 0; prank < MAX_PRI_RANKS; prank++ )
-                {
-                        dimm = prg[prank][port] >> 2;
-                        uint8_t rank = prg[prank][port] & 0x03;
-                        FAPI_DBG("BYTE DISABLE WORKAROUND: Looping through dimm: %d rank: %d ", dimm, rank);
-
-                        if (prg[prank][port] == rg_invalid[prank])      // invalid rank
-                        {
-                                FAPI_DBG("Primary rank group %i is INVALID, continuing...",
-                                                prank);
-                                continue;
-                        }
-
-                        if (dimm == 0)
-                        {
-                                if (rank == 0)
-                                {
-                                        l_ecmdRc |= db_reg_dimm0_rank0.copy(db_reg);
-                                }
-                                else if (rank == 1)
-                                {
-                                        l_ecmdRc |= db_reg_dimm0_rank1.copy(db_reg);
-                                }
-                                else if (rank == 2)
-                                {
-                                        l_ecmdRc |= db_reg_dimm0_rank2.copy(db_reg);
-                                }
-                                else if (rank == 3)
-                                {
-
-                                        l_ecmdRc |= db_reg_dimm0_rank3.copy(db_reg);
-                                }
-                        }
-                        else if (dimm == 1)
-                        {
-                                if (rank == 0)
-                                {
-                                        l_ecmdRc |= db_reg_dimm1_rank0.copy(db_reg);
-                                }
-                                else if (rank == 1)
-                                {
-                                        l_ecmdRc |= db_reg_dimm1_rank1.copy(db_reg);
-                                }
-                                else if (rank == 2)
-                                {
-                                        l_ecmdRc |= db_reg_dimm1_rank2.copy(db_reg);
-                                }
-                                else if (rank == 3)
-                                {
-                                        l_ecmdRc |= db_reg_dimm1_rank3.copy(db_reg);
-                                }
-                        }
-
-                        if (l_ecmdRc != ECMD_DBUF_SUCCESS)
-                        {
-                                 FAPI_ERR("Error from ecmdDataBuffer flushTo0() "
-                                                 "- rc 0x%.8X", l_ecmdRc);
-                                 rc.setEcmdError(l_ecmdRc);
-                                 return rc;
-                        }
-
-                        FAPI_INF("Setting BBM across dimm: %d rank: %d", dimm, rank);
-                        rc = setC4dq2reg(mba_target, port, dimm, rank, db_reg);
-                        if (rc)
-                        {
-                                FAPI_ERR("Error from setting register bitmap p%i: "
-                                        "dimm=%i, rank=%i rc=%i", port, dimm, rank,
-                                        static_cast<uint32_t>(rc));
-                                return rc;
-                        }
-
-                }// end of primary rank loop
-
-
-
-        } // end port loop
+			FAPI_ERR("ATTR_EFF_DRAM_WIDTH is invalid %u", l_dram_width);
+			FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_DRAM_WIDTH_INPUT_ERROR_GETBBM);
+			return rc;
+	}
+
+	l_ecmdRc = data_buffer.flushTo0();
+	if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+	{
+		 FAPI_ERR("Error from ecmdDataBuffer flushTo0() "
+				 "- rc 0x%.8X", l_ecmdRc);
+
+		 rc.setEcmdError(l_ecmdRc);
+		 return rc;
+	}
+	for (uint8_t port = 0; port < MAX_PORTS; port++ )	// [0:1]
+	{
+		// Initialize all the stored errors to 0.
+		l_ecmdRc |= db_reg_dimm0_rank0.flushTo0();
+		l_ecmdRc |= db_reg_dimm0_rank1.flushTo0();
+		l_ecmdRc |= db_reg_dimm0_rank2.flushTo0();
+		l_ecmdRc |= db_reg_dimm0_rank3.flushTo0();
+		l_ecmdRc |= db_reg_dimm1_rank0.flushTo0();
+		l_ecmdRc |= db_reg_dimm1_rank1.flushTo0();
+		l_ecmdRc |= db_reg_dimm1_rank2.flushTo0();
+		l_ecmdRc |= db_reg_dimm1_rank3.flushTo0();
+		l_rank0_invalid = 1; //0 = valid, 1 = invalid
+		l_rank1_invalid = 1; 
+		l_rank2_invalid = 1; 
+		l_rank3_invalid = 1; 
+		l_rank4_invalid = 1; 
+		l_rank5_invalid = 1; 
+		l_rank6_invalid = 1; 
+		l_rank7_invalid = 1;
+
+		if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+		{
+			 FAPI_ERR("Error from ecmdDataBuffer setHalfWord()"
+					 " for wrclk_mask - rc 0x%.8X", l_ecmdRc);
+
+			 rc.setEcmdError(l_ecmdRc);
+			 return rc;
+		}
+
+		// loop through primary ranks [0:3]
+		for (uint8_t prank = 0; prank < MAX_PRI_RANKS; prank++ )
+		{
+			dimm = prg[prank][port] >> 2;
+			uint8_t rank = prg[prank][port] & 0x03;
+			uint16_t l_data = 0;
+
+			if (prg[prank][port] == rg_invalid[prank])	// invalid rank
+			{
+				FAPI_DBG("Primary rank group %i is INVALID, continuing...",
+						prank);
+				if ( prg[prank][port] == 0)
+				{
+					l_ecmdRc |= db_reg_dimm0_rank0.flushTo1();
+					if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+					{
+						 FAPI_ERR("Error from ecmdDataBuffer setHalfWord() "
+							 "- rc 0x%.8X", l_ecmdRc);
+
+						 rc.setEcmdError(l_ecmdRc);
+						 return rc;
+					}
+				}
+			
+				if ( prg[prank][port] == 1)
+				{
+					l_ecmdRc |= db_reg_dimm0_rank1.flushTo1();
+					if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+					{
+						 FAPI_ERR("Error from ecmdDataBuffer setHalfWord() "
+							 "- rc 0x%.8X", l_ecmdRc);
+
+						 rc.setEcmdError(l_ecmdRc);
+						 return rc;
+					}
+				}
+			
+				if ( prg[prank][port] == 2)
+				{
+					l_ecmdRc |= db_reg_dimm0_rank2.flushTo1();
+					if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+					{
+						 FAPI_ERR("Error from ecmdDataBuffer setHalfWord() "
+							 "- rc 0x%.8X", l_ecmdRc);
+
+						 rc.setEcmdError(l_ecmdRc);
+						 return rc;
+					}
+				}
+			
+			
+				if ( prg[prank][port] == 3)
+				{
+					l_ecmdRc |= db_reg_dimm0_rank3.flushTo1();
+					if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+					{
+						 FAPI_ERR("Error from ecmdDataBuffer setHalfWord() "
+							 "- rc 0x%.8X", l_ecmdRc);
+
+						 rc.setEcmdError(l_ecmdRc);
+						 return rc;
+					}
+				}
+			
+
+			
+				if ( prg[prank][port] == 4)
+				{
+					l_ecmdRc |= db_reg_dimm1_rank0.flushTo1();
+					if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+					{
+						 FAPI_ERR("Error from ecmdDataBuffer setHalfWord() "
+							 "- rc 0x%.8X", l_ecmdRc);
+
+						 rc.setEcmdError(l_ecmdRc);
+						 return rc;
+					}
+				}
+			
+			
+				if ( prg[prank][port] == 5)
+				{
+					l_ecmdRc |= db_reg_dimm1_rank1.flushTo1();
+					if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+					{
+						 FAPI_ERR("Error from ecmdDataBuffer setHalfWord() "
+							 "- rc 0x%.8X", l_ecmdRc);
+
+						 rc.setEcmdError(l_ecmdRc);
+						 return rc;
+					}
+				}
+			
+			
+				if ( prg[prank][port] == 6)
+				{
+					l_ecmdRc |= db_reg_dimm1_rank2.flushTo1();
+					if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+					{
+						 FAPI_ERR("Error from ecmdDataBuffer setHalfWord() "
+							 "- rc 0x%.8X", l_ecmdRc);
+
+						 rc.setEcmdError(l_ecmdRc);
+						 return rc;
+					}
+				}
+			
+			
+				if ( prg[prank][port] == 7)
+				{
+					l_ecmdRc |= db_reg_dimm1_rank3.flushTo1();
+					if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+					{
+						 FAPI_ERR("Error from ecmdDataBuffer setHalfWord() "
+							 "- rc 0x%.8X", l_ecmdRc);
+
+						 rc.setEcmdError(l_ecmdRc);
+						 return rc;
+					}
+				}
+
+				continue;
+			}
+
+			// create the db_reg (all the failed bits of the port)
+			l_ecmdRc = db_reg.flushTo0();
+			if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+			{
+				 FAPI_ERR("Error from ecmdDataBuffer flushTo0() "
+						 "- rc 0x%.8X", l_ecmdRc);
+
+				 rc.setEcmdError(l_ecmdRc);
+				 return rc;
+			}
+
+			FAPI_DBG("Port%i, dimm=%i, prg%i rank=%i", port, dimm, prank, rank);
+			for ( uint8_t i=0; i < DP18_INSTANCES; i++ ) // dp18 [0:4]
+			{
+				// clear bits 48:63
+				l_ecmdRc = data_buffer.clearBit(48, BITS_PER_REG);
+				if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+				{
+					 FAPI_ERR("Error from ecmdDataBuffer setHalfWord() "
+							 "- rc 0x%.8X", l_ecmdRc);
+
+					 rc.setEcmdError(l_ecmdRc);
+					 return rc;
+				}
+
+				rc = fapiGetScom(mba_target, disable_reg[port][prank][i],
+						data_buffer);
+				if (rc)
+				{
+					FAPI_ERR("Error from fapiPutScom writing disable reg");
+					return rc;
+				}
+
+				l_data = data_buffer.getHalfWord(3);
+
+				FAPI_DBG("dp18_%i  0x%llx = 0x%x", i,
+						disable_reg[port][prank][i], l_data);
+
+				if (l_data != 0)
+				{
+					
+					l_ecmdRc = db_reg.setHalfWord(i, l_data);
+					if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+					{
+						 FAPI_ERR("Error from ecmdDataBuffer setHalfWord() "
+							 "- rc 0x%.8X", l_ecmdRc);
+
+						 rc.setEcmdError(l_ecmdRc);
+						 return rc;
+					}
+
+					FAPI_INF("+++ Setting Bad Bit Mask p%i: DIMM%i PRG%i "
+						"Rank%i \tdp18_%i addr=0x%llx, data=0x%04X", port,
+						dimm, prank, prg[prank][port], i,
+						disable_reg[port][prank][i], l_data);
+				}
+			} // end DP18 instance loop
+
+			if (prg[prank][port] == rg_invalid[prank])	// invalid rank
+			{
+				FAPI_DBG("Primary rank group %i: INVALID, continuing...",
+						prank);
+
+				continue;
+			}
+			
+
+			if (dimm == 0)
+			{
+				if (rank == 0)
+				{
+					l_ecmdRc |= db_reg.copy(db_reg_dimm0_rank0);
+					l_rank0_invalid = 0; //0 = valid, 1 = invalid
+				}
+				else if (rank == 1)
+				{
+					l_ecmdRc |= db_reg.copy(db_reg_dimm0_rank1);
+					l_rank1_invalid = 0; //0 = valid, 1 = invalid
+				}
+				else if (rank == 2)
+				{
+					l_ecmdRc |= db_reg.copy(db_reg_dimm0_rank2);						
+					l_rank2_invalid = 0; //0 = valid, 1 = invalid
+				}
+				else if (rank == 3)
+				{
+					l_ecmdRc |= db_reg.copy(db_reg_dimm0_rank3);
+					l_rank3_invalid = 0; //0 = valid, 1 = invalid
+				}
+			}
+			else if (dimm == 1)
+			{
+				if (rank == 0)
+				{
+					l_ecmdRc |= db_reg.copy(db_reg_dimm1_rank0);
+					l_rank4_invalid = 0; //0 = valid, 1 = invalid
+				}
+				else if (rank == 1)
+				{
+					l_ecmdRc |= db_reg.copy(db_reg_dimm1_rank1);
+					l_rank5_invalid = 0; //0 = valid, 1 = invalid
+				}
+				else if (rank == 2)
+				{
+					l_ecmdRc |= db_reg.copy(db_reg_dimm1_rank2);
+					l_rank6_invalid = 0; //0 = valid, 1 = invalid
+				}
+				else if (rank == 3)
+				{
+					l_ecmdRc |= db_reg.copy(db_reg_dimm1_rank3);
+					l_rank7_invalid = 0; //0 = valid, 1 = invalid
+				}
+			}
+
+			if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+			{
+				 FAPI_ERR("Error from ecmdDataBuffer copy() "
+					 "- rc 0x%.8X", l_ecmdRc);
+
+				 rc.setEcmdError(l_ecmdRc);
+				 return rc;
+			}
+
+		} // end primary rank loop
+
+
+		// loop through primary ranks [0:3]
+		for (uint8_t prank = 0; prank < MAX_PRI_RANKS; prank++ )
+		{
+
+			dimm = prg[prank][port] >> 2;
+			uint8_t rank = prg[prank][port] & 0x03;
+			uint16_t l_data = 0;
+			uint16_t l_data_rank0 = 0;
+			uint16_t l_data_rank1 = 0;
+			uint16_t l_data_rank2 = 0;
+			uint16_t l_data_rank3 = 0;
+			uint16_t l_data_rank4 = 0;
+			uint16_t l_data_rank5 = 0;
+			uint16_t l_data_rank6 = 0;
+			uint16_t l_data_rank7 = 0;
+			uint16_t l_data_curr_vpd = 0;
+
+			if (prg[prank][port] == rg_invalid[prank])	// invalid rank
+			{
+				FAPI_DBG("Primary rank group %i is INVALID, continuing...",
+						prank);
+				continue;
+			}
+
+			FAPI_DBG("Port%i, dimm=%i, prg%i rank=%i", port, dimm, prank, rank);
+			for ( uint8_t i=0; i < DP18_INSTANCES; i++ ) // dp18 [0:4]
+			{
+
+
+				l_data_rank0 = db_reg_dimm0_rank0.getHalfWord(i);
+				l_data_rank1 = db_reg_dimm0_rank1.getHalfWord(i);
+				l_data_rank2 = db_reg_dimm0_rank2.getHalfWord(i);
+				l_data_rank3 = db_reg_dimm0_rank3.getHalfWord(i);
+				l_data_rank4 = db_reg_dimm1_rank0.getHalfWord(i);
+				l_data_rank5 = db_reg_dimm1_rank1.getHalfWord(i);
+				l_data_rank6 = db_reg_dimm1_rank2.getHalfWord(i);
+				l_data_rank7 = db_reg_dimm1_rank3.getHalfWord(i);
+
+
+
+				if (dimm == 0)
+				{
+					if (rank == 0)
+					{
+						l_data = l_data_rank0;
+					}
+					else if (rank == 1)
+					{
+						l_data = l_data_rank1;
+					}
+					else if (rank == 2)
+					{
+						l_data = l_data_rank2;
+					}
+					else if (rank == 3)
+					{
+						l_data = l_data_rank3;
+					}
+				}
+				else if (dimm == 1)
+				{
+					if (rank == 0)
+					{
+						l_data = l_data_rank4;
+					}
+					else if (rank == 1)
+					{
+						l_data = l_data_rank5;
+					}
+					else if (rank == 2)
+					{
+						l_data = l_data_rank6;
+					}
+					else if (rank == 3)
+					{
+						l_data = l_data_rank7;
+					}
+				}
+
+
+				uint8_t is_clean = 1;
+			        rc = getC4dq2reg(mba_target, port, dimm, rank, db_reg_vpd, is_clean);
+				l_data_curr_vpd = db_reg_vpd.getHalfWord(i);
+
+				uint16_t mask = 0xF000;
+				// Temp remove of 0xE case
+				//uint16_t emask = 0xE000;
+				for (uint8_t n=0; n < 4; n++) {	// check each nibble
+					uint16_t nmask = mask >> (4*n);
+					// Temp remove of 0xE case
+					//uint16_t e_nmask = emask >> (4*n);
+
+
+					if ((nmask & l_data_curr_vpd) == nmask) {
+						FAPI_DBG("BYTE DISABLE WORKAROUND: Found a 0XF on nibble=%i Port%i, dimm=%i, prg%i rank=%i data= 0x%04X", n, port, dimm, prank, rank, l_data);
+						FAPI_DBG("BYTE DISABLE WORKAROUND: data rank 0 =0x%04X rank 1 =0x%04X rank 2 =0x%04X rank 3 =0x%04X rank 4 =0x%04X rank 5 =0x%04X rank 6 =0x%04X rank 7 =0x%04X", l_data_rank0,l_data_rank1,l_data_rank2,l_data_rank3,l_data_rank4,l_data_rank5,l_data_rank6,l_data_rank7 );
+						if (i_training_success)
+						{	//Leave it an F.
+							FAPI_DBG("BYTE DISABLE WORKAROUND: Training was successful so writing an 0xF to VPD. PRE data: 0x%04X", l_data);
+							l_data = l_data | nmask;
+						        FAPI_DBG("BYTE DISABLE WORKAROUND: POST DATA: 0x%04X", l_data);
+						}
+						else
+						{
+							if ( ( ((nmask & l_data_rank0) == nmask) || (l_rank0_invalid) ) && 
+							     ( ((nmask & l_data_rank1) == nmask) || (l_rank1_invalid) ) && 
+							     ( ((nmask & l_data_rank2) == nmask) || (l_rank2_invalid) ) && 
+							     ( ((nmask & l_data_rank3) == nmask) || (l_rank3_invalid) ) &&
+							     ( ((nmask & l_data_rank4) == nmask) || (l_rank4_invalid) ) && 
+							     ( ((nmask & l_data_rank5) == nmask) || (l_rank5_invalid) ) && 
+							     ( ((nmask & l_data_rank6) == nmask) || (l_rank6_invalid) ) && 
+							     ( ((nmask & l_data_rank7) == nmask) || (l_rank7_invalid) )   )
+							{
+								FAPI_DBG("BYTE DISABLE WORKAROUND: All ranks were F's and training was not successful.  Uncool.");
+								continue;
+							}
+							else
+							{
+
+								//Temprorarily removing 0xE version. Skipping Straight to 0xFs to all ranks.
+								/*
+								//Replacing F nibble with E nibble
+								FAPI_DBG("BYTE DISABLE WORKAROUND: Training was not successful so writing an 0xE to VPD. PRE DATA: 0x%04X", l_data);
+								l_data = (l_data & ~(nmask)) | e_nmask; 
+								FAPI_DBG("BYTE DISABLE WORKAROUND: POST DATA: 0x%04X", l_data);
+								*/
+								
+								//Replacing E nibble with F nibble
+								FAPI_DBG("BYTE DISABLE WORKAROUND: Training failed so writing an 0xF to VPD for all ranks.");
+								l_data = l_data  | nmask; 
+								l_data_rank0 = l_data_rank0  | nmask; 
+								l_data_rank1 = l_data_rank1  | nmask; 
+								l_data_rank2 = l_data_rank2  | nmask; 
+								l_data_rank3 = l_data_rank3  | nmask; 
+								l_data_rank4 = l_data_rank4  | nmask; 
+								l_data_rank5 = l_data_rank5  | nmask; 
+								l_data_rank6 = l_data_rank6  | nmask; 
+								l_data_rank7 = l_data_rank7  | nmask; 
+								
+							}
+						}
+					}
+					else if ( ((nmask & l_data_curr_vpd) != nmask) && ((nmask & l_data_curr_vpd) > 0)) {
+						FAPI_DBG("BYTE DISABLE WORKAROUND: Found a non-zero, non-F nibble. Applying to all ranks.");
+
+							if (l_dram_width == 4)
+							{
+								FAPI_DBG("BYTE DISABLE WORKAROUND: Its a x4 so turning it to a 0xF. PRE DATA: 0x%04X", l_data);
+								l_data = l_data  | nmask;
+								FAPI_DBG("BYTE DISABLE WORKAROUND: POST DATA: 0x%04X", l_data);
+
+ 								FAPI_DBG("BYTE DISABLE WORKAROUND: PRE data rank 0 =0x%04X rank 1 =0x%04X rank 2 =0x%04X rank 3 =0x%04X rank 4 =0x%04X rank 5 =0x%04X rank 6 =0x%04X rank 7 =0x%04X", l_data_rank0,l_data_rank1,l_data_rank2,l_data_rank3,l_data_rank4,l_data_rank5,l_data_rank6,l_data_rank7 );
+								l_data_rank0 = l_data_rank0  | nmask; 
+								l_data_rank1 = l_data_rank1  | nmask; 
+								l_data_rank2 = l_data_rank2  | nmask; 
+								l_data_rank3 = l_data_rank3  | nmask; 
+								l_data_rank4 = l_data_rank4  | nmask; 
+								l_data_rank5 = l_data_rank5  | nmask; 
+								l_data_rank6 = l_data_rank6  | nmask; 
+								l_data_rank7 = l_data_rank7  | nmask; 
+								FAPI_DBG("BYTE DISABLE WORKAROUND: POST data rank 0 =0x%04X rank 1 =0x%04X rank 2 =0x%04X rank 3 =0x%04X rank 4 =0x%04X rank 5 =0x%04X rank 6 =0x%04X rank 7 =0x%04X", l_data_rank0,l_data_rank1,l_data_rank2,l_data_rank3,l_data_rank4,l_data_rank5,l_data_rank6,l_data_rank7 );
+					
+							}
+							else if (l_dram_width == 8)
+							{
+								FAPI_DBG("BYTE DISABLE WORKAROUND: Its a x8 so leaving it the same.");
+								
+								FAPI_DBG("BYTE DISABLE WORKAROUND: PRE data rank 0 =0x%04X rank 1 =0x%04X rank 2 =0x%04X rank 3 =0x%04X rank 4 =0x%04X rank 5 =0x%04X rank 6 =0x%04X rank 7 =0x%04X", l_data_rank0,l_data_rank1,l_data_rank2,l_data_rank3,l_data_rank4,l_data_rank5,l_data_rank6,l_data_rank7 );
+								l_data_rank0 = (l_data_rank0) | ( l_data & nmask); 
+								l_data_rank1 = (l_data_rank1) | ( l_data & nmask); 
+								l_data_rank2 = (l_data_rank2) | ( l_data & nmask); 
+								l_data_rank3 = (l_data_rank3) | ( l_data & nmask);
+								l_data_rank4 = (l_data_rank4) | ( l_data & nmask); 
+								l_data_rank5 = (l_data_rank5) | ( l_data & nmask); 
+								l_data_rank6 = (l_data_rank6) | ( l_data & nmask); 
+								l_data_rank7 = (l_data_rank7) | ( l_data & nmask);
+
+								FAPI_DBG("BYTE DISABLE WORKAROUND: POST data rank 0 =0x%04X rank 1 =0x%04X rank 2 =0x%04X rank 3 =0x%04X rank 4 =0x%04X rank 5 =0x%04X rank 6 =0x%04X rank 7 =0x%04X", l_data_rank0,l_data_rank1,l_data_rank2,l_data_rank3,l_data_rank4,l_data_rank5,l_data_rank6,l_data_rank7 );
+							}
+
+
+
+
+					}
+					// Temporarily Removing the 0xE case with this workaround.
+					/*
+					else if ((nmask & l_data_curr_vpd) == e_nmask) {
+						FAPI_DBG("BYTE DISABLE WORKAROUND: Found a 0XE on nibble=%i Port%i, dimm=%i, prg%i rank=%i data= 0x%04X", n, port, dimm, prank, rank, l_data);
+						if (i_training_success)
+						{
+							//Leave it an E.
+							FAPI_DBG("BYTE DISABLE WORKAROUND: Training was successful so writing an 0xE to VPD.");
+						}
+						else
+						{
+							//Replacing E nibble with F nibble
+							FAPI_DBG("BYTE DISABLE WORKAROUND: Training failed so writing an 0xF to VPD for all ranks.");
+							l_data = l_data  | nmask; 
+							l_data_rank0 = l_data_rank0  | nmask; 
+							l_data_rank1 = l_data_rank1  | nmask; 
+							l_data_rank2 = l_data_rank2  | nmask; 
+							l_data_rank3 = l_data_rank3  | nmask; 
+							l_data_rank4 = l_data_rank4  | nmask; 
+							l_data_rank5 = l_data_rank5  | nmask; 
+							l_data_rank6 = l_data_rank6  | nmask; 
+							l_data_rank7 = l_data_rank7  | nmask; 
+						}
+					}
+					*/
+				}
+
+				if (dimm == 0)
+				{
+					if (rank == 0)
+					{
+						l_data_rank0 = l_data;
+					}
+					else if (rank == 1)
+					{
+						l_data_rank1 = l_data;
+					}
+					else if (rank == 2)
+					{
+						l_data_rank2 = l_data;
+					}
+					else if (rank == 3)
+					{
+						l_data_rank3 = l_data;
+					}
+				}
+				else if (dimm == 1)
+				{
+					if (rank == 0)
+					{
+						l_data_rank4 = l_data;
+					}
+					else if (rank == 1)
+					{
+						l_data_rank5 = l_data;
+					}
+					else if (rank == 2)
+					{
+						l_data_rank6 = l_data;
+					}
+					else if (rank == 3)
+					{
+						l_data_rank7 = l_data;
+					}
+				}
+
+
+				l_ecmdRc |= db_reg_dimm0_rank0.setHalfWord(i, l_data_rank0);
+				l_ecmdRc |= db_reg_dimm0_rank1.setHalfWord(i, l_data_rank1);
+				l_ecmdRc |= db_reg_dimm0_rank2.setHalfWord(i, l_data_rank2);
+				l_ecmdRc |= db_reg_dimm0_rank3.setHalfWord(i, l_data_rank3);
+
+				l_ecmdRc |= db_reg_dimm1_rank0.setHalfWord(i, l_data_rank4);
+				l_ecmdRc |= db_reg_dimm1_rank1.setHalfWord(i, l_data_rank5);
+				l_ecmdRc |= db_reg_dimm1_rank2.setHalfWord(i, l_data_rank6);
+				l_ecmdRc |= db_reg_dimm1_rank3.setHalfWord(i, l_data_rank7);
+
+				if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+				{
+					 FAPI_ERR("Error from ecmdDataBuffer flushTo0() "
+							 "- rc 0x%.8X", l_ecmdRc);
+					 rc.setEcmdError(l_ecmdRc);
+					 return rc;
+				}
+
+
+			}
+
+
+		}// end of primary rank loop
+
+
+		// loop through primary ranks [0:3]
+		for (uint8_t prank = 0; prank < MAX_PRI_RANKS; prank++ )
+		{
+			dimm = prg[prank][port] >> 2;
+			uint8_t rank = prg[prank][port] & 0x03;
+			FAPI_DBG("BYTE DISABLE WORKAROUND: Looping through dimm: %d rank: %d ", dimm, rank);
+
+			if (prg[prank][port] == rg_invalid[prank])	// invalid rank
+			{
+				FAPI_DBG("Primary rank group %i is INVALID, continuing...",
+						prank);
+				continue;
+			}
+
+			if (dimm == 0)
+			{
+				if (rank == 0)
+				{
+					l_ecmdRc |= db_reg_dimm0_rank0.copy(db_reg);
+				}
+				else if (rank == 1)
+				{
+					l_ecmdRc |= db_reg_dimm0_rank1.copy(db_reg);
+				}
+				else if (rank == 2)
+				{
+					l_ecmdRc |= db_reg_dimm0_rank2.copy(db_reg);
+				}
+				else if (rank == 3)
+				{
+
+					l_ecmdRc |= db_reg_dimm0_rank3.copy(db_reg);
+				}
+			}
+			else if (dimm == 1)
+			{
+				if (rank == 0)
+				{
+					l_ecmdRc |= db_reg_dimm1_rank0.copy(db_reg);
+				}
+				else if (rank == 1)
+				{
+					l_ecmdRc |= db_reg_dimm1_rank1.copy(db_reg);
+				}
+				else if (rank == 2)
+				{
+					l_ecmdRc |= db_reg_dimm1_rank2.copy(db_reg);
+				}
+				else if (rank == 3)
+				{
+					l_ecmdRc |= db_reg_dimm1_rank3.copy(db_reg);
+				}
+			}
+
+			if (l_ecmdRc != ECMD_DBUF_SUCCESS)
+			{
+				 FAPI_ERR("Error from ecmdDataBuffer flushTo0() "
+						 "- rc 0x%.8X", l_ecmdRc);
+				 rc.setEcmdError(l_ecmdRc);
+				 return rc;
+			}
+
+			FAPI_INF("Setting BBM across dimm: %d rank: %d", dimm, rank);
+			rc = setC4dq2reg(mba_target, port, dimm, rank, db_reg);
+			if (rc)
+			{
+				FAPI_ERR("Error from setting register bitmap p%i: "
+					"dimm=%i, rank=%i rc=%i", port, dimm, rank,
+					static_cast<uint32_t>(rc));
+				return rc;
+			}
+
+		}// end of primary rank loop
+
+
+
+	} // end port loop
     return rc;
 } // end mss_get_bbm_regs
 
 
 ReturnCode getC4dq2reg(const Target & i_mba, const uint8_t i_port,
-                const uint8_t i_dimm, const uint8_t i_rank, ecmdDataBufferBase &o_reg, uint8_t &is_clean)
+		const uint8_t i_dimm, const uint8_t i_rank, ecmdDataBufferBase &o_reg, uint8_t &is_clean)
 {
 // used by set_bbm(flash to registers)
 // calls dimmGetBadDqBitmap and converts the data to phy order in a databuffer
 // output reg = in phy based order(lanes)
 
-    uint8_t l_bbm[TOTAL_BYTES] = {0};   // bad bitmap from dimmGetBadDqBitmap
+    uint8_t l_bbm[TOTAL_BYTES] = {0};	// bad bitmap from dimmGetBadDqBitmap
     ReturnCode rc;
     uint32_t ecmdrc = ECMD_DBUF_SUCCESS;
-        uint8_t dq;
-        uint8_t phy_lane, phy_block;
+ 	uint8_t dq;
+	uint8_t phy_lane, phy_block;
 
-    ecmdrc = o_reg.flushTo0();          // clear output databuffer
+    ecmdrc = o_reg.flushTo0();		// clear output databuffer
     if (ecmdrc != ECMD_DBUF_SUCCESS)
     {
-                FAPI_ERR("Error from ecmdDataBuffer flushTo0() "
-                         "- rc 0x%.8X", ecmdrc);
+		FAPI_ERR("Error from ecmdDataBuffer flushTo0() "
+			 "- rc 0x%.8X", ecmdrc);
 
-                rc.setEcmdError(ecmdrc);
-                return rc;
+		rc.setEcmdError(ecmdrc);
+		return rc;
     }
 
     // get Centaur dq bitmap (C4 signal) order=[0:79], array of bytes
-    rc = dimmGetBadDqBitmap(i_mba, i_port, i_dimm, i_rank, l_bbm);
+    rc = dimmGetBadDqBitmap(i_mba, i_port, i_dimm, i_rank, l_bbm); 
     if (rc)
     {
-                FAPI_ERR("Error from dimmGetBadDqBitmap on port %i: "
-                         "dimm=%i, rank=%i rc=%i", i_port, i_dimm, i_rank,
-                         static_cast<uint32_t>(rc));
-                return rc;
-    }
-
-        uint8_t dimm_spare[MAX_PORTS][MAX_DIMMS][MAX_PRI_RANKS];
-        rc = FAPI_ATTR_GET(ATTR_VPD_DIMM_SPARE, &i_mba, dimm_spare);
-        if(rc) return rc;
-
-        for (uint8_t byte=0; byte < TOTAL_BYTES; byte++)
-        {
-                if (l_bbm[byte] != 0)
-                {
-                        if (byte == (TOTAL_BYTES-1))            // spare byte
-                        {
-                                uint8_t spare_bitmap = 0;
-
-                                switch (dimm_spare[i_port][i_dimm][i_rank])
-                        {
-                                case ENUM_ATTR_VPD_DIMM_SPARE_NO_SPARE: // 0xFF
-                                    continue;                                                   // ignore bbm data for nonexistent spare
-                            break;
-                                case ENUM_ATTR_VPD_DIMM_SPARE_LOW_NIBBLE:
-                                    spare_bitmap = 0x0F;
-                            break;
-                                case ENUM_ATTR_VPD_DIMM_SPARE_HIGH_NIBBLE:
-                                    spare_bitmap = 0xF0;
-                            break;
-                                case ENUM_ATTR_VPD_DIMM_SPARE_FULL_BYTE:
-                                    spare_bitmap = 0x00;
-                            break;
-                                        default:
-
-                                                //DECONFIG and FFDC INFO
-                                                const fapi::Target & TARGET_MBA_ERROR = i_mba;
-                                                const uint8_t & SPARE = dimm_spare[i_port][i_dimm][i_rank];
-                                                const uint8_t & PORT = i_port;
-                                                const uint8_t & DIMM = i_dimm;
-                                                const uint8_t & RANK = i_rank;
-
-                                                FAPI_ERR("ATTR_VPD_DIMM_SPARE is invalid %u",
-                                                        dimm_spare[i_port][i_dimm][i_rank]);
-                                                FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_DIMM_SPARE_INPUT_ERROR);
-                                                return rc;
-                                }
-
-                                if (l_bbm[byte] == spare_bitmap)        // spare already set via initfile
-                                        continue;
-                        }
-
-                        uint8_t bs=0;
-                        uint8_t be=8;
-                        uint8_t loc=0;
-                        is_clean = 0;
-
-                        if ((l_bbm[byte] & 0xF0) == 0xF0)       // 0xF?
-                        {
-                                dq = (byte * 8);                // for first lane
-                                // input=cen_c4_dq, output=phy block, lane
-                                rc = mss_c4_phy(i_mba, i_port, 0, RD_DQ,dq,
-                                                0, phy_lane,phy_block, 0);
-                                if (rc) return rc;
-
-                                if (l_bbm[byte] == 0xFF)
-                                {       // block lanes + 1st lane{0,8}
-                                        loc = (phy_block * 16) + (phy_lane & 0x08);
-                                        o_reg.setBit(loc, 8);   // set dq byte
-                                        FAPI_DBG("0xFF  byte=%i, lbbm=0x%02x  dp%i_%i dq=%i o=%i",
-                                                byte, l_bbm[byte], phy_block, phy_lane, dq, loc);
-                                        continue;
-                                }
-                                // block lanes + 1st lane{0,4,8,12}
-                                loc = (phy_block * 16) + (phy_lane & 0x0C);
-                                o_reg.setBit(loc, 4);           // set dq nibble0
-                                FAPI_DBG("0xF0  byte=%i, lbbm=0x%02x  dp%i_%i dq=%i o=%i",
-                                        byte, l_bbm[byte], phy_block, phy_lane, dq, loc);
-
-                                if (l_bbm[byte] == 0xF0)                        // done with byte
-                                        continue;
-                                bs=4;           // processed the first 4 bits already
-                        }
-                        else if ((l_bbm[byte] & 0x0F) == 0x0F)  // 0x?F
-                        {
-                                dq = (byte * 8) + 4;            // for first lane of dq
-                                rc = mss_c4_phy(i_mba, i_port, 0, RD_DQ,dq,
-                                                0, phy_lane, phy_block, 0);
-                                if (rc) return rc;
-                                // block lanes + 1st lane{0,4,8,12}
-                                loc = (phy_block * 16) + (phy_lane & 0x0C);
-                                FAPI_DBG("0x0F  byte=%i, lbbm=0x%02x  dp%i_%i dq=%i o=%i",
-                                        byte, l_bbm[byte], phy_block, phy_lane, dq, loc);
-                                o_reg.setBit(loc, 4);                           // set dq nibble1
-                                if (l_bbm[byte] == 0x0F)                        // done with byte
-                                        continue;
-                                be=4;           // processed the last 4 bits already
-                        }
-                        else if ((l_bbm[byte] >> 4) == 0)       // 0x0?
-                                bs=4;
-                        else if ((l_bbm[byte] & 0x0F) == 0)     // 0x?0
-                                be=4;
-
-                        for (uint8_t b=bs; b < be; b++)         // test each bit
-                        {
-                                if ((l_bbm[byte] & (0x80 >> b)) > 0)            // bit is set,
-                                {
-                                        dq = (byte * 8) + b;
-                                        rc=mss_c4_phy(i_mba, i_port, 0, RD_DQ,dq,
-                                                   0, phy_lane, phy_block, 0);
-                                        if (rc) return rc;
-                                        loc = (phy_block * 16) + phy_lane;
-                                        o_reg.setBit(loc);
-                                        FAPI_DBG("b=%i  byte=%i, lbbm=0x%02x  dp%i_%i dq=%i "
-                                                "loc=%i bs=%i be=%i", b, byte, l_bbm[byte],
-                                                phy_block, phy_lane, dq, loc, bs, be);
-                                }
-                        }
-                } // end if not clean
-        } // end byte
-        return rc;
+		FAPI_ERR("Error from dimmGetBadDqBitmap on port %i: "
+			 "dimm=%i, rank=%i rc=%i", i_port, i_dimm, i_rank,
+			 static_cast<uint32_t>(rc));
+		return rc;
+    }
+
+	uint8_t dimm_spare[MAX_PORTS][MAX_DIMMS][MAX_PRI_RANKS];
+	rc = FAPI_ATTR_GET(ATTR_VPD_DIMM_SPARE, &i_mba, dimm_spare);
+	if(rc) return rc;
+
+	for (uint8_t byte=0; byte < TOTAL_BYTES; byte++)
+	{
+		if (l_bbm[byte] != 0)
+		{
+			if (byte == (TOTAL_BYTES-1))		// spare byte
+			{
+				uint8_t spare_bitmap = 0;
+
+				switch (dimm_spare[i_port][i_dimm][i_rank])
+    			{
+			        case ENUM_ATTR_VPD_DIMM_SPARE_NO_SPARE:	// 0xFF
+			            continue;							// ignore bbm data for nonexistent spare
+		            break;
+			        case ENUM_ATTR_VPD_DIMM_SPARE_LOW_NIBBLE:
+			            spare_bitmap = 0x0F;
+		            break;
+			        case ENUM_ATTR_VPD_DIMM_SPARE_HIGH_NIBBLE:
+			            spare_bitmap = 0xF0;
+		            break;
+			        case ENUM_ATTR_VPD_DIMM_SPARE_FULL_BYTE:
+			            spare_bitmap = 0x00;
+		            break;
+					default:
+
+						//DECONFIG and FFDC INFO
+						const fapi::Target & TARGET_MBA_ERROR = i_mba;
+                        			const uint8_t & SPARE = dimm_spare[i_port][i_dimm][i_rank];
+                        			const uint8_t & PORT = i_port;
+                        			const uint8_t & DIMM = i_dimm;
+                        			const uint8_t & RANK = i_rank;
+
+						FAPI_ERR("ATTR_VPD_DIMM_SPARE is invalid %u", 
+							dimm_spare[i_port][i_dimm][i_rank]);
+						FAPI_SET_HWP_ERROR(rc, RC_MSS_DRAMINIT_TRAINING_DIMM_SPARE_INPUT_ERROR);
+						return rc;
+				}
+
+				if (l_bbm[byte] == spare_bitmap)	// spare already set via initfile
+					continue;
+			}
+
+			uint8_t bs=0;
+			uint8_t be=8;
+			uint8_t loc=0;
+			is_clean = 0;
+
+			if ((l_bbm[byte] & 0xF0) == 0xF0)	// 0xF?
+			{
+				dq = (byte * 8);		// for first lane
+				// input=cen_c4_dq, output=phy block, lane
+				rc = mss_c4_phy(i_mba, i_port, 0, RD_DQ,dq,
+						0, phy_lane,phy_block, 0);
+				if (rc) return rc;
+
+				if (l_bbm[byte] == 0xFF)
+				{	// block lanes + 1st lane{0,8}
+					loc = (phy_block * 16) + (phy_lane & 0x08);
+					o_reg.setBit(loc, 8); 	// set dq byte
+					FAPI_DBG("0xFF  byte=%i, lbbm=0x%02x  dp%i_%i dq=%i o=%i",
+						byte, l_bbm[byte], phy_block, phy_lane, dq, loc);
+					continue;
+				}
+				// block lanes + 1st lane{0,4,8,12}
+				loc = (phy_block * 16) + (phy_lane & 0x0C);
+				o_reg.setBit(loc, 4);		// set dq nibble0
+				FAPI_DBG("0xF0  byte=%i, lbbm=0x%02x  dp%i_%i dq=%i o=%i",
+					byte, l_bbm[byte], phy_block, phy_lane, dq, loc);
+
+				if (l_bbm[byte] == 0xF0)			// done with byte
+					continue;
+				bs=4;		// processed the first 4 bits already
+			}
+			else if ((l_bbm[byte] & 0x0F) == 0x0F)	// 0x?F
+			{
+				dq = (byte * 8) + 4;		// for first lane of dq
+				rc = mss_c4_phy(i_mba, i_port, 0, RD_DQ,dq,
+						0, phy_lane, phy_block, 0);
+				if (rc) return rc;
+				// block lanes + 1st lane{0,4,8,12}
+				loc = (phy_block * 16) + (phy_lane & 0x0C);
+				FAPI_DBG("0x0F  byte=%i, lbbm=0x%02x  dp%i_%i dq=%i o=%i",
+					byte, l_bbm[byte], phy_block, phy_lane, dq, loc);
+				o_reg.setBit(loc, 4);				// set dq nibble1
+				if (l_bbm[byte] == 0x0F)			// done with byte
+					continue;
+				be=4;		// processed the last 4 bits already
+			}
+			else if ((l_bbm[byte] >> 4) == 0)	// 0x0?
+				bs=4;
+			else if ((l_bbm[byte] & 0x0F) == 0)	// 0x?0
+				be=4;
+
+			for (uint8_t b=bs; b < be; b++)		// test each bit
+			{
+				if ((l_bbm[byte] & (0x80 >> b)) > 0)		// bit is set,
+				{
+					dq = (byte * 8) + b;
+					rc=mss_c4_phy(i_mba, i_port, 0, RD_DQ,dq,
+						   0, phy_lane, phy_block, 0);
+					if (rc) return rc;
+					loc = (phy_block * 16) + phy_lane;
+					o_reg.setBit(loc);
+					FAPI_DBG("b=%i  byte=%i, lbbm=0x%02x  dp%i_%i dq=%i "
+						"loc=%i bs=%i be=%i", b, byte, l_bbm[byte],
+						phy_block, phy_lane, dq, loc, bs, be);
+				}
+			}
+		} // end if not clean
+	} // end byte
+	return rc;
 } // end getC4dq2reg
 
 
@@ -7362,115 +7504,115 @@ ReturnCode setC4dq2reg(const Target &i_mba, const uint8_t i_port,
 // Converts the data from phy order (i_reg) to cen_c4_dq array
 // for dimmSetBadDqBitmap to write flash with
 
-        ReturnCode rc;
-        uint8_t l_bbm [TOTAL_BYTES] = {0};
-        uint8_t dq=0;
-        uint8_t phy_lane;
-        uint8_t phy_block;
-        uint8_t data;
+	ReturnCode rc;
+	uint8_t l_bbm [TOTAL_BYTES] = {0};
+	uint8_t dq=0;
+	uint8_t phy_lane;
+	uint8_t phy_block;
+ 	uint8_t data;
 
 
     // get Centaur dq bitmap (C4 signal) order=[0:79], array of bytes
-    rc = dimmGetBadDqBitmap(i_mba, i_port, i_dimm, i_rank, l_bbm);
+    rc = dimmGetBadDqBitmap(i_mba, i_port, i_dimm, i_rank, l_bbm); 
     if (rc)
     {
-                FAPI_ERR("Error from dimmGetBadDqBitmap on port %i: "
-                         "dimm=%i, rank=%i rc=%i", i_port, i_dimm, i_rank,
-                         static_cast<uint32_t>(rc));
-                return rc;
-    }
-
-        for (uint8_t byte=0; byte < TOTAL_BYTES; byte++)
-        {
-                data = i_reg.getByte(byte);
-                if (data != 0)                          // need to check bits
-                {
-                        uint8_t bs=0;
-                        uint8_t be=8;
-
-                        phy_block = (byte / 2);         // byte=[0..9], block=[0..4]
-                        FAPI_DBG("\n\t\t\t\t\t\tbyte=%i, data=0x%02x  phy_block=%i  ",
-                                byte, data, phy_block);
-                        if ((data & 0xF0) == 0xF0)      // 0xF?
-                        {
-                                phy_lane = 8 * (byte % 2);      // lane=[0,8]
-                                // input=block, lane  output=cen_dq
-                                rc = mss_c4_phy(i_mba, i_port, 0, RD_DQ,dq,
-                                                0, phy_lane, phy_block, 1);
-                                if (rc) return rc;
-
-                                if (data == 0xFF)
-                                {       // set 8 consecutive bits of the cen_c4_dq
-                                        l_bbm[(dq/8)] = 0xFF;
-                                        FAPI_DBG("0xFF dp%i_%i dq=%i, lbbm=0x%02x",
-                                                phy_block, phy_lane, dq, l_bbm[dq/8]);
-                                        continue;
-                                }
-
-                                l_bbm[(dq/8)] |= ((dq % 8) < 4) ? 0xF0 : 0x0F;
-                                FAPI_DBG("0xF0 dp%i_%i dq=%i, lbbm=0x%02x",
-                                        phy_block, phy_lane, dq, l_bbm[dq/8]);
-
-                                if (data == 0xF0)                       // done with byte
-                                        continue;
-                                bs=4;                   // need to work on other bits
-                        }
-                        else if ((data & 0x0F) == 0x0F) // 0x?F
-                        {
-                                phy_lane = (8 * (byte % 2)) + 4;        // lane=[4,12]
-                                rc = mss_c4_phy(i_mba, i_port, 0, RD_DQ, dq,
-                                                0, phy_lane, phy_block, 1);
-                                if (rc) return rc;
-
-                                l_bbm[(dq/8)] |= ((dq % 8) < 4) ? 0xF0 : 0x0F;
-                                FAPI_DBG("0x0F dp%i_%i dq=%i, lbbm=0x%02x",
-                                           phy_block, phy_lane, dq, l_bbm[dq/8]);
-
-                                if (data == 0x0F)                       // done with byte
-                                        continue;
-                                be=4;                   // need to work on other bits
-                        }
-                        else if ((data >> 4) == 0)      // 0x0?
-                                bs=4;
-                        else if ((data & 0x0F) == 0)    // 0x?0
-                                be=4;
-
-                        for (uint8_t b=bs; b < be; b++)         // test each bit
-                        {
-                                if ((data & (0x80 >> b)) > 0)           // bit is set,
-                                {
-                                        phy_lane = (8 * (byte % 2)) + b;
-                                        rc = mss_c4_phy(i_mba, i_port, 0, RD_DQ, dq,
-                                                        0, phy_lane, phy_block, 1);
-                                        if (rc) return rc;
-                                        l_bbm[(dq/8)] |= (0x80 >> (dq % 8));
-
-                                }
-                                else            // bit is not set,
-                                {
-                                        phy_lane = (8 * (byte % 2)) + b;
-                                        rc = mss_c4_phy(i_mba, i_port, 0, RD_DQ, dq,
-                                                        0, phy_lane, phy_block, 1);
-                                        if (rc) return rc;
-                                        l_bbm[(dq/8)] &= (~(0x80 >> (dq % 8)));
-
-                                }
-                        }
-                } //end if not clean
-        } //end byte
-
-        // set Centaur dq bitmap (C4 signal) order=[0:79], array of bytes
-        rc = dimmSetBadDqBitmap(i_mba, i_port, i_dimm, i_rank, l_bbm);
-        if (rc)
-        {
-
-                FAPI_ERR("Error from dimmSetBadDqBitmap on port %i: "
-                        "dimm=%i, rank=%i rc=%i", i_port, i_dimm, i_rank,
-                        static_cast<uint32_t>(rc));
-                return rc;
-        }
-
-        return rc;
+		FAPI_ERR("Error from dimmGetBadDqBitmap on port %i: "
+			 "dimm=%i, rank=%i rc=%i", i_port, i_dimm, i_rank,
+			 static_cast<uint32_t>(rc));
+		return rc;
+    }
+
+	for (uint8_t byte=0; byte < TOTAL_BYTES; byte++)
+	{
+		data = i_reg.getByte(byte);
+		if (data != 0)				// need to check bits
+		{
+			uint8_t bs=0;
+			uint8_t be=8;
+
+			phy_block = (byte / 2);		// byte=[0..9], block=[0..4]
+			FAPI_DBG("\n\t\t\t\t\t\tbyte=%i, data=0x%02x  phy_block=%i  ",
+				byte, data, phy_block);
+			if ((data & 0xF0) == 0xF0)	// 0xF?
+			{
+				phy_lane = 8 * (byte % 2);	// lane=[0,8]
+				// input=block, lane  output=cen_dq
+				rc = mss_c4_phy(i_mba, i_port, 0, RD_DQ,dq,
+						0, phy_lane, phy_block, 1);
+				if (rc) return rc;
+
+				if (data == 0xFF)
+				{	// set 8 consecutive bits of the cen_c4_dq
+					l_bbm[(dq/8)] = 0xFF;
+					FAPI_DBG("0xFF dp%i_%i dq=%i, lbbm=0x%02x",
+						phy_block, phy_lane, dq, l_bbm[dq/8]);
+					continue;
+				}
+
+				l_bbm[(dq/8)] |= ((dq % 8) < 4) ? 0xF0 : 0x0F;
+				FAPI_DBG("0xF0 dp%i_%i dq=%i, lbbm=0x%02x",
+					phy_block, phy_lane, dq, l_bbm[dq/8]);
+
+				if (data == 0xF0)			// done with byte
+					continue;
+				bs=4;			// need to work on other bits
+			}
+			else if ((data & 0x0F) == 0x0F)	// 0x?F
+			{
+				phy_lane = (8 * (byte % 2)) + 4;	// lane=[4,12]
+				rc = mss_c4_phy(i_mba, i_port, 0, RD_DQ, dq,
+						0, phy_lane, phy_block, 1);
+				if (rc) return rc;
+
+				l_bbm[(dq/8)] |= ((dq % 8) < 4) ? 0xF0 : 0x0F;
+				FAPI_DBG("0x0F dp%i_%i dq=%i, lbbm=0x%02x",
+					   phy_block, phy_lane, dq, l_bbm[dq/8]);
+
+				if (data == 0x0F)			// done with byte
+					continue;
+				be=4;			// need to work on other bits
+			}
+			else if ((data >> 4) == 0)	// 0x0?
+				bs=4;
+			else if ((data & 0x0F) == 0)	// 0x?0
+				be=4;
+
+			for (uint8_t b=bs; b < be; b++)		// test each bit
+			{
+				if ((data & (0x80 >> b)) > 0)		// bit is set,
+				{
+					phy_lane = (8 * (byte % 2)) + b;
+					rc = mss_c4_phy(i_mba, i_port, 0, RD_DQ, dq,
+							0, phy_lane, phy_block, 1);
+					if (rc) return rc;
+					l_bbm[(dq/8)] |= (0x80 >> (dq % 8));
+
+				}
+				else		// bit is not set,
+				{
+					phy_lane = (8 * (byte % 2)) + b;
+					rc = mss_c4_phy(i_mba, i_port, 0, RD_DQ, dq,
+							0, phy_lane, phy_block, 1);
+					if (rc) return rc;
+					l_bbm[(dq/8)] &= (~(0x80 >> (dq % 8)));
+
+				}
+			}
+		} //end if not clean
+	} //end byte
+
+	// set Centaur dq bitmap (C4 signal) order=[0:79], array of bytes
+	rc = dimmSetBadDqBitmap(i_mba, i_port, i_dimm, i_rank, l_bbm);
+	if (rc)
+	{
+
+		FAPI_ERR("Error from dimmSetBadDqBitmap on port %i: "
+			"dimm=%i, rank=%i rc=%i", i_port, i_dimm, i_rank,
+			static_cast<uint32_t>(rc));
+		return rc;
+	}
+
+	return rc;
 } //end setC4dq2reg
 
 
@@ -7479,17 +7621,17 @@ fapi::ReturnCode mss_setup_dqs_offset(Target &i_target) {
    fapi::ReturnCode rc;
    uint32_t rc_num = 0;
    ecmdDataBufferBase buffer(64);
-   uint64_t scom_addr_array[10] = {DPHY01_DDRPHY_DP18_DQSCLK_OFFSET_P0_0_0x800000370301143F ,
-      DPHY01_DDRPHY_DP18_DQSCLK_OFFSET_P0_1_0x800004370301143F ,
-      DPHY01_DDRPHY_DP18_DQSCLK_OFFSET_P0_2_0x800008370301143F ,
-      DPHY01_DDRPHY_DP18_DQSCLK_OFFSET_P0_3_0x80000C370301143F ,
-      DPHY01_DDRPHY_DP18_DQSCLK_OFFSET_P0_4_0x800010370301143F ,
-      DPHY01_DDRPHY_DP18_DQSCLK_OFFSET_P1_0_0x800100370301143F ,
-      DPHY01_DDRPHY_DP18_DQSCLK_OFFSET_P1_1_0x800104370301143F ,
-      DPHY01_DDRPHY_DP18_DQSCLK_OFFSET_P1_2_0x800108370301143F ,
-      DPHY01_DDRPHY_DP18_DQSCLK_OFFSET_P1_3_0x80010C370301143F ,
+   uint64_t scom_addr_array[10] = {DPHY01_DDRPHY_DP18_DQSCLK_OFFSET_P0_0_0x800000370301143F , 
+      DPHY01_DDRPHY_DP18_DQSCLK_OFFSET_P0_1_0x800004370301143F , 
+      DPHY01_DDRPHY_DP18_DQSCLK_OFFSET_P0_2_0x800008370301143F , 
+      DPHY01_DDRPHY_DP18_DQSCLK_OFFSET_P0_3_0x80000C370301143F , 
+      DPHY01_DDRPHY_DP18_DQSCLK_OFFSET_P0_4_0x800010370301143F , 
+      DPHY01_DDRPHY_DP18_DQSCLK_OFFSET_P1_0_0x800100370301143F , 
+      DPHY01_DDRPHY_DP18_DQSCLK_OFFSET_P1_1_0x800104370301143F , 
+      DPHY01_DDRPHY_DP18_DQSCLK_OFFSET_P1_2_0x800108370301143F , 
+      DPHY01_DDRPHY_DP18_DQSCLK_OFFSET_P1_3_0x80010C370301143F , 
       DPHY01_DDRPHY_DP18_DQSCLK_OFFSET_P1_4_0x800110370301143F};
-
+      
    FAPI_INF("DDR4: setting up DQS offset to be 16");
    for(uint8_t scom_addr = 0; scom_addr < 10; ++scom_addr) {
       rc = fapiGetScom(i_target, scom_addr_array[scom_addr], buffer);
@@ -7499,13 +7641,13 @@ fapi::ReturnCode mss_setup_dqs_offset(Target &i_target) {
       if (rc_num)
       {
          FAPI_ERR( "mss_setup_dqs: Error setting up buffers");
-         rc.setEcmdError(rc_num);
-         return rc;
+    	 rc.setEcmdError(rc_num);
+    	 return rc;
       }
       rc = fapiPutScom(i_target, scom_addr_array[scom_addr], buffer);
       if(rc) return rc;
    }
-
+   
    return rc;
 }
 
diff --git a/src/usr/hwpf/hwp/dram_training/mss_funcs.C b/src/usr/hwpf/hwp/dram_training/mss_funcs.C
index 2c1accb..be85e1c 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_funcs.C
+++ b/src/usr/hwpf/hwp/dram_training/mss_funcs.C
@@ -22,12 +22,13 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_funcs.C,v 1.43 2015/09/10 14:57:26 thi Exp $
+// $Id: mss_funcs.C,v 1.45 2015/11/09 17:22:06 sglancy Exp $
 /* File mss_funcs.C created by SLOAT JACOB D. (JAKE),2D3970 on Fri Apr 22 2011. */
 
 //------------------------------------------------------------------------------
 // *! (C) Copyright International Business Machines Corp. 2007
 // *! All Rights Reserved -- Property of IBM
+// *! *** IBM Confidential ***
 //------------------------------------------------------------------------------
 // *! TITLE : mss_funcs.C
 // *! DESCRIPTION : Tools for centaur procedures
@@ -44,6 +45,7 @@
 //------------------------------------------------------------------------------
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|-----------------------------------------------
+//  1.44   | rwheeler |23-OCT-15| ccs toggle between ports bug 
 //  1.43   | thi      |10-SEP-15| Fixed more RC stuff
 //  1.42   | kmack    |03-SEP-15| Fixed up some RC stuff
 //  1.41   | sglancy  |21-AUG-15| Fixed ODT initialization bug - ODT must be held low through ZQ cal
@@ -135,7 +137,7 @@ ReturnCode mss_ccs_set_end_bit(
 
     i_instruction_number = i_instruction_number + 1;
 
-    FAPI_INF( "Setting End Bit on instruction (NOP): %d.", i_instruction_number);
+    FAPI_DBG( "Setting End Bit on instruction (NOP): %d.", i_instruction_number);
 
     // Single NOP with CKE raised high and the end bit set high
     rc_num = rc_num | csn_8.setBit(0,8);
@@ -209,9 +211,9 @@ ReturnCode mss_address_mirror_swizzle(
         FAPI_INF( "ADDRESS MIRRORING ON %s PORT%d DIMM%d RANK%d", i_target.toEcmdString(), i_port, i_dimm, i_rank);
 
         rc_num = rc_num | io_address.extractPreserve(&mirror_mode_ad, 0, 16, 0);
-        FAPI_INF( "PRE - MIRROR MODE ADDRESS: 0x%04X", mirror_mode_ad);
+        FAPI_DBG( "PRE - MIRROR MODE ADDRESS: 0x%04X", mirror_mode_ad);
         rc_num = rc_num | io_bank.extractPreserve(&mirror_mode_ba, 0, 3, 0);
-        FAPI_INF( "PRE - MIRROR MODE BANK ADDRESS: 0x%04X", mirror_mode_ba);
+        FAPI_DBG( "PRE - MIRROR MODE BANK ADDRESS: 0x%04X", mirror_mode_ba);
 
         //Initialize address and bank address as the same pre mirror mode swizzle
         rc_num = rc_num | address_post_swizzle_16.insert(io_address, 0, 16, 0);
@@ -283,9 +285,9 @@ ReturnCode mss_address_mirror_swizzle(
         }
 
         rc_num = rc_num | address_post_swizzle_16.extractPreserve(&mirror_mode_ad, 0, 16, 0);
-        FAPI_INF( "POST - MIRROR MODE ADDRESS: 0x%04X", mirror_mode_ad);
+        FAPI_DBG( "POST - MIRROR MODE ADDRESS: 0x%04X", mirror_mode_ad);
         rc_num = rc_num | bank_post_swizzle_3.extractPreserve(&mirror_mode_ba, 0, 3, 0);
-        FAPI_INF( "POST - MIRROR MODE BANK ADDRESS: 0x%04X", mirror_mode_ba);
+        FAPI_DBG( "POST - MIRROR MODE BANK ADDRESS: 0x%04X", mirror_mode_ba);
 
         //copy address and bank address back to the IO variables
         rc_num = rc_num | io_address.insert(address_post_swizzle_16, 0, 16, 0);
@@ -347,16 +349,23 @@ ReturnCode mss_ccs_inst_arry_0(
     rc_num = rc_num | data_buffer.insert(i_cke, 24, 4, 0);
     rc_num = rc_num | data_buffer.insert(i_cke, 28, 4, 0);
 
-    if (i_port == 0)
+    if (i_port == 3)
     {
         rc_num = rc_num | data_buffer.insert(i_csn, 32, 8, 0);
-        rc_num = rc_num | data_buffer.insertFromRight((uint8_t)0xFF,40,8);
+        rc_num = rc_num | data_buffer.insert(i_csn, 40, 8, 0);
+        rc_num = rc_num | data_buffer.insert(i_odt, 48, 4, 0);
+        rc_num = rc_num | data_buffer.insert(i_odt, 52, 4, 0);
+    }
+    else if (i_port == 0)
+    {
+        rc_num = rc_num | data_buffer.insert(i_csn, 32, 8, 0);
+        rc_num = rc_num | data_buffer.setBit(40, 8);
         rc_num = rc_num | data_buffer.insert(i_odt, 48, 4, 0);
         rc_num = rc_num | data_buffer.insertFromRight((uint8_t)0x00,52,4);
     }
     else
     {
-        rc_num = rc_num | data_buffer.insert((uint8_t)0xFF,32,8);
+        rc_num = rc_num | data_buffer.setBit(32, 8);
         rc_num = rc_num | data_buffer.insert(i_csn, 40, 8, 0);
         rc_num = rc_num | data_buffer.insertFromRight((uint8_t)0x00,48,4);
         rc_num = rc_num | data_buffer.insert(i_odt, 52, 4, 0);
@@ -488,7 +497,7 @@ ReturnCode mss_ccs_load_data_pattern(
 
     if (io_instruction_number > 31)
     {
-        FAPI_INF("mss_ccs_load_data_pattern: CCS Instruction Array index out of bounds");
+        FAPI_ERR("mss_ccs_load_data_pattern: CCS Instruction Array index out of bounds");
     }
     else
     {
@@ -582,12 +591,12 @@ ReturnCode mss_ccs_start_stop(
     if (i_start_stop == MSS_CCS_START)
     {
         rc_num = rc_num | data_buffer.setBit(0,1);
-        FAPI_INF(" Executing contents of CCS." );
+        FAPI_DBG(" Executing contents of CCS." );
     }
     else if (i_start_stop == MSS_CCS_STOP)
     {
         rc_num = rc_num | data_buffer.setBit(1,1);
-        FAPI_INF(" Halting execution of the CCS." );
+        FAPI_DBG(" Halting execution of the CCS." );
     }
 
     if (rc_num)
@@ -723,7 +732,7 @@ ReturnCode mss_execute_ccs_inst_array(
     }
     else if (status == MSS_STAT_QUERY_PASS)
     {
-        FAPI_INF("CCS Executed Successfully.");
+        FAPI_DBG("CCS Executed Successfully.");
     }
     else
     {
diff --git a/src/usr/hwpf/hwp/mc_config/mss_eff_config/mss_eff_config.C b/src/usr/hwpf/hwp/mc_config/mss_eff_config/mss_eff_config.C
index 321d9fe..9f5bff4 100644
--- a/src/usr/hwpf/hwp/mc_config/mss_eff_config/mss_eff_config.C
+++ b/src/usr/hwpf/hwp/mc_config/mss_eff_config/mss_eff_config.C
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_eff_config.C,v 1.55 2015/10/02 19:49:34 sglancy Exp $
+// $Id: mss_eff_config.C,v 1.63 2015/11/09 17:22:04 sglancy Exp $
 // $Source: /afs/awd/projects/eclipz/KnowledgeBase/.cvsroot/eclipz/chips/
 //          centaur/working/procedures/ipl/fapi/mss_eff_config.C,v $
 //------------------------------------------------------------------------------
@@ -45,6 +45,17 @@
 //------------------------------------------------------------------------------
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|-----------------------------------------------
+//   1.63  | asaetow  |03-NOV-15| Added support for new attribute ATTR_EFF_DRAM_ADDRESS_MIRRORING (from Steve Glancy)
+//         |          |         | Added support of ATTR_EFF_DRAM_AL for DDR4 3DS (from Jeremy Neaton)
+//         |          |         | Note: DO NOT pickup w/o memory_attributes.xml v1.166 or newer
+//   1.62  | jneaton  |05-NOV-15| Added 3DS AL support
+//   1.61  | preeragh |29-OCT-15| Updated ATTR_EFF_FINE_REFRESH_MODE based upon CUSTOM_dimm ATTR
+//   1.60  | preeragh |29-OCT-15| Updated IBM_TYPE 2A Case and ATTR_EFF_DIMM_RANKS_CONFIGED for 3D TSV Case
+//   1.59  | sglancy  |26-OCT-15| Updated ATTR_VPD_DRAM_WRDDR4_VREF to have a new definition
+//   1.58  | asaetow/sglancy |23-OCT-15| Added ATTR_EFF_VREF_DQ_TRAIN_VALUE, ATTR_EFF_VREF_DQ_TRAIN_RANGE, and ATTR_EFF_VREF_DQ_TRAIN_ENABLE for DDR4, eq from Steve Glancy below. Glancy made equation adjustments
+//         |          |         | Note: ATTR_EFF_VREF_DQ_TRAIN_ENABLE = DISABLE, ATTR_EFF_VREF_DQ_TRAIN_RANGE = RANGE1 if ATTR_VPD_DRAM_WRDDR4_VREF > 24 else RANGE2, ATTR_EFF_VREF_DQ_TRAIN_VALUE = ATTR_VPD_DRAM_WRDDR4_VREF - ATTR_EFF_VREF_DQ_TRAIN_RANGE * 24
+//   1.57  | asaetow  |22-OCT-15| Added ENUM_ATTR_EFF_CS_CMD_LATENCY_DISABLE default for DDR4.
+//   1.56  | preeragh |21-OCT-15| Added 3D TSV support and DDR4 ATTR
 //   1.55  | sglancy  |02-OCT-15| Fixed RCD support for DDR4 ISRDIMMs
 //   1.54  | asaetow  |13-AUG-15| Added ATTR_SPD_SDRAM_ROWS=R17 and ATTR_SPD_SDRAM_ROWS=R18 for DDR4.
 //   1.53  | asaetow  |31-JUL-15| Changed code based on FW code review.
@@ -285,6 +296,7 @@ struct mss_eff_config_data
     uint8_t dram_trrdl;
     uint8_t dram_tccdl;
     uint8_t dram_twtrl;
+    
 };
 
 //------------------------------------------------------------------------------
@@ -296,6 +308,8 @@ struct mss_eff_config_spd_data
 {
     uint8_t dram_device_type[PORT_SIZE][DIMM_SIZE];
     uint8_t sdram_device_type[PORT_SIZE][DIMM_SIZE];
+    uint8_t sdram_device_type_signal_loading[PORT_SIZE][DIMM_SIZE];
+    uint8_t sdram_die_count[PORT_SIZE][DIMM_SIZE];
     uint8_t module_type[PORT_SIZE][DIMM_SIZE];
     uint8_t custom[PORT_SIZE][DIMM_SIZE];
     uint8_t sdram_banks[PORT_SIZE][DIMM_SIZE];
@@ -324,7 +338,9 @@ struct mss_eff_config_spd_data
     uint8_t trtpmin[PORT_SIZE][DIMM_SIZE];
     uint32_t tfawmin[PORT_SIZE][DIMM_SIZE];
 
+
     // DDR4 only
+    uint8_t sdram_bankgroups_ddr4[PORT_SIZE][DIMM_SIZE];
     uint8_t trrdsmin[PORT_SIZE][DIMM_SIZE];
     uint8_t trrdlmin[PORT_SIZE][DIMM_SIZE];
     uint8_t tccdlmin[PORT_SIZE][DIMM_SIZE];
@@ -333,17 +349,50 @@ struct mss_eff_config_spd_data
     uint32_t trfc4min[PORT_SIZE][DIMM_SIZE];
     uint8_t twtrsmin[PORT_SIZE][DIMM_SIZE];
     uint8_t twtrlmin[PORT_SIZE][DIMM_SIZE];
+    uint32_t addr_map_reg_to_dram[PORT_SIZE][DIMM_SIZE]; // Assuming right align based on dimm_spd_attributes.xml
+
+
+    // DDR4 LR only
+    uint8_t dimm_module_lr_attributes[PORT_SIZE][DIMM_SIZE];
+    uint32_t lr_register_manf_id[PORT_SIZE][DIMM_SIZE]; // Assuming right align based on dimm_spd_attributes.xml
+    uint8_t lr_reg_output_drv_strength_ck[PORT_SIZE][DIMM_SIZE];
+    uint8_t lr_dram_vref_dq_rank0[PORT_SIZE][DIMM_SIZE];
+    uint8_t lr_dram_vref_dq_rank1[PORT_SIZE][DIMM_SIZE];
+    uint8_t lr_dram_vref_dq_rank2[PORT_SIZE][DIMM_SIZE];
+    uint8_t lr_dram_vref_dq_rank3[PORT_SIZE][DIMM_SIZE];
+    uint8_t lr_buf_vref_dq_for_dram[PORT_SIZE][DIMM_SIZE];
+    uint8_t lr_buf_mdq_drv_less_than_1866[PORT_SIZE][DIMM_SIZE];
+    uint8_t lr_buf_mdq_drv_1866_2400[PORT_SIZE][DIMM_SIZE];
+    uint8_t lr_buf_mdq_drv_2400_3200[PORT_SIZE][DIMM_SIZE];
+    uint8_t lr_dram_drv_strength[PORT_SIZE][DIMM_SIZE];
+    uint8_t lr_dram_odt_rtt_wr_less_than_1866[PORT_SIZE][DIMM_SIZE];
+    uint8_t lr_dram_odt_rtt_nom_less_than_1866[PORT_SIZE][DIMM_SIZE];
+    uint8_t lr_dram_odt_rtt_wr_1866_2400[PORT_SIZE][DIMM_SIZE];
+    uint8_t lr_dram_odt_rtt_nom_1866_2400[PORT_SIZE][DIMM_SIZE];
+    uint8_t lr_dram_odt_rtt_wr_2400_3200[PORT_SIZE][DIMM_SIZE];
+    uint8_t lr_dram_odt_rtt_nom_2400_3200[PORT_SIZE][DIMM_SIZE];
+    uint8_t lr_dram_odt_rtt_park_less_than_1866[PORT_SIZE][DIMM_SIZE];
+    uint8_t lr_dram_odt_rtt_park_1866_2400[PORT_SIZE][DIMM_SIZE];
+    uint8_t lr_dram_odt_rtt_park_2400_3200[PORT_SIZE][DIMM_SIZE];
+
 
     // Not needed for GA1 CDIMM, will need to enable check for ISDIMM.
-    //uint8_t sdram_optional_features[PORT_SIZE][DIMM_SIZE];
-    //uint8_t sdram_thermal_and_refresh_options[PORT_SIZE][DIMM_SIZE];
-    //uint8_t module_thermal_sensor[PORT_SIZE][DIMM_SIZE];
+    uint8_t sdram_optional_features[PORT_SIZE][DIMM_SIZE];
+    uint8_t sdram_thermal_and_refresh_options[PORT_SIZE][DIMM_SIZE];
+    uint8_t module_thermal_sensor[PORT_SIZE][DIMM_SIZE];
 
     uint8_t fine_offset_tckmin[PORT_SIZE][DIMM_SIZE];
     uint8_t fine_offset_taamin[PORT_SIZE][DIMM_SIZE];
     uint8_t fine_offset_trcdmin[PORT_SIZE][DIMM_SIZE];
     uint8_t fine_offset_trpmin[PORT_SIZE][DIMM_SIZE];
     uint8_t fine_offset_trcmin[PORT_SIZE][DIMM_SIZE];
+    // DDR4 only
+    uint8_t fine_offset_tccdlmin[PORT_SIZE][DIMM_SIZE];
+    uint8_t fine_offset_trrdlmin[PORT_SIZE][DIMM_SIZE];
+    uint8_t fine_offset_trrdsmin[PORT_SIZE][DIMM_SIZE];
+    uint8_t fine_offset_tckmax[PORT_SIZE][DIMM_SIZE];
+
+
 
     // ATTR_SPD_MODULE_SPECIFIC_SECTION, Located in DDR3 SPD bytes 60d - 116d
     //uint8_t module_specific_section[PORT_SIZE][DIMM_SIZE][57];         
@@ -377,9 +426,9 @@ struct mss_eff_config_spd_data
 struct mss_eff_config_atts
 {
     uint8_t eff_dimm_ranks_configed[PORT_SIZE][DIMM_SIZE];
+    uint8_t eff_dram_address_mirroring[PORT_SIZE][DIMM_SIZE];
     // Using SPD byte68,69:76, enabled in GA2 for full RDIMM support
     uint64_t eff_dimm_rcd_cntl_word_0_15[PORT_SIZE][DIMM_SIZE];
-    uint64_t eff_lrdimm_additional_cntl_words[PORT_SIZE][DIMM_SIZE]; // LRDIMMs only
     uint8_t eff_dimm_size[PORT_SIZE][DIMM_SIZE];
     uint8_t eff_dimm_type;
     uint8_t eff_custom_dimm;
@@ -387,8 +436,36 @@ struct mss_eff_config_atts
     uint8_t eff_dram_asr;
     uint8_t eff_dram_bl;
     uint8_t eff_dram_banks;
-
-    // See mss_freq.C
+  //Added by saravanan
+    //uint8_t eff_rtt_park[PORT_SIZE];
+    uint8_t eff_cs_cmd_latency;
+    uint8_t eff_dimm_ddr4_rc00[PORT_SIZE][DIMM_SIZE];      
+    uint8_t eff_dimm_ddr4_rc01[PORT_SIZE][DIMM_SIZE];      
+    uint8_t eff_dimm_ddr4_rc02[PORT_SIZE][DIMM_SIZE];      
+    uint8_t eff_dimm_ddr4_rc03[PORT_SIZE][DIMM_SIZE];      
+    uint8_t eff_dimm_ddr4_rc04[PORT_SIZE][DIMM_SIZE];      
+    uint8_t eff_dimm_ddr4_rc05[PORT_SIZE][DIMM_SIZE];      
+    uint8_t eff_dimm_ddr4_rc06_07[PORT_SIZE][DIMM_SIZE];   
+    uint8_t eff_dimm_ddr4_rc08[PORT_SIZE][DIMM_SIZE];      
+    uint8_t eff_dimm_ddr4_rc09[PORT_SIZE][DIMM_SIZE];      
+    uint8_t eff_dimm_ddr4_rc10[PORT_SIZE][DIMM_SIZE];      
+    uint8_t eff_dimm_ddr4_rc11[PORT_SIZE][DIMM_SIZE];      
+    uint8_t eff_dimm_ddr4_rc12[PORT_SIZE][DIMM_SIZE];      
+    uint8_t eff_dimm_ddr4_rc13[PORT_SIZE][DIMM_SIZE];      
+    uint8_t eff_dimm_ddr4_rc14[PORT_SIZE][DIMM_SIZE];      
+    uint8_t eff_dimm_ddr4_rc15[PORT_SIZE][DIMM_SIZE];      
+    uint8_t eff_dimm_ddr4_rc_1x[PORT_SIZE][DIMM_SIZE];     
+    uint8_t eff_dimm_ddr4_rc_2x[PORT_SIZE][DIMM_SIZE];     
+    uint8_t eff_dimm_ddr4_rc_3x[PORT_SIZE][DIMM_SIZE];     
+    uint8_t eff_dimm_ddr4_rc_4x[PORT_SIZE][DIMM_SIZE];     
+    uint8_t eff_dimm_ddr4_rc_5x[PORT_SIZE][DIMM_SIZE];     
+    uint8_t eff_dimm_ddr4_rc_6x[PORT_SIZE][DIMM_SIZE];     
+    uint8_t eff_dimm_ddr4_rc_7x[PORT_SIZE][DIMM_SIZE];     
+    uint8_t eff_dimm_ddr4_rc_8x[PORT_SIZE][DIMM_SIZE];     
+    uint8_t eff_dimm_ddr4_rc_9x[PORT_SIZE][DIMM_SIZE];     
+    uint8_t eff_dimm_ddr4_rc_ax[PORT_SIZE][DIMM_SIZE];     
+    uint8_t eff_dimm_ddr4_rc_bx[PORT_SIZE][DIMM_SIZE];       
+  // See mss_freq.C
     //uint8_t eff_dram_cl;
 
     uint8_t eff_dram_cols;
@@ -464,9 +541,73 @@ struct mss_eff_config_atts
     uint8_t dimm_functional_vector;
     uint8_t mss_cal_step_enable; // Always run all cal steps
     uint32_t eff_vpd_version;
+
+    // DDR4 attributes
     uint8_t eff_dram_trrdl;
     uint8_t eff_dram_tccdl;
+	//uint8_t eff_dram_tccds;
     uint8_t eff_dram_twtrl;
+    uint8_t eff_vref_dq_train_value[PORT_SIZE][DIMM_SIZE][RANK_SIZE];
+    uint8_t eff_vref_dq_train_range[PORT_SIZE][DIMM_SIZE][RANK_SIZE];
+    uint8_t eff_vref_dq_train_enable[PORT_SIZE][DIMM_SIZE][RANK_SIZE];
+    uint8_t eff_mpr_page;
+    uint8_t eff_dram_lpasr;
+    uint8_t eff_geardown_mode;
+    uint8_t eff_per_dram_access;
+    uint8_t eff_temp_readout;
+    uint8_t eff_fine_refresh_mode;
+    uint8_t eff_mpr_rd_format;
+    uint8_t eff_max_powerdown_mode;
+    uint8_t eff_temp_ref_range;
+    uint8_t eff_temp_ref_mode;
+    uint8_t eff_int_vref_mon;
+    uint8_t eff_self_ref_abort;
+    uint8_t eff_rd_preamble_train;
+    uint8_t eff_rd_preamble;
+    uint8_t eff_wr_preamble;
+    uint8_t eff_odt_input_buff;
+    uint8_t eff_data_mask;
+    uint8_t eff_write_dbi;
+    uint8_t eff_read_dbi;
+    uint8_t eff_ca_parity;
+    uint8_t eff_ca_parity_latency;
+    uint8_t eff_ca_parity_error_status;
+    // DDR4 CRC attributes
+    uint8_t eff_write_crc;
+    uint8_t eff_crc_wr_latency;
+    uint8_t eff_crc_error_clear;
+
+    // DDR4 RDIMM attributes
+    /*uint8_t eff_dimm_ddr4_rc00;
+    uint8_t eff_dimm_ddr4_rc01;
+    uint8_t eff_dimm_ddr4_rc02;
+    uint8_t eff_dimm_ddr4_rc03;
+    uint8_t eff_dimm_ddr4_rc04;
+    uint8_t eff_dimm_ddr4_rc05;
+    uint8_t eff_dimm_ddr4_rc06_07;
+    uint8_t eff_dimm_ddr4_rc08;
+    uint8_t eff_dimm_ddr4_rc09;
+    uint8_t eff_dimm_ddr4_rc10;
+    uint8_t eff_dimm_ddr4_rc11;
+    uint8_t eff_dimm_ddr4_rc12;
+    uint8_t eff_dimm_ddr4_rc13;
+    uint8_t eff_dimm_ddr4_rc14;
+    uint8_t eff_dimm_ddr4_rc15;
+    uint8_t eff_dimm_ddr4_rc_1x;
+    uint8_t eff_dimm_ddr4_rc_2x;
+    uint8_t eff_dimm_ddr4_rc_3x;
+    uint8_t eff_dimm_ddr4_rc_4x;
+    uint8_t eff_dimm_ddr4_rc_5x;
+    uint8_t eff_dimm_ddr4_rc_6x;
+    uint8_t eff_dimm_ddr4_rc_7x;
+    uint8_t eff_dimm_ddr4_rc_8x;
+    uint8_t eff_dimm_ddr4_rc_9x;
+    uint8_t eff_dimm_ddr4_rc_ax;
+    uint8_t eff_dimm_ddr4_rc_bx;    
+*/
+    // DDR4 LRDIMM attributes
+    uint64_t eff_lrdimm_word_x[PORT_SIZE][DIMM_SIZE];
+    uint64_t eff_lrdimm_additional_cntl_words[PORT_SIZE][DIMM_SIZE];
 };
 
 //------------------------------------------------------------------------------
@@ -572,6 +713,11 @@ fapi::ReturnCode mss_eff_config_read_spd_data(fapi::Target i_target_dimm,
         rc = FAPI_ATTR_GET(ATTR_SPD_SDRAM_DEVICE_TYPE, &i_target_dimm,
                 p_o_spd_data->sdram_device_type[i_port][i_dimm]);
         if(rc) break;
+        rc = FAPI_ATTR_GET(ATTR_SPD_SDRAM_DEVICE_TYPE_SIGNAL_LOADING, &i_target_dimm,p_o_spd_data->sdram_device_type_signal_loading[i_port][i_dimm]);
+        if(rc) break;
+        rc = FAPI_ATTR_GET(ATTR_SPD_SDRAM_DIE_COUNT, &i_target_dimm,
+                p_o_spd_data->sdram_die_count[i_port][i_dimm]);
+        if(rc) break;
         rc = FAPI_ATTR_GET(ATTR_SPD_MODULE_TYPE, &i_target_dimm,
             p_o_spd_data->module_type[i_port][i_dimm]);
         if(rc) break;
@@ -650,28 +796,26 @@ fapi::ReturnCode mss_eff_config_read_spd_data(fapi::Target i_target_dimm,
 
         } else if (p_o_spd_data->dram_device_type[i_port][i_dimm] == fapi::ENUM_ATTR_SPD_DRAM_DEVICE_TYPE_DDR4) {
            // DDR4 only
-                        uint8_t l_spd_tb_mtb_ddr4, l_spd_tb_ftb_ddr4;
-                        rc = FAPI_ATTR_GET(ATTR_SPD_TIMEBASE_MTB_DDR4, &i_target_dimm,
-                                        l_spd_tb_mtb_ddr4);
-                        if (rc) break;
-
-                        rc = FAPI_ATTR_GET(ATTR_SPD_TIMEBASE_FTB_DDR4, &i_target_dimm,
-                                        l_spd_tb_ftb_ddr4);
-                        if (rc) break;
-
-                        if ( (l_spd_tb_mtb_ddr4 != 0)||(l_spd_tb_ftb_ddr4 != 0) )
-                        {
-                                FAPI_ERR("Invalid DDR4 MTB/FTB Timebase received from SPD attribute on %s!", i_target_dimm.toEcmdString());
-                                FAPI_SET_HWP_ERROR(rc, RC_MSS_EFF_CONFIG_INVALID_DDR4_SPD_TB);
-                                break;
-                        }
-            // AST HERE: !If DDR4 spec changes to include other values, this section needs to be updated!
-                        // for 1000fs = 1ps = 1000 * 1 / 1
-                        p_o_spd_data->ftb_dividend[i_port][i_dimm] = 1;
-                        p_o_spd_data->ftb_divisor[i_port][i_dimm] = 1;
-                        // for 125ps = 1000 * 1 / 8
-                        p_o_spd_data->mtb_dividend[i_port][i_dimm] = 1;
-                        p_o_spd_data->mtb_divisor[i_port][i_dimm] = 8;
+
+           uint8_t l_spd_tb_mtb_ddr4, l_spd_tb_ftb_ddr4;
+           rc = FAPI_ATTR_GET(ATTR_SPD_TIMEBASE_MTB_DDR4, &i_target_dimm, l_spd_tb_mtb_ddr4);
+           if (rc) break;
+
+           rc = FAPI_ATTR_GET(ATTR_SPD_TIMEBASE_FTB_DDR4, &i_target_dimm, l_spd_tb_ftb_ddr4);
+           if (rc) break;
+
+           // AST HERE: !If DDR4 spec changes to include other values, this section needs to be updated!
+           if ((l_spd_tb_mtb_ddr4 != 0) || (l_spd_tb_ftb_ddr4 != 0)) {
+              FAPI_ERR("Invalid DDR4 MTB/FTB Timebase received from SPD attribute on %s!", i_target_dimm.toEcmdString());
+              FAPI_SET_HWP_ERROR(rc, RC_MSS_EFF_CONFIG_INVALID_DDR4_SPD_TB);
+              break;
+           }
+           // for 1000fs = 1ps = 1000 * 1 / 1
+           p_o_spd_data->ftb_dividend[i_port][i_dimm] = 1;
+           p_o_spd_data->ftb_divisor[i_port][i_dimm] = 1;
+           // for 125ps = 1000 * 1 / 8
+           p_o_spd_data->mtb_dividend[i_port][i_dimm] = 1;
+           p_o_spd_data->mtb_divisor[i_port][i_dimm] = 8;
 
                         // not available in ddr4 spd, these are replacements.  need to double check
                         // 15 ns for all speeds
@@ -684,40 +828,16 @@ fapi::ReturnCode mss_eff_config_read_spd_data(fapi::Target i_target_dimm,
                                 (p_o_spd_data->mtb_dividend[i_port][i_dimm] * 1000) /
                         p_o_spd_data->mtb_divisor[i_port][i_dimm]);
 
-                        // 3 trfc values, 1x, 2x, 4x
-                        rc = FAPI_ATTR_GET(ATTR_SPD_TRFC1MIN_DDR4, &i_target_dimm,
-                                p_o_spd_data->trfc1min[i_port][i_dimm]);
-                        if(rc) break;
-
-// FW is reading out and giving the data in big endian format for some reason.
-// need to fix this...  XML is documented correctly.
-/* //                   if (p_o_spd_data->trfc1min[i_port][i_dimm] > 0xFFF) {
-                                p_o_spd_data->trfc1min[i_port][i_dimm] |= 
-                                        (p_o_spd_data->trfc1min[i_port][i_dimm] & 0xFF) << 16;
-                                p_o_spd_data->trfc1min[i_port][i_dimm] =
-                                        p_o_spd_data->trfc1min[i_port][i_dimm] >> 8;
-//                      }
-*/
-//  need to look at this more sometimes the bytes are swapped in SPD...
-                        switch(p_o_spd_data->trfc1min[i_port][i_dimm])
-                        {
-                        case 0x0005:
-                            p_o_spd_data->trfc1min[i_port][i_dimm] = 0x0500;
-                            break;
-                        case 0x2008:
-                            p_o_spd_data->trfc1min[i_port][i_dimm] = 0x0820;
-                            break;
-                        case 0xF00A:
-                            p_o_spd_data->trfc1min[i_port][i_dimm] = 0x0AF0;
-                            break;
-                        }
-
-                        rc = FAPI_ATTR_GET(ATTR_SPD_TRFC2MIN_DDR4, &i_target_dimm,
-                                p_o_spd_data->trfc2min[i_port][i_dimm]);
-                        if(rc) break;
-                        rc = FAPI_ATTR_GET(ATTR_SPD_TRFC4MIN_DDR4, &i_target_dimm,
-                                p_o_spd_data->trfc4min[i_port][i_dimm]);
-                        if(rc) break;
+           // 3 trfc values, 1x, 2x, 4x
+           rc = FAPI_ATTR_GET(ATTR_SPD_TRFC1MIN_DDR4, &i_target_dimm, p_o_spd_data->trfc1min[i_port][i_dimm]);
+           if(rc) break;
+           rc = FAPI_ATTR_GET(ATTR_SPD_TRFC2MIN_DDR4, &i_target_dimm, p_o_spd_data->trfc2min[i_port][i_dimm]);
+           if(rc) break;
+           rc = FAPI_ATTR_GET(ATTR_SPD_TRFC4MIN_DDR4, &i_target_dimm, p_o_spd_data->trfc4min[i_port][i_dimm]);
+           if(rc) break;
+           //FAPI_INF("AST: trfc1min[%d][%d] = %d on %s.", i_port, i_dimm, p_o_spd_data->trfc1min[i_port][i_dimm], i_target_dimm.toEcmdString());
+           //FAPI_INF("AST: trfc2min[%d][%d] = %d on %s.", i_port, i_dimm, p_o_spd_data->trfc2min[i_port][i_dimm], i_target_dimm.toEcmdString());
+           //FAPI_INF("AST: trfc4min[%d][%d] = %d on %s.", i_port, i_dimm, p_o_spd_data->trfc4min[i_port][i_dimm], i_target_dimm.toEcmdString());
 
                         // ddr4 has 's' (short; different bank group) and
                         // 'l' (long; same bank group) values
@@ -744,12 +864,63 @@ fapi::ReturnCode mss_eff_config_read_spd_data(fapi::Target i_target_dimm,
                                 p_o_spd_data->twtrlmin[i_port][i_dimm]);        // 7.5ns
                         if(rc) break;
 */
-                        p_o_spd_data->twtrsmin[i_port][i_dimm] = 2500 / (       // 2.5 ns
-                (p_o_spd_data->mtb_dividend[i_port][i_dimm] * 1000) /
-                                            p_o_spd_data->mtb_divisor[i_port][i_dimm]);
-                        p_o_spd_data->twtrlmin[i_port][i_dimm] = 7500 / (       // 7.5 ns
-                (p_o_spd_data->mtb_dividend[i_port][i_dimm] * 1000) /
-                                            p_o_spd_data->mtb_divisor[i_port][i_dimm]);
+           p_o_spd_data->twtrsmin[i_port][i_dimm] = 2500 / (       // 2.5 ns
+              (p_o_spd_data->mtb_dividend[i_port][i_dimm] * 1000) /
+              p_o_spd_data->mtb_divisor[i_port][i_dimm]);
+           p_o_spd_data->twtrlmin[i_port][i_dimm] = 7500 / (       // 7.5 ns
+              (p_o_spd_data->mtb_dividend[i_port][i_dimm] * 1000) /
+              p_o_spd_data->mtb_divisor[i_port][i_dimm]);
+
+           // DDR4 RDIMM/LRDIMM Support
+              rc = FAPI_ATTR_GET(ATTR_SPD_ADDR_MAP_REG_TO_DRAM, &i_target_dimm, p_o_spd_data->addr_map_reg_to_dram[i_port][i_dimm]);
+              if(rc) break;
+           // DDR4 LRDIMM Support  AST HERE
+           if (p_o_spd_data->module_type[i_port][i_dimm] == fapi::ENUM_ATTR_SPD_MODULE_TYPE_LRDIMM) {
+              rc = FAPI_ATTR_GET(ATTR_SPD_DIMM_MODULE_ATTRIBUTES, &i_target_dimm, p_o_spd_data->dimm_module_lr_attributes[i_port][i_dimm]);
+              if(rc) break;
+              rc = FAPI_ATTR_GET(ATTR_SPD_REGISTER_MANF_ID, &i_target_dimm, p_o_spd_data->lr_register_manf_id[i_port][i_dimm]);
+              if(rc) break;
+              rc = FAPI_ATTR_GET(ATTR_SPD_REG_OUTPUT_DRV_STRENGTH_CK, &i_target_dimm, p_o_spd_data->lr_reg_output_drv_strength_ck[i_port][i_dimm]);
+              if(rc) break;
+              rc = FAPI_ATTR_GET(ATTR_SPD_LR_DRAM_VREF_DQ_RANK0, &i_target_dimm, p_o_spd_data->lr_dram_vref_dq_rank0[i_port][i_dimm]);
+              if(rc) break;
+              rc = FAPI_ATTR_GET(ATTR_SPD_LR_DRAM_VREF_DQ_RANK1, &i_target_dimm, p_o_spd_data->lr_dram_vref_dq_rank1[i_port][i_dimm]);
+              if(rc) break;
+              rc = FAPI_ATTR_GET(ATTR_SPD_LR_DRAM_VREF_DQ_RANK2, &i_target_dimm, p_o_spd_data->lr_dram_vref_dq_rank2[i_port][i_dimm]);
+              if(rc) break;
+              rc = FAPI_ATTR_GET(ATTR_SPD_LR_DRAM_VREF_DQ_RANK3, &i_target_dimm, p_o_spd_data->lr_dram_vref_dq_rank3[i_port][i_dimm]);
+              if(rc) break;
+              rc = FAPI_ATTR_GET(ATTR_SPD_LR_BUF_VREF_DQ_FOR_DRAM, &i_target_dimm, p_o_spd_data->lr_buf_vref_dq_for_dram[i_port][i_dimm]);
+              if(rc) break;
+              rc = FAPI_ATTR_GET(ATTR_SPD_LR_BUF_MDQ_DRV_LESS_THAN_1866, &i_target_dimm, p_o_spd_data->lr_buf_mdq_drv_less_than_1866[i_port][i_dimm]);
+              if(rc) break;
+              rc = FAPI_ATTR_GET(ATTR_SPD_LR_BUF_MDQ_DRV_1866_2400, &i_target_dimm, p_o_spd_data->lr_buf_mdq_drv_1866_2400[i_port][i_dimm]);
+              if(rc) break;
+              rc = FAPI_ATTR_GET(ATTR_SPD_LR_BUF_MDQ_DRV_2400_3200, &i_target_dimm, p_o_spd_data->lr_buf_mdq_drv_2400_3200[i_port][i_dimm]);
+              if(rc) break;
+              rc = FAPI_ATTR_GET(ATTR_SPD_LR_DRAM_DRV_STRENGTH, &i_target_dimm, p_o_spd_data->lr_dram_drv_strength[i_port][i_dimm]);
+              if(rc) break;
+              rc = FAPI_ATTR_GET(ATTR_SPD_LR_DRAM_ODT_RTT_WR_LESS_THAN_1866, &i_target_dimm, p_o_spd_data->lr_dram_odt_rtt_wr_less_than_1866[i_port][i_dimm]);
+              if(rc) break;
+              rc = FAPI_ATTR_GET(ATTR_SPD_LR_DRAM_ODT_RTT_NOM_LESS_THAN_1866, &i_target_dimm, p_o_spd_data->lr_dram_odt_rtt_nom_less_than_1866[i_port][i_dimm]);
+              if(rc) break;
+              rc = FAPI_ATTR_GET(ATTR_SPD_LR_DRAM_ODT_RTT_WR_1866_2400, &i_target_dimm, p_o_spd_data->lr_dram_odt_rtt_wr_1866_2400[i_port][i_dimm]);
+              if(rc) break;
+              rc = FAPI_ATTR_GET(ATTR_SPD_LR_DRAM_ODT_RTT_NOM_1866_2400, &i_target_dimm, p_o_spd_data->lr_dram_odt_rtt_nom_1866_2400[i_port][i_dimm]);
+              if(rc) break;
+              rc = FAPI_ATTR_GET(ATTR_SPD_LR_DRAM_ODT_RTT_WR_2400_3200, &i_target_dimm, p_o_spd_data->lr_dram_odt_rtt_wr_2400_3200[i_port][i_dimm]);
+              if(rc) break;
+              rc = FAPI_ATTR_GET(ATTR_SPD_LR_DRAM_ODT_RTT_NOM_2400_3200, &i_target_dimm, p_o_spd_data->lr_dram_odt_rtt_nom_2400_3200[i_port][i_dimm]);
+              if(rc) break;
+              rc = FAPI_ATTR_GET(ATTR_SPD_LR_DRAM_ODT_RTT_PARK_LESS_THAN_1866, &i_target_dimm, p_o_spd_data->lr_dram_odt_rtt_park_less_than_1866[i_port][i_dimm]);
+              if(rc) break;
+              rc = FAPI_ATTR_GET(ATTR_SPD_LR_DRAM_ODT_RTT_PARK_1866_2400, &i_target_dimm, p_o_spd_data->lr_dram_odt_rtt_park_1866_2400[i_port][i_dimm]);
+              if(rc) break;
+              rc = FAPI_ATTR_GET(ATTR_SPD_LR_DRAM_ODT_RTT_PARK_2400_3200, &i_target_dimm, p_o_spd_data->lr_dram_odt_rtt_park_2400_3200[i_port][i_dimm]);
+              if(rc) break;
+
+		}
+
         } else {
            FAPI_ERR("Incompatable SPD DRAM generation on %s!", i_target_dimm.toEcmdString());
            FAPI_SET_HWP_ERROR(rc, RC_MSS_EFF_CONFIG_INCOMPATABLE_SPD_DRAM_GEN);
@@ -773,17 +944,15 @@ fapi::ReturnCode mss_eff_config_read_spd_data(fapi::Target i_target_dimm,
             p_o_spd_data->tfawmin[i_port][i_dimm]);
         if(rc) break;
 
-        // Not needed for GA1 CDIMM, will need to enable check for ISDIMM.
-        //rc = FAPI_ATTR_GET(ATTR_SPD_SDRAM_OPTIONAL_FEATURES, &i_target_dimm,
-            //p_o_spd_data->sdram_optional_features[i_port][i_dimm]);
-        //if(rc) break;
-        //rc = FAPI_ATTR_GET(ATTR_SPD_SDRAM_THERMAL_AND_REFRESH_OPTIONS,
-            //&i_target_dimm,
-            //p_o_spd_data->sdram_thermal_and_refresh_options[i_port][i_dimm]);
-        //if(rc) break;
-        //rc = FAPI_ATTR_GET(ATTR_SPD_MODULE_THERMAL_SENSOR, &i_target_dimm,
-            //p_o_spd_data->module_thermal_sensor[i_port][i_dimm]);
-        //if(rc) break;
+        
+        // Allows feature checking
+        rc = FAPI_ATTR_GET(ATTR_SPD_SDRAM_OPTIONAL_FEATURES, &i_target_dimm, p_o_spd_data->sdram_optional_features[i_port][i_dimm]);
+        if(rc) break;
+        rc = FAPI_ATTR_GET(ATTR_SPD_SDRAM_THERMAL_AND_REFRESH_OPTIONS, &i_target_dimm, p_o_spd_data->sdram_thermal_and_refresh_options[i_port][i_dimm]);
+        if(rc) break;
+        rc = FAPI_ATTR_GET(ATTR_SPD_MODULE_THERMAL_SENSOR, &i_target_dimm, p_o_spd_data->module_thermal_sensor[i_port][i_dimm]);
+        if(rc) break;
+
 
         rc = FAPI_ATTR_GET(ATTR_SPD_FINE_OFFSET_TCKMIN, &i_target_dimm,
             p_o_spd_data->fine_offset_tckmin[i_port][i_dimm]);
@@ -1353,21 +1522,24 @@ fapi::ReturnCode mss_eff_config_setup_eff_atts(
     fapi::ReturnCode rc;
     const fapi::Target& TARGET_MBA = i_target_mba;
 
+
+    uint8_t vpd_dram_address_mirroring[PORT_SIZE][DIMM_SIZE];
+    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_ADDRESS_MIRRORING, &i_target_mba, vpd_dram_address_mirroring);
+
     uint8_t mss_dram_2n_mode_enable;
     rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_2N_MODE_ENABLED, &i_target_mba, mss_dram_2n_mode_enable);
     if(rc) return rc;
-    // set select atts members to non-zero
-    if ( mss_dram_2n_mode_enable == fapi::ENUM_ATTR_VPD_DRAM_2N_MODE_ENABLED_TRUE ) {
-       p_o_atts->eff_dram_al = fapi::ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_2; // Always use AL = CL - 2 for 2N/2T mode
-    } else {
-       p_o_atts->eff_dram_al = fapi::ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_1; // Always use AL = CL - 1 for 1N/1T mode
-    }
+
+    // DDR4 Vref
+    uint8_t l_attr_vpd_dram_wrddr4_vref[PORT_SIZE];
+    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_WRDDR4_VREF, &i_target_mba, l_attr_vpd_dram_wrddr4_vref);
 
     // Transfer powerdown request from system attr to DRAM attr
     uint8_t mss_power_control_requested;
     rc = FAPI_ATTR_GET(ATTR_MRW_POWER_CONTROL_REQUESTED, NULL, mss_power_control_requested); 
     if(rc) return rc;
-    if ( mss_power_control_requested == fapi::ENUM_ATTR_MRW_POWER_CONTROL_REQUESTED_FASTEXIT) {
+	
+	if ( mss_power_control_requested == fapi::ENUM_ATTR_MRW_POWER_CONTROL_REQUESTED_FASTEXIT) {
        p_o_atts->eff_dram_dll_ppd = fapi::ENUM_ATTR_EFF_DRAM_DLL_PPD_FASTEXIT;
     } else {
        p_o_atts->eff_dram_dll_ppd = fapi::ENUM_ATTR_EFF_DRAM_DLL_PPD_SLOWEXIT; // if "OFF" default to SLOWEXIT, FASTEXIT settings in mba_def.initfile are causing fails.  Workaround to use SLOWEXIT.
@@ -1840,6 +2012,55 @@ fapi::ReturnCode mss_eff_config_setup_eff_atts(
                                         p_o_atts->eff_dram_trrdl = p_i_mss_eff_config_data->dram_trrdl;
                                 }
                 FAPI_INF("DDR4 tRRDs = %i, tRRDl = %i", p_o_atts->eff_dram_trrd, p_o_atts->eff_dram_trrdl);
+
+            // DDR4 Vref DQ Train
+            for (int l_cur_mba_rank = 0; l_cur_mba_rank < RANK_SIZE; l_cur_mba_rank += 1) {
+               p_o_atts->eff_vref_dq_train_enable[l_cur_mba_port][l_cur_mba_dimm][l_cur_mba_rank] = fapi::ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_DISABLE;
+               //VREF DQ range is set to 1 -> range 2
+	       if (l_attr_vpd_dram_wrddr4_vref[l_cur_mba_port] & 0x40) {
+                  p_o_atts->eff_vref_dq_train_range[l_cur_mba_port][l_cur_mba_dimm][l_cur_mba_rank] = fapi::ENUM_ATTR_EFF_VREF_DQ_TRAIN_RANGE_RANGE2;
+               } else {
+                  p_o_atts->eff_vref_dq_train_range[l_cur_mba_port][l_cur_mba_dimm][l_cur_mba_rank] = fapi::ENUM_ATTR_EFF_VREF_DQ_TRAIN_RANGE_RANGE1;
+               }
+               p_o_atts->eff_vref_dq_train_value[l_cur_mba_port][l_cur_mba_dimm][l_cur_mba_rank] = l_attr_vpd_dram_wrddr4_vref[l_cur_mba_port] & 0x3f;
+            }
+
+            // DDR4 controls/features
+            p_o_atts->eff_cs_cmd_latency = fapi::ENUM_ATTR_EFF_CS_CMD_LATENCY_DISABLE;
+            p_o_atts->eff_mpr_page = 0;
+            p_o_atts->eff_mpr_page = 0;
+            p_o_atts->eff_dram_lpasr = ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_NORMAL;
+            p_o_atts->eff_geardown_mode = ENUM_ATTR_EFF_GEARDOWN_MODE_HALF;
+            p_o_atts->eff_per_dram_access = ENUM_ATTR_EFF_PER_DRAM_ACCESS_DISABLE;
+            p_o_atts->eff_temp_readout = ENUM_ATTR_EFF_TEMP_READOUT_DISABLE; 
+			//Preet   --- ISDIMM based System = 4X Refresh and CDIMMs - Normal as per warren
+			if((p_o_atts->eff_custom_dimm == fapi::ENUM_ATTR_EFF_CUSTOM_DIMM_YES) && (p_o_atts->eff_dram_gen == fapi::ENUM_ATTR_EFF_DRAM_GEN_DDR4))			
+				{ p_o_atts->eff_fine_refresh_mode = ENUM_ATTR_EFF_FINE_REFRESH_MODE_NORMAL;}
+			else
+				{p_o_atts->eff_fine_refresh_mode = ENUM_ATTR_EFF_FINE_REFRESH_MODE_FIXED_4X;}
+			
+            p_o_atts->eff_mpr_rd_format = ENUM_ATTR_EFF_MPR_RD_FORMAT_SERIAL;
+            p_o_atts->eff_max_powerdown_mode = ENUM_ATTR_EFF_MAX_POWERDOWN_MODE_DISABLE; 
+            p_o_atts->eff_temp_ref_range = ENUM_ATTR_EFF_TEMP_REF_RANGE_NORMAL; 
+            p_o_atts->eff_temp_ref_mode = ENUM_ATTR_EFF_TEMP_REF_MODE_ENABLE; 
+            p_o_atts->eff_int_vref_mon = ENUM_ATTR_EFF_INT_VREF_MON_DISABLE;  
+            p_o_atts->eff_self_ref_abort = ENUM_ATTR_EFF_SELF_REF_ABORT_DISABLE; 
+            p_o_atts->eff_rd_preamble_train = ENUM_ATTR_EFF_RD_PREAMBLE_TRAIN_DISABLE;       
+            p_o_atts->eff_rd_preamble = ENUM_ATTR_EFF_RD_PREAMBLE_1NCLK; 
+            p_o_atts->eff_wr_preamble = ENUM_ATTR_EFF_WR_PREAMBLE_1NCLK;
+            p_o_atts->eff_odt_input_buff = ENUM_ATTR_EFF_ODT_INPUT_BUFF_ACTIVATED;
+            p_o_atts->eff_data_mask = ENUM_ATTR_EFF_DATA_MASK_DISABLE;
+            p_o_atts->eff_write_dbi = ENUM_ATTR_EFF_WRITE_DBI_DISABLE;
+            p_o_atts->eff_read_dbi = ENUM_ATTR_EFF_READ_DBI_DISABLE; 
+            p_o_atts->eff_ca_parity = ENUM_ATTR_EFF_CA_PARITY_DISABLE;
+            p_o_atts->eff_ca_parity_latency = ENUM_ATTR_EFF_CA_PARITY_LATENCY_DISABLE; 
+            p_o_atts->eff_ca_parity_error_status = ENUM_ATTR_EFF_CA_PARITY_ERROR_STATUS_CLEAR; 
+			
+            p_o_atts->eff_write_crc = ENUM_ATTR_EFF_WRITE_CRC_DISABLE; 
+            p_o_atts->eff_crc_wr_latency = ENUM_ATTR_EFF_CRC_WR_LATENCY_4NCK; 
+            p_o_atts->eff_crc_error_clear = ENUM_ATTR_EFF_CRC_ERROR_CLEAR_CLEAR; 
+
+
          } else {
             FAPI_ERR("Incompatable DRAM generation on %s!",i_target_mba.toEcmdString());
             uint8_t& DRAM_DEVICE_TYPE_0_0 = p_i_data->dram_device_type[0][0];
@@ -1869,6 +2090,10 @@ fapi::ReturnCode mss_eff_config_setup_eff_atts(
                     p_i_mss_eff_config_data->dram_tccdl;
             }
          }
+		 
+		 //Preet TCCD_S
+		 //p_o_atts->eff_dram_tccds = 4;
+		 
 //------------------------------------------------------------------------------
             p_i_mss_eff_config_data->dram_trp = calc_timing_in_clk
                 (
@@ -2063,7 +2288,7 @@ fapi::ReturnCode mss_eff_config_setup_eff_atts(
                 p_o_atts->eff_dram_trfc =
                     p_i_mss_eff_config_data->dram_trfc;
             }
-            // AST HERE: Need DDR4 attributes for other refresh rates, 2x, 4x
+            // AST HERE: Need DDR4 attributes for other refresh rates, 2x, 4x if we want to support those modes
 
          } else {
             FAPI_ERR("Incompatable DRAM generation on %s!",i_target_mba.toEcmdString());
@@ -2293,7 +2518,8 @@ FAPI_DBG("DDR4 Check:  SPD=0x%x, p_i_tFAWmin (nCK) = %i",
 
     p_o_atts->eff_vpd_version = 0xFFFFFF; // set VPD version to a large number, searching for smallest
     // the VPD version is 2 ASCI characters, so this is always later than that
-
+	uint8_t die_count = 1;
+	uint8_t ranks_3d_tsv = 0;
     // Assigning dependent values to attributes
     for (int l_cur_mba_port = 0; l_cur_mba_port <
             PORT_SIZE; l_cur_mba_port += 1)
@@ -2304,7 +2530,47 @@ FAPI_DBG("DDR4 Check:  SPD=0x%x, p_i_tFAWmin (nCK) = %i",
           if (p_i_mss_eff_config_data->
               cur_dimm_spd_valid_u8array[l_cur_mba_port][l_cur_mba_dimm] == MSS_EFF_VALID)
           {
-             if (p_i_data->num_ranks[l_cur_mba_port]
+             
+			 //FAPI_INF("Preet - DIE Count = %d",p_i_data->sdram_die_count[l_cur_mba_port][l_cur_mba_dimm]);
+
+            if ( p_i_data->sdram_device_type[l_cur_mba_port][l_cur_mba_dimm] == 
+                 fapi::ENUM_ATTR_SPD_SDRAM_DEVICE_TYPE_NON_STANDARD) {
+					 //Preet - Added 3TSV Type here 
+					 if (p_i_data->sdram_device_type_signal_loading[l_cur_mba_port][l_cur_mba_dimm] == fapi::ENUM_ATTR_SPD_SDRAM_DEVICE_TYPE_SIGNAL_LOADING_SINGLE_LOAD_STACK )
+					 {
+						p_o_atts->eff_stack_type[l_cur_mba_port][l_cur_mba_dimm] = fapi::ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS;  
+					 }
+               else
+						{
+							p_o_atts->eff_stack_type[l_cur_mba_port][l_cur_mba_dimm] = fapi::ENUM_ATTR_EFF_STACK_TYPE_DDP_QDP;
+						}
+            } 
+			else {
+               p_o_atts->eff_stack_type[l_cur_mba_port][l_cur_mba_dimm] = fapi::ENUM_ATTR_EFF_STACK_TYPE_NONE;
+            }
+			 
+			if (p_o_atts->eff_stack_type[l_cur_mba_port][l_cur_mba_dimm] == fapi::ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS)
+			{
+				if (p_i_data->sdram_die_count[l_cur_mba_port][l_cur_mba_dimm]== fapi::ENUM_ATTR_SPD_SDRAM_DIE_COUNT_DIE2)
+					{die_count = 2;}
+				else if(p_i_data->sdram_die_count[l_cur_mba_port][l_cur_mba_dimm]== fapi::ENUM_ATTR_SPD_SDRAM_DIE_COUNT_DIE4)
+					{die_count = 4;}
+				else if(p_i_data->sdram_die_count[l_cur_mba_port][l_cur_mba_dimm]== fapi::ENUM_ATTR_SPD_SDRAM_DIE_COUNT_DIE8)
+					{die_count = 8;}
+				
+				if (p_i_data->num_ranks[l_cur_mba_port][l_cur_mba_dimm] == fapi::ENUM_ATTR_SPD_NUM_RANKS_R1)
+				{ranks_3d_tsv = 1*die_count;}
+				else if (p_i_data->num_ranks[l_cur_mba_port][l_cur_mba_dimm] == fapi::ENUM_ATTR_SPD_NUM_RANKS_R2)
+				{ranks_3d_tsv = 2*die_count;}
+				else if (p_i_data->num_ranks[l_cur_mba_port][l_cur_mba_dimm] == fapi::ENUM_ATTR_SPD_NUM_RANKS_R4)
+				{ranks_3d_tsv = 4*die_count;}
+			
+				p_o_atts->eff_num_ranks_per_dimm[l_cur_mba_port][l_cur_mba_dimm] = ranks_3d_tsv;
+			
+			}  //end of 3d TSV
+	else      //if Non-3D TSV
+		{
+			 if (p_i_data->num_ranks[l_cur_mba_port]
                     [l_cur_mba_dimm] == 0x04)                 // for 8R LRDIMM  since no ENUM defined yet for SPD of 8R
 //                    [l_cur_mba_dimm] == fapi::ENUM_ATTR_SPD_NUM_RANKS_R8)
             {
@@ -2343,15 +2609,10 @@ FAPI_DBG("DDR4 Check:  SPD=0x%x, p_i_tFAWmin (nCK) = %i",
                 p_o_atts->eff_dimm_ranks_configed[l_cur_mba_port]
                     [l_cur_mba_dimm] = 0x00;
             }
-
-            if ( p_i_data->sdram_device_type[l_cur_mba_port][l_cur_mba_dimm] == 
-                 fapi::ENUM_ATTR_SPD_SDRAM_DEVICE_TYPE_NON_STANDARD) {
-               p_o_atts->eff_stack_type[l_cur_mba_port][l_cur_mba_dimm] = fapi::ENUM_ATTR_EFF_STACK_TYPE_DDP_QDP;
-            } else {
-               p_o_atts->eff_stack_type[l_cur_mba_port][l_cur_mba_dimm] = fapi::ENUM_ATTR_EFF_STACK_TYPE_NONE;
-            }
-
-                        uint8_t& UNSUPPORTED_VAL = p_o_atts->eff_ibm_type[l_cur_mba_port][l_cur_mba_dimm];
+		  }
+			//Preet
+			
+			uint8_t& UNSUPPORTED_VAL = p_o_atts->eff_ibm_type[l_cur_mba_port][l_cur_mba_dimm];
             // AST HERE: Needed SPD byte33[7,1:0], for expanded IBM_TYPE
             if ( p_o_atts->eff_dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_RDIMM ) {
                if (p_o_atts->eff_num_ranks_per_dimm[l_cur_mba_port][l_cur_mba_dimm] == 1) {
@@ -2366,14 +2627,28 @@ FAPI_DBG("DDR4 Check:  SPD=0x%x, p_i_tFAWmin (nCK) = %i",
                   FAPI_SET_HWP_ERROR(rc, RC_MSS_EFF_CONFIG_RDIMM_UNSUPPORTED_TYPE); return rc;
                }
             } else if (( p_o_atts->eff_dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_UDIMM ) && ( p_o_atts->eff_custom_dimm == fapi::ENUM_ATTR_EFF_CUSTOM_DIMM_YES )) {
-               if (p_o_atts->eff_num_ranks_per_dimm[l_cur_mba_port][l_cur_mba_dimm] == 1) {
-                  p_o_atts->eff_ibm_type[l_cur_mba_port][l_cur_mba_dimm] = fapi::ENUM_ATTR_EFF_IBM_TYPE_TYPE_1A;
-               } else if (p_o_atts->eff_num_ranks_per_dimm[l_cur_mba_port][l_cur_mba_dimm] == 2) {
-                  p_o_atts->eff_ibm_type[l_cur_mba_port][l_cur_mba_dimm] = fapi::ENUM_ATTR_EFF_IBM_TYPE_TYPE_1B;
+               if (p_o_atts->eff_stack_type[l_cur_mba_port][l_cur_mba_dimm] == fapi::ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+                  if (p_o_atts->eff_num_ranks_per_dimm[l_cur_mba_port][l_cur_mba_dimm] == 2) {
+                     p_o_atts->eff_ibm_type[l_cur_mba_port][l_cur_mba_dimm] = fapi::ENUM_ATTR_EFF_IBM_TYPE_TYPE_2A;
+                  } else if (p_o_atts->eff_num_ranks_per_dimm[l_cur_mba_port][l_cur_mba_dimm] == 4) {
+                     p_o_atts->eff_ibm_type[l_cur_mba_port][l_cur_mba_dimm] = fapi::ENUM_ATTR_EFF_IBM_TYPE_TYPE_2B;
+                  } else {
+                     p_o_atts->eff_ibm_type[l_cur_mba_port][l_cur_mba_dimm] = fapi::ENUM_ATTR_EFF_IBM_TYPE_UNDEFINED;
+                     FAPI_ERR("Currently unsupported IBM_TYPE on %s!", i_target_mba.toEcmdString());
+                     FAPI_SET_HWP_ERROR(rc, RC_MSS_EFF_CONFIG_UDIMM_UNSUPPORTED_TYPE); return rc;
+                  }
                } else {
-                  p_o_atts->eff_ibm_type[l_cur_mba_port][l_cur_mba_dimm] = fapi::ENUM_ATTR_EFF_IBM_TYPE_UNDEFINED;
-                  FAPI_ERR("Currently unsupported IBM_TYPE on %s!", i_target_mba.toEcmdString());
-                  FAPI_SET_HWP_ERROR(rc, RC_MSS_EFF_CONFIG_UDIMM_UNSUPPORTED_TYPE); return rc;
+                  if (p_o_atts->eff_num_ranks_per_dimm[l_cur_mba_port][l_cur_mba_dimm] == 1) {
+                     p_o_atts->eff_ibm_type[l_cur_mba_port][l_cur_mba_dimm] = fapi::ENUM_ATTR_EFF_IBM_TYPE_TYPE_1A;
+                  } else if (p_o_atts->eff_num_ranks_per_dimm[l_cur_mba_port][l_cur_mba_dimm] == 2) {
+                     p_o_atts->eff_ibm_type[l_cur_mba_port][l_cur_mba_dimm] = fapi::ENUM_ATTR_EFF_IBM_TYPE_TYPE_1B;
+                  } else if (p_o_atts->eff_num_ranks_per_dimm[l_cur_mba_port][l_cur_mba_dimm] == 4) {
+                     p_o_atts->eff_ibm_type[l_cur_mba_port][l_cur_mba_dimm] = fapi::ENUM_ATTR_EFF_IBM_TYPE_TYPE_1D;
+                  } else {
+                     p_o_atts->eff_ibm_type[l_cur_mba_port][l_cur_mba_dimm] = fapi::ENUM_ATTR_EFF_IBM_TYPE_UNDEFINED;
+                     FAPI_ERR("Currently unsupported IBM_TYPE on %s!", i_target_mba.toEcmdString());
+                     FAPI_SET_HWP_ERROR(rc, RC_MSS_EFF_CONFIG_UDIMM_UNSUPPORTED_TYPE); return rc;
+                  }
                }
             } else if ( p_o_atts->eff_dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM ) {
                if (p_o_atts->eff_dram_gen == fapi::ENUM_ATTR_EFF_DRAM_GEN_DDR3) {
@@ -2398,6 +2673,53 @@ FAPI_DBG("DDR4 Check:  SPD=0x%x, p_i_tFAWmin (nCK) = %i",
                FAPI_ERR("Currently unsupported DIMM_TYPE on %s!", i_target_mba.toEcmdString());
                FAPI_SET_HWP_ERROR(rc, RC_MSS_EFF_CONFIG_DIMM_UNSUPPORTED_TYPE); return rc;
             }
+
+            // Support for new attribute ATTR_EFF_DRAM_ADDRESS_MIRRORING 
+            if ( p_o_atts->eff_dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_RDIMM ) {
+               if (p_o_atts->eff_dram_gen == fapi::ENUM_ATTR_EFF_DRAM_GEN_DDR4) {
+                  // Assuming Byte136[7:0]:Byte137[7:0] right align based on dimm_spd_attributes.xml
+                  // Mask for bit0 of Byte136 = 0x00000100
+                  if ((p_i_data->addr_map_reg_to_dram[l_cur_mba_port][l_cur_mba_dimm] & 0x00000001) != 0) {
+                     if (p_o_atts->eff_num_ranks_per_dimm[l_cur_mba_port][l_cur_mba_dimm] == 4) {
+                        p_o_atts->eff_dram_address_mirroring[l_cur_mba_port][l_cur_mba_dimm] = 0x05;
+                     } else if (p_o_atts->eff_num_ranks_per_dimm[l_cur_mba_port][l_cur_mba_dimm] == 2) {
+                        p_o_atts->eff_dram_address_mirroring[l_cur_mba_port][l_cur_mba_dimm] = 0x04;
+                     } else {
+                        p_o_atts->eff_dram_address_mirroring[l_cur_mba_port][l_cur_mba_dimm] = 0x00;
+                     }
+                  } else {
+                     p_o_atts->eff_dram_address_mirroring[l_cur_mba_port][l_cur_mba_dimm] = 0x00;
+                  }
+               } else {
+                  p_o_atts->eff_dram_address_mirroring[l_cur_mba_port][l_cur_mba_dimm] = 0x00;
+               }
+            } else if (( p_o_atts->eff_dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_UDIMM ) && ( p_o_atts->eff_custom_dimm == fapi::ENUM_ATTR_EFF_CUSTOM_DIMM_YES )) {
+               p_o_atts->eff_dram_address_mirroring[l_cur_mba_port][l_cur_mba_dimm] = vpd_dram_address_mirroring[l_cur_mba_port][l_cur_mba_dimm];
+            } else if ( p_o_atts->eff_dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM ) {
+               if (p_o_atts->eff_dram_gen == fapi::ENUM_ATTR_EFF_DRAM_GEN_DDR4) {
+                  // Assuming Byte136[7:0]:Byte137[7:0] right align based on dimm_spd_attributes.xml
+                  // Mask for bit0 of Byte136 = 0x00000100
+                  if ((p_i_data->addr_map_reg_to_dram[l_cur_mba_port][l_cur_mba_dimm] & 0x00000100) != 0) {
+                     if (p_o_atts->eff_num_ranks_per_dimm[l_cur_mba_port][l_cur_mba_dimm] == 4) {
+                        p_o_atts->eff_dram_address_mirroring[l_cur_mba_port][l_cur_mba_dimm] = 0x05;
+                     } else if (p_o_atts->eff_num_ranks_per_dimm[l_cur_mba_port][l_cur_mba_dimm] == 2) {
+                        p_o_atts->eff_dram_address_mirroring[l_cur_mba_port][l_cur_mba_dimm] = 0x04;
+                     } else {
+                        p_o_atts->eff_dram_address_mirroring[l_cur_mba_port][l_cur_mba_dimm] = 0x00;
+                     }
+                  } else {
+                     p_o_atts->eff_dram_address_mirroring[l_cur_mba_port][l_cur_mba_dimm] = 0x00;
+                  }
+               } else {
+                  // DDR3 LRDIMM not supported
+                  p_o_atts->eff_dram_address_mirroring[l_cur_mba_port][l_cur_mba_dimm] = 0x00;
+               }
+            } else {
+               p_o_atts->eff_dram_address_mirroring[l_cur_mba_port][l_cur_mba_dimm] = 0x00;
+               FAPI_ERR("Currently unsupported DIMM_TYPE on %s!", i_target_mba.toEcmdString());
+               FAPI_SET_HWP_ERROR(rc, RC_MSS_EFF_CONFIG_DIMM_UNSUPPORTED_TYPE); return rc;
+            }
+
           } else {
              p_o_atts->eff_num_ranks_per_dimm[l_cur_mba_port]
                  [l_cur_mba_dimm] = 0;
@@ -2405,6 +2727,7 @@ FAPI_DBG("DDR4 Check:  SPD=0x%x, p_i_tFAWmin (nCK) = %i",
                  [l_cur_mba_dimm] = 0x00;
             p_o_atts->eff_stack_type[l_cur_mba_port][l_cur_mba_dimm] = fapi::ENUM_ATTR_EFF_STACK_TYPE_NONE;
             p_o_atts->eff_ibm_type[l_cur_mba_port][l_cur_mba_dimm] = fapi::ENUM_ATTR_EFF_IBM_TYPE_UNDEFINED;
+            p_o_atts->eff_dram_address_mirroring[l_cur_mba_port][l_cur_mba_dimm] = 0x00;
           }
 //------------------------------------------------------------------------------
           
@@ -2462,8 +2785,27 @@ FAPI_DBG("DDR4 Check:  SPD=0x%x, p_i_tFAWmin (nCK) = %i",
             {
                 p_o_atts->eff_num_master_ranks_per_dimm[l_cur_mba_port]
                         [l_cur_mba_dimm] = 1;
-            } 
-            else 
+            }
+				//Preet Add 3 TSV Type here     
+			else if ((p_i_data->dram_device_type[l_cur_mba_port][l_cur_mba_dimm] == fapi::ENUM_ATTR_SPD_DRAM_DEVICE_TYPE_DDR4) && (p_i_data->sdram_device_type_signal_loading[l_cur_mba_port][l_cur_mba_dimm] == fapi::ENUM_ATTR_SPD_SDRAM_DEVICE_TYPE_SIGNAL_LOADING_SINGLE_LOAD_STACK))
+			{
+				//FAPI_INF("Preet +++ - %d num_ranks --- ",p_i_data->num_ranks[l_cur_mba_port][l_cur_mba_dimm] );
+				if(p_i_data->num_ranks[l_cur_mba_port][l_cur_mba_dimm] == fapi::ENUM_ATTR_SPD_NUM_RANKS_R1)
+				{
+						p_o_atts->eff_num_master_ranks_per_dimm[l_cur_mba_port][l_cur_mba_dimm] = 1;
+						p_o_atts->eff_dimm_ranks_configed[l_cur_mba_port][l_cur_mba_dimm] = 0x80;
+				}
+			else if(p_i_data->num_ranks[l_cur_mba_port][l_cur_mba_dimm] == fapi::ENUM_ATTR_SPD_NUM_RANKS_R2)
+				{	p_o_atts->eff_num_master_ranks_per_dimm[l_cur_mba_port][l_cur_mba_dimm] = 2;
+					p_o_atts->eff_dimm_ranks_configed[l_cur_mba_port][l_cur_mba_dimm] = 0xC0;
+				}
+			else if(p_i_data->num_ranks[l_cur_mba_port][l_cur_mba_dimm] == fapi::ENUM_ATTR_SPD_NUM_RANKS_R4)
+				{
+					p_o_atts->eff_num_master_ranks_per_dimm[l_cur_mba_port][l_cur_mba_dimm] = 4;
+					p_o_atts->eff_dimm_ranks_configed[l_cur_mba_port][l_cur_mba_dimm] = 0xF0;
+				}
+			}
+			else 
             {
                 // AST HERE: Needs SPD byte33[7,1:0],
                 //  currently hard coded to no stacking
@@ -2550,6 +2892,9 @@ FAPI_DBG("DDR4 Check:  SPD=0x%x, p_i_tFAWmin (nCK) = %i",
                p_o_atts->eff_dimm_rcd_cntl_word_0_15[l_cur_mba_port][l_cur_mba_dimm] = p_o_atts->eff_dimm_rcd_cntl_word_0_15[l_cur_mba_port][l_cur_mba_dimm] | l_mss_volt_mask;
                p_o_atts->eff_dimm_rcd_cntl_word_0_15[l_cur_mba_port][l_cur_mba_dimm] = p_o_atts->eff_dimm_rcd_cntl_word_0_15[l_cur_mba_port][l_cur_mba_dimm] | l_rcd_ibt_mask;
                p_o_atts->eff_dimm_rcd_cntl_word_0_15[l_cur_mba_port][l_cur_mba_dimm] = p_o_atts->eff_dimm_rcd_cntl_word_0_15[l_cur_mba_port][l_cur_mba_dimm] | l_rcd_output_timing_mask;
+            } else if ((p_o_atts->eff_dram_gen == fapi::ENUM_ATTR_EFF_DRAM_GEN_DDR4) && ( p_o_atts->eff_dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_RDIMM ) && (p_o_atts->eff_num_ranks_per_dimm[l_cur_mba_port][l_cur_mba_dimm] != 0)) {
+               // AST HERE: Need to add DDR4 RDIMM support.
+               p_o_atts->eff_dimm_rcd_cntl_word_0_15[l_cur_mba_port][l_cur_mba_dimm] = 0x0000000000000000LL;
             } else {
                p_o_atts->eff_dimm_rcd_cntl_word_0_15[l_cur_mba_port][l_cur_mba_dimm] = 0x0000000000000000LL;
             }
@@ -2569,6 +2914,40 @@ FAPI_DBG("DDR4 Check:  SPD=0x%x, p_i_tFAWmin (nCK) = %i",
 
         } // inner for loop
     } // outer for loop
+
+
+    // Select EFF_DRAM_AL
+    if (p_i_data->dram_device_type[0][0] == fapi::ENUM_ATTR_SPD_DRAM_DEVICE_TYPE_DDR3) {
+       if ( mss_dram_2n_mode_enable == fapi::ENUM_ATTR_VPD_DRAM_2N_MODE_ENABLED_TRUE ) {
+          p_o_atts->eff_dram_al = fapi::ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_2; // Always use AL = CL - 2 for 2N/2T mode
+       } else {
+          p_o_atts->eff_dram_al = fapi::ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_1; // Always use AL = CL - 1 for 1N/1T mode
+       }
+    } else if (p_i_data->dram_device_type[0][0] == fapi::ENUM_ATTR_SPD_DRAM_DEVICE_TYPE_DDR4) {
+       if ( p_o_atts->eff_stack_type[0][0] == fapi::ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS ) {
+          if ( mss_dram_2n_mode_enable == fapi::ENUM_ATTR_VPD_DRAM_2N_MODE_ENABLED_TRUE ) {
+             p_o_atts->eff_dram_al = fapi::ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_3; // Always use AL = CL - 3 for 2N/2T mode
+          } else {
+             p_o_atts->eff_dram_al = fapi::ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_2; // Always use AL = CL - 2 for 1N/1T mode
+          }
+       } else {
+          if ( mss_dram_2n_mode_enable == fapi::ENUM_ATTR_VPD_DRAM_2N_MODE_ENABLED_TRUE ) {
+             p_o_atts->eff_dram_al = fapi::ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_2; // Always use AL = CL - 2 for 2N/2T mode
+          } else {
+             p_o_atts->eff_dram_al = fapi::ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_1; // Always use AL = CL - 1 for 1N/1T mode
+          }
+       }
+    } else {
+       FAPI_ERR("Incompatable DRAM generation on %s!",i_target_mba.toEcmdString());
+       uint8_t& DRAM_DEVICE_TYPE_0_0 = p_i_data->dram_device_type[0][0];
+       uint8_t& DRAM_DEVICE_TYPE_0_1 = p_i_data->dram_device_type[0][1];
+       uint8_t& DRAM_DEVICE_TYPE_1_0 = p_i_data->dram_device_type[1][0];
+       uint8_t& DRAM_DEVICE_TYPE_1_1 = p_i_data->dram_device_type[1][1];
+       FAPI_SET_HWP_ERROR(rc, RC_MSS_EFF_CONFIG_INCOMPATABLE_DRAM_GEN);
+       return rc;
+    }
+
+
     return rc;
 } // end mss_eff_config_setup_eff_atts()
 
@@ -2596,6 +2975,9 @@ fapi::ReturnCode mss_eff_config_write_eff_atts(
 
     do
     {
+
+        rc = FAPI_ATTR_SET(ATTR_EFF_DRAM_ADDRESS_MIRRORING, &i_target_mba, p_i_atts->eff_dram_address_mirroring);if(rc) break;
+
         // Set attributes
         rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_RANKS_CONFIGED, &i_target_mba,
                 p_i_atts->eff_dimm_ranks_configed);
@@ -2703,18 +3085,21 @@ fapi::ReturnCode mss_eff_config_write_eff_atts(
                 p_i_atts->eff_dram_trrd);
         if(rc) break;
         // DDR4 only
-        // AST HERE: Need ATTR added
-        //rc = FAPI_ATTR_SET(ATTR_EFF_DRAM_TRRD_L, &i_target_mba,
-        //        p_i_atts->eff_dram_trrd);
-        //if(rc) break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DRAM_TRRD_L, &i_target_mba, 
+			p_i_atts->eff_dram_trrdl);
+        if(rc) break;
         // DDR4 only
         rc = FAPI_ATTR_SET(ATTR_TCCD_L, &i_target_mba,
-                p_i_atts->eff_dram_tccdl);
+			p_i_atts->eff_dram_tccdl);
         if(rc) break;
 
         rc = FAPI_ATTR_SET(ATTR_EFF_DRAM_TCCD_L, &i_target_mba,
                 p_i_atts->eff_dram_tccdl);
         if(rc) break;
+		
+		//rc = FAPI_ATTR_SET(ATTR_EFF_DRAM_TCCD_S, &i_target_mba,
+        //        p_i_atts->eff_dram_tccds);
+        //if(rc) break;
 
         rc = FAPI_ATTR_SET(ATTR_EFF_DRAM_TRTP, &i_target_mba,
                 p_i_atts->eff_dram_trtp);
@@ -2723,10 +3108,9 @@ fapi::ReturnCode mss_eff_config_write_eff_atts(
                 p_i_atts->eff_dram_twtr);
         if(rc) break;
         // DDR4 only
-        // AST HERE: Need ATTR added
-        //rc = FAPI_ATTR_SET(ATTR_EFF_DRAM_TWTRL, &i_target_mba,
-        //p_i_atts->eff_dram_twtrl);
-        //if(rc) break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DRAM_TWTR_L, &i_target_mba,
+        p_i_atts->eff_dram_twtrl);
+        if(rc) break;
         rc = FAPI_ATTR_SET(ATTR_EFF_DRAM_WIDTH, &i_target_mba,
                 p_i_atts->eff_dram_width);
         if(rc) break;
@@ -2846,6 +3230,68 @@ fapi::ReturnCode mss_eff_config_write_eff_atts(
                 p_i_atts->dimm_functional_vector);
         if(rc) break;
 
+        // DDR4 Only
+        rc = FAPI_ATTR_SET(ATTR_EFF_VREF_DQ_TRAIN_VALUE, &i_target_mba, p_i_atts->eff_vref_dq_train_value); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_VREF_DQ_TRAIN_RANGE, &i_target_mba, p_i_atts->eff_vref_dq_train_range); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target_mba, p_i_atts->eff_vref_dq_train_enable); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_MPR_PAGE, &i_target_mba, p_i_atts->eff_mpr_page); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DRAM_LPASR, &i_target_mba, p_i_atts->eff_dram_lpasr); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_GEARDOWN_MODE, &i_target_mba, p_i_atts->eff_geardown_mode); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_PER_DRAM_ACCESS, &i_target_mba, p_i_atts->eff_per_dram_access); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_TEMP_READOUT, &i_target_mba, p_i_atts->eff_temp_readout); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_FINE_REFRESH_MODE, &i_target_mba, p_i_atts->eff_fine_refresh_mode); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_CRC_WR_LATENCY, &i_target_mba, p_i_atts->eff_crc_wr_latency); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_MPR_RD_FORMAT, &i_target_mba, p_i_atts->eff_mpr_rd_format); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_MAX_POWERDOWN_MODE, &i_target_mba, p_i_atts->eff_max_powerdown_mode); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_TEMP_REF_RANGE, &i_target_mba, p_i_atts->eff_temp_ref_range); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_TEMP_REF_MODE, &i_target_mba, p_i_atts->eff_temp_ref_mode); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_INT_VREF_MON, &i_target_mba, p_i_atts->eff_int_vref_mon); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_SELF_REF_ABORT, &i_target_mba, p_i_atts->eff_self_ref_abort); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_RD_PREAMBLE_TRAIN, &i_target_mba, p_i_atts->eff_rd_preamble_train); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_RD_PREAMBLE, &i_target_mba, p_i_atts->eff_rd_preamble); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_WR_PREAMBLE, &i_target_mba, p_i_atts->eff_wr_preamble); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_ODT_INPUT_BUFF, &i_target_mba, p_i_atts->eff_odt_input_buff); if(rc)  break;
+        //rc = FAPI_ATTR_SET(ATTR_EFF_RTT_PARK, &i_target_mba, p_i_atts->eff_rtt_park); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DATA_MASK, &i_target_mba, p_i_atts->eff_data_mask); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_WRITE_DBI, &i_target_mba, p_i_atts->eff_write_dbi); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_READ_DBI, &i_target_mba, p_i_atts->eff_read_dbi); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_CA_PARITY, &i_target_mba, p_i_atts->eff_ca_parity); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_CA_PARITY_LATENCY, &i_target_mba, p_i_atts->eff_ca_parity_latency); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_CA_PARITY_ERROR_STATUS, &i_target_mba, p_i_atts->eff_ca_parity_error_status); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_WRITE_CRC, &i_target_mba, p_i_atts->eff_write_crc); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_CS_CMD_LATENCY, &i_target_mba, p_i_atts->eff_cs_cmd_latency); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_CRC_ERROR_CLEAR, &i_target_mba, p_i_atts->eff_crc_error_clear); if(rc)  break;
+        // DDR4 RDIMM Preet
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC00, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc00); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC01, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc01); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC02, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc02); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC03, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc03); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC04, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc04); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC05, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc05); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC06_07, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc06_07); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC08, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc08); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC09, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc09); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC10, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc10); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC11, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc11); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC12, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc12); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC13, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc13); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC14, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc14); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC15, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc15); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC_1x, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc_1x); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC_2x, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc_2x); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC_3x, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc_3x); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC_4x, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc_4x); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC_5x, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc_5x); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC_6x, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc_6x); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC_7x, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc_7x); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC_8x, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc_8x); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC_9x, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc_9x); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC_Ax, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc_ax); if(rc)  break;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DIMM_DDR4_RC_Bx, &i_target_mba, p_i_atts->eff_dimm_ddr4_rc_bx); if(rc)  break;
+
+
+
+        // Calibration switches
         rc = FAPI_ATTR_SET(ATTR_MSS_CAL_STEP_ENABLE, &i_target_mba,
                 p_i_atts->mss_cal_step_enable);
         if(rc) break;
diff --git a/src/usr/hwpf/hwp/mc_config/mss_freq/mss_freq.C b/src/usr/hwpf/hwp/mc_config/mss_freq/mss_freq.C
index 42fb34b..56f470b 100644
--- a/src/usr/hwpf/hwp/mc_config/mss_freq/mss_freq.C
+++ b/src/usr/hwpf/hwp/mc_config/mss_freq/mss_freq.C
@@ -242,9 +242,21 @@ fapi::ReturnCode mss_freq(const fapi::Target &i_target_memb)
                         //Invalid due to the fact that JEDEC dictates that these should be zero.
                         // Log error and continue to next DIMM
                         FAPI_ERR("Invalid data received from SPD DDR4 MTB/FTB Timebase");
+                        
                         const uint8_t &MTB_DDR4 = l_spd_tb_mtb_ddr4;
                         const uint8_t &FTB_DDR4 = l_spd_tb_ftb_ddr4;
                         const fapi::Target &DIMM_TARGET = l_dimm_targets[j];
+
+                        l_rc = FAPI_ATTR_GET(ATTR_SPD_TAAMIN,
+                                            &l_dimm_targets[j],
+                                            l_spd_min_taa_MTB);
+                        if (l_rc)
+                        {
+                            FAPI_ERR("EYECATCHER: ERRORED GETTING ATTR: %x",
+                                    l_spd_min_taa_MTB);
+                        }
+                        FAPI_INF("EYECATCHER: ATTR_SPD_TAAMIN - %x", l_spd_min_taa_MTB )
+                        
                         FAPI_SET_HWP_ERROR(l_rc, RC_MSS_UNSUPPORTED_SPD_DATA_DDR4);
                         fapiLogError(l_rc);
                         continue;
@@ -311,6 +323,10 @@ fapi::ReturnCode mss_freq(const fapi::Target &i_target_memb)
                     FAPI_ERR("Unable to read SPD Minimum TA    std::vector<fapi::Target> l_target_dimm_array;A (Min CAS Latency Time).");
                     break;
                 }
+
+            
+
+
                 l_rc = FAPI_ATTR_GET(ATTR_SPD_CAS_LATENCIES_SUPPORTED, &l_dimm_targets[j], l_spd_cas_lat_supported);
                 if (l_rc)
                 {
diff --git a/src/usr/hwpf/hwp/memory_attributes.xml b/src/usr/hwpf/hwp/memory_attributes.xml
index df3a2ef..bb85be8 100644
--- a/src/usr/hwpf/hwp/memory_attributes.xml
+++ b/src/usr/hwpf/hwp/memory_attributes.xml
@@ -23,10 +23,25 @@
 <!--                                                                        -->
 <!-- IBM_PROLOG_END_TAG                                                     -->
 <attributes>
-<!-- $Id: memory_attributes.xml,v 1.159AL_custom 2014/11/18 17:35:29 aalugore Exp $ -->
+<!-- $Id: memory_attributes.xml,v 1.166 2015/11/04 15:55:30 asaetow Exp $ -->
 <!-- DO NOT EDIT THIS FILE DIRECTLY PLEASE UPDATE THE ODS FILE AND FOLLOW THE INSTRUCTION TAB -->
 <!-- PLEASE SEE MARK BELLOWS (BELLOWS.IBM.COM) OR OTHERS ON MEMORY TEAM FOR HELP -->
-<!-- *********************************************************************** -->
+<!-- *********************************************************************** --> 
+
+<attribute>
+    <id>ATTR_EFF_DRAM_ADDRESS_MIRRORING</id>
+    <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
+    <description>
+        Ranks that have address mirroring.
+        This data is derived from SPD and C-DIMM VPD.
+        Bit wise map bit4=RANK0_MIRRORED, bit5=RANK1_MIRRORED, bit6=RANK2_MIRRORED, bit7=RANK3_MIRRORED
+    Note: Muliple ranks can be mirrored.
+    </description>
+    <valueType>uint8</valueType>
+    <array> 2 2</array>
+    <writeable/>
+    <odmVisable/>
+</attribute>
 
 <attribute>
     <id>ATTR_MSS_VOLT</id>
@@ -99,7 +114,7 @@ Set by: PLL settings written by Dave Cadigan</description>
 <id>ATTR_MSS_VREF_CAL_CNTL</id>
     <targetType>TARGET_TYPE_MEMBUF_CHIP</targetType>
     <description>Training Control over IPL - ENUM - 0x00=DISABLE /Skip V-ref Train; 0x01=DRAM - Enable V-Ref Train DRAM Level; 0x02=RANK Level Training; 0x03=PORT Level Training; 0x04=MBA Level; 0x05=CENTAUR level;
-        Default Value = 0x01;
+	Default Value = 0x01;
 </description>
     <valueType>uint8</valueType>
     <platInit/>
@@ -108,7 +123,7 @@ Set by: PLL settings written by Dave Cadigan</description>
     <odmChangeable/>
     <persistRuntime/>
 </attribute>
-
+	
 <attribute>
     <id>ATTR_MSS_DIMM_MFG_ID_CODE</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
@@ -794,6 +809,19 @@ firmware notes: none</description>
 </attribute>
 
 <attribute>
+    <id>ATTR_EFF_DRAM_TRRD_L</id>
+    <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
+    <description>DDR4 - Row to Row:Long timings tRRD_L : bank accesses within the same bank group
+creator: mss_eff_cnfg_timing
+consumer: various
+firmware notes: none</description>
+    <valueType>uint8</valueType>
+    <writeable/>
+    <odmVisable/>
+    <odmChangeable/>
+</attribute>
+
+<attribute>
     <id>ATTR_EFF_DRAM_TRP</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
     <description>Row Precharge Delay.  Used in various locations and is computed in mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.  Each memory channel will have a value.
@@ -872,6 +900,19 @@ firmware notes: none</description>
 </attribute>
 
 <attribute>
+    <id>ATTR_EFF_DRAM_TWTR_L</id>
+    <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
+    <description>DDR4 - Long timings (tCCD_L, tRRD_L, and tWTR_L): bank accesses within the same bank group
+creator: mss_eff_cnfg_timing
+consumer: various
+firmware notes: none</description>
+    <valueType>uint8</valueType>
+    <writeable/>
+    <odmVisable/>
+    <odmChangeable/>
+</attribute>
+
+<attribute>
     <id>ATTR_EFF_DRAM_TRTP</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
     <description>Internal Read to Precharge Delay. Used in various locations and is computed in mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.  Each memory channel will have a value.
@@ -932,7 +973,7 @@ creator: mss_eff_cnfg_timing
 consumer: various
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <enum>DISABLE = 0, CL_MINUS_1 = 1, CL_MINUS_2 = 2</enum>
+    <enum>DISABLE = 0, CL_MINUS_1 = 1, CL_MINUS_2 = 2, CL_MINUS_3 = 3</enum>
     <writeable/>
     <odmVisable/>
     <odmChangeable/>
@@ -1177,15 +1218,14 @@ firmware notes: none</description>
     <id>ATTR_EFF_DIMM_DDR4_RC00</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
     <description>F0RC00: Global Features Control Word.For normal operation, output inversion is always enabled. For DIMM vendor test purpose, output inversion can be disabled. 
-When disabled, register tPDM is not guaranteed to be met. NOTE: Default value - 0x00. Values Range from 0-8.
+When disabled, register tPDM is not guaranteed to be met. NOTE: creator: mss_eff_cnfg will set Default value - 0x00. Values Range from 0-8.
 00 - Normal Operation; 01 - Output Inversion Disabled; 02 - Weak Drive Enabled; 04 - A outputs disabled; 08 - B outputs disabled; So on.
 No need to calculate; User can override with desired experimental value.
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1195,13 +1235,12 @@ firmware notes: none</description>
     <id>ATTR_EFF_DIMM_DDR4_RC01</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
     <description>F0RC01 - Clock Driver Enable Control Word.1. Output clocks may be individually turned on or off to conserve power. The system must read the module SPD to determine which clock outputs are used by the module. The PLL remains locked on CK_t/CK_c unless the system stops the clock inputs to the DDR4RCD02 to enter the lowest power mode.
-        Default value - 0x00. Values Range from 0-8. No need to calculate; User can override with desired experimental value.
+	creator: mss_eff_cnfg will set Default value - 0x00. Values Range from 0-8. No need to calculate; User can override with desired experimental value.
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1210,13 +1249,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC02</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>F0RC02: Timing and IBT Control Word; Default value - 0x00. Values Range from 0-8. No need to calculate; User can override with desired experimental value.
+    <description>F0RC02: Timing and IBT Control Word; mss_eff_cnfg will set Default value - 0x00. Values Range from 0-8. No need to calculate; User can override with desired experimental value.
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1225,13 +1263,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC03</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>F0RC03 - CA and CS Signals Driver Characteristics Control Word;  Default value - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD byte 137, 1st Nibble for CS and CA.
+    <description>F0RC03 - CA and CS Signals Driver Characteristics Control Word;  mss_eff_cnfg will set Default value - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD byte 137, 1st Nibble for CS and CA.
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1240,13 +1277,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC04</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>F0RC04 - ODT and CKE Signals Driver Characteristics Control Word;  Default value - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD byte 137, 2nd Nibble for ODT and CKE.
+    <description>F0RC04 - ODT and CKE Signals Driver Characteristics Control Word; mss_eff_cnfg will set Default value - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD byte 137, 2nd Nibble for ODT and CKE.
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1255,13 +1291,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC05</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>F0RC05 - Clock Driver Characteristics Control Word;  Default value - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD byte 138, 2nd Nibble for CK.
+    <description>F0RC05 - Clock Driver Characteristics Control Word; mss_eff_cnfg will set Default value - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD byte 138, 2nd Nibble for CK.
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1270,13 +1305,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC06_07</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>F0RC06: Command Space Control Word definition;  Default value - 0xF0 (NOP). Values Range from 00 to F0. F0RC07 not used. RDIMM
+    <description>F0RC06: Command Space Control Word definition; mss_eff_cnfg will set Default value - 0xF0 (NOP). Values Range from 00 to F0. F0RC07 not used. RDIMM
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1285,14 +1319,13 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC08</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>F0RC08: Input/Output Configuration Control Word; Default value - 0x03. Values Range from 00 to 08 decimal. Check the stack height and calculate dynamically; 00 = Stack height_8; 01 = Stack height_4;
+    <description>F0RC08: Input/Output Configuration Control Word; mss_eff_cnfg will set Default value - 0x03. Values Range from 00 to 08 decimal. Check the stack height and calculate dynamically; 00 = Stack height_8; 01 = Stack height_4;
         02 = Stack height_2;
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1301,13 +1334,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC09</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>F0RC09: Power Saving Settings Control Word; Default value - 0xF0 (NOP). Values Range from 00 to F0. No need to calculate; User can override with desired experimental value.
+    <description>F0RC06: Command Space Control Word definition;mss_eff_cnfg will set  Default value - 0xF0 (NOP). Values Range from 00 to F0. No need to calculate; User can override with desired experimental value.
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1316,13 +1348,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC10</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>RDIMM Operating Speed;  Read from ATTR_MSS_FREQ; Default value - 00. Values Range from 00 to 09. No need to calculate; User can override with desired experimental value.
+    <description>RDIMM Operating Speed;  Read from ATTR_MSS_FREQ; mss_eff_cnfg will set Default value - 00. Values Range from 00 to 09. No need to calculate; User can override with desired experimental value.
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1331,13 +1362,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC11</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>Operating Voltage VDD and VrefCA Source Control Word; Read from ATTR_MSS_VOLT. Default value - 14. Values Range from 00 to 15 decimal.  No need to calculate; User can override with desired experimental value.
+    <description>Operating Voltage VDD and VrefCA Source Control Word; Read from ATTR_MSS_VOLT.mss_eff_cnfg will set Default value - 14. Values Range from 00 to 15 decimal.  No need to calculate; User can override with desired experimental value.
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1346,13 +1376,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC12</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>F0RC0C - Training Control Word; Default value - 00. Values Range from 00 to 07 decimal.No need to calculate; User can override with desired experimental value. 
+    <description>F0RC0C - Training Control Word; mss_eff_cnfg will set Default value - 00. Values Range from 00 to 07 decimal.No need to calculate; User can override with desired experimental value. 
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1361,13 +1390,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC13</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>F0RC0D - DIMM Configuration Control Word; Default value - 0B. Values Range from 00 to 15 decimal. Dynamically calculated using 4 bits[0:3] Bit 0 - Address Mirroring; Bit 1 - Rdimm(1)/Lrdimm (0) ; Bit 2 - N/A ; Bit 3 - CS Mode (Direct / Quad CS mode etc); 
+    <description>F0RC0D - DIMM Configuration Control Word; mss_eff_cnfg will set Default value - 0B. Values Range from 00 to 15 decimal. Dynamically calculated using 4 bits[0:3] Bit 0 - Address Mirroring; Bit 1 - Rdimm(1)/Lrdimm (0) ; Bit 2 - N/A ; Bit 3 - CS Mode (Direct / Quad CS mode etc); 
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1376,13 +1404,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC14</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>F0RC0E - Parity Control Word;  Default value - 00. Check from ATTR_EFF_CA_PARITY and assign; Values Range from 00 to 0F. 
+    <description>F0RC0E - Parity Control Word; mss_eff_cnfg will set Default value - 00. Check from ATTR_EFF_CA_PARITY and assign; Values Range from 00 to 0F. 
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1391,13 +1418,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC15</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>F0RC0F - Command Latency Adder Control Word;  Default value - 04. Values Range from 00 to 04. No need to calculate; User can override with desired experimental value.
+    <description>F0RC0F - Command Latency Adder Control Word; mss_eff_cnfg will set  Default value - 04. Values Range from 00 to 04. No need to calculate; User can override with desired experimental value.
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1406,13 +1432,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC_1x</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>F0RC1x - Internal VrefCA Control Word; Default value - 00. Values Range from 00 to 3F.No need to calculate; User can override with desired experimental value. 
+    <description>F0RC1x - Internal VrefCA Control Word; mss_eff_cnfg will set Default value - 00. Values Range from 00 to 3F.No need to calculate; User can override with desired experimental value. 
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1421,13 +1446,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC_2x</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>F0RC2x: I2C Bus Control Word; Default value - 00. Values Range from 00 to FF.No need to calculate; User can override with desired experimental value. 
+    <description>F0RC2x: I2C Bus Control Word; mss_eff_cnfg will set Default value - 00. Values Range from 00 to FF.No need to calculate; User can override with desired experimental value. 
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1436,13 +1460,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC_3x</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>F0RC3x - Fine Granularity RDIMM Operating Speed;  Default value = (Operating Freq - 1250)/20. Values Range from 00 to 61 Hex. 
+    <description>F0RC3x - Fine Granularity RDIMM Operating Speed; mss_eff_cnfg will set Default value = (Operating Freq - 1250)/20. Values Range from 00 to 61 Hex. 
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1451,13 +1474,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC_4x</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>F0RC4x: CW Source Selection Control Word; Default value - 00. Values Range from 00 to FF. No need to calculate; User can override with desired experimental value.
+    <description>F0RC4x: CW Source Selection Control Word; mss_eff_cnfg will set Default value - 00. Values Range from 00 to FF. No need to calculate; User can override with desired experimental value.
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1466,13 +1488,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC_5x</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>F0RC5x: CW Destination Selection and Write/Read Additional QxODT[1:0] Signal High; Default value - 00. Values Range from 00 to FF. No need to calculate; User can override with desired experimental value.
+    <description>F0RC5x: CW Destination Selection and Write/Read Additional QxODT[1:0] Signal High; mss_eff_cnfg will set Default value - 00. Values Range from 00 to FF. No need to calculate; User can override with desired experimental value.
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1481,13 +1502,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC_6x</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>F0RC6x: CW Data Control Word;  Default value - 00. Values Range from 00 to FF.No need to calculate; User can override with desired experimental value. 
+    <description>F0RC6x: CW Data Control Word; mss_eff_cnfg will set Default value - 00. Values Range from 00 to FF.No need to calculate; User can override with desired experimental value. 
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1496,13 +1516,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC_7x</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>F0RC7x: IBT Control Word; Default value - 00. Values Range from 00 to FF.No need to calculate; User can override with desired experimental value.
+    <description>F0RC7x: IBT Control Word; mss_eff_cnfg will set Default value - 00. Values Range from 00 to FF.No need to calculate; User can override with desired experimental value.
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1511,13 +1530,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC_8x</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>F0RC8x: ODT Input Buffer/IBT, QxODT Output Buffer and Timing Control Word;  Default value - 00. Values Range from 00 to FF. No need to calculate; User can override with desired experimental value.
+    <description>F0RC8x: ODT Input Buffer/IBT, QxODT Output Buffer and Timing Control Word; mss_eff_cnfg will set Default value - 00. Values Range from 00 to FF. No need to calculate; User can override with desired experimental value.
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1526,13 +1544,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC_9x</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>F0RC9x1: QxODT[1:0] Write Pattern Control Word; Default value - 00. Values Range from 00 to FF.No need to calculate; User can override with desired experimental value. 
+    <description>F0RC9x1: QxODT[1:0] Write Pattern Control Word; mss_eff_cnfg will set Default value - 00. Values Range from 00 to FF.No need to calculate; User can override with desired experimental value. 
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1541,13 +1558,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC_Ax</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>F0RCAx1: QxODT[1:0] Read Pattern Control Word; Default value - 00. Values Range from 00 to FF. No need to calculate; User can override with desired experimental value. 
+    <description>F0RCAx1: QxODT[1:0] Read Pattern Control Word; mss_eff_cnfg will set Default value - 00. Values Range from 00 to FF. No need to calculate; User can override with desired experimental value. 
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -1556,13 +1572,12 @@ firmware notes: none</description>
 <attribute>
     <id>ATTR_EFF_DIMM_DDR4_RC_Bx</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
-    <description>F0RCBx: IBT and MRS Snoop Control Word;  Default value - 07. Values Range from 00 to FF. No need to calculate; User can override with desired experimental value. 
+    <description>F0RCBx: IBT and MRS Snoop Control Word; mss_eff_cnfg will set Default value - 07. Values Range from 00 to FF. No need to calculate; User can override with desired experimental value. 
 creator: mss_eff_cnfg
 consumer: mss_dram_init
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <writeable/>
-    <platInit/>
+	<writeable/>
     <odmVisable/>
     <odmChangeable/>
     <array> 2 2</array>
@@ -2491,7 +2506,7 @@ creator: mss_eff_cnfg
 consumer: various
 firmware notes: none</description>
     <valueType>uint8</valueType>
-    <enum>DEACTIVATED = 0, ACTIVATED = 1</enum>
+    <enum>ACTIVATED = 0, DEACTIVATED = 1</enum>
     <writeable/>
     <odmVisable/>
     <odmChangeable/>
@@ -2569,7 +2584,7 @@ firmware notes: none</description>
 </attribute>
 
 <attribute>
-    <id>ATTR_VREF_DQ_TRAIN_VALUE</id>
+    <id>ATTR_EFF_VREF_DQ_TRAIN_VALUE</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
     <description>vrefdq_train value. This is for DDR4 MRS6.  Computed in mss_eff_cnfg. Each memory channel will have a value.
 Creator: mss_eff_cnfg
@@ -2583,7 +2598,7 @@ Firmware notes: none</description>
 </attribute>
 
 <attribute>
-    <id>ATTR_VREF_DQ_TRAIN_RANGE</id>
+    <id>ATTR_EFF_VREF_DQ_TRAIN_RANGE</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
     <description>vrefdq_train range. This is for DDR4 MRS6.  Computed in mss_eff_cnfg. Each memory channel will have a value.
 Creator: mss_eff_cnfg
@@ -2598,7 +2613,7 @@ Firmware notes: none</description>
 </attribute>
 
 <attribute>
-    <id>ATTR_VREF_DQ_TRAIN_ENABLE</id>
+    <id>ATTR_EFF_VREF_DQ_TRAIN_ENABLE</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
     <description>vrefdq_train enable. This is for DDR4 MRS6.  Computed in mss_eff_cnfg. Each memory channel will have a value.
 Creator: mss_eff_cnfg
@@ -2627,6 +2642,20 @@ Firmware notes: none</description>
 </attribute>
 
 <attribute>
+    <id>ATTR_EFF_DRAM_TCCD_S</id>
+    <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
+    <description>tccd_S. This is for DDR4 MRS6.  Computed in mss_eff_cnfg. Each memory channel will have a value.
+Creator: mss_eff_cnfg
+Consumer:various
+Firmware notes: none</description>
+    <valueType>uint8</valueType>
+    <enum>4NCK = 4, 5NCK = 5, 6NCK = 6, 7NCK = 7, 8NCK = 8</enum>
+    <writeable/>
+    <odmVisable/>
+    <odmChangeable/>
+</attribute>
+
+<attribute>
     <id>ATTR_TCCD_L</id>
     <targetType>TARGET_TYPE_MBA_CHIPLET</targetType>
     <description>tccd_l. This is for DDR4 MRS6.  Computed in mss_eff_cnfg. Each memory channel will have a value.
@@ -3052,7 +3081,7 @@ Will be set at an MBA level with one policy to be used</description>
     <odmVisable/>
     <odmChangeable/>
     <enum>NONE = 0, 8_0G = 1, 9_6G = 2, 8_0G_OR_9_6G = 3</enum>
-</attribute>
+</attribute> 
 
 <attribute>
     <id>ATTR_MRW_STRICT_MBA_PLUG_RULE_CHECKING</id>
@@ -3425,7 +3454,7 @@ Will be set at an MBA level with one policy to be used</description>
     <valueType>uint32</valueType>
     <platInit/>
     <odmVisable/>
-</attribute>
+</attribute>  
 
 <attribute>
     <id>ATTR_MRW_MEM_SENSOR_CACHE_ADDR_MAP</id>
diff --git a/src/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttr.C b/src/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttr.C
index 5cb3cab..be115f6 100644
--- a/src/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttr.C
+++ b/src/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttr.C
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: getMBvpdAttr.C,v 1.9 2015/10/06 15:17:45 dcrowell Exp $
+// $Id: getMBvpdAttr.C,v 1.10 2015/11/02 21:42:14 sglancy Exp $
 /**
  *  @file getMBvpdAttr.C
  *
@@ -100,6 +100,8 @@ fapi::ReturnCode xlate_DRAM_RON (const fapi::AttributeId i_attr,
                                      uint8_t & io_value);
 fapi::ReturnCode xlate_RTT_NOM  (const fapi::AttributeId i_attr,
                                      uint8_t & io_value);
+fapi::ReturnCode xlate_RTT_PARK  (const fapi::AttributeId i_attr,
+                                     uint8_t & io_value);
 fapi::ReturnCode xlate_RTT_WR   (const fapi::AttributeId i_attr,
                                      uint8_t & io_value);
 fapi::ReturnCode xlate_WR_VREF  (const fapi::AttributeId i_attr,
@@ -890,8 +892,7 @@ uint32_t getUint32 (const uint16_t & i_dataSpecial,
     }
     else
     {
-        memcpy(&o_val, i_pBuffer, sizeof(o_val));
-        o_val = FAPI_BE32TOH(o_val);
+        o_val  = FAPI_BE32TOH(*(uint32_t*) i_pBuffer);
     }
 
     return o_val;
@@ -1058,6 +1059,10 @@ fapi::ReturnCode returnValue (const MBvpdAttrDef*   i_pAttrDef,
                                 l_fapirc=xlate_RTT_NOM(i_pAttrDef->iv_attrId,
                                                                        l_value);
                                 break;
+                            case XLATE_RTT_PARK: // translate
+                                l_fapirc=xlate_RTT_PARK(i_pAttrDef->iv_attrId,
+                                                                       l_value);
+                                break;
                             case XLATE_RTT_WR: // translate
                                 l_fapirc=xlate_RTT_WR(i_pAttrDef->iv_attrId,
                                                                        l_value);
@@ -1315,6 +1320,61 @@ fapi::ReturnCode xlate_RTT_NOM (const fapi::AttributeId i_attr,
 }
 
 // ----------------------------------------------------------------------------
+// Translate vpd values to attribute enumeration for ATTR_VPD_DRAM_RTT_PARK
+// ----------------------------------------------------------------------------
+fapi::ReturnCode xlate_RTT_PARK (const fapi::AttributeId i_attr,
+                                         uint8_t & io_value)
+{
+    fapi::ReturnCode l_fapirc;
+    const uint8_t DRAM_RTT_PARK_DISABLE = 0x00;
+    const uint8_t DRAM_RTT_PARK_OHM34 = 0x07;
+    const uint8_t DRAM_RTT_PARK_OHM40 = 0x03;
+    const uint8_t DRAM_RTT_PARK_OHM48 = 0x85;
+    const uint8_t DRAM_RTT_PARK_OHM60 = 0x01;
+    const uint8_t DRAM_RTT_PARK_OHM80 = 0x06;
+    const uint8_t DRAM_RTT_PARK_OHM120 = 0x02;
+    const uint8_t DRAM_RTT_PARK_OHM240 = 0x84;
+
+    switch(io_value)
+    {
+    case DRAM_RTT_PARK_DISABLE:
+        io_value=fapi::ENUM_ATTR_VPD_DRAM_RTT_PARK_DISABLE;
+        break;
+    case DRAM_RTT_PARK_OHM34:
+        io_value = fapi::ENUM_ATTR_VPD_DRAM_RTT_PARK_34OHM;
+        break;
+    case DRAM_RTT_PARK_OHM40:
+        io_value = fapi::ENUM_ATTR_VPD_DRAM_RTT_PARK_40OHM;
+        break;
+    case DRAM_RTT_PARK_OHM48:
+        io_value = fapi::ENUM_ATTR_VPD_DRAM_RTT_PARK_48OHM;
+        break;
+    case DRAM_RTT_PARK_OHM60:
+        io_value = fapi::ENUM_ATTR_VPD_DRAM_RTT_PARK_60OHM;
+        break;
+    case DRAM_RTT_PARK_OHM80:
+        io_value = fapi::ENUM_ATTR_VPD_DRAM_RTT_PARK_80OHM;
+        break;
+    case DRAM_RTT_PARK_OHM120:
+        io_value = fapi::ENUM_ATTR_VPD_DRAM_RTT_PARK_120OHM;
+        break;
+    case DRAM_RTT_PARK_OHM240:
+        io_value = fapi::ENUM_ATTR_VPD_DRAM_RTT_PARK_240OHM;
+        break;
+    default:
+        FAPI_ERR("Unsupported VPD encode for ATTR_VPD_DRAM_RTT_PARK 0x%02x",
+                    io_value);
+        const fapi::AttributeId & ATTR_ID = i_attr;
+        const uint8_t  & VPD_VALUE = io_value;
+        FAPI_SET_HWP_ERROR(l_fapirc, RC_MBVPD_TERM_DATA_UNSUPPORTED_VPD_ENCODE);
+        break;
+    }
+
+    return  l_fapirc;
+}
+
+
+// ----------------------------------------------------------------------------
 // Translate vpd values to attribute enumeration for ATTR_VPD_DRAM_RTT_WR
 // ----------------------------------------------------------------------------
 fapi::ReturnCode xlate_RTT_WR (const fapi::AttributeId i_attr,
diff --git a/src/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttrData.C b/src/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttrData.C
index 27fd1d8..d54510f 100644
--- a/src/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttrData.C
+++ b/src/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttrData.C
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: getMBvpdAttrData.C,v 1.7 2015/09/30 20:44:12 janssens Exp $
+// $Id: getMBvpdAttrData.C,v 1.9 2015/11/02 21:42:23 sglancy Exp $
 /**
  *  @file getMBvpdAttrData.C
  *
@@ -61,11 +61,13 @@ const MBvpdAttrDef g_MBVPD_ATTR_DEF_array [] =
     {ATTR_VPD_MT_VERSION_BYTE,ALL_DIMM,VM_01,MBVPD_KEYWORD_MT,0,UINT8,0},
     {ATTR_VPD_MT_DATA_CONTROL_BYTE,ALL_DIMM,VM_01,MBVPD_KEYWORD_MT,1,UINT8,0},
     {ATTR_VPD_PERIODIC_MEMCAL_MODE_OPTIONS,ALL_DIMM,VM_01,MBVPD_KEYWORD_MR,50,UINT32_BY2|UINT16_DATA,0},
-    {ATTR_VPD_DRAM_RTT_PARK,ALL_DIMM,VM_01,MBVPD_KEYWORD_MT,10,UINT8_BY2_BY2_BY4|XLATE_RTT_WR,0},
+    {ATTR_VPD_DRAM_RTT_PARK,ALL_DIMM,VM_01,MBVPD_KEYWORD_MT,56,UINT8_BY2_BY2_BY4|XLATE_RTT_PARK,0},
     {ATTR_VPD_RD_CTR_WINDAGE_OFFSET,ALL_DIMM,VM_01,MBVPD_KEYWORD_MT,64,UINT32_BY2|UINT16_DATA,0},
 
-    {ATTR_VPD_DIMM_RCD_OUTPUT_TIMING,ALL_DIMM,VM_01,MBVPD_KEYWORD_MT,68,UINT8_BY2_BY2|DEFAULT_VALUE,0},
-    {ATTR_VPD_DIMM_RCD_IBT,ALL_DIMM,VM_01,MBVPD_KEYWORD_MT,66,UINT32_BY2_BY2|DEFAULT_VALUE,0},
+    {ATTR_VPD_DIMM_RCD_OUTPUT_TIMING,ISDIMM,VM_01,MBVPD_KEYWORD_MT,68,UINT8_BY2_BY2|BOTH_DIMMS,0},
+    {ATTR_VPD_DIMM_RCD_IBT,ISDIMM,VM_01,MBVPD_KEYWORD_MT,66,UINT32_BY2_BY2|UINT8_DATA,0},
+    {ATTR_VPD_DIMM_RCD_OUTPUT_TIMING,CDIMM,VM_01,MBVPD_KEYWORD_MT,68,UINT8_BY2_BY2|DEFAULT_VALUE,0},
+    {ATTR_VPD_DIMM_RCD_IBT,CDIMM,VM_01,MBVPD_KEYWORD_MT,66,UINT32_BY2_BY2|DEFAULT_VALUE,0},
     {ATTR_VPD_CEN_RD_VREF,ALL_DIMM,VM_01,MBVPD_KEYWORD_MT,34,UINT32_BY2|UINT8_DATA|XLATE_RD_VREF,0},
     {ATTR_VPD_DRAM_WR_VREF,ALL_DIMM,VM_01,MBVPD_KEYWORD_MT,35,UINT32_BY2|UINT8_DATA|XLATE_WR_VREF,0},
     {ATTR_VPD_DRAM_WRDDR4_VREF,ALL_DIMM,VM_01,MBVPD_KEYWORD_MT,36,UINT8_BY2,0},
diff --git a/src/usr/targeting/common/xmltohb/attribute_types.xml b/src/usr/targeting/common/xmltohb/attribute_types.xml
index b167638..39bfe11 100644
--- a/src/usr/targeting/common/xmltohb/attribute_types.xml
+++ b/src/usr/targeting/common/xmltohb/attribute_types.xml
@@ -7569,6 +7569,24 @@ firmware notes: Used as override attribute for pstate procedure
 </attribute>
 
 <attribute>
+    <id>EFF_DRAM_TRRD_L</id>
+    <description>DDR4 - Row to Row:Long timings tRRD_L : bank accesses within the same bank group
+creator: mss_eff_cnfg_timing
+consumer: various</description>
+    <simpleType>
+        <uint8_t>
+        </uint8_t>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+    <hwpfToHbAttrMap>
+        <id>ATTR_EFF_DRAM_TRRD_L</id>
+        <macro>DIRECT</macro>
+    </hwpfToHbAttrMap>
+</attribute>
+
+<attribute>
     <id>EFF_DRAM_TRP</id>
     <description>DRAM Row Precharge Delay. Initialized and used by HWPs.</description>
     <simpleType>
@@ -7665,6 +7683,22 @@ firmware notes: Used as override attribute for pstate procedure
 </attribute>
 
 <attribute>
+    <id>EFF_DRAM_TWTR_L</id>
+    <description>DDR4 -Long timings (tCCD_L, tRRD_L, and tWTR_L): bank accesses within the same bank group</description>
+    <simpleType>
+        <uint8_t>
+        </uint8_t>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+    <hwpfToHbAttrMap>
+        <id>ATTR_EFF_DRAM_TWTR_L</id>
+        <macro>DIRECT</macro>
+    </hwpfToHbAttrMap>
+</attribute>
+
+<attribute>
     <id>EFF_DRAM_TRTP</id>
     <description>DRAM Internal Read to Precharge Delay. Initialized and used by HWPs.</description>
     <simpleType>
@@ -11623,8 +11657,8 @@ firmware notes: Platforms should initialize this attribute to AUTO (0)</descript
 </attribute>
 
 <attribute>
-    <id>EFF_VREF_DQ_TRAIN_VALUE</id>
-    <description>vrefdq_train value. This is for DDR4 MRS6.  Computed in mss_eff_cnfg. Each memory channel will have a value.
+    <id>EFF_VREF_DQ_TRAIN_RANGE</id>
+    <description>vrefdq_train range. This is for DDR4 MRS6.  Computed in mss_eff_cnfg. Each memory channel will have a value.
       creator: mss_eff_cnfg
       consumer: various
       firmware notes: none</description>
@@ -11636,14 +11670,14 @@ firmware notes: Platforms should initialize this attribute to AUTO (0)</descript
     <readable/>
     <writeable/>
     <hwpfToHbAttrMap>
-        <id>ATTR_VREF_DQ_TRAIN_VALUE</id>
+        <id>ATTR_EFF_VREF_DQ_TRAIN_RANGE</id>
         <macro>DIRECT</macro>
     </hwpfToHbAttrMap>
 </attribute>
 
 <attribute>
-    <id>EFF_VREF_DQ_TRAIN_RANGE</id>
-    <description>vrefdq_train range. This is for DDR4 MRS6.  Computed in mss_eff_cnfg. Each memory channel will have a value.
+    <id>EFF_VREF_DQ_TRAIN_ENABLE</id>
+    <description>vrefdq_train enable. This is for DDR4 MRS6.  Computed in mss_eff_cnfg. Each memory channel will have a value.
       creator: mss_eff_cnfg
       consumer: various
       firmware notes: none</description>
@@ -11655,14 +11689,14 @@ firmware notes: Platforms should initialize this attribute to AUTO (0)</descript
     <readable/>
     <writeable/>
     <hwpfToHbAttrMap>
-        <id>ATTR_VREF_DQ_TRAIN_RANGE</id>
+        <id>ATTR_EFF_VREF_DQ_TRAIN_ENABLE</id>
         <macro>DIRECT</macro>
     </hwpfToHbAttrMap>
 </attribute>
 
 <attribute>
-    <id>EFF_VREF_DQ_TRAIN_ENABLE</id>
-    <description>vrefdq_train enable. This is for DDR4 MRS6.  Computed in mss_eff_cnfg. Each memory channel will have a value.
+    <id>EFF_VREF_DQ_TRAIN_VALUE</id>
+    <description>vrefdq_train value. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory channel will have a value.
       creator: mss_eff_cnfg
       consumer: various
       firmware notes: none</description>
@@ -11674,11 +11708,12 @@ firmware notes: Platforms should initialize this attribute to AUTO (0)</descript
     <readable/>
     <writeable/>
     <hwpfToHbAttrMap>
-        <id>ATTR_VREF_DQ_TRAIN_ENABLE</id>
+        <id>ATTR_EFF_VREF_DQ_TRAIN_VALUE</id>
         <macro>DIRECT</macro>
     </hwpfToHbAttrMap>
 </attribute>
 
+
 <attribute>
     <id>TCCD_L</id>
     <description>tccd_l. This is for DDR4 MRS6.  Computed in mss_eff_cnfg. Each memory channel will have a value.
@@ -16021,6 +16056,7 @@ firmware notes: Platforms should initialize this attribute to AUTO (0)</descript
     </description>
     <simpleType>
         <uint8_t>
+            <default>0</default>
         </uint8_t>
         <array>2,2</array>
     </simpleType>
@@ -16043,6 +16079,7 @@ firmware notes: Platforms should initialize this attribute to AUTO (0)</descript
     </description>
     <simpleType>
         <uint8_t>
+            <default>0</default>
         </uint8_t>
         <array>2,2</array>
     </simpleType>
@@ -16065,6 +16102,7 @@ firmware notes: Platforms should initialize this attribute to AUTO (0)</descript
     </description>
     <simpleType>
         <uint8_t>
+            <default>0</default>
         </uint8_t>
         <array>2,2</array>
     </simpleType>
@@ -16087,6 +16125,7 @@ firmware notes: Platforms should initialize this attribute to AUTO (0)</descript
     </description>
     <simpleType>
         <uint8_t>
+            <default>0</default>
         </uint8_t>
         <array>2,2</array>
     </simpleType>
@@ -16110,6 +16149,7 @@ firmware notes: Platforms should initialize this attribute to AUTO (0)</descript
     </description>
     <simpleType>
         <uint8_t>
+            <default>0</default>
         </uint8_t>
         <array>2,2</array>
     </simpleType>
@@ -16132,6 +16172,7 @@ firmware notes: Platforms should initialize this attribute to AUTO (0)</descript
     </description>
     <simpleType>
         <uint8_t>
+            <default>0</default>
         </uint8_t>
         <array>2,2</array>
     </simpleType>
@@ -16176,6 +16217,7 @@ firmware notes: Platforms should initialize this attribute to AUTO (0)</descript
     </description>
     <simpleType>
         <uint8_t>
+            <default>0</default>
         </uint8_t>
         <array>2,2</array>
     </simpleType>
@@ -16221,6 +16263,7 @@ firmware notes: Platforms should initialize this attribute to AUTO (0)</descript
     </description>
     <simpleType>
         <uint8_t>
+            <default>0</default>
         </uint8_t>
         <array>2,2</array>
     </simpleType>
@@ -16264,6 +16307,7 @@ firmware notes: Platforms should initialize this attribute to AUTO (0)</descript
     </description>
     <simpleType>
         <uint8_t>
+            <default>0</default>
         </uint8_t>
         <array>2,2</array>
     </simpleType>
@@ -16549,6 +16593,25 @@ firmware notes: Platforms should initialize this attribute to AUTO (0)</descript
 </attribute>
 
 <attribute>
+    <id>EFF_DRAM_TCCD_S</id>
+    <description>tccd_s. This is for DDR4 MRS6.  Computed in mss_eff_cnfg. Each memory channel will have a value.
+                 Creator: mss_eff_cnfg
+                 Consumer:various
+                 Firmware notes: none
+    </description>
+    <simpleType>
+        <uint8_t></uint8_t>
+    </simpleType>
+    <persistency>volatile-zeroed</persistency>
+    <readable/>
+    <writeable/>
+    <hwpfToHbAttrMap>
+        <id>ATTR_EFF_DRAM_TCCD_S</id>
+        <macro>DIRECT</macro>
+    </hwpfToHbAttrMap>
+</attribute>
+
+<attribute>
     <id>EFF_LRDIMM_WORD_X</id>
     <description>Additional buffer control word for LRDIMM building of the BCW</description>
     <simpleType>
@@ -16635,55 +16698,6 @@ firmware notes: Platforms should initialize this attribute to AUTO (0)</descript
     <readable/>
 </attribute>
 
-<attribute>
-    <id>EFF_DRAM_TRRD_L</id>
-    <description>DRAM Row to Row Delay. Initialized and used by HWPs.</description>
-    <simpleType>
-        <uint8_t>
-        </uint8_t>
-    </simpleType>
-    <persistency>volatile-zeroed</persistency>
-    <readable/>
-    <writeable/>
-    <hwpfToHbAttrMap>
-        <id>ATTR_EFF_DRAM_TRRD_L</id>
-        <macro>DIRECT</macro>
-    </hwpfToHbAttrMap>
-</attribute>
-
-<attribute>
-    <id>EFF_DRAM_TWTR_L</id>
-    <description>DRAM Internal Write to Read Delay. Initialized and used by HWPs.</description>
-    <simpleType>
-        <uint8_t>
-        </uint8_t>
-    </simpleType>
-    <persistency>volatile-zeroed</persistency>
-    <readable/>
-    <writeable/>
-    <hwpfToHbAttrMap>
-        <id>ATTR_EFF_DRAM_TWTR_L</id>
-        <macro>DIRECT</macro>
-    </hwpfToHbAttrMap>
-</attribute>
 
-<attribute>
-    <id>EFF_DRAM_TCCD_S</id>
-    <description>tccd_l. This is for DDR4 MRS6.  Computed in mss_eff_cnfg. Each memory channel will have a value.
-                 Creator: mss_eff_cnfg
-                 Consumer:various
-                 Firmware notes: none
-    </description>
-    <simpleType>
-        <uint8_t></uint8_t>
-    </simpleType>
-    <persistency>volatile-zeroed</persistency>
-    <readable/>
-    <writeable/>
-    <hwpfToHbAttrMap>
-        <id>ATTR_EFF_DRAM_TCCD_S</id>
-        <macro>DIRECT</macro>
-    </hwpfToHbAttrMap>
-</attribute>
 
 </attributes>
-- 
1.8.2.2

