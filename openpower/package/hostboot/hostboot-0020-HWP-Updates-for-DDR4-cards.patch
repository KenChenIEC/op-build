From c92a2ffbb4ceebec12ebb398e40da0882c3225f9 Mon Sep 17 00:00:00 2001
From: aalugore <aalugore@us.ibm.com>
Date: Mon, 15 Feb 2016 16:51:01 -0600
Subject: [PATCH] SW327804: HWP Updates for DDR4 cards on Garrison(hwp review)

CQ:SW327804
Change-Id: I77402cd90f4c5ba969fb14de08051876ed9c30c3
---
 .../usr/hwpf/hwp/mvpd_accessors/getMBvpdAttr.H     |    5 +-
 .../hwpf/hwp/dram_training/memory_mss_funcs.xml    |   17 +-
 .../dram_training/mss_draminit/mss_ddr4_funcs.H    |   31 +-
 .../hwp/dram_training/mss_draminit/mss_draminit.C  |    9 +-
 .../mss_draminit_mc/mss_draminit_mc.C              |   19 +-
 .../mss_draminit_trainadv/mss_access_delay_reg.C   |  201 +-
 .../mss_draminit_trainadv/mss_access_delay_reg.H   |   21 +-
 .../mss_draminit_trainadv/mss_ddr4_funcs.C         | 2087 ++++++++++-
 .../mss_draminit_trainadv/mss_ddr4_pda.C           | 2965 +++++----------
 .../mss_draminit_trainadv/mss_ddr4_pda.H           |   55 +-
 .../mss_draminit_training_advanced.C               | 3866 +++++++++++---------
 .../mss_draminit_trainadv/mss_mcbist_common.C      |   18 +-
 .../mss_draminit_trainadv/mss_mrs6_DDR4.C          |   11 +-
 .../mss_draminit_training/mss_draminit_training.C  |   41 +-
 src/usr/hwpf/hwp/dram_training/mss_funcs.C         |  117 +-
 .../mss_lrdimm_funcs/mss_lrdimm_ddr4_funcs.H       |  120 +-
 .../mss_lrdimm_funcs/mss_lrdimm_funcs.C            |    7 +-
 src/usr/hwpf/hwp/initfiles/cen_ddrphy.initfile     |   33 +-
 src/usr/hwpf/hwp/lab_dimm_spd_attributes.xml       |   13 +-
 .../memory_mss_eff_config_rank_group.xml           |   36 +-
 .../memory_mss_eff_config_termination.xml          |   69 +-
 .../hwp/mc_config/mss_eff_config/mss_eff_config.C  |    5 +-
 .../mss_eff_config/mss_eff_config_termination.C    |   34 +-
 src/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttr.C     |   71 +-
 src/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttrData.C |   12 +-
 .../hwp/mvpd_accessors/getMBvpdSpareDramData.C     |    2 +-
 26 files changed, 5727 insertions(+), 4138 deletions(-)

diff --git a/src/include/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttr.H b/src/include/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttr.H
index 5916174..e5af2c9 100644
--- a/src/include/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttr.H
+++ b/src/include/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttr.H
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2014,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2014,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: getMBvpdAttr.H,v 1.7 2015/10/06 18:04:03 janssens Exp $
+// $Id: getMBvpdAttr.H,v 1.8 2015/11/02 21:42:22 sglancy Exp $
 
 /**
  *  @file getMBvpdAttr.H
@@ -198,6 +198,7 @@ namespace getAttrData
     // for UNIT8_BY2_BY2_BY4 (all mutually exclusive)
         XLATE_RTT_NOM  = 0x0100,
         XLATE_RTT_WR   = 0x0200,
+        XLATE_RTT_PARK   = 0x0400,
 
     // for UINT32_BY2 (all mutually exclusive)
         XLATE_RD_VREF  = 0x0100,
diff --git a/src/usr/hwpf/hwp/dram_training/memory_mss_funcs.xml b/src/usr/hwpf/hwp/dram_training/memory_mss_funcs.xml
index 479c5ec..84f5a4a 100644
--- a/src/usr/hwpf/hwp/dram_training/memory_mss_funcs.xml
+++ b/src/usr/hwpf/hwp/dram_training/memory_mss_funcs.xml
@@ -5,7 +5,9 @@
 <!--                                                                        -->
 <!-- OpenPOWER HostBoot Project                                             -->
 <!--                                                                        -->
-<!-- COPYRIGHT International Business Machines Corp. 2013,2014              -->
+<!-- Contributors Listed Below - COPYRIGHT 2013,2016                        -->
+<!-- [+] International Business Machines Corp.                              -->
+<!--                                                                        -->
 <!--                                                                        -->
 <!-- Licensed under the Apache License, Version 2.0 (the "License");        -->
 <!-- you may not use this file except in compliance with the License.       -->
@@ -21,7 +23,7 @@
 <!--                                                                        -->
 <!-- IBM_PROLOG_END_TAG                                                     -->
 <hwpErrors>
-<!-- $Id: memory_mss_funcs.xml,v 1.3 2014/03/31 15:54:05 jdsloat Exp $ -->
+<!-- $Id: memory_mss_funcs.xml,v 1.4 2016/02/12 19:44:11 sglancy Exp $ -->
 <!-- For file ../../ipl/fapi/mss_funcs.C -->
 <!-- // *! OWNER NAME : jdsloat@us.ibm.com -->
 <!-- // *! BACKUP NAME : -->
@@ -161,6 +163,15 @@
     <target>TARGET_MBA_ERROR</target>
   </deconfigure>
 </hwpError>
-
+  
+  <hwpError>
+    <rc>RC_MSS_CCS_INDEX_OUT_OF_BOUNDS</rc>
+    <description>An invalid CCS array index was passsed to the function.</description>
+    <ffdc>INDEX_VALUE</ffdc>
+    <callout>
+      <procedure>CODE</procedure>
+      <priority>HIGH</priority>
+    </callout>
+  </hwpError>
 
 </hwpErrors>
diff --git a/src/usr/hwpf/hwp/dram_training/mss_draminit/mss_ddr4_funcs.H b/src/usr/hwpf/hwp/dram_training/mss_draminit/mss_ddr4_funcs.H
index 327b894..e2e0984 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_draminit/mss_ddr4_funcs.H
+++ b/src/usr/hwpf/hwp/dram_training/mss_draminit/mss_ddr4_funcs.H
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2013,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2013,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_ddr4_funcs.H,v 1.5 2015/09/04 18:14:20 thi Exp $
+// $Id: mss_ddr4_funcs.H,v 1.6 2015/11/09 17:22:00 sglancy Exp $
 
 //------------------------------------------------------------------------------
 // *! (C) Copyright International Business Machines Corp. 2013
@@ -105,6 +105,33 @@ fapi::ReturnCode mss_rcd_load_ddr4(
 //--------------------------------------------------------------
 fapi::ReturnCode mss_create_rcd_ddr4( const fapi::Target& i_target_mba);
 
+/**
+ * @loads in a nominal MRS value into the address_16 and bank_3
+ *
+ * @param[in]  target:  Reference to centaur.mba target, 
+ * @param[out]  ecmdDataBufferBase& bank_3:  bank bits to be issued during MRS
+ * @param[out]  ecmdDataBufferBase& address_16:  16 address lanes to be issued during MRS - setup during function
+ * @param[in]  uint8_t MRS:  which MRS to configure
+ * @param[in]  uint8_t i_port_number: the port on which to configure the MRS - used for ID'ing which attributes to use
+ * @param[in]  uint8_t dimm_number: the DIMM on which to configure the MRS - used for ID'ing which attributes to use
+ * @param[in]  uint8_t rank_number: the rank on which to configure the MRS - used for ID'ing which attributes to use
+ *
+ * @return ReturnCode
+ */
+fapi::ReturnCode mss_ddr4_load_nominal_mrs_pda(fapi::Target& i_target,ecmdDataBufferBase& bank_3,ecmdDataBufferBase& address_16,uint8_t MRS,uint8_t i_port_number, uint8_t dimm_number, uint8_t rank_number);
+/**
+ * @Modifies the passed in address_16 buffer based upon the given attribute and data
+ *
+ * @param[in]  target:  Reference to centaur.mba target, 
+ * @param[in/out]  ecmdDataBufferBase& address_16:  MRS values - this is modified by the given attribute name and data
+ * @param[in]  uint32_t attribute_name:  enumerated value containing the attribute name to be modified - attr_name tells the function which bits to modify
+ * @param[in]  uint8_t attribute_data:   data telss the function what values to set to the modified bits
+ *
+ * @return ReturnCode
+ */
+fapi::ReturnCode mss_ddr4_modify_mrs_pda(fapi::Target& i_target,ecmdDataBufferBase& address_16,uint32_t attribute_name,uint8_t attribute_data);
+
+fapi::ReturnCode mss_ddr4_rtt_nom_rtt_wr_swap(fapi::Target& i_target, uint8_t i_mbaPosition, uint32_t i_port_number, uint8_t i_rank, uint32_t i_rank_pair_group, uint32_t& io_ccs_inst_cnt, uint8_t& io_dram_rtt_nom_original);
 #endif /* _MSS_DDR4_FUNCS_H */
 
 
diff --git a/src/usr/hwpf/hwp/dram_training/mss_draminit/mss_draminit.C b/src/usr/hwpf/hwp/dram_training/mss_draminit/mss_draminit.C
index e95011a..55c8674 100755
--- a/src/usr/hwpf/hwp/dram_training/mss_draminit/mss_draminit.C
+++ b/src/usr/hwpf/hwp/dram_training/mss_draminit/mss_draminit.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2012,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2012,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_draminit.C,v 1.70 2015/09/04 01:10:11 kmack Exp $
+// $Id: mss_draminit.C,v 1.71 2015/11/09 17:22:01 sglancy Exp $
 //------------------------------------------------------------------------------
 // Don't forget to create CVS comments when you check in your changes!
 //------------------------------------------------------------------------------
@@ -30,6 +30,7 @@
 //------------------------------------------------------------------------------
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|-----------------------------------------------
+//  1.71   | sglancy  |03-NOV-15| Fixed attribute names for DDR4 RDIMM
 //  1.70   | kmack    |01-Sep-15| Fixed more RCs and removed extraneous comments
 //  1.69   | kmack    |28-Aug-15| Fixed an RC
 //  1.68   | kmack    |10-Aug-15| Moved the mss_lrdimm_ddr4_db_load call to the be included or not included based on def FAPI_LRDIMM
@@ -347,7 +348,7 @@ ReturnCode mss_draminit_cloned(Target& i_target)
     rc = FAPI_ATTR_GET(ATTR_IS_SIMULATION, NULL, is_sim);
     if(rc) return rc;
     uint8_t address_mirror_map[2][2]; //address_mirror_map[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
     if(rc) return rc;
 
 
@@ -1885,7 +1886,7 @@ ReturnCode mss_mrs_load(
     if(rc) return rc;
 
     uint8_t address_mirror_map[2][2]; //address_mirror_map[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
     if(rc) return rc;
 
 
diff --git a/src/usr/hwpf/hwp/dram_training/mss_draminit_mc/mss_draminit_mc.C b/src/usr/hwpf/hwp/dram_training/mss_draminit_mc/mss_draminit_mc.C
index 23b6564..d42250c 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_draminit_mc/mss_draminit_mc.C
+++ b/src/usr/hwpf/hwp/dram_training/mss_draminit_mc/mss_draminit_mc.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2012,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2012,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_draminit_mc.C,v 1.51 2015/03/19 16:48:09 dcadiga Exp $
+// $Id: mss_draminit_mc.C,v 1.53 2016/02/12 19:45:51 sglancy Exp $
 //------------------------------------------------------------------------------
 // *! (C) Copyright International Business Machines Corp. 2011
 // *! All Rights Reserved -- Property of IBM
@@ -38,6 +38,7 @@
 //Run cen_draminit_mc.C to complete the initialization sequence. This performs the steps of
 //***Set the IML Complete bit MBSSQ(2) (SCOM Addr: 0x02011417) to indicate that IML has completed
 //***Start the refresh engines
+
 //***Enabling periodic calibration and power management.
 //------------------------------------------------------------------------------
 // Don't forget to create CVS comments when you check in your changes!
@@ -46,6 +47,8 @@
 //------------------------------------------------------------------------------
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|-----------------------------------------------
+//  1.53   | sglancy  |12-FEB-16| Addressed FW comments
+//  1.52   | sglancy  |07-DEC-15| Temporary: commented out call to RCD check code to workaround DDR4 ISRDIMM bug
 //  1.51   | dcadiga  |18-MAR-15| Added function to enable address inversion on port 1
 //  1.50   | gollub   |12-FEB-15| Changed maint cmd delay from 100mSec to 1mSec
 //  1.49   | gollub   |12-FEB-15| Add check for RCD protect time on RDIMM and LRDIMM
@@ -233,12 +236,12 @@ ReturnCode mss_draminit_mc_cloned(Target& i_target)
 
         // Step Two.1: Check RCD protect time on RDIMM and LRDIMM
         FAPI_INF( "+++ Check RCD protect time on RDIMM and LRDIMM +++");
-        rc = mss_check_RCD_protect_time(l_mbaChiplets[i]);
+        /*rc = mss_check_RCD_protect_time(l_mbaChiplets[i]);
         if(rc)
         {
            FAPI_ERR("---Error During Check RCD protect time rc = 0x%08X (creator = %d)---", uint32_t(rc), rc.getCreator());
            return rc;
-        }
+        }*/
 	
 	//Step Two.2: Enable address inversion on each MBA for ALL CARDS
 	FAPI_INF("+++ Setting up adr inversion for port 1 +++");
@@ -250,6 +253,7 @@ ReturnCode mss_draminit_mc_cloned(Target& i_target)
         }
 	
 
+
         // Step Three: Enable Refresh
         FAPI_INF( "+++ Enabling Refresh +++");
 	ecmdDataBufferBase mba01_ref0q_data_buffer_64(64);
@@ -1033,6 +1037,13 @@ ReturnCode mss_check_RCD_protect_time (Target& i_target)
                         }
                     
 
+                        // DEBUG Read MBACALFIR
+                        l_rc = fapiGetScom(i_target, MBA01_MBACALFIR_0x03010400, l_mbacalfir); 
+                        if(l_rc) return l_rc;
+                        FAPI_DBG("DEBUG: MBACALFIR after RCD parity error inject = 0x%.8X 0x%.8X port%d, dimm%d, %s",
+                        l_mbacalfir.getWord(0), l_mbacalfir.getWord(1), l_port, l_dimm, i_target.toEcmdString());
+
+
                         //------------------------------------------------------ 
                         // Check for MBECCFIR bit 45: maint RCD parity error
                         //------------------------------------------------------    
diff --git a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_access_delay_reg.C b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_access_delay_reg.C
index d5c1855..bc4ea38 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_access_delay_reg.C
+++ b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_access_delay_reg.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2012,2014                        */
+/* Contributors Listed Below - COPYRIGHT 2012,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_access_delay_reg.C,v 1.25 2014/04/18 19:23:36 jdsloat Exp $
+// $Id: mss_access_delay_reg.C,v 1.27 2016/02/12 19:45:56 sglancy Exp $
 //------------------------------------------------------------------------------
 // *! (C) Copyright International Business Machines Corp. 2011
 // *! All Rights Reserved -- Property of IBM
@@ -61,6 +61,8 @@
 //   1.23  | mjjones  |17-Jan-14| Fixed layout and error handling for RAS Review
 //   1.24  |sauchadh  |24-Jan-14| Added check for unused DQS 
 //   1.25  |sauchadh  |18-Apr-14| SW257010: mss_c4_phy: initialized dqs_lane array and verbose flag, used array indexes rather than counter
+//   1.26   |sauchadh  |30-Sep-15| Added functionality for CDIMM based registers and ATTR_VPD_ISDIMMTOC4DQS,ATTR_VPD_ISDIMMTOC4DQ in rosetta map
+//   1.27   |sglancy  |12-Feb-16| Addressed FW comments
 
 //----------------------------------------------------------------------
 //  My Includes
@@ -255,6 +257,38 @@ fapi::ReturnCode mss_access_delay_reg(const fapi::Target & i_target_mba,
 	 
    }
    
+   else if(i_input_type_e==RAW_CDIMM_WR_DQ || i_input_type_e==RAW_CDIMM_RD_DQ) 
+   {
+      l_type=CDIMM_DQ;
+         
+      if(i_input_index_u8>l_CDIMM_dqmax)    
+      {
+         FAPI_ERR("CDIMM_DQ: Wrong input index specified (%d, max %d)" ,
+         i_input_index_u8, l_CDIMM_dqmax);
+         FAPI_SET_HWP_ERROR(rc, RC_MSS_ACCESS_DELAY_REG_INVALID_INPUT);
+         return rc;
+      }
+     
+      rc=rosetta_map(i_target_mba,i_port_u8,l_type,i_input_index_u8,i_verbose,l_val); if(rc) return rc;
+      
+      if(i_verbose==1)
+      {
+         FAPI_INF("C4 value is=%d",l_val);
+      }   
+      rc=cross_coupled(i_target_mba,i_port_u8,l_rank_pair,i_input_type_e,l_val,i_verbose,l_out); if(rc) return rc;
+      if(i_verbose==1)
+      {
+         FAPI_INF("scom_address=%llX",l_out.scom_addr);
+         FAPI_INF("start bit=%d",l_out.start_bit);
+         FAPI_INF("length=%d",l_out.bit_length);
+      }   
+      l_scom_add=l_out.scom_addr;
+      l_sbit=l_out.start_bit;
+      l_len=l_out.bit_length;
+	 
+   }
+   
+   
    else if(i_input_type_e==ADDRESS)
    {
       if(i_input_index_u8<=18) // 19 delay values for Address
@@ -525,6 +559,30 @@ fapi::ReturnCode mss_access_delay_reg(const fapi::Target & i_target_mba,
          
    }
    
+   else if (i_input_type_e==RAW_CDIMM_WR_DQS || i_input_type_e==RAW_CDIMM_RD_DQS || i_input_type_e==RAW_CDIMM_DQS_ALIGN ||  i_input_type_e==RAW_CDIMM_DQS_GATE || i_input_type_e==RAW_CDIMM_DQSCLK)	    
+   {
+     
+      l_type=CDIMM_DQS;
+      
+      rc=rosetta_map(i_target_mba,i_port_u8,l_type,i_input_index_u8,i_verbose,l_val); if(rc) return rc;
+      if(i_verbose==1)
+      {
+         FAPI_INF("C4 value is=%d",l_val);
+      }
+      rc=cross_coupled(i_target_mba,i_port_u8,l_rank_pair,i_input_type_e,l_val,i_verbose,l_out); if(rc) return rc;
+      if(i_verbose==1)
+      {
+         FAPI_INF("scom_address=%llX",l_out.scom_addr);
+         FAPI_INF("start bit=%d",l_out.start_bit);
+         FAPI_INF("length=%d",l_out.bit_length); 
+      }
+      l_scom_add=l_out.scom_addr;
+      l_sbit=l_out.start_bit;
+      l_len=l_out.bit_length;   
+         
+   }
+   
+   
    
    else if(i_input_type_e==RAW_RDCLK_0 || i_input_type_e==RAW_RDCLK_1 || i_input_type_e==RAW_RDCLK_2 || i_input_type_e==RAW_RDCLK_3 || i_input_type_e==RAW_RDCLK_4) 
    {
@@ -1131,21 +1189,21 @@ fapi::ReturnCode mss_access_delay_reg(const fapi::Target & i_target_mba,
       if(i_input_type_e==RD_DQ || i_input_type_e==RD_DQS || i_input_type_e==RAW_RD_DQ_0 || i_input_type_e==RAW_RD_DQ_1 || i_input_type_e==RAW_RD_DQ_2 || i_input_type_e==RAW_RD_DQ_3 || i_input_type_e==RAW_RD_DQ_4 || i_input_type_e==RAW_RD_DQS_0 || i_input_type_e==RAW_RD_DQS_1 || i_input_type_e==RAW_RD_DQS_2 || i_input_type_e==RAW_RD_DQS_3 || i_input_type_e==RAW_RD_DQS_4
       || i_input_type_e==RAW_SYS_ADDR_CLK || i_input_type_e==RAW_SYS_CLK_0 || i_input_type_e==RAW_SYS_CLK_1 || i_input_type_e==RAW_SYS_CLK_2 || i_input_type_e==RAW_SYS_CLK_3 || i_input_type_e==RAW_SYS_CLK_4 || i_input_type_e==RAW_WR_CLK_0 || i_input_type_e==RAW_WR_CLK_1 || i_input_type_e==RAW_WR_CLK_2 || i_input_type_e==RAW_WR_CLK_3 || i_input_type_e==RAW_WR_CLK_4
       || i_input_type_e==RAW_ADDR_0 || i_input_type_e==RAW_ADDR_1 || i_input_type_e==RAW_ADDR_2 || i_input_type_e==RAW_ADDR_3 || i_input_type_e==RAW_DQS_ALIGN_0 || i_input_type_e==RAW_DQS_ALIGN_1 || i_input_type_e==RAW_DQS_ALIGN_2 || i_input_type_e==RAW_DQS_ALIGN_3 || i_input_type_e==RAW_DQS_ALIGN_4
-      || i_input_type_e==DQS_ALIGN || i_input_type_e==COMMAND || i_input_type_e==ADDRESS || i_input_type_e==CONTROL || i_input_type_e==CLOCK )   
+      || i_input_type_e==DQS_ALIGN || i_input_type_e==COMMAND || i_input_type_e==ADDRESS || i_input_type_e==CONTROL || i_input_type_e==CLOCK || i_input_type_e==RAW_CDIMM_RD_DQ || i_input_type_e==RAW_CDIMM_RD_DQS || i_input_type_e==RAW_CDIMM_DQS_ALIGN)   
       {
          l_start=25;   // l_start is starting bit of delay value in the register. There are different registers and each register has a different field for delay
       }
-      else if(i_input_type_e==WR_DQ || i_input_type_e==WR_DQS || i_input_type_e==RAW_WR_DQ_0 || i_input_type_e==RAW_WR_DQ_1 || i_input_type_e==RAW_WR_DQ_2 || i_input_type_e==RAW_WR_DQ_3 || i_input_type_e==RAW_WR_DQ_4 || i_input_type_e==RAW_WR_DQS_0 || i_input_type_e==RAW_WR_DQS_1 || i_input_type_e==RAW_WR_DQS_2 || i_input_type_e==RAW_WR_DQS_3 || i_input_type_e==RAW_WR_DQS_4 )
+      else if(i_input_type_e==WR_DQ || i_input_type_e==WR_DQS || i_input_type_e==RAW_WR_DQ_0 || i_input_type_e==RAW_WR_DQ_1 || i_input_type_e==RAW_WR_DQ_2 || i_input_type_e==RAW_WR_DQ_3 || i_input_type_e==RAW_WR_DQ_4 || i_input_type_e==RAW_WR_DQS_0 || i_input_type_e==RAW_WR_DQS_1 || i_input_type_e==RAW_WR_DQS_2 || i_input_type_e==RAW_WR_DQS_3 || i_input_type_e==RAW_WR_DQS_4 || i_input_type_e==RAW_CDIMM_WR_DQ || i_input_type_e==RAW_CDIMM_WR_DQS )
       {
          l_start=22;
       }
    
-      else if(i_input_type_e==RAW_DQS_GATE_0 || i_input_type_e==RAW_DQS_GATE_1 || i_input_type_e==RAW_DQS_GATE_2 || i_input_type_e==RAW_DQS_GATE_3 || i_input_type_e==RAW_DQS_GATE_4 || i_input_type_e==DQS_GATE)
+      else if(i_input_type_e==RAW_DQS_GATE_0 || i_input_type_e==RAW_DQS_GATE_1 || i_input_type_e==RAW_DQS_GATE_2 || i_input_type_e==RAW_DQS_GATE_3 || i_input_type_e==RAW_DQS_GATE_4 || i_input_type_e==DQS_GATE || i_input_type_e==RAW_CDIMM_DQS_GATE)
       {
          l_start=29;
       }
       
-      else if(i_input_type_e==RAW_RDCLK_0 || i_input_type_e==RAW_RDCLK_1 || i_input_type_e==RAW_RDCLK_2 || i_input_type_e==RAW_RDCLK_3 || i_input_type_e==RAW_RDCLK_4 || i_input_type_e==RDCLK || i_input_type_e==RAW_DQSCLK_0 || i_input_type_e==RAW_DQSCLK_1 || i_input_type_e==RAW_DQSCLK_2 || i_input_type_e==RAW_DQSCLK_3 || i_input_type_e==RAW_DQSCLK_4 || i_input_type_e==DQSCLK)
+      else if(i_input_type_e==RAW_RDCLK_0 || i_input_type_e==RAW_RDCLK_1 || i_input_type_e==RAW_RDCLK_2 || i_input_type_e==RAW_RDCLK_3 || i_input_type_e==RAW_RDCLK_4 || i_input_type_e==RDCLK || i_input_type_e==RAW_DQSCLK_0 || i_input_type_e==RAW_DQSCLK_1 || i_input_type_e==RAW_DQSCLK_2 || i_input_type_e==RAW_DQSCLK_3 || i_input_type_e==RAW_DQSCLK_4 || i_input_type_e==DQSCLK || i_input_type_e==RAW_CDIMM_DQSCLK)
       {
          l_start=30;  
       }
@@ -1241,7 +1299,7 @@ fapi::ReturnCode cross_coupled(const fapi::Target & i_target_mba,
    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_WIDTH, &i_target_mba, l_dram_width); if(rc) return rc;
    
       
-   if(i_input_type_e==RD_DQ || i_input_type_e==WR_DQ)
+   if(i_input_type_e==RD_DQ || i_input_type_e==WR_DQ || i_input_type_e==RAW_CDIMM_WR_DQ || i_input_type_e==RAW_CDIMM_RD_DQ )
    {
       if(i_port==0 && l_mbapos==0)
       {
@@ -1285,7 +1343,7 @@ fapi::ReturnCode cross_coupled(const fapi::Target & i_target_mba,
       out.bit_length=l_len; 
    }
    
-   else if (i_input_type_e==WR_DQS ||  i_input_type_e==DQS_ALIGN)	    
+   else if (i_input_type_e==WR_DQS ||  i_input_type_e==DQS_ALIGN || i_input_type_e==RAW_CDIMM_WR_DQS || i_input_type_e==RAW_CDIMM_DQS_ALIGN)	    
    {
       if(i_port==0 && l_mbapos==0)
       {
@@ -1638,7 +1696,7 @@ fapi::ReturnCode cross_coupled(const fapi::Target & i_target_mba,
    }   
       
     
-   else if (i_input_type_e==RD_DQS || i_input_type_e==DQS_GATE || i_input_type_e==RDCLK || i_input_type_e==DQSCLK)	    
+   else if (i_input_type_e==RD_DQS || i_input_type_e==DQS_GATE || i_input_type_e==RDCLK || i_input_type_e==DQSCLK || i_input_type_e==RAW_CDIMM_DQS_GATE || i_input_type_e==RAW_CDIMM_DQSCLK || i_input_type_e==RAW_CDIMM_RD_DQS )	    
    {
       
       
@@ -1754,8 +1812,8 @@ fapi::ReturnCode rosetta_map(const fapi::Target & i_target_mba,
 
     fapi::ReturnCode rc;
    
-   const uint8_t l_ISDIMM_dqmax=71; 
-   const uint8_t l_CDIMM_dqmax=79;
+   //const uint8_t l_ISDIMM_dqmax=71; 
+   //const uint8_t l_CDIMM_dqmax=79;
    uint8_t l_mbapos = 0;
    uint8_t l_dimmtype=0;
    const uint8_t l_maxdq=72;
@@ -1774,11 +1832,30 @@ fapi::ReturnCode rosetta_map(const fapi::Target & i_target_mba,
    const uint8_t GL_DQS_p1_g2[l_maxdqs]={2,0,4,16,8,10,12,14,6,3,1,5,17,9,11,13,15,7};
    const uint8_t GL_DQS_p2[l_maxdqs]={2,0,4,16,8,10,12,14,6,3,1,5,17,9,11,13,15,7};
    const uint8_t GL_DQS_p3[l_maxdqs]={0,2,4,16,8,10,12,14,6,1,3,5,17,9,11,13,15,7};
-   
+   uint8_t l_isdm_c4_dq[4][80];
+   uint8_t l_isdm_c4_dqs[4][20];
+   /* uint8_t l_isdimm2c4dqp0[80]={0}; */
+      
+                
    rc = FAPI_ATTR_GET(ATTR_MSS_DQS_SWIZZLE_TYPE, &i_target_mba, l_swizzle); if(rc) return rc;
+   rc = FAPI_ATTR_GET(ATTR_EFF_CUSTOM_DIMM, &i_target_mba, l_dimmtype); if(rc) return rc;
+   
+   
+   fapi::Target i_target_centaur;
+   rc = fapiGetParentChip(i_target_mba, i_target_centaur); 
+   if (rc)
+   {
+      FAPI_DBG("%s:Error in getting parent chip!",i_target_mba.toEcmdString()); return rc;
+   }
+   
+   if(l_dimmtype!=fapi::ENUM_ATTR_EFF_CUSTOM_DIMM_YES)
+   {
+      rc = FAPI_ATTR_GET(ATTR_VPD_ISDIMMTOC4DQS, &i_target_centaur,l_isdm_c4_dqs); if(rc) return rc;
+      rc = FAPI_ATTR_GET(ATTR_VPD_ISDIMMTOC4DQ, &i_target_centaur,l_isdm_c4_dq); if(rc) return rc;
+   }   
    
    
-   if(l_swizzle ==0 || l_swizzle ==1)
+   if(l_swizzle ==0 || l_swizzle ==1 || l_swizzle ==2)  
    {
       if(i_verbose==1)
       {
@@ -1811,9 +1888,7 @@ fapi::ReturnCode rosetta_map(const fapi::Target & i_target_mba,
        return rc;
    }
    
-   rc = FAPI_ATTR_GET(ATTR_EFF_CUSTOM_DIMM, &i_target_mba, l_dimmtype); if(rc) return rc;
-   
-   if(l_dimmtype==fapi::ENUM_ATTR_EFF_CUSTOM_DIMM_YES)
+      /*if(l_dimmtype==fapi::ENUM_ATTR_EFF_CUSTOM_DIMM_YES)
    {
       if(i_input_index>l_CDIMM_dqmax)    
       {
@@ -1830,7 +1905,7 @@ fapi::ReturnCode rosetta_map(const fapi::Target & i_target_mba,
          FAPI_SET_HWP_ERROR(rc, RC_ROSETTA_MAP_INVALID_INPUT);
          return rc;
       }
-   }
+   } */
     	
    if(i_input_type_e ==ISDIMM_DQ)
    {
@@ -1840,11 +1915,15 @@ fapi::ReturnCode rosetta_map(const fapi::Target & i_target_mba,
          {
             o_value=GL_DQ_p0_g1[i_input_index];   
          }
-         else
+         else if(l_swizzle==0)
          {
             o_value=GL_DQ_p0_g2[i_input_index];    
          }
-            
+         else
+         {
+            o_value=l_isdm_c4_dq[i_port][i_input_index];  
+         }    
+          
       }
 	            
       else if(i_port==1 && l_mbapos==0)
@@ -1853,20 +1932,44 @@ fapi::ReturnCode rosetta_map(const fapi::Target & i_target_mba,
          {
             o_value=GL_DQ_p1_g1[i_input_index];
          }
-         else
+         
+         else if(l_swizzle==0)
          {
             o_value=GL_DQ_p1_g2[i_input_index];    
          }
+         
+         else
+         {
+            o_value=l_isdm_c4_dq[i_port][i_input_index];  
+         } 
+
       }
    
       else if(i_port==0 && l_mbapos==1)
       {
-         o_value=GL_DQ_p2[i_input_index];    
+         if(l_swizzle==1 || l_swizzle==0)
+         {
+            o_value=GL_DQ_p2[i_input_index];
+         }
+         else
+         {
+            o_value=l_isdm_c4_dq[i_port][i_input_index];      
+         }
       }
-      else 
+      
+      else
       {
-         o_value=GL_DQ_p3[i_input_index];    
+         if(l_swizzle==1 || l_swizzle==0)
+         {
+            o_value=GL_DQ_p3[i_input_index];
+         }
+         else
+         {
+            o_value=l_isdm_c4_dq[i_port][i_input_index];      
+         }
+         
       }
+
           
    }
       
@@ -1880,11 +1983,15 @@ fapi::ReturnCode rosetta_map(const fapi::Target & i_target_mba,
          {
             o_value=GL_DQS_p0_g1[i_input_index];
          }
-         else 
+         else if(l_swizzle==0) 
          {
             o_value=GL_DQS_p0_g2[i_input_index];    
          }
-            
+         else
+         {
+            o_value=l_isdm_c4_dqs[i_port][i_input_index];  
+         }  
+                    
       }    
       else if(i_port==1 && l_mbapos==0)
       {
@@ -1892,20 +1999,42 @@ fapi::ReturnCode rosetta_map(const fapi::Target & i_target_mba,
          {
             o_value=GL_DQS_p1_g1[i_input_index];
          }
-         else 
+         else if(l_swizzle==0)  
          {
             o_value=GL_DQS_p1_g2[i_input_index];    
          }
-            
+         else
+         {
+            o_value=l_isdm_c4_dqs[i_port][i_input_index];   
+         }  
+                 
       }
+
       else if(i_port==0 && l_mbapos==1)
       {
-         o_value=GL_DQS_p2[i_input_index];
+         if(l_swizzle==1 || l_swizzle==0)
+         {
+            o_value=GL_DQS_p2[i_input_index];
+         }
+         else
+         {
+            o_value=l_isdm_c4_dqs[i_port][i_input_index]; 
+         }  
       }
       else 
       {
-         o_value=GL_DQS_p3[i_input_index];
+         if(l_swizzle==1 || l_swizzle==0)
+         {
+            o_value=GL_DQS_p3[i_input_index];
+         }
+         
+         else
+         {
+             o_value=l_isdm_c4_dqs[i_port][i_input_index]; 
+         }
+         
       }
+
                     
    }      
    else if(i_input_type_e==CDIMM_DQS)
@@ -1966,7 +2095,7 @@ fapi::ReturnCode get_address(const fapi::Target & i_target_mba,
    uint8_t l_tmp=0;
    rc = FAPI_ATTR_GET(ATTR_CHIP_UNIT_POS, &i_target_mba, l_mbapos); if(rc) return rc;
    
-   if(i_input_type_e==WR_DQ_t || i_input_type_e==RAW_WR_DQ)
+   if(i_input_type_e==WR_DQ_t || i_input_type_e==RAW_WR_DQ || i_input_type_e==RAW_CDIMM_WR_DQ_t )
    {
       if(i_lane > 7)
       {
@@ -1999,7 +2128,7 @@ fapi::ReturnCode get_address(const fapi::Target & i_target_mba,
      
    }
    
-   else if(i_input_type_e==RD_DQ_t || i_input_type_e==RAW_RD_DQ)
+   else if(i_input_type_e==RD_DQ_t || i_input_type_e==RAW_RD_DQ || i_input_type_e==RAW_CDIMM_RD_DQ_t)
    {
       l_scom_address_64|=0x00000050;       
       l_scom_address_64=l_scom_address_64<<32;
@@ -2066,7 +2195,7 @@ fapi::ReturnCode get_address(const fapi::Target & i_target_mba,
    }    
         
        
-   else if(i_input_type_e==WR_DQS_t  || i_input_type_e==RAW_WR_DQS)    
+   else if(i_input_type_e==WR_DQS_t  || i_input_type_e==RAW_WR_DQS || i_input_type_e==RAW_CDIMM_WR_DQS_t)    
    {
       
       if(i_input_type_e==RAW_WR_DQS)
@@ -2164,7 +2293,7 @@ fapi::ReturnCode get_address(const fapi::Target & i_target_mba,
       
    } 
             
-   else if(i_input_type_e==RD_DQS_t || i_input_type_e==RAW_RD_DQS) 
+   else if(i_input_type_e==RD_DQS_t || i_input_type_e==RAW_RD_DQS || i_input_type_e==RAW_CDIMM_RD_DQS_t) 
    {
       
       if(i_input_type_e==RAW_RD_DQS)
@@ -2283,7 +2412,7 @@ fapi::ReturnCode get_address(const fapi::Target & i_target_mba,
      
    }
    
-    else if(i_input_type_e==DQSCLK_t || i_input_type_e==RAW_DQSCLK) 
+    else if(i_input_type_e==DQSCLK_t || i_input_type_e==RAW_DQSCLK || i_input_type_e==RAW_CDIMM_DQSCLK_t) 
    {
       if(i_input_type_e==RAW_DQSCLK) 
       {
@@ -2341,7 +2470,7 @@ fapi::ReturnCode get_address(const fapi::Target & i_target_mba,
    }
    
      
-   else if(i_input_type_e==DQS_ALIGN_t || i_input_type_e==RAW_DQS_ALIGN) 
+   else if(i_input_type_e==DQS_ALIGN_t || i_input_type_e==RAW_DQS_ALIGN  || i_input_type_e==RAW_CDIMM_DQS_ALIGN_t) 
    {
       
       if(i_input_type_e==RAW_DQS_ALIGN)
@@ -2533,7 +2662,7 @@ fapi::ReturnCode get_address(const fapi::Target & i_target_mba,
      
    }    
    
-   else if(i_input_type_e==RAW_DQS_GATE ||  i_input_type_e==DQS_GATE_t)
+   else if(i_input_type_e==RAW_DQS_GATE ||  i_input_type_e==DQS_GATE_t || i_input_type_e==RAW_CDIMM_DQS_GATE_t)
    {
       if(i_input_type_e==RAW_DQS_GATE)
       {
diff --git a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_access_delay_reg.H b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_access_delay_reg.H
index 6cb8156..a36c334 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_access_delay_reg.H
+++ b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_access_delay_reg.H
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2012,2014                        */
+/* Contributors Listed Below - COPYRIGHT 2012,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-//$Id: mss_access_delay_reg.H,v 1.12 2014/01/24 17:22:16 sasethur Exp $
+//$Id: mss_access_delay_reg.H,v 1.13 2015/09/30 06:46:46 sasethur Exp $
 //------------------------------------------------------------------------------
 // *! (C) Copyright International Business Machines Corp. 2011
 // *! All Rights Reserved -- Property of IBM
@@ -42,6 +42,7 @@
 //------------------------------------------------------------------------------
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|-----------------------------------------------
+//   1.13  | sauchadh |30-sep-15| Added enums for CDIMM based registers 
 //   1.12  | mjjones  |20-Jan-14| RAS Review Updates
 //   1.1   | sauchadh |15-Oct-12| First Draft.
 //------------------------------------------------------------------------------
@@ -70,24 +71,28 @@ enum access_type_t {
 
 enum input_type_t {
    WR_DQ,
+   RAW_CDIMM_WR_DQ,
    RAW_WR_DQ_0,
    RAW_WR_DQ_1,
    RAW_WR_DQ_2,
    RAW_WR_DQ_3,
    RAW_WR_DQ_4,
    RD_DQ,
+   RAW_CDIMM_RD_DQ,
    RAW_RD_DQ_0,
    RAW_RD_DQ_1,
    RAW_RD_DQ_2,
    RAW_RD_DQ_3,
    RAW_RD_DQ_4,
    WR_DQS,
+   RAW_CDIMM_WR_DQS,
    RAW_WR_DQS_0,
    RAW_WR_DQS_1,
    RAW_WR_DQS_2,
    RAW_WR_DQS_3,
    RAW_WR_DQS_4,
    RD_DQS,
+   RAW_CDIMM_RD_DQS,
    RAW_RD_DQS_0,
    RAW_RD_DQS_1,
    RAW_RD_DQS_2,
@@ -109,12 +114,14 @@ enum input_type_t {
    RAW_ADDR_2,
    RAW_ADDR_3,
    DQS_GATE,
+   RAW_CDIMM_DQS_GATE,
    RAW_DQS_GATE_0,
    RAW_DQS_GATE_1,
    RAW_DQS_GATE_2,
    RAW_DQS_GATE_3,
    RAW_DQS_GATE_4,
    DQS_ALIGN,
+   RAW_CDIMM_DQS_ALIGN,
    RAW_DQS_ALIGN_0,
    RAW_DQS_ALIGN_1,
    RAW_DQS_ALIGN_2,
@@ -126,12 +133,13 @@ enum input_type_t {
    RAW_RDCLK_3,
    RAW_RDCLK_4,
    RDCLK,
+   DQSCLK,
+   RAW_CDIMM_DQSCLK,
    RAW_DQSCLK_0,
    RAW_DQSCLK_1,
    RAW_DQSCLK_2,
    RAW_DQSCLK_3,
    RAW_DQSCLK_4,
-   DQSCLK,
    COMMAND,
    CONTROL,
    CLOCK,
@@ -142,12 +150,16 @@ enum input_type_t {
 enum ip_type_t {
    WR_DQ_t,
    RAW_WR_DQ,
+   RAW_CDIMM_WR_DQ_t,
    RD_DQ_t,
    RAW_RD_DQ,
+   RAW_CDIMM_RD_DQ_t,
    WR_DQS_t,
    RAW_WR_DQS,
+   RAW_CDIMM_WR_DQS_t,
    RD_DQS_t,
    RAW_RD_DQS,
+   RAW_CDIMM_RD_DQS_t,
    RD_CLK_t,
    RAW_SYS_ADDR_CLKS0S1,
    RAW_SYS_CLK,
@@ -155,12 +167,15 @@ enum ip_type_t {
    RAW_ADDR,
    DQS_GATE_t,
    RAW_DQS_GATE,
+   RAW_CDIMM_DQS_GATE_t,
    DQS_ALIGN_t,
    RAW_DQS_ALIGN,
+   RAW_CDIMM_DQS_ALIGN_t,
    RDCLK_t,
    RAW_RDCLK,
    DQSCLK_t,
    RAW_DQSCLK,
+   RAW_CDIMM_DQSCLK_t,
    COMMAND_t,
    CONTROL_t,
    CLOCK_t,
diff --git a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_funcs.C b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_funcs.C
index 357ebfb..c9b30dd 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_funcs.C
+++ b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_funcs.C
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_ddr4_funcs.C,v 1.17 2015/10/23 15:11:23 sglancy Exp $
+// $Id: mss_ddr4_funcs.C,v 1.22 2016/02/12 19:45:55 sglancy Exp $
 //------------------------------------------------------------------------------
 // *! (C) Copyright International Business Machines Corp. 2013
 // *! All Rights Reserved -- Property of IBM
@@ -43,6 +43,10 @@
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|-----------------------------------------------
 //         |          |         |
+//  1.21   | 02/12/16 | sglancy | Addressed FW comments
+//  1.20   | 01/14/16 | sglancy | Fixed bug in termination swap code
+//  1.19   | 11/16/15 | sglancy | Fixed R/LRDIMM bug
+//  1.18   | 11/03/15 | sglancy | Fixed attribute names for DDR4 RDIMM
 //  1.17   | 10/23/15 | sglancy | Changed attribute names
 //  1.16   | 10/21/15 | sglancy | Changed attribute names
 //  1.15   | 08/28/15 | sglancy | Added RCs - addressed FW comments
@@ -148,7 +152,7 @@ ReturnCode mss_ddr4_invert_mpr_write( Target& i_target_mba) {
     if(rc) return rc;
 
     uint8_t address_mirror_map[2][2]; //address_mirror_map[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_ADDRESS_MIRRORING, &i_target_mba, address_mirror_map);
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_ADDRESS_MIRRORING, &i_target_mba, address_mirror_map);
     if(rc) return rc;
 
    uint8_t dram_stack[2][2];
@@ -1207,7 +1211,7 @@ ReturnCode mss_mrs_load_ddr4(
     if(rc) return rc;
 
     uint8_t address_mirror_map[2][2]; //address_mirror_map[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
     if(rc) return rc;
 
 
@@ -1215,7 +1219,7 @@ ReturnCode mss_mrs_load_ddr4(
     rc = fapiGetScom(i_target, CCS_MODEQ_AB_REG_0x030106A7, data_buffer);
     if(rc) return rc;
     //Setting up CCS mode
-    rc_num = rc_num | data_buffer.setBit(51);
+    rc_num = rc_num | data_buffer.setBit(61);
     if(rc_num) {
        rc.setEcmdError(rc_num);
        return rc;
@@ -1412,6 +1416,10 @@ ReturnCode mss_mrs_load_ddr4(
     {
         dram_al = 0x40;
     }
+    else if (dram_al == ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_3) //Jeremy
+    {
+    	dram_al = 0xC0;
+    }
 
     if (wr_lvl == ENUM_ATTR_EFF_DRAM_WR_LVL_ENABLE_DISABLE)
     {
@@ -2458,6 +2466,2077 @@ ReturnCode mss_mrs_load_ddr4(
     return rc;
 }
 
+//Converts RTT_WR values to RTT_NOM
+uint8_t convert_rtt_wr_to_rtt_nom(uint8_t rtt_wr, uint8_t & rtt_nom) {
+   switch(rtt_wr) {
+      case ENUM_ATTR_VPD_DRAM_RTT_WR_OHM120:
+           rtt_nom = ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM120;
+	   break;
+      case 240:
+           rtt_nom = ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM240;
+	   break;
+      case 0xFF:
+      case ENUM_ATTR_VPD_DRAM_RTT_WR_DISABLE: 
+      default:
+           FAPI_INF("RTT_WR is disabled! Skipping the swap of termination values to keep RTT_NOM with it's nominal values!!");
+	   return 1;
+   }
+   return 0;
+}
+
+ReturnCode mss_ddr4_rtt_nom_rtt_wr_swap(
+            Target& i_target,
+            uint8_t i_mbaPosition,
+            uint32_t i_port_number,
+            uint8_t i_rank,
+	    uint32_t i_rank_pair_group,
+            uint32_t& io_ccs_inst_cnt,
+	    uint8_t& io_dram_rtt_nom_original
+            )
+{
+    // Target MBA level
+    // This is a function written specifically for mss_draminit_training
+    // Meant for placing RTT_WR into RTT_NOM within MR1 before wr_lvl
+    // If the function argument dram_rtt_nom_original has a value of 0xFF it will put the original rtt_nom there
+    // and write rtt_wr to the rtt_nom value
+    // If the function argument dram_rtt_nom_original has any value besides 0xFF it will try to write that value to rtt_nom.
+    
+    FAPI_INF("Swapping RTT_WR values into RTT_NOM or swapping RTT_NOM back to its nominal value");
+    
+    ReturnCode rc;
+    ReturnCode rc_buff;
+    uint32_t rc_num = 0;
+
+    ecmdDataBufferBase address_16(16);
+    ecmdDataBufferBase address_16_backup(16);
+    ecmdDataBufferBase bank_3(3);
+    ecmdDataBufferBase activate_1(1);
+    rc_num = rc_num | activate_1.setBit(0);
+    ecmdDataBufferBase rasn_1(1);
+    rc_num = rc_num | rasn_1.clearBit(0);
+    ecmdDataBufferBase casn_1(1);
+    rc_num = rc_num | casn_1.clearBit(0);
+    ecmdDataBufferBase wen_1(1);
+    rc_num = rc_num | wen_1.clearBit(0);
+    ecmdDataBufferBase cke_4(4);
+    rc_num = rc_num | cke_4.setBit(0,4);
+    ecmdDataBufferBase csn_8(8);
+    rc_num = rc_num | csn_8.setBit(0,8);
+    ecmdDataBufferBase odt_4(4);
+    rc_num = rc_num | odt_4.clearBit(0,4);
+    ecmdDataBufferBase ddr_cal_type_4(4);
+
+    ecmdDataBufferBase num_idles_16(16);
+    ecmdDataBufferBase num_repeat_16(16);
+    ecmdDataBufferBase data_20(20);
+    ecmdDataBufferBase read_compare_1(1);
+    ecmdDataBufferBase rank_cal_4(4);
+    ecmdDataBufferBase ddr_cal_enable_1(1);
+    ecmdDataBufferBase ccs_end_1(1);
+
+    ecmdDataBufferBase mrs1_16(16);
+    ecmdDataBufferBase mrs2_16(16);
+
+    ecmdDataBufferBase data_buffer_64(64);
+
+    uint8_t dimm = 0;
+    uint8_t dimm_rank = 0;
+
+    // dimm 0, dimm_rank 0-3 = ranks 0-3; dimm 1, dimm_rank 0-3 = ranks 4-7
+    dimm = (i_rank) / 4;
+    dimm_rank = i_rank - 4*dimm;
+
+
+    uint8_t dimm_type;
+    rc = FAPI_ATTR_GET(ATTR_EFF_DIMM_TYPE, &i_target, dimm_type);
+    if(rc) return rc;
+
+    uint8_t is_sim = 0;
+    rc = FAPI_ATTR_GET(ATTR_IS_SIMULATION, NULL, is_sim);
+    if(rc) return rc;
+    
+    uint8_t dram_stack[2][2];
+    rc = FAPI_ATTR_GET(ATTR_EFF_STACK_TYPE, &i_target, dram_stack);
+    if(rc) return rc;
+   
+    
+
+    uint8_t address_mirror_map[2][2]; //address_mirror_map[port][dimm]
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
+    if(rc) return rc;
+
+
+    // Raise CKE high with NOPS, waiting min Reset CKE exit time (tXPR) - 400 cycles
+    rc_num = rc_num | csn_8.setBit(0,8);
+    rc_num = rc_num | address_16.clearBit(0, 16);
+    rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 400, 0, 16);
+    if(rc_num)
+    {
+	rc.setEcmdError(rc_num);
+	return rc;
+    }
+    rc = mss_ccs_inst_arry_0( i_target,
+                              io_ccs_inst_cnt,
+                              address_16,
+                              bank_3,
+                              activate_1,
+                              rasn_1,
+                              casn_1,
+                              wen_1,
+                              cke_4,
+                              csn_8,
+                              odt_4,
+                              ddr_cal_type_4,
+                              i_port_number);
+    if(rc) return rc;
+    rc = mss_ccs_inst_arry_1( i_target,
+                              io_ccs_inst_cnt,
+                              num_idles_16,
+                              num_repeat_16,
+                              data_20,
+                              read_compare_1,
+                              rank_cal_4,
+                              ddr_cal_enable_1,
+                              ccs_end_1);
+    if(rc) return rc;
+    io_ccs_inst_cnt ++;
+
+    rc_num = rc_num | csn_8.setBit(0,8);
+    rc_num = rc_num | csn_8.clearBit(i_rank);
+    //sets up the MRS
+    rc_num = rc_num | rasn_1.clearBit(0,1);
+    rc_num = rc_num | casn_1.clearBit(0,1);
+    rc_num = rc_num | wen_1.clearBit(0,1);
+    
+    // MRS CMD to CMD spacing = 12 cycles
+    rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 12, 0, 16);
+    if(rc_num)
+    {
+	rc.setEcmdError(rc_num);
+	return rc;
+    }
+
+    FAPI_INF( "Editing RTT_NOM during wr_lvl or for PDA for %s PORT: %d RP: %d", i_target.toEcmdString(), i_port_number, i_rank_pair_group);
+    
+    //load nominal MRS values for the MR1, which contains RTT_NOM
+    rc = mss_ddr4_load_nominal_mrs_pda(i_target, bank_3, address_16,MRS1_BA, i_port_number,  dimm,  dimm_rank);
+    if(rc) return rc;
+    
+    uint8_t dram_rtt_nom[2][2][4];
+    uint8_t dram_rtt_wr[2][2][4];
+    
+    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_RTT_WR, &i_target, dram_rtt_wr);
+    if(rc) return rc;
+    
+    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_RTT_NOM, &i_target, dram_rtt_nom);
+    if(rc) return rc;
+    
+    uint32_t addr16_print1,addr16_print2;
+    addr16_print1 = addr16_print2 = 0;
+    
+    //do modifications based upon RTT_WR values if need be - a 0xFF indicates no swap done, so do the swap
+    if(io_dram_rtt_nom_original == 0xFF) {
+       io_dram_rtt_nom_original = 1;
+       uint8_t skip_swap = convert_rtt_wr_to_rtt_nom(dram_rtt_wr[i_port_number][dimm][dimm_rank], dram_rtt_nom[i_port_number][dimm][dimm_rank]);
+       //skips the remainder of the swapping code if it is not needed - this is not an error, just returning out of the function
+       if(skip_swap) return rc;
+       
+       FAPI_INF("Swapping RTT_WR value of 0x%02x into RTT_NOM=0x%02x",dram_rtt_wr[i_port_number][dimm][dimm_rank],dram_rtt_nom[i_port_number][dimm][dimm_rank]);
+       rc_num = rc_num | address_16.extractPreserve(&addr16_print1, 0, 16, 0);
+       if(rc_num)
+       {
+	   rc.setEcmdError(rc_num);
+	   return rc;
+       }
+       
+       rc = mss_ddr4_modify_mrs_pda(i_target,address_16,ATTR_VPD_DRAM_RTT_NOM,dram_rtt_nom[i_port_number][dimm][dimm_rank]);
+       if(rc) return rc;
+       rc_num = rc_num | address_16.extractPreserve(&addr16_print2, 0, 16, 0);
+       if(rc_num)
+       {
+	   rc.setEcmdError(rc_num);
+	   return rc;
+       }
+       FAPI_INF("Modified MR1 to have RTT_WR's value in RTT_NOM");
+       FAPI_INF("Printing before 0x%04x and after 0x%04x",addr16_print1,addr16_print2);
+    }
+    else {
+       FAPI_INF("Not doing the swap, just setting back to nominal values 0x%02x",io_dram_rtt_nom_original);
+       uint8_t skip_swap = convert_rtt_wr_to_rtt_nom(dram_rtt_wr[i_port_number][dimm][dimm_rank], dram_rtt_nom[i_port_number][dimm][dimm_rank]);
+       //skips the remainder of the swapping code if it is not needed - this is not an error, just returning out of the function
+       if(skip_swap) return rc;
+    }
+   
+   rc_num = rc_num | address_16_backup.insert(address_16, 0, 16, 0);
+   if(rc_num)
+   {
+       rc.setEcmdError(rc_num);
+       return rc;
+   }
+   
+   
+   FAPI_INF("Issueing MRS command"); 
+   
+    //loads the previous DRAM
+   if (( address_mirror_map[i_port_number][dimm] & (0x08 >> dimm_rank) ) && (is_sim == 0))
+   {
+       FAPI_INF("Doing address_mirroring_swizzle for %d %d %d %02x",i_port_number,dimm,dimm_rank,address_mirror_map[i_port_number][dimm] );
+       rc = mss_address_mirror_swizzle(i_target, i_port_number, dimm, dimm_rank, address_16, bank_3);
+       if(rc) return rc;
+   }
+   else {
+      FAPI_INF("No swizzle for address_mirroring_swizzle necessary for %d %d %d 0x%02x",i_port_number,dimm,dimm_rank,address_mirror_map[i_port_number][dimm] );
+   }
+
+   // Only corresponding CS to rank
+   rc_num = rc_num | csn_8.setBit(0,8); 
+   rc_num = rc_num | csn_8.clearBit(i_rank);
+   if(dram_stack[i_port_number][dimm]  == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+      rc_num = rc_num | csn_8.clearBit(2,2); 
+      rc_num = rc_num | csn_8.clearBit(6,2); 
+   }
+   
+   if(rc_num)
+   {
+       rc.setEcmdError(rc_num);
+       return rc;
+   }
+   
+   // Send out to the CCS array 
+   rc = mss_ccs_inst_arry_0( i_target,
+   	    io_ccs_inst_cnt,
+   	    address_16,
+   	    bank_3,
+   	    activate_1,
+   	    rasn_1,
+   	    casn_1,
+   	    wen_1,
+   	    cke_4,
+   	    csn_8,
+   	    odt_4,
+   	    ddr_cal_type_4,
+   	    i_port_number);
+   if(rc) return rc;
+   rc = mss_ccs_inst_arry_1( i_target,
+   	    io_ccs_inst_cnt,
+   	    num_idles_16,
+   	    num_repeat_16,
+   	    data_20,
+   	    read_compare_1,
+   	    rank_cal_4,
+   	    ddr_cal_enable_1,
+   	    ccs_end_1);
+   if(rc) return rc;
+   io_ccs_inst_cnt ++;
+
+   //is an R or LR DIMM -> do a B side MRS write
+   if ( (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_RDIMM) || (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) ) {
+      //takes values from the backup
+      address_16.clearBit(0, 16);
+      rc_num = rc_num | address_16.insert(address_16_backup, 0, 16, 0);
+      
+      //FLIPS all necessary bits
+      // Indicate B-Side DRAMS BG1=1 
+      rc_num = rc_num | address_16.setBit(15);  // Set BG1 = 1
+ 
+      rc_num = rc_num | address_16.flipBit(3,7); // Invert A3:A9
+      rc_num = rc_num | address_16.flipBit(11);  // Invert A11
+      rc_num = rc_num | address_16.flipBit(13);  // Invert A13
+      rc_num = rc_num | address_16.flipBit(14);  // Invert A17
+      rc_num = rc_num | bank_3.flipBit(0,3);	 // Invert BA0,BA1,BG0
+      
+      if(rc_num)
+      {
+         rc.setEcmdError(rc_num);
+         return rc;
+      }
+      
+      //loads the previous DRAM
+      if (( address_mirror_map[i_port_number][dimm] & (0x08 >> dimm_rank) ) && (is_sim == 0))
+      {
+   	  rc = mss_address_mirror_swizzle(i_target, i_port_number, dimm, dimm_rank, address_16, bank_3);
+   	  if(rc) return rc;
+      }
+      
+      // Only corresponding CS to rank
+      rc_num = rc_num | csn_8.setBit(0,8); 
+      rc_num = rc_num | csn_8.clearBit(i_rank);
+      if(dram_stack[i_port_number][dimm]  == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+         rc_num = rc_num | csn_8.clearBit(2,2); 
+         rc_num = rc_num | csn_8.clearBit(6,2); 
+      }
+   
+      if(rc_num)
+      {
+         rc.setEcmdError(rc_num);
+         return rc;
+      }
+      
+      // Send out to the CCS array 
+      rc = mss_ccs_inst_arry_0( i_target,
+   	       io_ccs_inst_cnt,
+   	       address_16,
+   	       bank_3,
+   	       activate_1,
+   	       rasn_1,
+   	       casn_1,
+   	       wen_1,
+   	       cke_4,
+   	       csn_8,
+   	       odt_4,
+   	       ddr_cal_type_4,
+   	       i_port_number);
+      if(rc) return rc;
+      rc = mss_ccs_inst_arry_1( i_target,
+   	       io_ccs_inst_cnt,
+   	       num_idles_16,
+   	       num_repeat_16,
+   	       data_20,
+   	       read_compare_1,
+   	       rank_cal_4,
+   	       ddr_cal_enable_1,
+   	       ccs_end_1);
+      if(rc) return rc;
+      io_ccs_inst_cnt ++;
+   }
+   
+   
+   //sets a NOP as the last command
+   rc_num = rc_num | cke_4.setBit(0,4);
+   rc_num = rc_num | csn_8.setBit(0,8);
+   rc_num = rc_num | address_16.clearBit(0, 16);
+   rc_num = rc_num | rasn_1.setBit(0,1);
+   rc_num = rc_num | casn_1.setBit(0,1);
+   rc_num = rc_num | wen_1.setBit(0,1);
+   
+   if(rc_num)
+   {
+       rc.setEcmdError(rc_num);
+       return rc;
+   }
+   
+   // Send out to the CCS array 
+   rc = mss_ccs_inst_arry_0( i_target,
+   	    io_ccs_inst_cnt,
+   	    address_16,
+   	    bank_3,
+   	    activate_1,
+   	    rasn_1,
+   	    casn_1,
+   	    wen_1,
+   	    cke_4,
+   	    csn_8,
+   	    odt_4,
+   	    ddr_cal_type_4,
+   	    i_port_number);
+   if(rc) return rc;
+   rc = mss_ccs_inst_arry_1( i_target,
+   	    io_ccs_inst_cnt,
+   	    num_idles_16,
+   	    num_repeat_16,
+   	    data_20,
+   	    read_compare_1,
+   	    rank_cal_4,
+   	    ddr_cal_enable_1,
+   	    ccs_end_1);
+   if(rc) return rc;
+   io_ccs_inst_cnt ++;
+   
+   //Setup end bit for CCS
+   rc = mss_ccs_set_end_bit (i_target, io_ccs_inst_cnt-1);
+   if (rc) return rc;
+   
+   //Execute the CCS array
+   FAPI_INF("Executing the CCS array\n");
+   rc = mss_execute_ccs_inst_array (i_target, 100, 60);
+   if(rc) return rc;
+    
+    return rc;
+
+}
+
+
+//////////////////////////////////////////////////////////////////////////////////
+/// mss_ddr4_modify_mrs_pda
+/// disables per-DRAM addressability funcitonality on both ports on the passed MBA
+//////////////////////////////////////////////////////////////////////////////////
+ReturnCode mss_ddr4_modify_mrs_pda(Target& i_target,ecmdDataBufferBase& address_16,uint32_t attribute_name,uint8_t attribute_data) {
+   ReturnCode rc;
+   uint32_t rc_num = 0;
+   uint8_t dram_bl = attribute_data;
+   uint8_t read_bt = attribute_data; //Read Burst Type 
+   uint8_t dram_cl = attribute_data;
+   uint8_t test_mode = attribute_data; //TEST MODE 
+   uint8_t dll_reset = attribute_data; //DLL Reset 
+   uint8_t dram_wr = attribute_data; //DRAM write recovery
+   uint8_t dram_rtp = attribute_data; //DRAM RTP - read to precharge
+   uint8_t dram_wr_rtp = attribute_data;
+   uint8_t dll_precharge = attribute_data; //DLL Control For Precharge if (dll_precharge == ENUM_ATTR_EFF_DRAM_DLL_PPD_SLOWEXIT)
+   uint8_t dll_enable = attribute_data; //DLL Enable 
+   uint8_t out_drv_imp_cntl = attribute_data;
+   uint8_t dram_rtt_nom = attribute_data;
+   uint8_t dram_al = attribute_data;
+   uint8_t wr_lvl = attribute_data; //write leveling enable
+   uint8_t tdqs_enable = attribute_data; //TDQS Enable 
+   uint8_t q_off = attribute_name; //Qoff - Output buffer Enable 
+   uint8_t lpasr = attribute_data; // Low Power Auto Self-Refresh -- new not yet supported
+   uint8_t cwl = attribute_data; // CAS Write Latency 
+   uint8_t dram_rtt_wr = attribute_data;
+   uint8_t mpr_op = attribute_data; // MPR Op
+   uint8_t mpr_page = attribute_data; // MPR Page Selection  
+   uint8_t geardown_mode = attribute_data; // Gear Down Mode  
+   uint8_t temp_readout = attribute_data; // Temperature sensor readout  
+   uint8_t fine_refresh = attribute_data; // fine refresh mode  
+   uint8_t wr_latency = attribute_data; // write latency for CRC and DM  
+   uint8_t write_crc = attribute_data; // CAS Write Latency 
+   uint8_t read_format = attribute_data; // MPR READ FORMAT  
+   uint8_t max_pd_mode = attribute_data; // Max Power down mode 
+   uint8_t temp_ref_range = attribute_data; // Temp ref range 
+   uint8_t temp_ref_mode = attribute_data; // Temp controlled ref mode 
+   uint8_t vref_mon = attribute_data; // Internal Vref Monitor 
+   uint8_t cs_cmd_latency = attribute_data; // CS to CMD/ADDR Latency 
+   uint8_t ref_abort = attribute_data; // Self Refresh Abort 
+   uint8_t rd_pre_train_mode = attribute_data; // Read Pre amble Training Mode 
+   uint8_t rd_preamble = attribute_data; // Read Pre amble 
+   uint8_t wr_preamble = attribute_data; // Write Pre amble 
+   uint8_t ca_parity_latency = attribute_data; //C/A Parity Latency Mode  
+   uint8_t crc_error_clear = attribute_data; //CRC Error Clear  
+   uint8_t ca_parity_error_status = attribute_data; //C/A Parity Error Status  
+   uint8_t odt_input_buffer = attribute_data; //ODT Input Buffer during power down  
+   uint8_t rtt_park = attribute_data; //RTT_Park value  
+   uint8_t ca_parity = attribute_data; //CA Parity Persistance Error  
+   uint8_t data_mask = attribute_data; //Data Mask  
+   uint8_t write_dbi = attribute_data; //Write DBI  
+   uint8_t read_dbi = attribute_data; //Read DBI  
+   uint8_t vrefdq_train_value = attribute_data; //vrefdq_train value   
+   uint8_t vrefdq_train_range = attribute_data; //vrefdq_train range   
+   uint8_t vrefdq_train_enable = attribute_data; //vrefdq_train enable  
+   uint8_t tccd_l = attribute_data; //tccd_l  
+   uint8_t dram_access;
+
+   switch (attribute_name) {
+       case ATTR_EFF_DRAM_BL:
+	   if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_BL8)
+           {
+               dram_bl = 0x00;
+           }
+           else if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_OTF)
+           {
+               dram_bl = 0x80;
+           }
+           else if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_BC4)
+           {
+               dram_bl = 0x40;
+           }
+	   rc_num = rc_num | address_16.insert((uint8_t) dram_bl, 0, 2, 0);
+	   break;
+       case ATTR_EFF_DRAM_RBT:
+	   if (read_bt == ENUM_ATTR_EFF_DRAM_RBT_SEQUENTIAL)
+           {
+               read_bt = 0x00;
+           }
+           else if (read_bt == ENUM_ATTR_EFF_DRAM_RBT_INTERLEAVE)
+           {
+               read_bt = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) read_bt, 3, 1, 0);
+	   break;
+       case ATTR_EFF_DRAM_CL:
+	   if ((dram_cl > 8)&&(dram_cl < 17))
+           {
+               dram_cl = dram_cl - 9; 
+           }
+           else if ((dram_cl > 17)&&(dram_cl < 25))
+           {
+               dram_cl = (dram_cl >> 1) - 1;   
+           }
+           dram_cl = mss_reverse_8bits(dram_cl);
+           rc_num = rc_num | address_16.insert((uint8_t) dram_cl, 2, 1, 0);
+           rc_num = rc_num | address_16.insert((uint8_t) dram_cl, 4, 3, 1);
+	   break;
+       case ATTR_EFF_DRAM_TM:
+	   if (test_mode == ENUM_ATTR_EFF_DRAM_TM_NORMAL)
+           {
+               test_mode = 0x00;
+           }
+           else if (test_mode == ENUM_ATTR_EFF_DRAM_TM_TEST)
+           {
+               test_mode = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) test_mode, 7, 1);
+	   break;
+       case ATTR_EFF_DRAM_DLL_RESET:
+	   dll_reset = 0x00;
+	   FAPI_ERR( "ERROR: ATTR_EFF_DRAM_DLL_RESET accessed during PDA functionality, overwritten");
+           rc_num = rc_num | address_16.insert((uint8_t) dll_reset, 8, 1);
+	   break;
+       case ATTR_EFF_DRAM_WR:
+           if ( (dram_wr == 10) )//&& (dram_rtp == 5) )
+           {
+               dram_wr_rtp = 0x00;
+           }
+           else if ( (dram_wr == 12) )//&& (dram_rtp == 6) )
+           {
+               dram_wr_rtp = 0x80;
+           }
+           else if ( (dram_wr == 13) )//&& (dram_rtp == 7) )
+           {
+               dram_wr_rtp = 0x40;
+           }
+           else if ( (dram_wr == 14) )//&& (dram_rtp == 8) )
+           {
+               dram_wr_rtp = 0xC0;
+           }
+           else if ( (dram_wr == 18) )//&& (dram_rtp == 9) )
+           {
+               dram_wr_rtp = 0x20;
+           }
+           else if ( (dram_wr == 20) )//&& (dram_rtp == 10) )
+           {
+               dram_wr_rtp = 0xA0;
+           }
+           else if ( (dram_wr == 24) )//&& (dram_rtp == 12) )
+           {
+               dram_wr_rtp = 0x60;
+           }
+    	   rc_num = rc_num | address_16.insert((uint8_t) dram_wr_rtp, 9, 3);
+	   break;
+       case ATTR_EFF_DRAM_TRTP:
+           if ( (dram_rtp == 5) )
+           {
+               dram_wr_rtp = 0x00;
+           }
+           else if ( (dram_rtp == 6) )
+           {
+               dram_wr_rtp = 0x80;
+           }
+           else if ( (dram_rtp == 7) )
+           {
+               dram_wr_rtp = 0x40;
+           }
+           else if ( (dram_rtp == 8) )
+           {
+               dram_wr_rtp = 0xC0;
+           }
+           else if ( (dram_rtp == 9) )
+           {
+               dram_wr_rtp = 0x20;
+           }
+           else if ( (dram_rtp == 10) )
+           {
+               dram_wr_rtp = 0xA0;
+           }
+           else if ( (dram_rtp == 12) )
+           {
+               dram_wr_rtp = 0x60;
+           }
+    	   rc_num = rc_num | address_16.insert((uint8_t) dram_wr_rtp, 9, 3);
+	   break;
+       case ATTR_EFF_DRAM_DLL_PPD:
+           if (dll_precharge == ENUM_ATTR_EFF_DRAM_DLL_PPD_SLOWEXIT)
+	   {
+               dll_precharge = 0x00;
+           }
+           else if (dll_precharge == ENUM_ATTR_EFF_DRAM_DLL_PPD_FASTEXIT)
+           {
+               dll_precharge = 0xFF;
+           }
+	   FAPI_INF("ERROR: ATTR_EFF_DRAM_DLL_PPD is an unused MRS value!!! Skipping...");
+	   break;
+       case ATTR_EFF_DRAM_DLL_ENABLE:
+           if (dll_enable == ENUM_ATTR_EFF_DRAM_DLL_ENABLE_DISABLE)
+           {
+               dll_enable = 0x00;
+           }
+           else if (dll_enable == ENUM_ATTR_EFF_DRAM_DLL_ENABLE_ENABLE)
+           {
+               dll_enable = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) dll_enable, 0, 1, 0);
+	   break;
+       case ATTR_VPD_DRAM_RON:
+	   if (out_drv_imp_cntl == ENUM_ATTR_VPD_DRAM_RON_OHM34)
+           {
+               out_drv_imp_cntl = 0x00;
+           }
+    	   // Not currently supported
+           else if (out_drv_imp_cntl == ENUM_ATTR_VPD_DRAM_RON_OHM48) //not supported
+           {
+               out_drv_imp_cntl = 0x80;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) out_drv_imp_cntl, 1, 2, 0);
+	   break;
+       case ATTR_VPD_DRAM_RTT_NOM:
+	   if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_DISABLE)
+           {
+               dram_rtt_nom = 0x00;
+           }
+           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM240) //not supported
+           {
+               dram_rtt_nom = 0x20;
+           }
+           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM48) //not supported
+           {
+               dram_rtt_nom = 0xA0;
+           }
+           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM40)
+           {
+               dram_rtt_nom = 0xC0;
+           }
+           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM60)
+           {
+               dram_rtt_nom = 0x80;
+           }
+           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM120)
+           {
+               dram_rtt_nom = 0x40;
+           }
+           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM80) // not supported
+           {
+               dram_rtt_nom = 0x60;
+           }
+           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM34) // not supported
+           {
+               dram_rtt_nom = 0xE0;
+           }
+	   
+           rc_num = rc_num | address_16.insert((uint8_t) dram_rtt_nom, 8, 3, 0);
+	   break;
+       case ATTR_EFF_DRAM_AL:
+	   if (dram_al == ENUM_ATTR_EFF_DRAM_AL_DISABLE)
+           {
+               dram_al = 0x00;
+           }
+           else if (dram_al == ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_1)
+           {
+               dram_al = 0x80;
+           }
+           else if (dram_al == ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_2)
+           {
+               dram_al = 0x40;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) dram_al, 3, 2, 0);
+	   break;
+       case ATTR_EFF_DRAM_WR_LVL_ENABLE:
+	   if (wr_lvl == ENUM_ATTR_EFF_DRAM_WR_LVL_ENABLE_DISABLE)
+           {
+               wr_lvl = 0x00;
+           }
+           else if (wr_lvl == ENUM_ATTR_EFF_DRAM_WR_LVL_ENABLE_ENABLE)
+           {
+               wr_lvl = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) wr_lvl, 7, 1, 0);
+	   break;
+       case ATTR_EFF_DRAM_TDQS:
+	   if (tdqs_enable == ENUM_ATTR_EFF_DRAM_TDQS_DISABLE)
+           {
+               tdqs_enable = 0x00;
+           }
+           else if (tdqs_enable == ENUM_ATTR_EFF_DRAM_TDQS_ENABLE)
+           {
+               tdqs_enable = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) tdqs_enable, 11, 1, 0);
+	   break;
+       case ATTR_EFF_DRAM_OUTPUT_BUFFER:
+           if (q_off == ENUM_ATTR_EFF_DRAM_OUTPUT_BUFFER_DISABLE)
+           {
+               q_off = 0xFF;
+           }
+           else if (q_off == ENUM_ATTR_EFF_DRAM_OUTPUT_BUFFER_ENABLE)
+           {
+               q_off = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) q_off, 12, 1, 0);
+	   break;
+       case ATTR_EFF_DRAM_LPASR:
+           if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_NORMAL)
+           {
+               lpasr = 0x00;
+           }
+           else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_REDUCED)
+           {
+               lpasr = 0x80;
+           }
+           else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_EXTENDED)
+           {
+               lpasr = 0x40;
+           }
+           else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_ASR)
+           {
+               lpasr = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) lpasr, 6, 2);
+	   break;
+       case ATTR_EFF_DRAM_CWL:
+	   if ((cwl > 8)&&(cwl < 13))
+           {
+               cwl = cwl - 9; 
+           }
+           else if ((cwl > 13)&&(cwl < 19))
+           {
+               cwl = (cwl >> 1) - 3;   
+           }
+           else
+           {
+              //no correcct value for CWL was found
+              FAPI_INF("ERROR: Improper CWL value found. Setting CWL to 9 and continuing...");
+              cwl = 0;
+           }
+	   cwl = mss_reverse_8bits(cwl);
+	   rc_num = rc_num | address_16.insert((uint8_t) cwl, 3, 3);
+	   break;
+       case ATTR_VPD_DRAM_RTT_WR:
+	   if (dram_rtt_wr == ENUM_ATTR_VPD_DRAM_RTT_WR_DISABLE)
+           {
+               dram_rtt_wr = 0x00;
+           }
+           else if (dram_rtt_wr == ENUM_ATTR_VPD_DRAM_RTT_WR_OHM120)
+           {
+               dram_rtt_wr = 0x80;
+           }
+           else if (dram_rtt_wr == 240)//ENUM_ATTR_EFF_DRAM_RTT_WR_OHM240)
+           {
+               dram_rtt_wr = 0x40;
+           }
+           else if (dram_rtt_wr == 0xFF)//ENUM_ATTR_EFF_DRAM_RTT_WR_HIGHZ)
+           {
+               dram_rtt_wr = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) dram_rtt_wr, 9, 2);
+           break;
+       case ATTR_EFF_WRITE_CRC:
+	   if ( write_crc == ENUM_ATTR_EFF_WRITE_CRC_ENABLE)
+           {
+               write_crc = 0xFF;
+           }
+           else if (write_crc == ENUM_ATTR_EFF_WRITE_CRC_DISABLE)
+           {
+               write_crc = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) write_crc, 12, 1);
+	   break;
+       case ATTR_EFF_MPR_MODE:
+	   if (mpr_op == ENUM_ATTR_EFF_MPR_MODE_ENABLE)
+           {
+               mpr_op = 0xFF;
+           }
+           else if (mpr_op == ENUM_ATTR_EFF_MPR_MODE_DISABLE)
+           {
+               mpr_op = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) mpr_op, 2, 1);
+	   break;
+       case ATTR_EFF_MPR_PAGE:
+           mpr_page = mss_reverse_8bits(mpr_page);
+    	   rc_num = rc_num | address_16.insert((uint8_t) mpr_page, 0, 2);
+	   break;
+       case ATTR_EFF_GEARDOWN_MODE:
+	   if ( geardown_mode == ENUM_ATTR_EFF_GEARDOWN_MODE_HALF)
+           {
+        	geardown_mode = 0x00;
+           }
+           else if ( geardown_mode == ENUM_ATTR_EFF_GEARDOWN_MODE_QUARTER)
+           {
+        	geardown_mode = 0xFF;
+           }
+           
+           if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_ENABLE)
+           {
+               temp_readout = 0xFF;
+           }
+           else if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_DISABLE)
+           {
+               temp_readout = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) geardown_mode, 3, 1);
+	   break;
+       case ATTR_EFF_TEMP_READOUT:
+	   if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_ENABLE)
+    	   {
+    	       temp_readout = 0xFF;
+    	   }
+    	   else if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_DISABLE)
+    	   {
+    	       temp_readout = 0x00;
+    	   }
+           rc_num = rc_num | address_16.insert((uint8_t) temp_readout, 5, 1);
+	   break;
+       case ATTR_EFF_FINE_REFRESH_MODE:
+	   if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_NORMAL)
+           {
+               fine_refresh = 0x00;
+           }
+           else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FIXED_2X)
+           {
+               fine_refresh = 0x80;
+           }
+           else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FIXED_4X)
+           {
+               fine_refresh = 0x40;
+           }
+           else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FLY_2X)
+           {
+               fine_refresh = 0xA0;
+           }
+           else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FLY_4X)
+           {
+               fine_refresh = 0x60;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) fine_refresh, 6, 3);
+	   break;
+       case ATTR_EFF_CRC_WR_LATENCY:
+           if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_4NCK)
+           {
+               wr_latency = 0x00;
+           }
+           else if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_5NCK)
+           {
+               wr_latency = 0x80;
+           }
+           else if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_6NCK)
+           {
+               wr_latency = 0xC0;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) wr_latency, 9, 2);
+	   break;
+       case ATTR_EFF_MPR_RD_FORMAT:
+           if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_SERIAL)
+           {
+               read_format = 0x00;
+           }
+           else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_PARALLEL)
+           {
+               read_format = 0x80;
+           }
+           else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_STAGGERED)
+           {
+               read_format = 0x40;
+           }
+           else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_RESERVED_TEMP)
+           {
+               read_format = 0xC0;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) read_format, 11, 2);
+	   break;
+       case ATTR_EFF_PER_DRAM_ACCESS:
+           FAPI_INF("ERROR: ATTR_EFF_PER_DRAM_ACCESS selected.  Forcing PDA to be on for this function");
+	   dram_access = 0xFF;
+	   rc_num = rc_num | address_16.insert((uint8_t) dram_access, 4, 1);
+	   break;
+       case ATTR_EFF_MAX_POWERDOWN_MODE:
+	   if ( max_pd_mode == ENUM_ATTR_EFF_MAX_POWERDOWN_MODE_ENABLE)
+           {
+               max_pd_mode = 0xF0;
+           }
+           else if ( max_pd_mode == ENUM_ATTR_EFF_MAX_POWERDOWN_MODE_DISABLE)
+           {
+               max_pd_mode = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) max_pd_mode, 1, 1);
+	   break;
+       case ATTR_EFF_TEMP_REF_RANGE:
+	   if (temp_ref_range == ENUM_ATTR_EFF_TEMP_REF_RANGE_NORMAL)
+           {
+               temp_ref_range = 0x00;
+           }
+           else if ( temp_ref_range== ENUM_ATTR_EFF_TEMP_REF_RANGE_EXTEND)
+           {
+               temp_ref_range = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) temp_ref_range, 2, 1);
+	   break;
+       case ATTR_EFF_TEMP_REF_MODE:
+	   if (temp_ref_mode == ENUM_ATTR_EFF_TEMP_REF_MODE_ENABLE)
+           {
+               temp_ref_mode = 0x80;
+           }
+           else if (temp_ref_mode == ENUM_ATTR_EFF_TEMP_REF_MODE_DISABLE)
+           {
+               temp_ref_mode = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) temp_ref_mode, 3, 1);
+	   break;
+       case ATTR_EFF_INT_VREF_MON:
+	   if ( vref_mon == ENUM_ATTR_EFF_INT_VREF_MON_ENABLE)
+           {
+               vref_mon = 0xFF;
+           }
+           else if ( vref_mon == ENUM_ATTR_EFF_INT_VREF_MON_DISABLE)
+           {
+               vref_mon = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) vref_mon, 4, 1);
+	   break;
+       case ATTR_EFF_CS_CMD_LATENCY:
+	   if ( cs_cmd_latency == 3)
+           {
+               cs_cmd_latency = 0x80;
+           }
+           else if (cs_cmd_latency == 4)
+           {
+               cs_cmd_latency = 0x40;
+           }
+           else if (cs_cmd_latency == 5)
+           {
+               cs_cmd_latency = 0xC0;
+           }
+           else if (cs_cmd_latency == 6)
+           {
+               cs_cmd_latency = 0x20;
+           }
+           else if (cs_cmd_latency == 8)
+           {
+               cs_cmd_latency = 0xA0;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) cs_cmd_latency, 6, 3);
+	   break;
+       case ATTR_EFF_SELF_REF_ABORT:
+	   if (ref_abort == ENUM_ATTR_EFF_SELF_REF_ABORT_ENABLE)
+           {
+               ref_abort = 0xFF;
+           }
+           else if (ref_abort == ENUM_ATTR_EFF_SELF_REF_ABORT_DISABLE)
+           {
+               ref_abort = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) ref_abort, 9, 1);
+	   break;
+       case ATTR_EFF_RD_PREAMBLE_TRAIN:
+	   if (rd_pre_train_mode == ENUM_ATTR_EFF_RD_PREAMBLE_TRAIN_ENABLE)
+           {
+               rd_pre_train_mode = 0xFF;
+           }
+           else if (rd_pre_train_mode == ENUM_ATTR_EFF_RD_PREAMBLE_TRAIN_DISABLE)
+           {
+               rd_pre_train_mode = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) rd_pre_train_mode, 10, 1);
+	   break;
+       case ATTR_EFF_RD_PREAMBLE:
+	   if (rd_preamble == ENUM_ATTR_EFF_RD_PREAMBLE_1NCLK)
+           {
+               rd_preamble = 0x00;
+           }
+           else if (rd_preamble == ENUM_ATTR_EFF_RD_PREAMBLE_2NCLK)
+           {
+               rd_preamble = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) rd_preamble, 11, 1);
+	   break;
+       case ATTR_EFF_WR_PREAMBLE:
+           if (wr_preamble == ENUM_ATTR_EFF_WR_PREAMBLE_1NCLK)
+           {
+               wr_preamble = 0x00;
+           }
+           else if (wr_preamble == ENUM_ATTR_EFF_WR_PREAMBLE_2NCLK)
+           {
+               wr_preamble = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) wr_preamble, 12, 1);
+	   break;
+       case ATTR_EFF_CA_PARITY_LATENCY:
+	   if (ca_parity_latency == 4)
+           {
+               ca_parity_latency = 0x80;
+           }
+           else if (ca_parity_latency == 5)
+           {
+               ca_parity_latency = 0x40;
+           }
+           else if (ca_parity_latency == 6)
+           {
+               ca_parity_latency = 0xC0;
+           }
+           else if (ca_parity_latency == 8)
+           {
+               ca_parity_latency = 0x20;
+           }
+           else if (ca_parity_latency == ENUM_ATTR_EFF_CA_PARITY_LATENCY_DISABLE)
+           {
+               ca_parity_latency = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) ca_parity_latency, 0, 2);
+	   break;
+       case ATTR_EFF_CRC_ERROR_CLEAR:
+	   if (crc_error_clear == ENUM_ATTR_EFF_CRC_ERROR_CLEAR_ERROR)
+           {
+               crc_error_clear = 0xFF;
+           }
+           else if (crc_error_clear == ENUM_ATTR_EFF_CRC_ERROR_CLEAR_CLEAR)
+           {
+               crc_error_clear = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) crc_error_clear, 3, 1);
+	   break;
+       case ATTR_EFF_CA_PARITY_ERROR_STATUS:
+	   if (ca_parity_error_status == ENUM_ATTR_EFF_CA_PARITY_ERROR_STATUS_ERROR)
+           {
+               ca_parity_error_status = 0xFF;
+           }
+           else if (ca_parity_error_status == ENUM_ATTR_EFF_CA_PARITY_ERROR_STATUS_CLEAR)
+           {
+               ca_parity_error_status = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) ca_parity_error_status, 4, 1);
+	   break;
+       case ATTR_EFF_ODT_INPUT_BUFF:
+	   if (odt_input_buffer == ENUM_ATTR_EFF_ODT_INPUT_BUFF_ACTIVATED)
+           {
+               odt_input_buffer = 0x00;
+           }
+           else if (odt_input_buffer == ENUM_ATTR_EFF_ODT_INPUT_BUFF_DEACTIVATED)
+           {
+               odt_input_buffer = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) odt_input_buffer, 5, 1);
+	   break;
+       case ATTR_VPD_DRAM_RTT_PARK:
+	   if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_DISABLE)
+           {
+               rtt_park = 0x00;
+           }
+           else if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_60OHM)
+           {
+               rtt_park = 0x80;
+           }
+           else if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_40OHM)
+           {
+               rtt_park = 0xC0;
+           }
+           else if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_120OHM)
+           {
+               rtt_park = 0x40;
+           }
+           else if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_240OHM)
+           {
+               rtt_park = 0x20;
+           }
+           else if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_48OHM)
+           {
+               rtt_park = 0xA0;
+           }
+           else if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_80OHM)
+           {
+               rtt_park = 0x60;
+           }
+           else if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_34OHM)
+           {
+               rtt_park = 0xE0;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) rtt_park, 6, 3);
+	   break;
+       case ATTR_EFF_CA_PARITY:
+	   if (ca_parity == ENUM_ATTR_EFF_CA_PARITY_ENABLE)
+           {
+               ca_parity = 0xFF;
+           }
+           else if (ca_parity == ENUM_ATTR_EFF_CA_PARITY_DISABLE)
+           {
+               ca_parity = 0x00;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) ca_parity, 9, 1);
+	   break;
+       case ATTR_EFF_DATA_MASK:
+	   if (data_mask == ENUM_ATTR_EFF_DATA_MASK_DISABLE)
+           {
+               data_mask = 0x00;
+           }
+           else if (data_mask == ENUM_ATTR_EFF_DATA_MASK_ENABLE)
+           {
+               data_mask = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) data_mask, 10, 1);
+	   break;
+       case ATTR_EFF_WRITE_DBI:
+	   if (write_dbi == ENUM_ATTR_EFF_WRITE_DBI_DISABLE)
+           {
+               write_dbi = 0x00;
+           }
+           else if (write_dbi == ENUM_ATTR_EFF_WRITE_DBI_ENABLE)
+           {
+               write_dbi = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) write_dbi, 11, 1);
+	   break;
+       case ATTR_EFF_READ_DBI:
+           if (read_dbi == ENUM_ATTR_EFF_READ_DBI_DISABLE)
+           {
+               read_dbi = 0x00;
+           }
+           else if (read_dbi == ENUM_ATTR_EFF_READ_DBI_ENABLE)
+           {
+               read_dbi = 0xFF;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) read_dbi, 12, 1);
+	   break;
+       case ATTR_EFF_VREF_DQ_TRAIN_VALUE:
+	   vrefdq_train_value = mss_reverse_8bits(vrefdq_train_value);
+           rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_value, 0, 6);
+	   break;
+       case ATTR_EFF_VREF_DQ_TRAIN_RANGE:
+	   if (vrefdq_train_range == ENUM_ATTR_EFF_VREF_DQ_TRAIN_RANGE_RANGE1)
+           {
+               vrefdq_train_range = 0x00;
+           }
+           else if (vrefdq_train_range == ENUM_ATTR_EFF_VREF_DQ_TRAIN_RANGE_RANGE2)
+           {
+               vrefdq_train_range = 0xFF;
+           } 
+           rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_range, 6, 1);
+	   break;
+       case ATTR_EFF_VREF_DQ_TRAIN_ENABLE:
+	   if (vrefdq_train_enable == ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE)
+           {
+               vrefdq_train_enable = 0xFF;
+           }
+           else if (vrefdq_train_enable == ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_DISABLE)
+           {
+               vrefdq_train_enable = 0x00;
+           }   
+           rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_enable, 7, 1);
+	   break;
+       case ATTR_TCCD_L:
+           if (tccd_l == 4)
+           {
+               tccd_l = 0x00;
+           }
+           else if (tccd_l == 5)
+           {
+               tccd_l = 0x80;
+           }
+           else if (tccd_l == 6)
+           {
+               tccd_l = 0x40;
+           }	
+           else if (tccd_l == 7)
+           {
+               tccd_l = 0xC0;
+           }
+           else if (tccd_l == 8)
+           {
+               tccd_l = 0x20;
+           }
+           rc_num = rc_num | address_16.insert((uint8_t) tccd_l, 10, 3);
+	   break;
+	//MRS attribute not found, error out
+      default: 
+         const uint32_t NONMRS_ATTR_NAME = attribute_name;
+	 const fapi::Target & MBA_TARGET = i_target; 
+	 FAPI_SET_HWP_ERROR(rc, RC_MSS_PDA_NONMRS_ATTR_NAME);
+	 FAPI_ERR("ERROR!! Found attribute name not associated with an MRS! Exiting...");
+   }
+   if (rc_num)
+   {
+       FAPI_ERR( "mss_ddr4_modify_mrs_pda: Error setting up buffers");
+       rc.setEcmdError(rc_num);
+       return rc;
+   }
+   return rc;
+}
+
+//////////////////////////////////////////////////////////////////////////////////
+/// mss_ddr4_load_nominal_mrs_pda
+/// disables per-DRAM addressability funcitonality on both ports on the passed MBA
+//////////////////////////////////////////////////////////////////////////////////
+ReturnCode mss_ddr4_load_nominal_mrs_pda(Target& i_target,ecmdDataBufferBase& bank_3,ecmdDataBufferBase& address_16,uint8_t MRS,uint8_t i_port_number, uint8_t dimm_number, uint8_t rank_number) {
+    ReturnCode rc;  
+    uint32_t rc_num = 0;
+    
+    rc_num = rc_num | address_16.clearBit(0,16);
+    rc_num = rc_num | bank_3.clearBit(0,3);
+    if (rc_num)
+    {
+    	FAPI_ERR( "mss_mrs_load: Error setting up buffers");
+    	rc.setEcmdError(rc_num);
+    	return rc;
+    }
+
+    //Lines commented out in the following section are waiting for xml attribute adds
+    //MRS0
+    if(MRS == MRS0_BA) {
+    	uint8_t dram_bl;
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_BL, &i_target, dram_bl);
+    	if(rc) return rc;
+    	uint8_t read_bt; //Read Burst Type 
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_RBT, &i_target, read_bt);
+    	if(rc) return rc;
+    	uint8_t dram_cl;
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_CL, &i_target, dram_cl);
+    	if(rc) return rc;
+    	uint8_t test_mode; //TEST MODE 
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_TM, &i_target, test_mode);
+    	if(rc) return rc;
+    	uint8_t dll_reset; //DLL Reset 
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_DLL_RESET, &i_target, dll_reset);
+    	if(rc) return rc;
+    	uint8_t dram_wr; //DRAM write recovery
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_WR, &i_target, dram_wr);
+    	if(rc) return rc;
+    	uint8_t dram_rtp; //DRAM RTP - read to precharge
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_TRTP, &i_target, dram_rtp);
+    	if(rc) return rc;
+    	uint8_t dll_precharge; //DLL Control For Precharge 
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_DLL_PPD, &i_target, dll_precharge);
+    	if(rc) return rc;
+
+    	if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_BL8)
+    	{
+    	    dram_bl = 0x00;
+    	}
+    	else if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_OTF)
+    	{
+    	    dram_bl = 0x80;
+    	}
+    	else if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_BC4)
+    	{
+    	    dram_bl = 0x40;
+    	}
+
+    	uint8_t dram_wr_rtp = 0x00;
+    	if ( (dram_wr == 10) )//&& (dram_rtp == 5) )
+    	{
+    	    dram_wr_rtp = 0x00;
+    	}
+    	else if ( (dram_wr == 12) )//&& (dram_rtp == 6) )
+    	{
+    	    dram_wr_rtp = 0x80;
+    	}
+    	else if ( (dram_wr == 13) )//&& (dram_rtp == 7) )
+    	{
+    	    dram_wr_rtp = 0x40;
+    	}
+    	else if ( (dram_wr == 14) )//&& (dram_rtp == 8) )
+    	{
+    	    dram_wr_rtp = 0xC0;
+    	}
+    	else if ( (dram_wr == 18) )//&& (dram_rtp == 9) )
+    	{
+    	    dram_wr_rtp = 0x20;
+    	}
+    	else if ( (dram_wr == 20) )//&& (dram_rtp == 10) )
+    	{
+    	    dram_wr_rtp = 0xA0;
+    	}
+    	else if ( (dram_wr == 24) )//&& (dram_rtp == 12) )
+    	{
+    	    dram_wr_rtp = 0x60;
+    	}
+
+    	if (read_bt == ENUM_ATTR_EFF_DRAM_RBT_SEQUENTIAL)
+    	{
+    	    read_bt = 0x00;
+    	}
+    	else if (read_bt == ENUM_ATTR_EFF_DRAM_RBT_INTERLEAVE)
+    	{
+    	    read_bt = 0xFF;
+    	}
+
+    	if ((dram_cl > 8)&&(dram_cl < 17))
+    	{
+    	    dram_cl = dram_cl - 9; 
+    	}
+    	else if ((dram_cl > 17)&&(dram_cl < 25))
+    	{
+    	    dram_cl = (dram_cl >> 1) - 1;   
+    	}
+    	dram_cl = mss_reverse_8bits(dram_cl);
+
+    	if (test_mode == ENUM_ATTR_EFF_DRAM_TM_NORMAL)
+    	{
+    	    test_mode = 0x00;
+    	}
+    	else if (test_mode == ENUM_ATTR_EFF_DRAM_TM_TEST)
+    	{
+    	    test_mode = 0xFF;
+    	}
+	
+	FAPI_INF("Overwriting DLL reset with values to not reset the DRAM.");
+    	dll_reset = 0x00;
+
+    	if (dll_precharge == ENUM_ATTR_EFF_DRAM_DLL_PPD_SLOWEXIT)
+    	{
+    	    dll_precharge = 0x00;
+    	}
+    	else if (dll_precharge == ENUM_ATTR_EFF_DRAM_DLL_PPD_FASTEXIT)
+    	{
+    	    dll_precharge = 0xFF;
+    	}
+	//For DDR4:
+	//Address 14 = Address 17, Address 15 = BG1
+        rc_num = rc_num | address_16.insert((uint8_t) dram_bl, 0, 2, 0);
+        rc_num = rc_num | address_16.insert((uint8_t) dram_cl, 2, 1, 0);
+        rc_num = rc_num | address_16.insert((uint8_t) read_bt, 3, 1, 0);
+        rc_num = rc_num | address_16.insert((uint8_t) dram_cl, 4, 3, 1);
+        rc_num = rc_num | address_16.insert((uint8_t) test_mode, 7, 1);
+        rc_num = rc_num | address_16.insert((uint8_t) dll_reset, 8, 1);
+	rc_num = rc_num | address_16.insert((uint8_t) dram_wr_rtp, 9, 3);
+	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 12, 4);
+	
+	rc_num = rc_num | bank_3.insert((uint8_t) MRS0_BA, 0, 1, 7);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS0_BA, 1, 1, 6);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS0_BA, 2, 1, 5);
+	if (rc_num)
+        {
+            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
+            rc.setEcmdError(rc_num);
+            return rc;
+        }
+    }
+    
+    //MRS1
+    else if(MRS == MRS1_BA) {
+    	uint8_t dll_enable; //DLL Enable 
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_DLL_ENABLE, &i_target, dll_enable);
+    	if(rc) return rc;
+    	uint8_t out_drv_imp_cntl[2][2];
+    	rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_RON, &i_target, out_drv_imp_cntl);
+    	if(rc) return rc;
+    	uint8_t dram_rtt_nom[2][2][4];
+    	rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_RTT_NOM, &i_target, dram_rtt_nom);
+    	if(rc) return rc;
+    	uint8_t dram_al;
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_AL, &i_target, dram_al);
+    	if(rc) return rc;
+    	uint8_t wr_lvl; //write leveling enable
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_WR_LVL_ENABLE, &i_target, wr_lvl);
+    	if(rc) return rc;
+    	uint8_t tdqs_enable; //TDQS Enable 
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_TDQS, &i_target, tdqs_enable);
+    	if(rc) return rc;
+    	uint8_t q_off; //Qoff - Output buffer Enable 
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_OUTPUT_BUFFER, &i_target, q_off);
+    	if(rc) return rc;
+
+    	if (dll_enable == ENUM_ATTR_EFF_DRAM_DLL_ENABLE_DISABLE)
+    	{
+    	    dll_enable = 0x00;
+    	}
+    	else if (dll_enable == ENUM_ATTR_EFF_DRAM_DLL_ENABLE_ENABLE)
+    	{
+    	    dll_enable = 0xFF;
+    	}
+
+    	if (dram_al == ENUM_ATTR_EFF_DRAM_AL_DISABLE)
+    	{
+    	    dram_al = 0x00;
+    	}
+    	else if (dram_al == ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_1)
+    	{
+    	    dram_al = 0x80;
+    	}
+    	else if (dram_al == ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_2)
+    	{
+    	    dram_al = 0x40;
+    	}
+	else if (dram_al == ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_3) {
+	    dram_al = 0xC0;
+	}
+
+    	if (wr_lvl == ENUM_ATTR_EFF_DRAM_WR_LVL_ENABLE_DISABLE)
+    	{
+    	    wr_lvl = 0x00;
+    	}
+    	else if (wr_lvl == ENUM_ATTR_EFF_DRAM_WR_LVL_ENABLE_ENABLE)
+    	{
+    	    wr_lvl = 0xFF;
+    	}
+
+    	if (tdqs_enable == ENUM_ATTR_EFF_DRAM_TDQS_DISABLE)
+    	{
+    	    tdqs_enable = 0x00;
+    	}
+    	else if (tdqs_enable == ENUM_ATTR_EFF_DRAM_TDQS_ENABLE)
+    	{
+    	    tdqs_enable = 0xFF;
+    	}
+
+    	if (q_off == ENUM_ATTR_EFF_DRAM_OUTPUT_BUFFER_DISABLE)
+    	{
+    	    q_off = 0xFF;
+    	}
+    	else if (q_off == ENUM_ATTR_EFF_DRAM_OUTPUT_BUFFER_ENABLE)
+    	{
+    	    q_off = 0x00;
+    	}
+        if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_DISABLE)
+        {
+            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0x00;
+        }
+        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM240) //not supported
+        {
+            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0x20;
+        }
+        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM48) //not supported
+        {
+            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0xA0;
+        }
+        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM40)
+        {
+            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0xC0;
+        }
+        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM60)
+        {
+            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0x80;
+        }
+        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM120)
+        {
+            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0x40;
+        }
+        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM80) // not supported
+        {
+            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0x60;
+        }
+        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM34) // not supported
+        {
+            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0xE0;
+        }
+
+        if (out_drv_imp_cntl[i_port_number][dimm_number] == ENUM_ATTR_VPD_DRAM_RON_OHM34)
+        {
+            out_drv_imp_cntl[i_port_number][dimm_number] = 0x00;
+        }
+	// Not currently supported
+        else if (out_drv_imp_cntl[i_port_number][dimm_number] == ENUM_ATTR_VPD_DRAM_RON_OHM48) //not supported
+        {
+            out_drv_imp_cntl[i_port_number][dimm_number] = 0x80;
+        }
+
+	//For DDR4:
+	//Address 14 = Address 17, Address 15 = BG1
+        rc_num = rc_num | address_16.insert((uint8_t) dll_enable, 0, 1, 0);
+        rc_num = rc_num | address_16.insert((uint8_t) out_drv_imp_cntl[i_port_number][dimm_number], 1, 2, 0);
+        rc_num = rc_num | address_16.insert((uint8_t) dram_al, 3, 2, 0);
+        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 5, 2);
+        rc_num = rc_num | address_16.insert((uint8_t) wr_lvl, 7, 1, 0);
+        rc_num = rc_num | address_16.insert((uint8_t) dram_rtt_nom[i_port_number][dimm_number][rank_number], 8, 3, 0);
+        rc_num = rc_num | address_16.insert((uint8_t) tdqs_enable, 11, 1, 0);
+        rc_num = rc_num | address_16.insert((uint8_t) q_off, 12, 1, 0);
+        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 13, 3);
+	
+	rc_num = rc_num | bank_3.insert((uint8_t) MRS1_BA, 0, 1, 7);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS1_BA, 1, 1, 6);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS1_BA, 2, 1, 5);
+	if (rc_num)
+        {
+            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
+            rc.setEcmdError(rc_num);
+            return rc;
+        }
+    }
+    //MRS2
+    else if(MRS == MRS2_BA) {
+    	uint8_t lpasr; // Low Power Auto Self-Refresh -- new not yet supported
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_LPASR, &i_target, lpasr);
+    	if(rc) return rc;
+    	uint8_t cwl; // CAS Write Latency 
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_CWL, &i_target, cwl);
+    	if(rc) return rc;
+    	uint8_t dram_rtt_wr[2][2][4];
+    	rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_RTT_WR, &i_target, dram_rtt_wr);
+    	if(rc) return rc;
+    	uint8_t write_crc; // CAS Write Latency 
+    	rc = FAPI_ATTR_GET(ATTR_EFF_WRITE_CRC, &i_target, write_crc);
+    	if(rc) return rc;
+
+    	if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_NORMAL)
+    	{
+    	    lpasr = 0x00;
+    	}
+    	else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_REDUCED)
+    	{
+    	    lpasr = 0x80;
+    	}
+    	else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_EXTENDED)
+    	{
+    	    lpasr = 0x40;
+    	}
+    	else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_ASR)
+    	{
+    	    lpasr = 0xFF;
+    	}
+
+    	if ((cwl > 8)&&(cwl < 13))
+    	{
+    	    cwl = cwl - 9; 
+    	}
+    	else if ((cwl > 13)&&(cwl < 19))
+    	{
+    	    cwl = (cwl >> 1) - 3;   
+    	}
+    	else
+    	{
+    	   //no correcct value for CWL was found
+    	   FAPI_INF("ERROR: Improper CWL value found. Setting CWL to 9 and continuing...");
+    	   cwl = 0;
+    	}
+    	cwl = mss_reverse_8bits(cwl);
+
+    	if ( write_crc == ENUM_ATTR_EFF_WRITE_CRC_ENABLE)
+    	{
+    	    write_crc = 0xFF;
+    	}
+    	else if (write_crc == ENUM_ATTR_EFF_WRITE_CRC_DISABLE)
+    	{
+    	    write_crc = 0x00;
+    	}
+	if (dram_rtt_wr[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_WR_DISABLE)
+        {
+            dram_rtt_wr[i_port_number][dimm_number][rank_number] = 0x00;
+        }
+        else if (dram_rtt_wr[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_WR_OHM120)
+        {
+            dram_rtt_wr[i_port_number][dimm_number][rank_number] = 0x80;
+        }
+        else if (dram_rtt_wr[i_port_number][dimm_number][rank_number] == 240)//ENUM_ATTR_EFF_DRAM_RTT_WR_OHM240)
+        {
+            dram_rtt_wr[i_port_number][dimm_number][rank_number] = 0x40;
+        }
+        else if (dram_rtt_wr[i_port_number][dimm_number][rank_number] == 0xFF)//ENUM_ATTR_EFF_DRAM_RTT_WR_HIGHZ)
+        {
+            dram_rtt_wr[i_port_number][dimm_number][rank_number] = 0xFF;
+        }
+
+        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 0, 3);
+        rc_num = rc_num | address_16.insert((uint8_t) cwl, 3, 3);
+        rc_num = rc_num | address_16.insert((uint8_t) lpasr, 6, 2);
+        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 8, 1);
+        rc_num = rc_num | address_16.insert((uint8_t) dram_rtt_wr[i_port_number][dimm_number][rank_number], 9, 2);
+        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 11, 1);
+        rc_num = rc_num | address_16.insert((uint8_t) write_crc, 12, 1);
+        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 13, 2);
+	
+	rc_num = rc_num | bank_3.insert((uint8_t) MRS2_BA, 0, 1, 7);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS2_BA, 1, 1, 6);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS2_BA, 2, 1, 5);
+	if (rc_num)
+        {
+            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
+            rc.setEcmdError(rc_num);
+            return rc;
+        }
+    }
+    //MRS3
+    else if(MRS == MRS3_BA) {
+    	uint8_t mpr_op; // MPR Op
+    	rc = FAPI_ATTR_GET(ATTR_EFF_MPR_MODE, &i_target, mpr_op);
+    	if(rc) return rc;
+    	uint8_t mpr_page; // MPR Page Selection  - NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_MPR_PAGE, &i_target, mpr_page);
+    	if(rc) return rc;
+    	uint8_t geardown_mode; // Gear Down Mode  - NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_GEARDOWN_MODE, &i_target, geardown_mode);
+    	if(rc) return rc;
+    	uint8_t temp_readout; // Temperature sensor readout  - NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_TEMP_READOUT, &i_target, temp_readout);
+    	if(rc) return rc;
+    	uint8_t fine_refresh; // fine refresh mode  - NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_FINE_REFRESH_MODE, &i_target, fine_refresh);
+    	if(rc) return rc;
+    	uint8_t wr_latency; // write latency for CRC and DM  - NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_CRC_WR_LATENCY, &i_target, wr_latency);
+    	if(rc) return rc;
+    	uint8_t read_format; // MPR READ FORMAT  - NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_MPR_RD_FORMAT, &i_target, read_format);
+    	if(rc) return rc;
+
+    	if (mpr_op == ENUM_ATTR_EFF_MPR_MODE_ENABLE)
+    	{
+    	    mpr_op = 0xFF;
+    	}
+    	else if (mpr_op == ENUM_ATTR_EFF_MPR_MODE_DISABLE)
+    	{
+    	    mpr_op = 0x00;
+    	}
+
+    	mpr_page = mss_reverse_8bits(mpr_page);
+
+    	if ( geardown_mode == ENUM_ATTR_EFF_GEARDOWN_MODE_HALF)
+    	{
+    	     geardown_mode = 0x00;
+    	}
+    	else if ( geardown_mode == ENUM_ATTR_EFF_GEARDOWN_MODE_QUARTER)
+    	{
+    	     geardown_mode = 0xFF;
+    	}
+    	
+    	if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_ENABLE)
+    	{
+    	    temp_readout = 0xFF;
+    	}
+    	else if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_DISABLE)
+    	{
+    	    temp_readout = 0x00;
+    	}
+
+    	if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_NORMAL)
+    	{
+    	    fine_refresh = 0x00;
+    	}
+    	else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FIXED_2X)
+    	{
+    	    fine_refresh = 0x80;
+    	}
+    	else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FIXED_4X)
+    	{
+    	    fine_refresh = 0x40;
+    	}
+    	else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FLY_2X)
+    	{
+    	    fine_refresh = 0xA0;
+    	}
+    	else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FLY_4X)
+    	{
+    	    fine_refresh = 0x60;
+    	}
+
+    	if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_4NCK)
+    	{
+    	    wr_latency = 0x00;
+    	}
+    	else if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_5NCK)
+    	{
+    	    wr_latency = 0x80;
+    	}
+    	else if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_6NCK)
+    	{
+    	    wr_latency = 0xC0;
+    	}
+
+    	if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_SERIAL)
+    	{
+    	    read_format = 0x00;
+    	}
+    	else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_PARALLEL)
+    	{
+    	    read_format = 0x80;
+    	}
+    	else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_STAGGERED)
+    	{
+    	    read_format = 0x40;
+    	}
+    	else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_RESERVED_TEMP)
+    	{
+    	    read_format = 0xC0;
+    	}
+	
+	rc_num = rc_num | address_16.insert((uint8_t) mpr_page, 0, 2);
+        rc_num = rc_num | address_16.insert((uint8_t) mpr_op, 2, 1);
+        rc_num = rc_num | address_16.insert((uint8_t) geardown_mode, 3, 1);
+        rc_num = rc_num | address_16.insert((uint8_t) 0xFF, 4, 1); //has PDA mode enabled!!!! just for this code!
+        rc_num = rc_num | address_16.insert((uint8_t) temp_readout, 5, 1);
+        rc_num = rc_num | address_16.insert((uint8_t) fine_refresh, 6, 3);
+        rc_num = rc_num | address_16.insert((uint8_t) wr_latency, 9, 2);
+        rc_num = rc_num | address_16.insert((uint8_t) read_format, 11, 2);
+        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 13, 2);
+	
+	rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 0, 1, 7);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 1, 1, 6);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 2, 1, 5);
+	if (rc_num)
+        {
+            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
+            rc.setEcmdError(rc_num);
+            return rc;
+        }
+    }
+    //MRS4
+    else if(MRS == MRS4_BA) {
+    	uint8_t max_pd_mode; // Max Power down mode -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_MAX_POWERDOWN_MODE, &i_target, max_pd_mode);
+    	if(rc) return rc;
+    	uint8_t temp_ref_range; // Temp ref range -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_TEMP_REF_RANGE, &i_target, temp_ref_range);
+    	if(rc) return rc;
+    	uint8_t temp_ref_mode; // Temp controlled ref mode -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_TEMP_REF_MODE, &i_target, temp_ref_mode);
+    	if(rc) return rc;
+    	uint8_t vref_mon; // Internal Vref Monitor -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_INT_VREF_MON, &i_target, vref_mon);
+    	if(rc) return rc;
+    	uint8_t cs_cmd_latency; // CS to CMD/ADDR Latency -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_CS_CMD_LATENCY, &i_target, cs_cmd_latency);
+    	if(rc) return rc;
+    	uint8_t ref_abort; // Self Refresh Abort -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_SELF_REF_ABORT, &i_target, ref_abort);
+    	if(rc) return rc;
+    	uint8_t rd_pre_train_mode; // Read Pre amble Training Mode -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_RD_PREAMBLE_TRAIN, &i_target, rd_pre_train_mode);
+    	if(rc) return rc;
+    	uint8_t rd_preamble; // Read Pre amble -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_RD_PREAMBLE, &i_target, rd_preamble);
+    	if(rc) return rc;
+    	uint8_t wr_preamble; // Write Pre amble -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_WR_PREAMBLE, &i_target, wr_preamble);
+    	if(rc) return rc;
+
+    	if ( max_pd_mode == ENUM_ATTR_EFF_MAX_POWERDOWN_MODE_ENABLE)
+    	{
+    	    max_pd_mode = 0xF0;
+    	}
+    	else if ( max_pd_mode == ENUM_ATTR_EFF_MAX_POWERDOWN_MODE_DISABLE)
+    	{
+    	    max_pd_mode = 0x00;
+    	}
+
+    	if (temp_ref_range == ENUM_ATTR_EFF_TEMP_REF_RANGE_NORMAL)
+    	{
+    	    temp_ref_range = 0x00;
+    	}
+    	else if ( temp_ref_range== ENUM_ATTR_EFF_TEMP_REF_RANGE_EXTEND)
+    	{
+    	    temp_ref_range = 0xFF;
+    	}
+
+    	if (temp_ref_mode == ENUM_ATTR_EFF_TEMP_REF_MODE_ENABLE)
+    	{
+    	    temp_ref_mode = 0x80;
+    	}
+    	else if (temp_ref_mode == ENUM_ATTR_EFF_TEMP_REF_MODE_DISABLE)
+    	{
+    	    temp_ref_mode = 0x00;
+    	}
+
+    	if ( vref_mon == ENUM_ATTR_EFF_INT_VREF_MON_ENABLE)
+    	{
+    	    vref_mon = 0xFF;
+    	}
+    	else if ( vref_mon == ENUM_ATTR_EFF_INT_VREF_MON_DISABLE)
+    	{
+    	    vref_mon = 0x00;
+    	}
+
+
+    	if ( cs_cmd_latency == 3)
+    	{
+    	    cs_cmd_latency = 0x80;
+    	}
+    	else if (cs_cmd_latency == 4)
+    	{
+    	    cs_cmd_latency = 0x40;
+    	}
+    	else if (cs_cmd_latency == 5)
+    	{
+    	    cs_cmd_latency = 0xC0;
+    	}
+    	else if (cs_cmd_latency == 6)
+    	{
+    	    cs_cmd_latency = 0x20;
+    	}
+    	else if (cs_cmd_latency == 8)
+    	{
+    	    cs_cmd_latency = 0xA0;
+    	}
+
+    	if (ref_abort == ENUM_ATTR_EFF_SELF_REF_ABORT_ENABLE)
+    	{
+    	    ref_abort = 0xFF;
+    	}
+    	else if (ref_abort == ENUM_ATTR_EFF_SELF_REF_ABORT_DISABLE)
+    	{
+    	    ref_abort = 0x00;
+    	}
+
+    	if (rd_pre_train_mode == ENUM_ATTR_EFF_RD_PREAMBLE_TRAIN_ENABLE)
+    	{
+    	    rd_pre_train_mode = 0xFF;
+    	}
+    	else if (rd_pre_train_mode == ENUM_ATTR_EFF_RD_PREAMBLE_TRAIN_DISABLE)
+    	{
+    	    rd_pre_train_mode = 0x00;
+    	}
+
+    	if (rd_preamble == ENUM_ATTR_EFF_RD_PREAMBLE_1NCLK)
+    	{
+    	    rd_preamble = 0x00;
+    	}
+    	else if (rd_preamble == ENUM_ATTR_EFF_RD_PREAMBLE_2NCLK)
+    	{
+    	    rd_preamble = 0xFF;
+    	}
+
+    	if (wr_preamble == ENUM_ATTR_EFF_WR_PREAMBLE_1NCLK)
+    	{
+    	    wr_preamble = 0x00;
+    	}
+    	else if (wr_preamble == ENUM_ATTR_EFF_WR_PREAMBLE_2NCLK)
+    	{
+    	    wr_preamble = 0xFF;
+    	}
+    	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 0, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) max_pd_mode, 1, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) temp_ref_range, 2, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) temp_ref_mode, 3, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) vref_mon, 4, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 5, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) cs_cmd_latency, 6, 3);
+    	rc_num = rc_num | address_16.insert((uint8_t) ref_abort, 9, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) rd_pre_train_mode, 10, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) rd_preamble, 11, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) wr_preamble, 12, 1);
+	
+	rc_num = rc_num | bank_3.insert((uint8_t) MRS4_BA, 0, 1, 7);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS4_BA, 1, 1, 6);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS4_BA, 2, 1, 5);
+	if (rc_num)
+        {
+            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
+            rc.setEcmdError(rc_num);
+            return rc;
+        }
+    }
+    //MRS5
+    else if(MRS == MRS5_BA) {
+    	uint8_t ca_parity_latency; //C/A Parity Latency Mode  -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_CA_PARITY_LATENCY , &i_target, ca_parity_latency);
+    	if(rc) return rc;
+    	uint8_t crc_error_clear; //CRC Error Clear  -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_CRC_ERROR_CLEAR , &i_target, crc_error_clear);
+    	if(rc) return rc;
+    	uint8_t ca_parity_error_status; //C/A Parity Error Status  -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_CA_PARITY_ERROR_STATUS , &i_target, ca_parity_error_status);
+    	if(rc) return rc;
+    	uint8_t odt_input_buffer; //ODT Input Buffer during power down  -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_ODT_INPUT_BUFF , &i_target, odt_input_buffer);
+    	if(rc) return rc;
+    	uint8_t rtt_park[2][2][4]; //RTT_Park value  -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_RTT_PARK , &i_target, rtt_park);
+    	if(rc) return rc;
+    	uint8_t ca_parity; //CA Parity Persistance Error  -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_CA_PARITY , &i_target, ca_parity);
+    	if(rc) return rc;
+    	uint8_t data_mask; //Data Mask  -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_DATA_MASK , &i_target, data_mask);
+    	if(rc) return rc;
+    	uint8_t write_dbi; //Write DBI  -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_WRITE_DBI , &i_target, write_dbi);
+    	if(rc) return rc;
+    	uint8_t read_dbi; //Read DBI  -  NEW
+    	rc = FAPI_ATTR_GET(ATTR_EFF_READ_DBI , &i_target, read_dbi);
+    	if(rc) return rc;
+
+
+    	if (ca_parity_latency == 4)
+    	{
+    	    ca_parity_latency = 0x80;
+    	}
+    	else if (ca_parity_latency == 5)
+    	{
+    	    ca_parity_latency = 0x40;
+    	}
+    	else if (ca_parity_latency == 6)
+    	{
+    	    ca_parity_latency = 0xC0;
+    	}
+    	else if (ca_parity_latency == 8)
+    	{
+    	    ca_parity_latency = 0x20;
+    	}
+    	else if (ca_parity_latency == ENUM_ATTR_EFF_CA_PARITY_LATENCY_DISABLE)
+    	{
+    	    ca_parity_latency = 0x00;
+    	}
+
+    	if (crc_error_clear == ENUM_ATTR_EFF_CRC_ERROR_CLEAR_ERROR)
+    	{
+    	    crc_error_clear = 0xFF;
+    	}
+    	else if (crc_error_clear == ENUM_ATTR_EFF_CRC_ERROR_CLEAR_CLEAR)
+    	{
+    	    crc_error_clear = 0x00;
+    	}
+
+    	if (ca_parity_error_status == ENUM_ATTR_EFF_CA_PARITY_ERROR_STATUS_ERROR)
+    	{
+    	    ca_parity_error_status = 0xFF;
+    	}
+    	else if (ca_parity_error_status == ENUM_ATTR_EFF_CA_PARITY_ERROR_STATUS_CLEAR)
+    	{
+    	    ca_parity_error_status = 0x00;
+    	}
+
+    	if (odt_input_buffer == ENUM_ATTR_EFF_ODT_INPUT_BUFF_ACTIVATED)
+    	{
+    	    odt_input_buffer = 0x00;
+    	}
+    	else if (odt_input_buffer == ENUM_ATTR_EFF_ODT_INPUT_BUFF_DEACTIVATED)
+    	{
+    	    odt_input_buffer = 0xFF;
+    	}
+
+
+    	if (ca_parity == ENUM_ATTR_EFF_CA_PARITY_ENABLE)
+    	{
+    	    ca_parity = 0xFF;
+    	}
+    	else if (ca_parity == ENUM_ATTR_EFF_CA_PARITY_DISABLE)
+    	{
+    	    ca_parity = 0x00;
+    	}
+
+    	if (data_mask == ENUM_ATTR_EFF_DATA_MASK_DISABLE)
+    	{
+    	    data_mask = 0x00;
+    	}
+    	else if (data_mask == ENUM_ATTR_EFF_DATA_MASK_ENABLE)
+    	{
+    	    data_mask = 0xFF;
+    	}
+
+    	if (write_dbi == ENUM_ATTR_EFF_WRITE_DBI_DISABLE)
+    	{
+    	    write_dbi = 0x00;
+    	}
+    	else if (write_dbi == ENUM_ATTR_EFF_WRITE_DBI_ENABLE)
+    	{
+    	    write_dbi = 0xFF;
+    	}
+
+    	if (read_dbi == ENUM_ATTR_EFF_READ_DBI_DISABLE)
+    	{
+    	    read_dbi = 0x00;
+    	}
+    	else if (read_dbi == ENUM_ATTR_EFF_READ_DBI_ENABLE)
+    	{
+    	    read_dbi = 0xFF;
+    	}
+    	if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_DISABLE)
+    	{
+    	    rtt_park[i_port_number][dimm_number][rank_number] = 0x00;
+    	}
+    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_60OHM)
+    	{
+    	    rtt_park[i_port_number][dimm_number][rank_number] = 0x80;
+    	}
+    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_40OHM)
+    	{
+    	    rtt_park[i_port_number][dimm_number][rank_number] = 0xC0;
+    	}
+    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_120OHM)
+    	{
+    	    rtt_park[i_port_number][dimm_number][rank_number] = 0x40;
+    	}
+    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_240OHM)
+    	{
+    	    rtt_park[i_port_number][dimm_number][rank_number] = 0x20;
+    	}
+    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_48OHM)
+    	{
+    	    rtt_park[i_port_number][dimm_number][rank_number] = 0xA0;
+    	}
+    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_80OHM)
+    	{
+    	    rtt_park[i_port_number][dimm_number][rank_number] = 0x60;
+    	}
+    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_34OHM)
+    	{
+    	    rtt_park[i_port_number][dimm_number][rank_number] = 0xE0;
+    	}
+
+    	rc_num = rc_num | address_16.insert((uint8_t) ca_parity_latency, 0, 2);
+    	rc_num = rc_num | address_16.insert((uint8_t) crc_error_clear, 3, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) ca_parity_error_status, 4, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) odt_input_buffer, 5, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) rtt_park[i_port_number][dimm_number][rank_number], 6, 3);
+    	rc_num = rc_num | address_16.insert((uint8_t) ca_parity, 9, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) data_mask, 10, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) write_dbi, 11, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) read_dbi, 12, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 13, 2);
+	
+	rc_num = rc_num | bank_3.insert((uint8_t) MRS5_BA, 0, 1, 7);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS5_BA, 1, 1, 6);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS5_BA, 2, 1, 5);
+	if (rc_num)
+        {
+            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
+            rc.setEcmdError(rc_num);
+            return rc;
+        }
+    }
+    //MRS6
+    else if(MRS == MRS6_BA) {
+    	uint8_t vrefdq_train_value[2][2][4]; //vrefdq_train value   -  NEW
+    	rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_VALUE, &i_target, vrefdq_train_value);
+    	if(rc) return rc;
+    	uint8_t vrefdq_train_range[2][2][4]; //vrefdq_train range   -  NEW
+    	rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_RANGE, &i_target, vrefdq_train_range);
+    	if(rc) return rc;
+    	uint8_t vrefdq_train_enable[2][2][4]; //vrefdq_train enable  -  NEW
+    	rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target, vrefdq_train_enable);
+    	if(rc) return rc;
+    	uint8_t tccd_l; //tccd_l  -  NEW
+    	rc = FAPI_ATTR_GET( ATTR_TCCD_L, &i_target, tccd_l);
+    	if(rc) return rc;
+    	if (tccd_l == 4)
+    	{
+    	    tccd_l = 0x00;
+    	}
+    	else if (tccd_l == 5)
+    	{
+    	    tccd_l = 0x80;
+    	}
+    	else if (tccd_l == 6)
+    	{
+    	    tccd_l = 0x40;
+    	}    
+    	else if (tccd_l == 7)
+    	{
+    	    tccd_l = 0xC0;
+    	}
+    	else if (tccd_l == 8)
+    	{
+    	    tccd_l = 0x20;
+    	}
+
+    	vrefdq_train_value[i_port_number][dimm_number][rank_number] = mss_reverse_8bits(vrefdq_train_value[i_port_number][dimm_number][rank_number]);
+
+    	if (vrefdq_train_range[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_VREF_DQ_TRAIN_RANGE_RANGE1)
+    	{
+    	    vrefdq_train_range[i_port_number][dimm_number][rank_number] = 0x00;
+    	}
+    	else if (vrefdq_train_range[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_VREF_DQ_TRAIN_RANGE_RANGE2)
+    	{
+    	    vrefdq_train_range[i_port_number][dimm_number][rank_number] = 0xFF;
+    	}   
+
+    	if (vrefdq_train_enable[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE)
+    	{
+    	    vrefdq_train_enable[i_port_number][dimm_number][rank_number] = 0xFF;
+    	}
+    	else if (vrefdq_train_enable[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_DISABLE)
+    	{
+    	    vrefdq_train_enable[i_port_number][dimm_number][rank_number] = 0x00;
+    	}   
+
+    	rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_value[i_port_number][dimm_number][rank_number], 0, 6);
+    	rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_range[i_port_number][dimm_number][rank_number], 6, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_enable[i_port_number][dimm_number][rank_number], 7, 1);
+    	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 8, 2);
+    	rc_num = rc_num | address_16.insert((uint8_t) tccd_l, 10, 3);
+    	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 13, 2);
+	
+	rc_num = rc_num | bank_3.insert((uint8_t) MRS6_BA, 0, 1, 7);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS6_BA, 1, 1, 6);
+        rc_num = rc_num | bank_3.insert((uint8_t) MRS6_BA, 2, 1, 5);
+	if (rc_num)
+        {
+            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
+            rc.setEcmdError(rc_num);
+            return rc;
+        }
+    }
+    else {
+        const uint32_t MRS_VALUE = MRS;
+	const fapi::Target & MBA_TARGET = i_target; 
+	FAPI_SET_HWP_ERROR(rc, RC_MSS_PDA_MRS_NOT_FOUND);
+	FAPI_ERR("ERROR!! Found attribute name not associated with an MRS! Exiting...");
+    }
+    
+    return rc;
+}
+
 //#endif
 
 
diff --git a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_pda.C b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_pda.C
index 95627c3..a618d37 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_pda.C
+++ b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_pda.C
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_ddr4_pda.C,v 1.44 2015/10/23 15:11:24 sglancy Exp $
+// $Id: mss_ddr4_pda.C,v 1.50 2016/02/12 19:45:52 sglancy Exp $
 //------------------------------------------------------------------------------
 // *! (C) Copyright International Business Machines Corp. 2013
 // *! All Rights Reserved -- Property of IBM
@@ -42,6 +42,11 @@
 //------------------------------------------------------------------------------
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|-----------------------------------------------
+//  1.15   | 02/12/16 | sglancy | Addressed FW comments
+//  1.15   | 02/03/16 | sglancy | Fixed FW compile issues
+//  1.15   | 01/11/16 | sglancy | Fixed issue with PDA timings
+//  1.15   | 11/09/15 | sglancy | Patch to fix cronus compile issue
+//  1.14   | 11/03/15 | sglancy | Fixed attribute names for DDR4 RDIMM
 //  1.13   | 10/23/15 | sglancy | Changed attribute names
 //  1.12   | 10/21/15 | sglancy | Changed attribute names
 //  1.11   | 07/23/15 | sglancy | Changed code to address FW comments
@@ -63,6 +68,7 @@
 #include <fapi.H>
 #include <mss_ddr4_pda.H>
 #include <mss_funcs.H>
+#include <mss_ddr4_funcs.H>
 #include <cen_scom_addresses.H>
 #include <mss_access_delay_reg.H>
 #include <vector>
@@ -146,7 +152,17 @@ ReturnCode PDA_MRS_Storage::checkPDAValid(Target& i_target) {
    
    //now checks based upon attributes
    uint8_t num_ranks[2][2];
-   rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM,&i_target,num_ranks); 
+   uint8_t dram_stack[2][2];
+   rc = FAPI_ATTR_GET(ATTR_EFF_STACK_TYPE, &i_target, dram_stack);
+   if(rc) return rc;
+   //get num master ranks per dimm for 3DS
+   if(dram_stack[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+      rc = FAPI_ATTR_GET(ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, &i_target, num_ranks);
+   }
+   //get num ranks per dimm for non-3DS
+   else {
+      rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target, num_ranks);
+   }
    if(rc) return rc;
    
    //no ranks on the selected dimm
@@ -411,12 +427,14 @@ ReturnCode mss_ddr4_checksort_pda(Target& i_target, vector<PDA_MRS_Storage>& pda
 /////////////////////////////////////////////////////////////////////////////////
 ReturnCode mss_ddr4_setup_pda(
             Target& i_target,
-            uint32_t& io_ccs_inst_cnt
+            uint32_t& io_ccs_inst_cnt,
+	    uint8_t dimm_to_run,
+	    uint8_t rank_to_run
             )
 {
     uint32_t i_port_number=0;
-    uint32_t dimm_number;
-    uint32_t rank_number;
+    uint32_t dimm_number = dimm_to_run;
+    uint32_t rank_number = rank_to_run;
     const uint32_t NUM_POLL = 10;
     const uint32_t WAIT_TIMER = 1500;
     ReturnCode rc;  
@@ -451,12 +469,26 @@ ReturnCode mss_ddr4_setup_pda(
     
     uint8_t num_ranks_array[2][2]; //[port][dimm]
     
+    uint8_t dram_stack[2][2];
+    rc = FAPI_ATTR_GET(ATTR_EFF_STACK_TYPE, &i_target, dram_stack);
+    if(rc) return rc;
+    
     uint8_t dimm_type;
     rc = FAPI_ATTR_GET(ATTR_EFF_DIMM_TYPE, &i_target, dimm_type);
     if(rc) return rc;
     
-    uint8_t num_ranks;
-    rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target, num_ranks_array);
+    uint8_t dram_gen;
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_GEN, &i_target, dram_gen);
+    if(rc) return rc;
+    
+    //get num master ranks per dimm for 3DS
+    if(dram_stack[dimm_to_run][rank_to_run] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+       rc = FAPI_ATTR_GET(ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, &i_target, num_ranks_array);
+    }
+    //get num ranks per dimm for non-3DS
+    else {
+       rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target, num_ranks_array);
+    }
     if(rc) return rc;
 
     uint8_t is_sim = 0;
@@ -464,7 +496,7 @@ ReturnCode mss_ddr4_setup_pda(
     if(rc) return rc;
 
     uint8_t address_mirror_map[2][2]; //address_mirror_map[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
     if(rc) return rc;
 
     // WORKAROUNDS 
@@ -472,6 +504,10 @@ ReturnCode mss_ddr4_setup_pda(
     if(rc) return rc;
     //Setting up CCS mode
     rc_num = rc_num | data_buffer.setBit(51);
+    //if in DDR4 mode, count the parity bit and set it
+    if((dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR4) && (dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM || dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_RDIMM) ) {
+       rc_num = rc_num | data_buffer.insertFromRight( (uint8_t)0xff, 61, 1);
+    }
     
     if (rc_num)
     {
@@ -488,6 +524,11 @@ ReturnCode mss_ddr4_setup_pda(
        // Raise CKE high with NOPS, waiting min Reset CKE exit time (tXPR) - 400 cycles
        rc_num = rc_num | cke_4.setBit(0,4);
        rc_num = rc_num | csn_8.setBit(0,8);
+       
+       if(dram_stack[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+          rc_num = rc_num | csn_8.clearBit(2,2); 
+          rc_num = rc_num | csn_8.clearBit(6,2); 
+       }
        rc_num = rc_num | address_16.clearBit(0, 16);
        rc_num = rc_num | odt_4.clearBit(0,4);
        rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 400, 0, 16);
@@ -525,6 +566,15 @@ ReturnCode mss_ddr4_setup_pda(
        io_ccs_inst_cnt ++;
     }
     
+    //Does the RTT_WR to RTT_NOM swapping
+    //loops through all ports
+    for(i_port_number=0;i_port_number<MAX_NUM_PORTS;i_port_number++) {
+       uint8_t io_dram_rtt_nom_original = 0xff;
+       rc = mss_ddr4_rtt_nom_rtt_wr_swap(i_target,0,i_port_number,rank_to_run+dimm_to_run*4,0xFF,io_ccs_inst_cnt,io_dram_rtt_nom_original);
+       if(rc) return rc;
+       io_ccs_inst_cnt = 0;
+    }
+    
     
     //Sets up MRS3 -> the MRS that has PDA
     uint8_t mpr_op; // MPR Op
@@ -552,152 +602,145 @@ ReturnCode mss_ddr4_setup_pda(
     //enables PDA mode
     //loops through all ports
     for(i_port_number=0;i_port_number<MAX_NUM_PORTS;i_port_number++) {
-    	// Dimm 0-1
-    	for ( dimm_number = 0; dimm_number < MAX_NUM_DIMMS; dimm_number++)
-    	{
-    	    num_ranks = num_ranks_array[i_port_number][dimm_number];
+    	
+       // Only corresponding CS to rank
+       rc_num = rc_num | csn_8.setBit(0,8); 
+       if(dram_stack[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+          rc_num = rc_num | csn_8.clearBit(2,2); 
+          rc_num = rc_num | csn_8.clearBit(6,2); 
+       }
+       rc_num = rc_num | csn_8.clearBit(rank_number+4*dimm_number);
+    
+       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 0, 1, 7);
+       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 1, 1, 6);
+       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 2, 1, 5);
+    
+       //sets up MRS3 ecmd buffer
+       rc_num = rc_num | mrs3.insert((uint8_t) mpr_page, 0, 2);
+       rc_num = rc_num | mrs3.insert((uint8_t) mpr_op, 2, 1);
+       rc_num = rc_num | mrs3.insert((uint8_t) geardown_mode, 3, 1);
+       rc_num = rc_num | mrs3.insert((uint8_t) 0xff, 4, 1); //enables PDA mode!!!!
+       rc_num = rc_num | mrs3.insert((uint8_t) temp_readout, 5, 1);
+       rc_num = rc_num | mrs3.insert((uint8_t) fine_refresh, 6, 3);
+       rc_num = rc_num | mrs3.insert((uint8_t) wr_latency, 9, 2);
+       rc_num = rc_num | mrs3.insert((uint8_t) read_format, 11, 2);
+       rc_num = rc_num | mrs3.insert((uint8_t) 0x00, 13, 2);
+       rc_num = rc_num | mrs3.extractPreserve(&MRS3, 0, 16, 0);
+       rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 24, 0, 16);
+       rc_num = rc_num | address_16.insert(mrs3, 0, 16, 0);
 
-    	    if (num_ranks == 0)
-    	    {
-    		FAPI_INF( "PORT%d DIMM%d not configured. Num_ranks: %d ", i_port_number, dimm_number, num_ranks);
-    	    }
-    	    else
-    	    {
-    		// Rank 0-3
-    		for ( rank_number = 0; rank_number < num_ranks; rank_number++)
-    		{
-    		   // Only corresponding CS to rank
-    		   rc_num = rc_num | csn_8.setBit(0,8); 
-    		   rc_num = rc_num | csn_8.clearBit(rank_number+4*dimm_number);
-    			
-    		   rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 0, 1, 7);
-    		   rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 1, 1, 6);
-    		   rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 2, 1, 5);
-    		   
-		   //sets up MRS3 ecmd buffer
-	           rc_num = rc_num | mrs3.insert((uint8_t) mpr_page, 0, 2);
-	           rc_num = rc_num | mrs3.insert((uint8_t) mpr_op, 2, 1);
-	           rc_num = rc_num | mrs3.insert((uint8_t) geardown_mode, 3, 1);
-	           rc_num = rc_num | mrs3.insert((uint8_t) 0xff, 4, 1); //enables PDA mode!!!!
-	           rc_num = rc_num | mrs3.insert((uint8_t) temp_readout, 5, 1);
-	           rc_num = rc_num | mrs3.insert((uint8_t) fine_refresh, 6, 3);
-	           rc_num = rc_num | mrs3.insert((uint8_t) wr_latency, 9, 2);
-	           rc_num = rc_num | mrs3.insert((uint8_t) read_format, 11, 2);
-	           rc_num = rc_num | mrs3.insert((uint8_t) 0x00, 13, 2);
-	           rc_num = rc_num | mrs3.extractPreserve(&MRS3, 0, 16, 0);
-	           rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 24, 0, 16);
-		   rc_num = rc_num | address_16.insert(mrs3, 0, 16, 0);
-		   
-    		   if (rc_num)
-    		   {
-    		       FAPI_ERR( "mss_ddr4_setup_pda: Error setting up buffers");
-    		       rc_buff.setEcmdError(rc_num);
-    		       return rc_buff;
-    		   }
-    		   
-	           
-    		   if (( address_mirror_map[i_port_number][dimm_number] & (0x08 >> rank_number) ) && (is_sim == 0))
-    		   {
-    		      rc = mss_address_mirror_swizzle(i_target, i_port_number, dimm_number, rank_number, address_16, bank_3);
-    		      if(rc) return rc;
-    		   }
-    		   
-    		   
-    		   // Send out to the CCS array 
-    		   rc = mss_ccs_inst_arry_0( i_target,
-    				     io_ccs_inst_cnt,
-    				     address_16,
-    				     bank_3,
-    				     activate_1,
-    				     rasn_1,
-    				     casn_1,
-    				     wen_1,
-    				     cke_4,
-    				     csn_8,
-    				     odt_4,
-    				     ddr_cal_type_4,
-    				     i_port_number);
-    		   if(rc) return rc;
-    		   rc = mss_ccs_inst_arry_1( i_target,
-    				     io_ccs_inst_cnt,
-    				     num_idles_16,
-    				     num_repeat_16,
-    				     data_20,
-    				     read_compare_1,
-    				     rank_cal_4,
-    				     ddr_cal_enable_1,
-    				     ccs_end_1);
-    		   if(rc) return rc;
-    		   io_ccs_inst_cnt ++;
-		   
-		   //if the DIMM is an R or LR DIMM, then run inverted for the B-Side DRAM
-                    if ( (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_RDIMM) || (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) ) 
-                    {
-		       //reload all MRS values (removes address swizzling)
-		       // Only corresponding CS to rank
-    		       rc_num = rc_num | csn_8.setBit(0,8); 
-    		       rc_num = rc_num | csn_8.clearBit(rank_number+4*dimm_number);
-    		    	    
-    		       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 0, 1, 7);
-    		       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 1, 1, 6);
-    		       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 2, 1, 5);
-    		       
-		       //sets up MRS3 ecmd buffer
-		       rc_num = rc_num | address_16.insert(mrs3, 0, 16, 0);
-		       
-		       //FLIPS all necessary bits
-		       // Indicate B-Side DRAMS BG1=1 
-                       rc_num = rc_num | address_16.setBit(15);  // Set BG1 = 1
+       if (rc_num)
+       {
+           FAPI_ERR( "mss_ddr4_setup_pda: Error setting up buffers");
+           rc_buff.setEcmdError(rc_num);
+           return rc_buff;
+       }
+    
+
+       if (( address_mirror_map[i_port_number][dimm_number] & (0x08 >> rank_number) ) && (is_sim == 0))
+       {
+          rc = mss_address_mirror_swizzle(i_target, i_port_number, dimm_number, rank_number, address_16, bank_3);
+          if(rc) return rc;
+       }
+    
+    
+       // Send out to the CCS array 
+       rc = mss_ccs_inst_arry_0( i_target,
+    	    		 io_ccs_inst_cnt,
+    	    		 address_16,
+    	    		 bank_3,
+    	    		 activate_1,
+    	    		 rasn_1,
+    	    		 casn_1,
+    	    		 wen_1,
+    	    		 cke_4,
+    	    		 csn_8,
+    	    		 odt_4,
+    	    		 ddr_cal_type_4,
+    	    		 i_port_number);
+       if(rc) return rc;
+       rc = mss_ccs_inst_arry_1( i_target,
+    	    		 io_ccs_inst_cnt,
+    	    		 num_idles_16,
+    	    		 num_repeat_16,
+    	    		 data_20,
+    	    		 read_compare_1,
+    	    		 rank_cal_4,
+    	    		 ddr_cal_enable_1,
+    	    		 ccs_end_1);
+       if(rc) return rc;
+       io_ccs_inst_cnt ++;
+
+       //if the DIMM is an R or LR DIMM, then run inverted for the B-Side DRAM
+        if ( (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_RDIMM) || (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) ) 
+        {
+           //reload all MRS values (removes address swizzling)
+           // Only corresponding CS to rank
+           rc_num = rc_num | csn_8.setBit(0,8); 
+           if(dram_stack[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+              rc_num = rc_num | csn_8.clearBit(2,2); 
+              rc_num = rc_num | csn_8.clearBit(6,2); 
+           }
+           rc_num = rc_num | csn_8.clearBit(rank_number+4*dimm_number);
+        	
+           rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 0, 1, 7);
+           rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 1, 1, 6);
+           rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 2, 1, 5);
+           
+           //sets up MRS3 ecmd buffer
+           rc_num = rc_num | address_16.insert(mrs3, 0, 16, 0);
+           
+           //FLIPS all necessary bits
+           // Indicate B-Side DRAMS BG1=1 
+           rc_num = rc_num | address_16.setBit(15);  // Set BG1 = 1
  
-                       rc_num = rc_num | address_16.flipBit(3,7); // Invert A3:A9
-                       rc_num = rc_num | address_16.flipBit(11);  // Invert A11
-                       rc_num = rc_num | address_16.flipBit(13);  // Invert A13
-                       rc_num = rc_num | address_16.flipBit(14);  // Invert A17
-                       rc_num = rc_num | bank_3.flipBit(0,3);	  // Invert BA0,BA1,BG0
-		       
-		       if (rc_num)
-    		       {
-    		     	   FAPI_ERR( "mss_ddr4_setup_pda: Error setting up buffers");
-    		     	   rc_buff.setEcmdError(rc_num);
-    		     	   return rc_buff;
-    		       }
-		     	   
-		     	   if (( address_mirror_map[i_port_number][dimm_number] & (0x08 >> rank_number) ) && (is_sim == 0))
-    		       {
-    		     	  rc = mss_address_mirror_swizzle(i_target, i_port_number, dimm_number, rank_number, address_16, bank_3);
-    		     	  if(rc) return rc;
-    		       }
-    		       
-    		       // Send out to the CCS array 
-    		       rc = mss_ccs_inst_arry_0( i_target,
-    		     	 		 io_ccs_inst_cnt,
-    		     	 		 address_16,
-    		     	 		 bank_3,
-    		     	 		 activate_1,
-    		     	 		 rasn_1,
-    		     	 		 casn_1,
-    		     	 		 wen_1,
-    		     	 		 cke_4,
-    		     	 		 csn_8,
-    		     	 		 odt_4,
-    		     	 		 ddr_cal_type_4,
-    		     	 		 i_port_number);
-    		       if(rc) return rc;
-    		       rc = mss_ccs_inst_arry_1( i_target,
-    		     	 		 io_ccs_inst_cnt,
-    		     	 		 num_idles_16,
-    		     	 		 num_repeat_16,
-    		     	 		 data_20,
-    		     	 		 read_compare_1,
-    		     	 		 rank_cal_4,
-    		     	 		 ddr_cal_enable_1,
-    		     	 		 ccs_end_1);
-    		       if(rc) return rc;
-    		       io_ccs_inst_cnt ++;
-		    }
-    		}    
-    	    }
-    	}
+           rc_num = rc_num | address_16.flipBit(3,7); // Invert A3:A9
+           rc_num = rc_num | address_16.flipBit(11);  // Invert A11
+           rc_num = rc_num | address_16.flipBit(13);  // Invert A13
+           rc_num = rc_num | address_16.flipBit(14);  // Invert A17
+           rc_num = rc_num | bank_3.flipBit(0,3);     // Invert BA0,BA1,BG0
+           
+           if (rc_num)
+           {
+               FAPI_ERR( "mss_ddr4_setup_pda: Error setting up buffers");
+               rc_buff.setEcmdError(rc_num);
+               return rc_buff;
+           }
+               
+               if (( address_mirror_map[i_port_number][dimm_number] & (0x08 >> rank_number) ) && (is_sim == 0))
+           {
+              rc = mss_address_mirror_swizzle(i_target, i_port_number, dimm_number, rank_number, address_16, bank_3);
+              if(rc) return rc;
+           }
+           
+           // Send out to the CCS array 
+           rc = mss_ccs_inst_arry_0( i_target,
+        		     io_ccs_inst_cnt,
+        		     address_16,
+        		     bank_3,
+        		     activate_1,
+        		     rasn_1,
+        		     casn_1,
+        		     wen_1,
+        		     cke_4,
+        		     csn_8,
+        		     odt_4,
+        		     ddr_cal_type_4,
+        		     i_port_number);
+           if(rc) return rc;
+           rc = mss_ccs_inst_arry_1( i_target,
+        		     io_ccs_inst_cnt,
+        		     num_idles_16,
+        		     num_repeat_16,
+        		     data_20,
+        		     read_compare_1,
+        		     rank_cal_4,
+        		     ddr_cal_enable_1,
+        		     ccs_end_1);
+           if(rc) return rc;
+           io_ccs_inst_cnt ++;
+        }
+    
     }
     
     //runs a NOP command for 24 cycle
@@ -758,6 +801,10 @@ ReturnCode mss_ddr4_setup_pda(
    rc_num |= data_buffer.setBit(52);    //RAS high
    rc_num |= data_buffer.setBit(53);    //CAS high
    rc_num |= data_buffer.setBit(54);    //WE high
+   //if in DDR4 mode, count the parity bit and set it
+    if((dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR4) && (dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM || dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_RDIMM) ) {
+       rc_num = rc_num | data_buffer.insertFromRight( (uint8_t)0xff, 61, 1);
+    }
    if (rc_num) {
       FAPI_ERR( "enable ccs setup: Error setting up buffers");
       rc.setEcmdError(rc_num);
@@ -791,10 +838,21 @@ ReturnCode mss_ddr4_setup_pda(
       }
    }
    
+   
+   //sets up the DRAM DQ drive time
+   uint8_t wl_launch_time;
+   uint8_t odt_hold_time;
+   uint8_t post_odt_nop_idle;
+   rc = mss_get_pda_odt_timings(i_target, wl_launch_time, odt_hold_time, post_odt_nop_idle);
+   if(rc) return rc;
+   wl_launch_time -= 7;
+   
    rc = fapiGetScom(i_target,  DPHY01_DDRPHY_WC_CONFIG3_P0_0x8000CC050301143F, data_buffer);
    if(rc) return rc;
    //Setting up CCS mode
    rc_num = rc_num | data_buffer.setBit(48);
+   rc_num = rc_num | data_buffer.insertFromRight((uint8_t)0x00,49,6);
+   rc_num = rc_num | data_buffer.insertFromRight((uint8_t)0xFF,55,6);
    if (rc_num)
    {
        FAPI_ERR( "mss_ddr4_setup_pda: Error setting up buffers");
@@ -808,6 +866,8 @@ ReturnCode mss_ddr4_setup_pda(
    if(rc) return rc;
    //Setting up CCS mode
    rc_num = rc_num | data_buffer.setBit(48);
+   rc_num = rc_num | data_buffer.insertFromRight((uint8_t)0x00,49,6);
+   rc_num = rc_num | data_buffer.insertFromRight((uint8_t)0xFF,55,6);
    if (rc_num)
    {
        FAPI_ERR( "mss_ddr4_setup_pda: Error setting up buffers");
@@ -833,10 +893,20 @@ ReturnCode mss_ddr4_pda(
     ReturnCode rc;
     uint8_t dram_loop_end;
     uint8_t dram_loop_end_with_spare;
-    
+    FAPI_INF("Commonly used PDA attributes: fapi::ATTR_EFF_VREF_DQ_TRAIN_ENABLE=0x%08x fapi::ATTR_EFF_VREF_DQ_TRAIN_VALUE=0x%08x",ATTR_EFF_VREF_DQ_TRAIN_ENABLE,ATTR_EFF_VREF_DQ_TRAIN_VALUE);
     //gets the rank information
     uint8_t num_ranks_array[2][2]; //[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target, num_ranks_array);
+    uint8_t dram_stack[2][2];
+    rc = FAPI_ATTR_GET(ATTR_EFF_STACK_TYPE, &i_target, dram_stack);
+    if(rc) return rc;
+    //get num master ranks per dimm for 3DS
+    if(dram_stack[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+       rc = FAPI_ATTR_GET(ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, &i_target, num_ranks_array);
+    }
+    //get num ranks per dimm for non-3DS
+    else {
+       rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target, num_ranks_array);
+    }
     if(rc) return rc;
     
     //gets the spare information
@@ -896,19 +966,63 @@ ReturnCode mss_ddr4_pda(
     return rc;
 }
 
-/////////////////////////////////////////////////////////////////////////////////
-/// mss_ddr4_run_pda
-/// runs per-DRAM addressability funcitonality on both ports on the passed MBA
-/////////////////////////////////////////////////////////////////////////////////
+//loops through and runs PDA on all MBA's
 ReturnCode mss_ddr4_run_pda(
             Target& i_target,
 	    vector<PDA_MRS_Storage> pda
+            ) {
+   ReturnCode rc;  
+   if(pda.size() == 0) return rc;
+   
+   
+   uint8_t num_ranks_array[2][2]; //[port][dimm]
+   
+   uint8_t dram_stack[2][2];
+   rc = FAPI_ATTR_GET(ATTR_EFF_STACK_TYPE, &i_target, dram_stack);
+   if(rc) return rc;
+   
+   if(dram_stack[0][0]  == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+      rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target, num_ranks_array);
+   }
+   else {
+      rc = FAPI_ATTR_GET(ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, &i_target, num_ranks_array);
+   }
+   if(rc) return rc;
+   
+   //loops through all DIMMs all Ranks
+   for(uint8_t dimm_to_run=0;dimm_to_run<2;dimm_to_run++) {
+      uint8_t largest_num_ranks = num_ranks_array[0][dimm_to_run];
+      if(largest_num_ranks < num_ranks_array[1][dimm_to_run]) largest_num_ranks = num_ranks_array[1][dimm_to_run];
+      
+      for(uint8_t rank_to_run=0;rank_to_run<largest_num_ranks;rank_to_run++) {
+         FAPI_INF("Running PDA on DIMM %d Rank %d!!",dimm_to_run, rank_to_run);
+         rc = mss_ddr4_run_pda_by_dimm_rank(i_target, pda, dimm_to_run, rank_to_run);
+	 if(rc) return rc;
+      }
+   }
+   
+   return rc;
+}
+
+
+/////////////////////////////////////////////////////////////////////////////////
+/// mss_ddr4_run_pda_by_dimm_rank
+/// runs per-DRAM addressability funcitonality on both ports on the passed MBA by dimm and rank
+/////////////////////////////////////////////////////////////////////////////////
+ReturnCode mss_ddr4_run_pda_by_dimm_rank(
+            Target& i_target,
+	    vector<PDA_MRS_Storage> pda,
+	    uint8_t dimm_to_run,
+	    uint8_t rank_to_run
             )
 {
     ReturnCode rc;  
     //no PDA was entered, just exit
     if(pda.size() == 0) return rc;
     
+    //DIMM/rank not found - exit
+    if(mss_ddr4_check_pda_empty_for_rank(pda,dimm_to_run,rank_to_run)) return rc;
+    
     uint32_t io_ccs_inst_cnt = 0;
     const uint32_t NUM_POLL = 10;
     const uint32_t WAIT_TIMER = 1500;
@@ -923,6 +1037,17 @@ ReturnCode mss_ddr4_run_pda(
     ecmdDataBufferBase rasn_1(1);
     ecmdDataBufferBase casn_1(1);
     ecmdDataBufferBase wen_1(1);
+    ecmdDataBufferBase rasn_1_odt(1);
+    ecmdDataBufferBase casn_1_odt(1);
+    ecmdDataBufferBase wen_1_odt(1);
+    ecmdDataBufferBase num_repeat_16_odt(16);
+    ecmdDataBufferBase num_idles_16_odt(16);
+    ecmdDataBufferBase csn_8_odt(8);
+    rc_num = rc_num | rasn_1_odt.clearBit(0,1);
+    rc_num = rc_num | casn_1_odt.clearBit(0,1);
+    rc_num = rc_num | wen_1_odt.clearBit(0,1);
+    rc_num = rc_num | csn_8_odt.setBit(0,8);
+    rc_num = rc_num | csn_8_odt.clearBit(7,1);
     ecmdDataBufferBase cke_4(4);
     rc_num = rc_num | cke_4.setBit(0,4);
     ecmdDataBufferBase csn_8(8);
@@ -956,8 +1081,8 @@ ReturnCode mss_ddr4_run_pda(
     
     ecmdDataBufferBase data_buffer(64);
     
-    uint8_t num_ranks_array[2][2]; //[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target, num_ranks_array);
+    uint8_t dram_stack[2][2];
+    rc = FAPI_ATTR_GET(ATTR_EFF_STACK_TYPE, &i_target, dram_stack);
     if(rc) return rc;
 
     uint8_t is_sim = 0;
@@ -965,40 +1090,76 @@ ReturnCode mss_ddr4_run_pda(
     if(rc) return rc;
 
     uint8_t address_mirror_map[2][2]; //address_mirror_map[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
     if(rc) return rc;
 
-    rc = mss_ddr4_setup_pda(i_target, io_ccs_inst_cnt );
-    if(rc)  return rc;
-    
-    rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 100, 0, 16);
+   rc = mss_ddr4_setup_pda(i_target, io_ccs_inst_cnt, dimm_to_run,rank_to_run );
+   if(rc) return rc;
    
+   uint8_t wl_launch_time;
+   uint8_t odt_hold_time;
+   uint8_t post_odt_nop_idle;
+   rc = mss_get_pda_odt_timings(i_target, wl_launch_time, odt_hold_time, post_odt_nop_idle);
    
+   rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 0, 0, 16);
+   rc_num = rc_num | num_repeat_16.insertFromRight((uint32_t) 0, 0, 16);
    
-    rc_num = rc_num | cke_4.setBit(0,4);
-    rc_num = rc_num | csn_8.setBit(0,8);
-    rc_num = rc_num | address_16.clearBit(0, 16);
-    rc_num = rc_num | odt_4.clearBit(0,4);
-    rc_num = rc_num | rasn_1.clearBit(0,1);
-    rc_num = rc_num | casn_1.clearBit(0,1);
-    rc_num = rc_num | wen_1.clearBit(0,1);
+   rc_num = rc_num | num_idles_16_odt.insertFromRight( post_odt_nop_idle, 0, 8);
+   rc_num = rc_num | num_repeat_16_odt.insertFromRight( odt_hold_time, 0, 8);
    
-   //gets the start PDA values
-   uint8_t prev_dram = pda[0].dram;
-   uint8_t prev_port = pda[0].port;
-   uint8_t prev_rank = pda[0].rank;
-   uint8_t prev_dimm = pda[0].dimm;
-   uint8_t prev_mrs  = pda[0].MRS;
-   rc = mss_ddr4_load_nominal_mrs_pda(i_target,bank_3,address_16, prev_mrs, prev_port, prev_dimm, prev_rank);
-   if(rc) return rc;
    
-   vector<PDA_Scom_Storage> scom_storage;
-   scom_storage.clear();
-   rc = mss_ddr4_add_dram_pda(i_target,prev_port,prev_dram,scom_storage);
+   
+   rc_num = rc_num | cke_4.setBit(0,4);
+   rc_num = rc_num | csn_8.setBit(0,8);
+   rc_num = rc_num | address_16.clearBit(0, 16);
+   rc_num = rc_num | odt_4.clearBit(0,4);
+   rc_num = rc_num | rasn_1.clearBit(0,1);
+   rc_num = rc_num | casn_1.clearBit(0,1);
+   rc_num = rc_num | wen_1.clearBit(0,1);
+   
+   if(rc_num)
+   {
+       rc.setEcmdError(rc_num);
+       return rc;
+   }
+   
+   uint8_t odt_wr[2][2][4];
+   rc = FAPI_ATTR_GET(ATTR_VPD_ODT_WR,  &i_target, odt_wr);
    if(rc) return rc;
    
+   bool prev_dram_set = false;
+   vector<PDA_Scom_Storage> scom_storage;
+   uint8_t prev_dram = 0;
+   uint8_t prev_port = 0;
+   uint8_t prev_rank = 0;
+   uint8_t prev_dimm = 0;
+   uint8_t prev_mrs  = 0;
+
    //runs through each PDA command
    for(uint32_t i=0;i<pda.size();i++) {
+      //did not find a PDA with the same DIMM and rank as requested
+      if(pda[i].rank != rank_to_run || pda[i].dimm != dimm_to_run) {
+         continue;
+      }
+      
+      //found a PDA of the same dimm and rank, but storage not set
+      if(!prev_dram_set) {
+         //gets the start PDA values
+         prev_dram = pda[i].dram;
+         prev_port = pda[i].port;
+         prev_rank = pda[i].rank;
+         prev_dimm = pda[i].dimm;
+         prev_mrs  = pda[i].MRS;
+	 prev_dram_set = true;
+	 
+         rc = mss_ddr4_load_nominal_mrs_pda(i_target,bank_3,address_16, prev_mrs, prev_port, prev_dimm, prev_rank);
+         if(rc) return rc;
+	 
+	 scom_storage.clear();
+	 rc = mss_ddr4_add_dram_pda(i_target,prev_port,prev_dram,scom_storage);
+	 if(rc) return rc;
+      }
+   
       FAPI_INF("Target %s On PDA %d is %s",i_target.toEcmdString(),i,pda[i].c_str());
       //dram, port, rank, dimm, and mrs are the same
       if(prev_dram == pda[i].dram && prev_port == pda[i].port && prev_rank == pda[i].rank && prev_dimm == pda[i].dimm && prev_mrs == pda[i].MRS) {
@@ -1024,6 +1185,16 @@ ReturnCode mss_ddr4_run_pda(
    	 rc_num = rc_num | csn_8.setBit(0,8); 
    	 rc_num = rc_num | csn_8.clearBit(prev_rank+4*prev_dimm);
 	 
+         if(dram_stack[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+            rc_num = rc_num | csn_8.clearBit(2,2); 
+            rc_num = rc_num | csn_8.clearBit(6,2); 
+         }
+	 rc_num = rc_num | odt_4.insert(odt_wr[prev_port][prev_dimm][prev_rank], 0, 4, 0);
+	 if(rc_num)
+    	 {
+    	     rc.setEcmdError(rc_num);
+    	     return rc;
+    	 }
    	 // Send out to the CCS array 
    	 rc = mss_ccs_inst_arry_0( i_target,
    	     	  io_ccs_inst_cnt,
@@ -1051,6 +1222,33 @@ ReturnCode mss_ddr4_run_pda(
    	 if(rc) return rc;
    	 io_ccs_inst_cnt ++;
 	 
+	 // Send out to the CCS array 
+   	 rc = mss_ccs_inst_arry_0( i_target,
+   	     	  io_ccs_inst_cnt,
+   	     	  address_16,
+   	     	  bank_3,
+   	     	  activate_1,
+   	     	  rasn_1_odt,
+   	     	  casn_1_odt,
+   	     	  wen_1_odt,
+   	     	  cke_4,
+   	     	  csn_8_odt,
+   	     	  odt_4,
+   	     	  ddr_cal_type_4,
+   	     	  prev_port);
+   	 if(rc) return rc;
+   	 rc = mss_ccs_inst_arry_1( i_target,
+   	     	  io_ccs_inst_cnt,
+   	     	  num_idles_16_odt,
+   	     	  num_repeat_16_odt,
+   	     	  data_20,
+   	     	  read_compare_1,
+   	     	  rank_cal_4,
+   	     	  ddr_cal_enable_1,
+   	     	  ccs_end_1);
+   	 if(rc) return rc;
+   	 io_ccs_inst_cnt ++;
+	 
 	 //is an R or LR DIMM -> do a B side MRS write
 	 if ( (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_RDIMM) || (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) ) {
 	    //takes values from the backup
@@ -1078,6 +1276,17 @@ ReturnCode mss_ddr4_run_pda(
    	    rc_num = rc_num | csn_8.setBit(0,8); 
    	    rc_num = rc_num | csn_8.clearBit(prev_rank+4*prev_dimm);
 	    
+            if(dram_stack[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+               rc_num = rc_num | csn_8.clearBit(2,2); 
+               rc_num = rc_num | csn_8.clearBit(6,2); 
+            }
+	    rc_num = rc_num | odt_4.insert(odt_wr[prev_port][prev_dimm][prev_rank], 0, 4, 0);
+	    if(rc_num)
+    	    {
+    	        rc.setEcmdError(rc_num);
+    	        return rc;
+    	    }
+	    
    	    // Send out to the CCS array 
    	    rc = mss_ccs_inst_arry_0( i_target,
    	   	     io_ccs_inst_cnt,
@@ -1104,7 +1313,34 @@ ReturnCode mss_ddr4_run_pda(
    	   	     ccs_end_1);
    	    if(rc) return rc;
    	    io_ccs_inst_cnt ++;
-	 }
+	    
+	    // Send out to the CCS array 
+            rc = mss_ccs_inst_arry_0( i_target,
+            	     io_ccs_inst_cnt,
+            	     address_16,
+            	     bank_3,
+            	     activate_1,
+            	     rasn_1_odt,
+            	     casn_1_odt,
+            	     wen_1_odt,
+            	     cke_4,
+            	     csn_8_odt,
+            	     odt_4,
+            	     ddr_cal_type_4,
+            	     prev_port);
+            if(rc) return rc;
+            rc = mss_ccs_inst_arry_1( i_target,
+            	     io_ccs_inst_cnt,
+            	     num_idles_16_odt,
+            	     num_repeat_16_odt,
+            	     data_20,
+            	     read_compare_1,
+            	     rank_cal_4,
+            	     ddr_cal_enable_1,
+            	     ccs_end_1);
+            if(rc) return rc;
+            io_ccs_inst_cnt ++;
+         }
 	 
 	 //the DRAM are different, so kick off CCS, and clear out the MRS DRAMs and set up a new DRAM
 	 if(prev_dram != pda[i].dram) {
@@ -1115,6 +1351,13 @@ ReturnCode mss_ddr4_run_pda(
     	    rc_num = rc_num | rasn_1.setBit(0,1);
     	    rc_num = rc_num | casn_1.setBit(0,1);
     	    rc_num = rc_num | wen_1.setBit(0,1);
+	    rc_num = rc_num | odt_4.insert((uint8_t) 0, 0, 4, 0);
+	    
+	    if(rc_num)
+    	    {
+    	        rc.setEcmdError(rc_num);
+    	        return rc;
+    	    }
 	    
 	    // Send out to the CCS array 
             rc = mss_ccs_inst_arry_0( i_target,
@@ -1227,76 +1470,35 @@ ReturnCode mss_ddr4_run_pda(
       } 
    }      
    
-   //runs the last PDA command
-   //adds values to a backup address_16 before doing the mirroring
-   address_16_backup.clearBit(0, 16);
-   rc_num = rc_num | address_16_backup.insert(address_16, 0, 16, 0);
-
-   //loads the previous DRAM
-   if (( address_mirror_map[prev_port][prev_dimm] & (0x08 >> prev_rank) ) && (is_sim == 0))
-   {
-       rc = mss_address_mirror_swizzle(i_target, prev_port, prev_dimm, prev_rank, address_16, bank_3);
-       if(rc) return rc;
-   }
-
-   // Only corresponding CS to rank
-   rc_num = rc_num | csn_8.setBit(0,8); 
-   rc_num = rc_num | csn_8.clearBit(prev_rank+4*prev_dimm);
-
-   // Send out to the CCS array 
-   rc = mss_ccs_inst_arry_0( i_target,
-   	    io_ccs_inst_cnt,
-   	    address_16,
-   	    bank_3,
-   	    activate_1,
-   	    rasn_1,
-   	    casn_1,
-   	    wen_1,
-   	    cke_4,
-   	    csn_8,
-   	    odt_4,
-   	    ddr_cal_type_4,
-   	    prev_port);
-   if(rc) return rc;
-   rc = mss_ccs_inst_arry_1( i_target,
-   	    io_ccs_inst_cnt,
-   	    num_idles_16,
-   	    num_repeat_16,
-   	    data_20,
-   	    read_compare_1,
-   	    rank_cal_4,
-   	    ddr_cal_enable_1,
-   	    ccs_end_1);
-   if(rc) return rc;
-   io_ccs_inst_cnt ++;
-
-   //is an R or LR DIMM -> do a B side MRS write
-   if ( (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_RDIMM) || (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) ) {
-      //takes values from the backup
-      address_16.clearBit(0, 16);
-      rc_num = rc_num | address_16.insert(address_16_backup, 0, 16, 0);
-      
-      //FLIPS all necessary bits
-      // Indicate B-Side DRAMS BG1=1 
-      rc_num = rc_num | address_16.setBit(15);  // Set BG1 = 1
- 
-      rc_num = rc_num | address_16.flipBit(3,7); // Invert A3:A9
-      rc_num = rc_num | address_16.flipBit(11);  // Invert A11
-      rc_num = rc_num | address_16.flipBit(13);  // Invert A13
-      rc_num = rc_num | address_16.flipBit(14);  // Invert A17
-      rc_num = rc_num | bank_3.flipBit(0,3);	 // Invert BA0,BA1,BG0
+   //runs the last PDA command, if and only if a PDA of the desired rank and dimm was run
+   if(prev_dram_set) {
+      //adds values to a backup address_16 before doing the mirroring
+      address_16_backup.clearBit(0, 16);
+      rc_num = rc_num | address_16_backup.insert(address_16, 0, 16, 0);
+      rc_num = rc_num | odt_4.insert(odt_wr[prev_port][prev_dimm][prev_rank], 0, 4, 0);
       
+      if(rc_num)
+      {
+          rc.setEcmdError(rc_num);
+          return rc;
+      }
+
       //loads the previous DRAM
       if (( address_mirror_map[prev_port][prev_dimm] & (0x08 >> prev_rank) ) && (is_sim == 0))
       {
    	  rc = mss_address_mirror_swizzle(i_target, prev_port, prev_dimm, prev_rank, address_16, bank_3);
    	  if(rc) return rc;
       }
-      
+
       // Only corresponding CS to rank
       rc_num = rc_num | csn_8.setBit(0,8); 
-      rc_num = rc_num | csn_8.clearBit(prev_rank+4*prev_dimm);
       
+      if(dram_stack[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+   	 rc_num = rc_num | csn_8.clearBit(2,2); 
+   	 rc_num = rc_num | csn_8.clearBit(6,2); 
+      }
+      rc_num = rc_num | csn_8.clearBit(prev_rank+4*prev_dimm);
+
       // Send out to the CCS array 
       rc = mss_ccs_inst_arry_0( i_target,
    	       io_ccs_inst_cnt,
@@ -1323,9 +1525,134 @@ ReturnCode mss_ddr4_run_pda(
    	       ccs_end_1);
       if(rc) return rc;
       io_ccs_inst_cnt ++;
+      
+      // Send out to the CCS array 
+      rc = mss_ccs_inst_arry_0( i_target,
+   	       io_ccs_inst_cnt,
+   	       address_16,
+   	       bank_3,
+   	       activate_1,
+   	       rasn_1_odt,
+   	       casn_1_odt,
+   	       wen_1_odt,
+   	       cke_4,
+   	       csn_8_odt,
+   	       odt_4,
+   	       ddr_cal_type_4,
+   	       prev_port);
+      if(rc) return rc;
+      rc = mss_ccs_inst_arry_1( i_target,
+   	       io_ccs_inst_cnt,
+   	       num_idles_16_odt,
+   	       num_repeat_16_odt,
+   	       data_20,
+   	       read_compare_1,
+   	       rank_cal_4,
+   	       ddr_cal_enable_1,
+   	       ccs_end_1);
+      if(rc) return rc;
+      io_ccs_inst_cnt ++;
+
+      //is an R or LR DIMM -> do a B side MRS write
+      if ( (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_RDIMM) || (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) ) {
+   	 //takes values from the backup
+   	 address_16.clearBit(0, 16);
+   	 rc_num = rc_num | address_16.insert(address_16_backup, 0, 16, 0);
+   	 
+   	 //FLIPS all necessary bits
+   	 // Indicate B-Side DRAMS BG1=1 
+   	 rc_num = rc_num | address_16.setBit(15);  // Set BG1 = 1
+    
+   	 rc_num = rc_num | address_16.flipBit(3,7); // Invert A3:A9
+   	 rc_num = rc_num | address_16.flipBit(11);  // Invert A11
+   	 rc_num = rc_num | address_16.flipBit(13);  // Invert A13
+   	 rc_num = rc_num | address_16.flipBit(14);  // Invert A17
+   	 rc_num = rc_num | bank_3.flipBit(0,3);     // Invert BA0,BA1,BG0
+   	 
+	 if(rc_num)
+    	 {
+    	     rc.setEcmdError(rc_num);
+    	     return rc;
+    	 }
+	 
+   	 //loads the previous DRAM
+   	 if (( address_mirror_map[prev_port][prev_dimm] & (0x08 >> prev_rank) ) && (is_sim == 0))
+   	 {
+   	     rc = mss_address_mirror_swizzle(i_target, prev_port, prev_dimm, prev_rank, address_16, bank_3);
+   	     if(rc) return rc;
+   	 }
+   	 
+   	 // Only corresponding CS to rank
+   	 rc_num = rc_num | csn_8.setBit(0,8); 
+   	 
+   	 if(dram_stack[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+   	    rc_num = rc_num | csn_8.clearBit(2,2); 
+   	    rc_num = rc_num | csn_8.clearBit(6,2); 
+   	 }
+   	 rc_num = rc_num | csn_8.clearBit(prev_rank+4*prev_dimm);
+   	 
+	 if(rc_num)
+    	 {
+    	     rc.setEcmdError(rc_num);
+    	     return rc;
+    	 }
+	 
+   	 // Send out to the CCS array 
+   	 rc = mss_ccs_inst_arry_0( i_target,
+   		  io_ccs_inst_cnt,
+   		  address_16,
+   		  bank_3,
+   		  activate_1,
+   		  rasn_1,
+   		  casn_1,
+   		  wen_1,
+   		  cke_4,
+   		  csn_8,
+   		  odt_4,
+   		  ddr_cal_type_4,
+   		  prev_port);
+   	 if(rc) return rc;
+   	 rc = mss_ccs_inst_arry_1( i_target,
+   		  io_ccs_inst_cnt,
+   		  num_idles_16,
+   		  num_repeat_16,
+   		  data_20,
+   		  read_compare_1,
+   		  rank_cal_4,
+   		  ddr_cal_enable_1,
+   		  ccs_end_1);
+   	 if(rc) return rc;
+   	 io_ccs_inst_cnt ++;
+   	 
+   	 // Send out to the CCS array 
+   	 rc = mss_ccs_inst_arry_0( i_target,
+   		  io_ccs_inst_cnt,
+   		  address_16,
+   		  bank_3,
+   		  activate_1,
+   		  rasn_1_odt,
+   		  casn_1_odt,
+   		  wen_1_odt,
+   		  cke_4,
+   		  csn_8_odt,
+   		  odt_4,
+   		  ddr_cal_type_4,
+   		  prev_port);
+   	 if(rc) return rc;
+   	 rc = mss_ccs_inst_arry_1( i_target,
+   		  io_ccs_inst_cnt,
+   		  num_idles_16_odt,
+   		  num_repeat_16_odt,
+   		  data_20,
+   		  read_compare_1,
+   		  rank_cal_4,
+   		  ddr_cal_enable_1,
+   		  ccs_end_1);
+   	 if(rc) return rc;
+   	 io_ccs_inst_cnt ++;
+      }
    }
    
-   
    //sets a NOP as the last command
    rc_num = rc_num | cke_4.setBit(0,4);
    rc_num = rc_num | csn_8.setBit(0,8);
@@ -1344,7 +1671,7 @@ ReturnCode mss_ddr4_run_pda(
    	    casn_1,
    	    wen_1,
    	    cke_4,
-   	    csn_8,
+   	    csn_8_odt,
    	    odt_4,
    	    ddr_cal_type_4,
    	    prev_port);
@@ -1387,7 +1714,7 @@ ReturnCode mss_ddr4_run_pda(
    //}
       
    io_ccs_inst_cnt = 0;
-   rc = mss_ddr4_disable_pda(i_target,io_ccs_inst_cnt);
+   rc = mss_ddr4_disable_pda(i_target,io_ccs_inst_cnt,dimm_to_run,rank_to_run);
    return rc;
 }
 
@@ -1432,7 +1759,7 @@ ReturnCode mss_ddr4_add_dram_pda(Target& i_target,uint8_t port,uint8_t dram,vect
       scom_start = 60 + (uint32_t)((phy_lane/8)*2);
       scom_len = 2;
    }
-   FAPI_INF("Enabling %016llx start at %d for %d bits",reg_address,scom_start,scom_len);
+   FAPI_INF("Enabling %016llx start at %d for %d bits for port %d dram %d",reg_address,scom_start,scom_len,port,dram);
    
    rc = fapiGetScom(i_target, reg_address, data_buffer);
    if(rc) return rc;
@@ -1455,10 +1782,10 @@ ReturnCode mss_ddr4_add_dram_pda(Target& i_target,uint8_t port,uint8_t dram,vect
 /// mss_ddr4_disable_pda
 /// disables per-DRAM addressability funcitonality on both ports on the passed MBA
 //////////////////////////////////////////////////////////////////////////////////
-ReturnCode mss_ddr4_disable_pda(Target& i_target,uint32_t& io_ccs_inst_cnt) {
+ReturnCode mss_ddr4_disable_pda(Target& i_target,uint32_t& io_ccs_inst_cnt, uint8_t dimm_to_run, uint8_t rank_to_run) {
     uint32_t i_port_number=0;
-    uint32_t dimm_number;
-    uint32_t rank_number;
+    uint32_t dimm_number = dimm_to_run;
+    uint32_t rank_number = rank_to_run;
     const uint32_t NUM_POLL = 10;
     const uint32_t WAIT_TIMER = 1500;
     ReturnCode rc;  
@@ -1488,14 +1815,38 @@ ReturnCode mss_ddr4_disable_pda(Target& i_target,uint32_t& io_ccs_inst_cnt) {
     ecmdDataBufferBase rank_cal_4(4);
     ecmdDataBufferBase ddr_cal_enable_1(1);
     ecmdDataBufferBase ccs_end_1(1);
+    
+    ecmdDataBufferBase rasn_1_odt(1);
+    ecmdDataBufferBase casn_1_odt(1);
+    ecmdDataBufferBase wen_1_odt(1);
+    ecmdDataBufferBase num_repeat_16_odt(16);
+    ecmdDataBufferBase num_idles_16_odt(16);
+    ecmdDataBufferBase csn_8_odt(8);
+    rc_num = rc_num | rasn_1_odt.clearBit(0,1);
+    rc_num = rc_num | casn_1_odt.clearBit(0,1);
+    rc_num = rc_num | wen_1_odt.clearBit(0,1);
+    rc_num = rc_num | csn_8_odt.setBit(0,8);
+    rc_num = rc_num | csn_8_odt.clearBit(7,1);
+    
+    if (rc_num) {
+       FAPI_ERR( "disable ccs setup: Error disabling up buffers");
+       rc_buff.setEcmdError(rc_num);
+       return rc_buff;
+    }
 
     ecmdDataBufferBase mrs3(16);
     uint16_t MRS3 = 0;
     
-    uint8_t num_ranks_array[2][2]; //[port][dimm]
+    uint8_t dram_gen;
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_GEN, &i_target, dram_gen);
+    if(rc) return rc;
+    
+    uint8_t odt_wr[2][2][4];
+    rc = FAPI_ATTR_GET(ATTR_VPD_ODT_WR,  &i_target, odt_wr);
+    if(rc) return rc;
     
-    uint8_t num_ranks;
-    rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target, num_ranks_array);
+    uint8_t dram_stack[2][2];
+    rc = FAPI_ATTR_GET(ATTR_EFF_STACK_TYPE, &i_target, dram_stack);
     if(rc) return rc;
 
     uint8_t dimm_type;
@@ -1507,7 +1858,7 @@ ReturnCode mss_ddr4_disable_pda(Target& i_target,uint32_t& io_ccs_inst_cnt) {
     if(rc) return rc;
 
     uint8_t address_mirror_map[2][2]; //address_mirror_map[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
     if(rc) return rc;
 
     // WORKAROUNDS 
@@ -1515,6 +1866,10 @@ ReturnCode mss_ddr4_disable_pda(Target& i_target,uint32_t& io_ccs_inst_cnt) {
     if(rc) return rc;
     //Setting up CCS mode
     rc_num = rc_num | data_buffer.setBit(51);
+    //if in DDR4 mode, count the parity bit and set it
+    if((dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR4) && (dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM || dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_RDIMM) ) {
+       rc_num = rc_num | data_buffer.insertFromRight( (uint8_t)0xff, 61, 1);
+    }
     if (rc_num) {
       FAPI_ERR( "disable ccs setup: Error disabling up buffers");
       rc_buff.setEcmdError(rc_num);
@@ -1587,6 +1942,19 @@ ReturnCode mss_ddr4_disable_pda(Target& i_target,uint32_t& io_ccs_inst_cnt) {
     rc = FAPI_ATTR_GET(ATTR_EFF_MPR_RD_FORMAT, &i_target, read_format);
     if(rc) return rc;
     
+    
+    //sets up the DRAM DQ drive time
+    uint8_t wl_launch_time;
+    uint8_t odt_hold_time;
+    uint8_t post_odt_nop_idle;
+    rc = mss_get_pda_odt_timings(i_target, wl_launch_time, odt_hold_time, post_odt_nop_idle);
+   
+    rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 0, 0, 16);
+    rc_num = rc_num | num_repeat_16.insertFromRight((uint32_t) 0, 0, 16);
+   
+    rc_num = rc_num | num_idles_16_odt.insertFromRight( post_odt_nop_idle, 0, 8);
+    rc_num = rc_num | num_repeat_16_odt.insertFromRight( odt_hold_time, 0, 8);
+    
     //exits PDA
     for(i_port_number=0;i_port_number<2;i_port_number++) {
     //loops through the DP18's and sets everything to 0's
@@ -1608,163 +1976,210 @@ ReturnCode mss_ddr4_disable_pda(Target& i_target,uint32_t& io_ccs_inst_cnt) {
     
     //exits PDA
     for(i_port_number=0;i_port_number<2;i_port_number++) {
-    	for ( dimm_number = 0; dimm_number < MAX_NUM_DIMMS; dimm_number++)
-    	{
-    	    num_ranks = num_ranks_array[i_port_number][dimm_number];
-
-    	    if (num_ranks == 0)
-    	    {
-    		FAPI_INF( "PORT%d DIMM%d not configured. Num_ranks: %d ", i_port_number, dimm_number, num_ranks);
-    	    }
-    	    else
-    	    {
-    		// Rank 0-3
-    		for ( rank_number = 0; rank_number < num_ranks; rank_number++)
-    		{
-    		   // Only corresponding CS to rank
-    		   rc_num = rc_num | csn_8.setBit(0,8); 
-    		   rc_num = rc_num | csn_8.clearBit(rank_number+4*dimm_number);
-    			
-    		   rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 0, 1, 7);
-    		   rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 1, 1, 6);
-    		   rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 2, 1, 5);
-    				
-	           //enables PDA
-	           rc_num = rc_num | mrs3.insert((uint8_t) mpr_page, 0, 2);
-	           rc_num = rc_num | mrs3.insert((uint8_t) mpr_op, 2, 1);
-	           rc_num = rc_num | mrs3.insert((uint8_t) geardown_mode, 3, 1);
-	           rc_num = rc_num | mrs3.insert((uint8_t) 0x00, 4, 1);
-	           rc_num = rc_num | mrs3.insert((uint8_t) temp_readout, 5, 1);
-	           rc_num = rc_num | mrs3.insert((uint8_t) fine_refresh, 6, 3);
-	           rc_num = rc_num | mrs3.insert((uint8_t) wr_latency, 9, 2);
-	           rc_num = rc_num | mrs3.insert((uint8_t) read_format, 11, 2);
-	           rc_num = rc_num | mrs3.insert((uint8_t) 0x00, 13, 2);
-	           rc_num = rc_num | mrs3.extractPreserve(&MRS3, 0, 16, 0);
-	           rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 100, 0, 16);
-		   
-		   //copies over values
-    		   rc_num = rc_num | address_16.insert(mrs3, 0, 16, 0);
-    		   if (rc_num)
-    		   {
-    		       FAPI_ERR( "mss_mrs_load: Error setting up buffers");
-    		       rc_buff.setEcmdError(rc_num);
-    		       return rc_buff;
-    		   }
-		   
-    		   if (( address_mirror_map[i_port_number][dimm_number] & (0x08 >> rank_number) ) && (is_sim == 0))
-    		   {
-    		      rc = mss_address_mirror_swizzle(i_target, i_port_number, dimm_number, rank_number, address_16, bank_3);
-    		      if(rc) return rc;
-    		   }
-		   
-    		   // Send out to the CCS array 
-    		   rc = mss_ccs_inst_arry_0( i_target,
-    				     io_ccs_inst_cnt,
-    				     address_16,
-    				     bank_3,
-    				     activate_1,
-    				     rasn_1,
-    				     casn_1,
-    				     wen_1,
-    				     cke_4,
-    				     csn_8,
-    				     odt_4,
-    				     ddr_cal_type_4,
-    				     i_port_number);
-    		   if(rc) return rc;
-    		   rc = mss_ccs_inst_arry_1( i_target,
-    				     io_ccs_inst_cnt,
-    				     num_idles_16,
-    				     num_repeat_16,
-    				     data_20,
-    				     read_compare_1,
-    				     rank_cal_4,
-    				     ddr_cal_enable_1,
-    				     ccs_end_1);
-    		   if(rc) return rc;
-    		   io_ccs_inst_cnt ++;
-		   
-		   //if the DIMM is an R or LR DIMM, then run inverted for the B-Side DRAM
-                   if ( (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_RDIMM) || (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) ) 
-		   {
-		   
-		       //reload all MRS values (removes address swizzling)
-		        // Only corresponding CS to rank
-    		       rc_num = rc_num | csn_8.setBit(0,8); 
-    		       rc_num = rc_num | csn_8.clearBit(rank_number+4*dimm_number);
-    		    	    
-    		       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 0, 1, 7);
-    		       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 1, 1, 6);
-    		       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 2, 1, 5);
-    		    		    
-	               //enables PDA
-	               rc_num = rc_num | mrs3.insert((uint8_t) mpr_page, 0, 2);
-	               rc_num = rc_num | mrs3.insert((uint8_t) mpr_op, 2, 1);
-	               rc_num = rc_num | mrs3.insert((uint8_t) geardown_mode, 3, 1);
-	               rc_num = rc_num | mrs3.insert((uint8_t) 0x00, 4, 1);
-	               rc_num = rc_num | mrs3.insert((uint8_t) temp_readout, 5, 1);
-	               rc_num = rc_num | mrs3.insert((uint8_t) fine_refresh, 6, 3);
-	               rc_num = rc_num | mrs3.insert((uint8_t) wr_latency, 9, 2);
-	               rc_num = rc_num | mrs3.insert((uint8_t) read_format, 11, 2);
-	               rc_num = rc_num | mrs3.insert((uint8_t) 0x00, 13, 2);
-	               rc_num = rc_num | mrs3.extractPreserve(&MRS3, 0, 16, 0);
-	               rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 100, 0, 16);
-		       //copies over values
-		       rc_num = rc_num | address_16.insert(mrs3, 0, 16, 0);
-		       
-		       //FLIPS all necessary bits
-		       // Indicate B-Side DRAMS BG1=1 
-                       rc_num = rc_num | address_16.setBit(15);  // Set BG1 = 1
+       // Only corresponding CS to rank
+       rc_num = rc_num | csn_8.setBit(0,8); 
+       if(dram_stack[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+          rc_num = rc_num | csn_8.clearBit(2,2); 
+          rc_num = rc_num | csn_8.clearBit(6,2); 
+       }
+       rc_num = rc_num | csn_8.clearBit(rank_number+4*dimm_number);
+    
+       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 0, 1, 7);
+       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 1, 1, 6);
+       rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 2, 1, 5);
+    	    	    
+       //enables PDA
+       rc_num = rc_num | mrs3.insert((uint8_t) mpr_page, 0, 2);
+       rc_num = rc_num | mrs3.insert((uint8_t) mpr_op, 2, 1);
+       rc_num = rc_num | mrs3.insert((uint8_t) geardown_mode, 3, 1);
+       rc_num = rc_num | mrs3.insert((uint8_t) 0x00, 4, 1);
+       rc_num = rc_num | mrs3.insert((uint8_t) temp_readout, 5, 1);
+       rc_num = rc_num | mrs3.insert((uint8_t) fine_refresh, 6, 3);
+       rc_num = rc_num | mrs3.insert((uint8_t) wr_latency, 9, 2);
+       rc_num = rc_num | mrs3.insert((uint8_t) read_format, 11, 2);
+       rc_num = rc_num | mrs3.insert((uint8_t) 0x00, 13, 2);
+       rc_num = rc_num | mrs3.extractPreserve(&MRS3, 0, 16, 0);
+       rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 100, 0, 16);
+       rc_num = rc_num | odt_4.insert(odt_wr[i_port_number][dimm_number][rank_number], 0, 4, 0);
+
+       //copies over values
+       rc_num = rc_num | address_16.insert(mrs3, 0, 16, 0);
+       if (rc_num)
+       {
+           FAPI_ERR( "mss_mrs_load: Error setting up buffers");
+           rc_buff.setEcmdError(rc_num);
+           return rc_buff;
+       }
+
+       if (( address_mirror_map[i_port_number][dimm_number] & (0x08 >> rank_number) ) && (is_sim == 0))
+       {
+          rc = mss_address_mirror_swizzle(i_target, i_port_number, dimm_number, rank_number, address_16, bank_3);
+          if(rc) return rc;
+       }
+
+       // Send out to the CCS array 
+       rc = mss_ccs_inst_arry_0( i_target,
+    	    		 io_ccs_inst_cnt,
+    	    		 address_16,
+    	    		 bank_3,
+    	    		 activate_1,
+    	    		 rasn_1,
+    	    		 casn_1,
+    	    		 wen_1,
+    	    		 cke_4,
+    	    		 csn_8,
+    	    		 odt_4,
+    	    		 ddr_cal_type_4,
+    	    		 i_port_number);
+       if(rc) return rc;
+       rc = mss_ccs_inst_arry_1( i_target,
+    	    		 io_ccs_inst_cnt,
+    	    		 num_idles_16,
+    	    		 num_repeat_16,
+    	    		 data_20,
+    	    		 read_compare_1,
+    	    		 rank_cal_4,
+    	    		 ddr_cal_enable_1,
+    	    		 ccs_end_1);
+       if(rc) return rc;
+       io_ccs_inst_cnt ++;
+
+       // Send out to the CCS array 
+       rc = mss_ccs_inst_arry_0( i_target,
+        	io_ccs_inst_cnt,
+        	address_16,
+        	bank_3,
+        	activate_1,
+        	rasn_1_odt,
+        	casn_1_odt,
+        	wen_1_odt,
+        	cke_4,
+        	csn_8_odt,
+        	odt_4,
+        	ddr_cal_type_4,
+        	i_port_number);
+       if(rc) return rc;
+       rc = mss_ccs_inst_arry_1( i_target,
+        	io_ccs_inst_cnt,
+        	num_idles_16_odt,
+        	num_repeat_16_odt,
+        	data_20,
+        	read_compare_1,
+        	rank_cal_4,
+        	ddr_cal_enable_1,
+        	ccs_end_1);
+       if(rc) return rc;
+       io_ccs_inst_cnt ++;
+
+       //if the DIMM is an R or LR DIMM, then run inverted for the B-Side DRAM
+       if ( (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_RDIMM) || (dimm_type == ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM) ) 
+       {
+
+           //reload all MRS values (removes address swizzling)
+            // Only corresponding CS to rank
+           rc_num = rc_num | csn_8.setBit(0,8); 
+           if(dram_stack[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) {
+              rc_num = rc_num | csn_8.clearBit(2,2); 
+              rc_num = rc_num | csn_8.clearBit(6,2); 
+           }
+           rc_num = rc_num | csn_8.clearBit(rank_number+4*dimm_number);
+        	
+           rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 0, 1, 7);
+           rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 1, 1, 6);
+           rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 2, 1, 5);
+        		
+           //enables PDA
+           rc_num = rc_num | mrs3.insert((uint8_t) mpr_page, 0, 2);
+           rc_num = rc_num | mrs3.insert((uint8_t) mpr_op, 2, 1);
+           rc_num = rc_num | mrs3.insert((uint8_t) geardown_mode, 3, 1);
+           rc_num = rc_num | mrs3.insert((uint8_t) 0x00, 4, 1);
+           rc_num = rc_num | mrs3.insert((uint8_t) temp_readout, 5, 1);
+           rc_num = rc_num | mrs3.insert((uint8_t) fine_refresh, 6, 3);
+           rc_num = rc_num | mrs3.insert((uint8_t) wr_latency, 9, 2);
+           rc_num = rc_num | mrs3.insert((uint8_t) read_format, 11, 2);
+           rc_num = rc_num | mrs3.insert((uint8_t) 0x00, 13, 2);
+           rc_num = rc_num | mrs3.extractPreserve(&MRS3, 0, 16, 0);
+           rc_num = rc_num | num_idles_16.insertFromRight((uint32_t) 100, 0, 16);
+           //copies over values
+           rc_num = rc_num | address_16.insert(mrs3, 0, 16, 0);
+           
+           //FLIPS all necessary bits
+           // Indicate B-Side DRAMS BG1=1 
+           rc_num = rc_num | address_16.setBit(15);  // Set BG1 = 1
  
-                       rc_num = rc_num | address_16.flipBit(3,7); // Invert A3:A9
-                       rc_num = rc_num | address_16.flipBit(11);  // Invert A11
-                       rc_num = rc_num | address_16.flipBit(13);  // Invert A13
-                       rc_num = rc_num | address_16.flipBit(14);  // Invert A17
-                       rc_num = rc_num | bank_3.flipBit(0,3);	  // Invert BA0,BA1,BG0
-		       
-		       if (rc_num)
-    		       {
-    		     	   FAPI_ERR( "mss_ddr4_setup_pda: Error setting up buffers");
-    		     	   rc_buff.setEcmdError(rc_num);
-    		     	   return rc_buff;
-    		       }
-		     	   
-		     	   if (( address_mirror_map[i_port_number][dimm_number] & (0x08 >> rank_number) ) && (is_sim == 0))
-    		       {
-    		     	  rc = mss_address_mirror_swizzle(i_target, i_port_number, dimm_number, rank_number, address_16, bank_3);
-    		     	  if(rc) return rc;
-    		       }
-    		       
-    		       // Send out to the CCS array 
-    		       rc = mss_ccs_inst_arry_0( i_target,
-    		     	 		 io_ccs_inst_cnt,
-    		     	 		 address_16,
-    		     	 		 bank_3,
-    		     	 		 activate_1,
-    		     	 		 rasn_1,
-    		     	 		 casn_1,
-    		     	 		 wen_1,
-    		     	 		 cke_4,
-    		     	 		 csn_8,
-    		     	 		 odt_4,
-    		     	 		 ddr_cal_type_4,
-    		     	 		 i_port_number);
-    		       if(rc) return rc;
-    		       rc = mss_ccs_inst_arry_1( i_target,
-    		     	 		 io_ccs_inst_cnt,
-    		     	 		 num_idles_16,
-    		     	 		 num_repeat_16,
-    		     	 		 data_20,
-    		     	 		 read_compare_1,
-    		     	 		 rank_cal_4,
-    		     	 		 ddr_cal_enable_1,
-    		     	 		 ccs_end_1);
-    		       if(rc) return rc;
-    		       io_ccs_inst_cnt ++;
-		    }
-    		}    
-    	    }
-    	}
+           rc_num = rc_num | address_16.flipBit(3,7); // Invert A3:A9
+           rc_num = rc_num | address_16.flipBit(11);  // Invert A11
+           rc_num = rc_num | address_16.flipBit(13);  // Invert A13
+           rc_num = rc_num | address_16.flipBit(14);  // Invert A17
+           rc_num = rc_num | bank_3.flipBit(0,3);     // Invert BA0,BA1,BG0
+           
+           if (rc_num)
+           {
+               FAPI_ERR( "mss_ddr4_setup_pda: Error setting up buffers");
+               rc_buff.setEcmdError(rc_num);
+               return rc_buff;
+           }
+               
+               if (( address_mirror_map[i_port_number][dimm_number] & (0x08 >> rank_number) ) && (is_sim == 0))
+           {
+              rc = mss_address_mirror_swizzle(i_target, i_port_number, dimm_number, rank_number, address_16, bank_3);
+              if(rc) return rc;
+           }
+           
+           // Send out to the CCS array 
+           rc = mss_ccs_inst_arry_0( i_target,
+        		     io_ccs_inst_cnt,
+        		     address_16,
+        		     bank_3,
+        		     activate_1,
+        		     rasn_1,
+        		     casn_1,
+        		     wen_1,
+        		     cke_4,
+        		     csn_8,
+        		     odt_4,
+        		     ddr_cal_type_4,
+        		     i_port_number);
+           if(rc) return rc;
+           rc = mss_ccs_inst_arry_1( i_target,
+        		     io_ccs_inst_cnt,
+        		     num_idles_16,
+        		     num_repeat_16,
+        		     data_20,
+        		     read_compare_1,
+        		     rank_cal_4,
+        		     ddr_cal_enable_1,
+        		     ccs_end_1);
+           if(rc) return rc;
+           io_ccs_inst_cnt ++;
+           
+           // Send out to the CCS array 
+           rc = mss_ccs_inst_arry_0( i_target,
+	    	    io_ccs_inst_cnt,
+	    	    address_16,
+	    	    bank_3,
+	    	    activate_1,
+	    	    rasn_1_odt,
+	    	    casn_1_odt,
+	    	    wen_1_odt,
+	    	    cke_4,
+	    	    csn_8_odt,
+	    	    odt_4,
+	    	    ddr_cal_type_4,
+	    	    i_port_number);
+           if(rc) return rc;
+           rc = mss_ccs_inst_arry_1( i_target,
+	    	    io_ccs_inst_cnt,
+	    	    num_idles_16_odt,
+	    	    num_repeat_16_odt,
+	    	    data_20,
+	    	    read_compare_1,
+	    	    rank_cal_4,
+	    	    ddr_cal_enable_1,
+	    	    ccs_end_1);
+           if(rc) return rc;
+           io_ccs_inst_cnt ++;
+       }
    }
    
    //Setup end bit for CCS
@@ -1820,1686 +2235,82 @@ ReturnCode mss_ddr4_disable_pda(Target& i_target,uint32_t& io_ccs_inst_cnt) {
    
    FAPI_INF("Successfully exited out of PDA mode.");
    io_ccs_inst_cnt = 0;
+   
+   //Does the RTT_WR to RTT_NOM swapping
+    //loops through all ports
+    for(i_port_number=0;i_port_number<MAX_NUM_PORTS;i_port_number++) {
+       uint8_t io_dram_rtt_nom_original = 0;
+       rc = mss_ddr4_rtt_nom_rtt_wr_swap(i_target,0,i_port_number,rank_number+dimm_number*4,0xFF,io_ccs_inst_cnt,io_dram_rtt_nom_original);
+       if(rc) return rc;
+       io_ccs_inst_cnt = 0;
+    }
+   
    return rc;
 }
 
-//////////////////////////////////////////////////////////////////////////////////
-/// mss_ddr4_modify_mrs_pda
-/// disables per-DRAM addressability funcitonality on both ports on the passed MBA
-//////////////////////////////////////////////////////////////////////////////////
-ReturnCode mss_ddr4_modify_mrs_pda(Target& i_target,ecmdDataBufferBase& address_16,uint32_t attribute_name,uint8_t attribute_data) {
-   ReturnCode rc;
-   uint32_t rc_num = 0;
-   uint8_t dram_bl = attribute_data;
-   uint8_t read_bt = attribute_data; //Read Burst Type 
-   uint8_t dram_cl = attribute_data;
-   uint8_t test_mode = attribute_data; //TEST MODE 
-   uint8_t dll_reset = attribute_data; //DLL Reset 
-   uint8_t dram_wr = attribute_data; //DRAM write recovery
-   uint8_t dram_rtp = attribute_data; //DRAM RTP - read to precharge
-   uint8_t dram_wr_rtp = attribute_data;
-   uint8_t dll_precharge = attribute_data; //DLL Control For Precharge if (dll_precharge == ENUM_ATTR_EFF_DRAM_DLL_PPD_SLOWEXIT)
-   uint8_t dll_enable = attribute_data; //DLL Enable 
-   uint8_t out_drv_imp_cntl = attribute_data;
-   uint8_t dram_rtt_nom = attribute_data;
-   uint8_t dram_al = attribute_data;
-   uint8_t wr_lvl = attribute_data; //write leveling enable
-   uint8_t tdqs_enable = attribute_data; //TDQS Enable 
-   uint8_t q_off = attribute_name; //Qoff - Output buffer Enable 
-   uint8_t lpasr = attribute_data; // Low Power Auto Self-Refresh -- new not yet supported
-   uint8_t cwl = attribute_data; // CAS Write Latency 
-   uint8_t dram_rtt_wr = attribute_data;
-   uint8_t mpr_op = attribute_data; // MPR Op
-   uint8_t mpr_page = attribute_data; // MPR Page Selection  
-   uint8_t geardown_mode = attribute_data; // Gear Down Mode  
-   uint8_t temp_readout = attribute_data; // Temperature sensor readout  
-   uint8_t fine_refresh = attribute_data; // fine refresh mode  
-   uint8_t wr_latency = attribute_data; // write latency for CRC and DM  
-   uint8_t write_crc = attribute_data; // CAS Write Latency 
-   uint8_t read_format = attribute_data; // MPR READ FORMAT  
-   uint8_t max_pd_mode = attribute_data; // Max Power down mode 
-   uint8_t temp_ref_range = attribute_data; // Temp ref range 
-   uint8_t temp_ref_mode = attribute_data; // Temp controlled ref mode 
-   uint8_t vref_mon = attribute_data; // Internal Vref Monitor 
-   uint8_t cs_cmd_latency = attribute_data; // CS to CMD/ADDR Latency 
-   uint8_t ref_abort = attribute_data; // Self Refresh Abort 
-   uint8_t rd_pre_train_mode = attribute_data; // Read Pre amble Training Mode 
-   uint8_t rd_preamble = attribute_data; // Read Pre amble 
-   uint8_t wr_preamble = attribute_data; // Write Pre amble 
-   uint8_t ca_parity_latency = attribute_data; //C/A Parity Latency Mode  
-   uint8_t crc_error_clear = attribute_data; //CRC Error Clear  
-   uint8_t ca_parity_error_status = attribute_data; //C/A Parity Error Status  
-   uint8_t odt_input_buffer = attribute_data; //ODT Input Buffer during power down  
-   uint8_t rtt_park = attribute_data; //RTT_Park value  
-   uint8_t ca_parity = attribute_data; //CA Parity Persistance Error  
-   uint8_t data_mask = attribute_data; //Data Mask  
-   uint8_t write_dbi = attribute_data; //Write DBI  
-   uint8_t read_dbi = attribute_data; //Read DBI  
-   uint8_t vrefdq_train_value = attribute_data; //vrefdq_train value   
-   uint8_t vrefdq_train_range = attribute_data; //vrefdq_train range   
-   uint8_t vrefdq_train_enable = attribute_data; //vrefdq_train enable  
-   uint8_t tccd_l = attribute_data; //tccd_l  
-   uint8_t dram_access;
-
-   switch (attribute_name) {
-       case ATTR_EFF_DRAM_BL:
-	   if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_BL8)
-           {
-               dram_bl = 0x00;
-           }
-           else if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_OTF)
-           {
-               dram_bl = 0x80;
-           }
-           else if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_BC4)
-           {
-               dram_bl = 0x40;
-           }
-	   rc_num = rc_num | address_16.insert((uint8_t) dram_bl, 0, 2, 0);
-	   break;
-       case ATTR_EFF_DRAM_RBT:
-	   if (read_bt == ENUM_ATTR_EFF_DRAM_RBT_SEQUENTIAL)
-           {
-               read_bt = 0x00;
-           }
-           else if (read_bt == ENUM_ATTR_EFF_DRAM_RBT_INTERLEAVE)
-           {
-               read_bt = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) read_bt, 3, 1, 0);
-	   break;
-       case ATTR_EFF_DRAM_CL:
-	   if ((dram_cl > 8)&&(dram_cl < 17))
-           {
-               dram_cl = dram_cl - 9; 
-           }
-           else if ((dram_cl > 17)&&(dram_cl < 25))
-           {
-               dram_cl = (dram_cl >> 1) - 1;   
-           }
-           dram_cl = mss_reverse_8bits(dram_cl);
-           rc_num = rc_num | address_16.insert((uint8_t) dram_cl, 2, 1, 0);
-           rc_num = rc_num | address_16.insert((uint8_t) dram_cl, 4, 3, 1);
-	   break;
-       case ATTR_EFF_DRAM_TM:
-	   if (test_mode == ENUM_ATTR_EFF_DRAM_TM_NORMAL)
-           {
-               test_mode = 0x00;
-           }
-           else if (test_mode == ENUM_ATTR_EFF_DRAM_TM_TEST)
-           {
-               test_mode = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) test_mode, 7, 1);
-	   break;
-       case ATTR_EFF_DRAM_DLL_RESET:
-	   dll_reset = 0x00;
-	   FAPI_ERR( "ERROR: ATTR_EFF_DRAM_DLL_RESET accessed during PDA functionality, overwritten");
-           rc_num = rc_num | address_16.insert((uint8_t) dll_reset, 8, 1);
-	   break;
-       case ATTR_EFF_DRAM_WR:
-           if ( (dram_wr == 10) )//&& (dram_rtp == 5) )
-           {
-               dram_wr_rtp = 0x00;
-           }
-           else if ( (dram_wr == 12) )//&& (dram_rtp == 6) )
-           {
-               dram_wr_rtp = 0x80;
-           }
-           else if ( (dram_wr == 13) )//&& (dram_rtp == 7) )
-           {
-               dram_wr_rtp = 0x40;
-           }
-           else if ( (dram_wr == 14) )//&& (dram_rtp == 8) )
-           {
-               dram_wr_rtp = 0xC0;
-           }
-           else if ( (dram_wr == 18) )//&& (dram_rtp == 9) )
-           {
-               dram_wr_rtp = 0x20;
-           }
-           else if ( (dram_wr == 20) )//&& (dram_rtp == 10) )
-           {
-               dram_wr_rtp = 0xA0;
-           }
-           else if ( (dram_wr == 24) )//&& (dram_rtp == 12) )
-           {
-               dram_wr_rtp = 0x60;
-           }
-    	   rc_num = rc_num | address_16.insert((uint8_t) dram_wr_rtp, 9, 3);
-	   break;
-       case ATTR_EFF_DRAM_TRTP:
-           if ( (dram_rtp == 5) )
-           {
-               dram_wr_rtp = 0x00;
-           }
-           else if ( (dram_rtp == 6) )
-           {
-               dram_wr_rtp = 0x80;
-           }
-           else if ( (dram_rtp == 7) )
-           {
-               dram_wr_rtp = 0x40;
-           }
-           else if ( (dram_rtp == 8) )
-           {
-               dram_wr_rtp = 0xC0;
-           }
-           else if ( (dram_rtp == 9) )
-           {
-               dram_wr_rtp = 0x20;
-           }
-           else if ( (dram_rtp == 10) )
-           {
-               dram_wr_rtp = 0xA0;
-           }
-           else if ( (dram_rtp == 12) )
-           {
-               dram_wr_rtp = 0x60;
-           }
-    	   rc_num = rc_num | address_16.insert((uint8_t) dram_wr_rtp, 9, 3);
-	   break;
-       case ATTR_EFF_DRAM_DLL_PPD:
-           if (dll_precharge == ENUM_ATTR_EFF_DRAM_DLL_PPD_SLOWEXIT)
-	   {
-               dll_precharge = 0x00;
-           }
-           else if (dll_precharge == ENUM_ATTR_EFF_DRAM_DLL_PPD_FASTEXIT)
-           {
-               dll_precharge = 0xFF;
-           }
-	   FAPI_INF("ERROR: ATTR_EFF_DRAM_DLL_PPD is an unused MRS value!!! Skipping...");
-	   break;
-       case ATTR_EFF_DRAM_DLL_ENABLE:
-           if (dll_enable == ENUM_ATTR_EFF_DRAM_DLL_ENABLE_DISABLE)
-           {
-               dll_enable = 0x00;
-           }
-           else if (dll_enable == ENUM_ATTR_EFF_DRAM_DLL_ENABLE_ENABLE)
-           {
-               dll_enable = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) dll_enable, 0, 1, 0);
-	   break;
-       case ATTR_VPD_DRAM_RON:
-	   if (out_drv_imp_cntl == ENUM_ATTR_VPD_DRAM_RON_OHM34)
-           {
-               out_drv_imp_cntl = 0x00;
-           }
-    	   // Not currently supported
-           else if (out_drv_imp_cntl == ENUM_ATTR_VPD_DRAM_RON_OHM48) //not supported
-           {
-               out_drv_imp_cntl = 0x80;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) out_drv_imp_cntl, 1, 2, 0);
-	   break;
-       case ATTR_VPD_DRAM_RTT_NOM:
-	   if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_DISABLE)
-           {
-               dram_rtt_nom = 0x00;
-           }
-           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM240) //not supported
-           {
-               dram_rtt_nom = 0x20;
-           }
-           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM48) //not supported
-           {
-               dram_rtt_nom = 0xA0;
-           }
-           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM40)
-           {
-               dram_rtt_nom = 0xC0;
-           }
-           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM60)
-           {
-               dram_rtt_nom = 0x80;
-           }
-           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM120)
-           {
-               dram_rtt_nom = 0x40;
-           }
-           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM80) // not supported
-           {
-               dram_rtt_nom = 0x60;
-           }
-           else if (dram_rtt_nom == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM34) // not supported
-           {
-               dram_rtt_nom = 0xE0;
-           }
-	   
-           rc_num = rc_num | address_16.insert((uint8_t) dram_rtt_nom, 8, 3, 0);
-	   break;
-       case ATTR_EFF_DRAM_AL:
-	   if (dram_al == ENUM_ATTR_EFF_DRAM_AL_DISABLE)
-           {
-               dram_al = 0x00;
-           }
-           else if (dram_al == ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_1)
-           {
-               dram_al = 0x80;
-           }
-           else if (dram_al == ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_2)
-           {
-               dram_al = 0x40;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) dram_al, 3, 2, 0);
-	   break;
-       case ATTR_EFF_DRAM_WR_LVL_ENABLE:
-	   if (wr_lvl == ENUM_ATTR_EFF_DRAM_WR_LVL_ENABLE_DISABLE)
-           {
-               wr_lvl = 0x00;
-           }
-           else if (wr_lvl == ENUM_ATTR_EFF_DRAM_WR_LVL_ENABLE_ENABLE)
-           {
-               wr_lvl = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) wr_lvl, 7, 1, 0);
-	   break;
-       case ATTR_EFF_DRAM_TDQS:
-	   if (tdqs_enable == ENUM_ATTR_EFF_DRAM_TDQS_DISABLE)
-           {
-               tdqs_enable = 0x00;
-           }
-           else if (tdqs_enable == ENUM_ATTR_EFF_DRAM_TDQS_ENABLE)
-           {
-               tdqs_enable = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) tdqs_enable, 11, 1, 0);
-	   break;
-       case ATTR_EFF_DRAM_OUTPUT_BUFFER:
-           if (q_off == ENUM_ATTR_EFF_DRAM_OUTPUT_BUFFER_DISABLE)
-           {
-               q_off = 0xFF;
-           }
-           else if (q_off == ENUM_ATTR_EFF_DRAM_OUTPUT_BUFFER_ENABLE)
-           {
-               q_off = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) q_off, 12, 1, 0);
-	   break;
-       case ATTR_EFF_DRAM_LPASR:
-           if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_NORMAL)
-           {
-               lpasr = 0x00;
-           }
-           else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_REDUCED)
-           {
-               lpasr = 0x80;
-           }
-           else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_EXTENDED)
-           {
-               lpasr = 0x40;
-           }
-           else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_ASR)
-           {
-               lpasr = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) lpasr, 6, 2);
-	   break;
-       case ATTR_EFF_DRAM_CWL:
-	   if ((cwl > 8)&&(cwl < 13))
-           {
-               cwl = cwl - 9; 
-           }
-           else if ((cwl > 13)&&(cwl < 19))
-           {
-               cwl = (cwl >> 1) - 3;   
-           }
-           else
-           {
-              //no correcct value for CWL was found
-              FAPI_INF("ERROR: Improper CWL value found. Setting CWL to 9 and continuing...");
-              cwl = 0;
-           }
-	   cwl = mss_reverse_8bits(cwl);
-	   rc_num = rc_num | address_16.insert((uint8_t) cwl, 3, 3);
-	   break;
-       case ATTR_VPD_DRAM_RTT_WR:
-	   if (dram_rtt_wr == ENUM_ATTR_VPD_DRAM_RTT_WR_DISABLE)
-           {
-               dram_rtt_wr = 0x00;
-           }
-           else if (dram_rtt_wr == ENUM_ATTR_VPD_DRAM_RTT_WR_OHM120)
-           {
-               dram_rtt_wr = 0x80;
-           }
-           else if (dram_rtt_wr == 240)//ENUM_ATTR_EFF_DRAM_RTT_WR_OHM240)
-           {
-               dram_rtt_wr = 0x40;
-           }
-           else if (dram_rtt_wr == 0xFF)//ENUM_ATTR_EFF_DRAM_RTT_WR_HIGHZ)
-           {
-               dram_rtt_wr = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) dram_rtt_wr, 9, 2);
-           break;
-       case ATTR_EFF_WRITE_CRC:
-	   if ( write_crc == ENUM_ATTR_EFF_WRITE_CRC_ENABLE)
-           {
-               write_crc = 0xFF;
-           }
-           else if (write_crc == ENUM_ATTR_EFF_WRITE_CRC_DISABLE)
-           {
-               write_crc = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) write_crc, 12, 1);
-	   break;
-       case ATTR_EFF_MPR_MODE:
-	   if (mpr_op == ENUM_ATTR_EFF_MPR_MODE_ENABLE)
-           {
-               mpr_op = 0xFF;
-           }
-           else if (mpr_op == ENUM_ATTR_EFF_MPR_MODE_DISABLE)
-           {
-               mpr_op = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) mpr_op, 2, 1);
-	   break;
-       case ATTR_EFF_MPR_PAGE:
-           mpr_page = mss_reverse_8bits(mpr_page);
-    	   rc_num = rc_num | address_16.insert((uint8_t) mpr_page, 0, 2);
-	   break;
-       case ATTR_EFF_GEARDOWN_MODE:
-	   if ( geardown_mode == ENUM_ATTR_EFF_GEARDOWN_MODE_HALF)
-           {
-        	geardown_mode = 0x00;
-           }
-           else if ( geardown_mode == ENUM_ATTR_EFF_GEARDOWN_MODE_QUARTER)
-           {
-        	geardown_mode = 0xFF;
-           }
-           
-           if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_ENABLE)
-           {
-               temp_readout = 0xFF;
-           }
-           else if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_DISABLE)
-           {
-               temp_readout = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) geardown_mode, 3, 1);
-	   break;
-       case ATTR_EFF_TEMP_READOUT:
-	   if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_ENABLE)
-    	   {
-    	       temp_readout = 0xFF;
-    	   }
-    	   else if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_DISABLE)
-    	   {
-    	       temp_readout = 0x00;
-    	   }
-           rc_num = rc_num | address_16.insert((uint8_t) temp_readout, 5, 1);
-	   break;
-       case ATTR_EFF_FINE_REFRESH_MODE:
-	   if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_NORMAL)
-           {
-               fine_refresh = 0x00;
-           }
-           else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FIXED_2X)
-           {
-               fine_refresh = 0x80;
-           }
-           else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FIXED_4X)
-           {
-               fine_refresh = 0x40;
-           }
-           else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FLY_2X)
-           {
-               fine_refresh = 0xA0;
-           }
-           else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FLY_4X)
-           {
-               fine_refresh = 0x60;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) fine_refresh, 6, 3);
-	   break;
-       case ATTR_EFF_CRC_WR_LATENCY:
-           if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_4NCK)
-           {
-               wr_latency = 0x00;
-           }
-           else if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_5NCK)
-           {
-               wr_latency = 0x80;
-           }
-           else if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_6NCK)
-           {
-               wr_latency = 0xC0;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) wr_latency, 9, 2);
-	   break;
-       case ATTR_EFF_MPR_RD_FORMAT:
-           if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_SERIAL)
-           {
-               read_format = 0x00;
-           }
-           else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_PARALLEL)
-           {
-               read_format = 0x80;
-           }
-           else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_STAGGERED)
-           {
-               read_format = 0x40;
-           }
-           else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_RESERVED_TEMP)
-           {
-               read_format = 0xC0;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) read_format, 11, 2);
-	   break;
-       case ATTR_EFF_PER_DRAM_ACCESS:
-           FAPI_INF("ERROR: ATTR_EFF_PER_DRAM_ACCESS selected.  Forcing PDA to be on for this function");
-	   dram_access = 0xFF;
-	   rc_num = rc_num | address_16.insert((uint8_t) dram_access, 4, 1);
-	   break;
-       case ATTR_EFF_MAX_POWERDOWN_MODE:
-	   if ( max_pd_mode == ENUM_ATTR_EFF_MAX_POWERDOWN_MODE_ENABLE)
-           {
-               max_pd_mode = 0xF0;
-           }
-           else if ( max_pd_mode == ENUM_ATTR_EFF_MAX_POWERDOWN_MODE_DISABLE)
-           {
-               max_pd_mode = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) max_pd_mode, 1, 1);
-	   break;
-       case ATTR_EFF_TEMP_REF_RANGE:
-	   if (temp_ref_range == ENUM_ATTR_EFF_TEMP_REF_RANGE_NORMAL)
-           {
-               temp_ref_range = 0x00;
-           }
-           else if ( temp_ref_range== ENUM_ATTR_EFF_TEMP_REF_RANGE_EXTEND)
-           {
-               temp_ref_range = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) temp_ref_range, 2, 1);
-	   break;
-       case ATTR_EFF_TEMP_REF_MODE:
-	   if (temp_ref_mode == ENUM_ATTR_EFF_TEMP_REF_MODE_ENABLE)
-           {
-               temp_ref_mode = 0x80;
-           }
-           else if (temp_ref_mode == ENUM_ATTR_EFF_TEMP_REF_MODE_DISABLE)
-           {
-               temp_ref_mode = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) temp_ref_mode, 3, 1);
-	   break;
-       case ATTR_EFF_INT_VREF_MON:
-	   if ( vref_mon == ENUM_ATTR_EFF_INT_VREF_MON_ENABLE)
-           {
-               vref_mon = 0xFF;
-           }
-           else if ( vref_mon == ENUM_ATTR_EFF_INT_VREF_MON_DISABLE)
-           {
-               vref_mon = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) vref_mon, 4, 1);
-	   break;
-       case ATTR_EFF_CS_CMD_LATENCY:
-	   if ( cs_cmd_latency == 3)
-           {
-               cs_cmd_latency = 0x80;
-           }
-           else if (cs_cmd_latency == 4)
-           {
-               cs_cmd_latency = 0x40;
-           }
-           else if (cs_cmd_latency == 5)
-           {
-               cs_cmd_latency = 0xC0;
-           }
-           else if (cs_cmd_latency == 6)
-           {
-               cs_cmd_latency = 0x20;
-           }
-           else if (cs_cmd_latency == 8)
-           {
-               cs_cmd_latency = 0xA0;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) cs_cmd_latency, 6, 3);
-	   break;
-       case ATTR_EFF_SELF_REF_ABORT:
-	   if (ref_abort == ENUM_ATTR_EFF_SELF_REF_ABORT_ENABLE)
-           {
-               ref_abort = 0xFF;
-           }
-           else if (ref_abort == ENUM_ATTR_EFF_SELF_REF_ABORT_DISABLE)
-           {
-               ref_abort = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) ref_abort, 9, 1);
-	   break;
-       case ATTR_EFF_RD_PREAMBLE_TRAIN:
-	   if (rd_pre_train_mode == ENUM_ATTR_EFF_RD_PREAMBLE_TRAIN_ENABLE)
-           {
-               rd_pre_train_mode = 0xFF;
-           }
-           else if (rd_pre_train_mode == ENUM_ATTR_EFF_RD_PREAMBLE_TRAIN_DISABLE)
-           {
-               rd_pre_train_mode = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) rd_pre_train_mode, 10, 1);
-	   break;
-       case ATTR_EFF_RD_PREAMBLE:
-	   if (rd_preamble == ENUM_ATTR_EFF_RD_PREAMBLE_1NCLK)
-           {
-               rd_preamble = 0x00;
-           }
-           else if (rd_preamble == ENUM_ATTR_EFF_RD_PREAMBLE_2NCLK)
-           {
-               rd_preamble = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) rd_preamble, 11, 1);
-	   break;
-       case ATTR_EFF_WR_PREAMBLE:
-           if (wr_preamble == ENUM_ATTR_EFF_WR_PREAMBLE_1NCLK)
-           {
-               wr_preamble = 0x00;
-           }
-           else if (wr_preamble == ENUM_ATTR_EFF_WR_PREAMBLE_2NCLK)
-           {
-               wr_preamble = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) wr_preamble, 12, 1);
-	   break;
-       case ATTR_EFF_CA_PARITY_LATENCY:
-	   if (ca_parity_latency == 4)
-           {
-               ca_parity_latency = 0x80;
-           }
-           else if (ca_parity_latency == 5)
-           {
-               ca_parity_latency = 0x40;
-           }
-           else if (ca_parity_latency == 6)
-           {
-               ca_parity_latency = 0xC0;
-           }
-           else if (ca_parity_latency == 8)
-           {
-               ca_parity_latency = 0x20;
-           }
-           else if (ca_parity_latency == ENUM_ATTR_EFF_CA_PARITY_LATENCY_DISABLE)
-           {
-               ca_parity_latency = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) ca_parity_latency, 0, 2);
-	   break;
-       case ATTR_EFF_CRC_ERROR_CLEAR:
-	   if (crc_error_clear == ENUM_ATTR_EFF_CRC_ERROR_CLEAR_ERROR)
-           {
-               crc_error_clear = 0xFF;
-           }
-           else if (crc_error_clear == ENUM_ATTR_EFF_CRC_ERROR_CLEAR_CLEAR)
-           {
-               crc_error_clear = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) crc_error_clear, 3, 1);
-	   break;
-       case ATTR_EFF_CA_PARITY_ERROR_STATUS:
-	   if (ca_parity_error_status == ENUM_ATTR_EFF_CA_PARITY_ERROR_STATUS_ERROR)
-           {
-               ca_parity_error_status = 0xFF;
-           }
-           else if (ca_parity_error_status == ENUM_ATTR_EFF_CA_PARITY_ERROR_STATUS_CLEAR)
-           {
-               ca_parity_error_status = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) ca_parity_error_status, 4, 1);
-	   break;
-       case ATTR_EFF_ODT_INPUT_BUFF:
-	   if (odt_input_buffer == ENUM_ATTR_EFF_ODT_INPUT_BUFF_ACTIVATED)
-           {
-               odt_input_buffer = 0x00;
-           }
-           else if (odt_input_buffer == ENUM_ATTR_EFF_ODT_INPUT_BUFF_DEACTIVATED)
-           {
-               odt_input_buffer = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) odt_input_buffer, 5, 1);
-	   break;
-       case ATTR_VPD_DRAM_RTT_PARK:
-	   if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_DISABLE)
-           {
-               rtt_park = 0x00;
-           }
-           else if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_60OHM)
-           {
-               rtt_park = 0x80;
-           }
-           else if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_40OHM)
-           {
-               rtt_park = 0xC0;
-           }
-           else if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_120OHM)
-           {
-               rtt_park = 0x40;
-           }
-           else if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_240OHM)
-           {
-               rtt_park = 0x20;
-           }
-           else if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_48OHM)
-           {
-               rtt_park = 0xA0;
-           }
-           else if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_80OHM)
-           {
-               rtt_park = 0x60;
-           }
-           else if (rtt_park == ENUM_ATTR_VPD_DRAM_RTT_PARK_34OHM)
-           {
-               rtt_park = 0xE0;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) rtt_park, 6, 3);
-	   break;
-       case ATTR_EFF_CA_PARITY:
-	   if (ca_parity == ENUM_ATTR_EFF_CA_PARITY_ENABLE)
-           {
-               ca_parity = 0xFF;
-           }
-           else if (ca_parity == ENUM_ATTR_EFF_CA_PARITY_DISABLE)
-           {
-               ca_parity = 0x00;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) ca_parity, 9, 1);
-	   break;
-       case ATTR_EFF_DATA_MASK:
-	   if (data_mask == ENUM_ATTR_EFF_DATA_MASK_DISABLE)
-           {
-               data_mask = 0x00;
-           }
-           else if (data_mask == ENUM_ATTR_EFF_DATA_MASK_ENABLE)
-           {
-               data_mask = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) data_mask, 10, 1);
-	   break;
-       case ATTR_EFF_WRITE_DBI:
-	   if (write_dbi == ENUM_ATTR_EFF_WRITE_DBI_DISABLE)
-           {
-               write_dbi = 0x00;
-           }
-           else if (write_dbi == ENUM_ATTR_EFF_WRITE_DBI_ENABLE)
-           {
-               write_dbi = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) write_dbi, 11, 1);
-	   break;
-       case ATTR_EFF_READ_DBI:
-           if (read_dbi == ENUM_ATTR_EFF_READ_DBI_DISABLE)
-           {
-               read_dbi = 0x00;
-           }
-           else if (read_dbi == ENUM_ATTR_EFF_READ_DBI_ENABLE)
-           {
-               read_dbi = 0xFF;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) read_dbi, 12, 1);
-	   break;
-       case ATTR_EFF_VREF_DQ_TRAIN_VALUE:
-	   vrefdq_train_value = mss_reverse_8bits(vrefdq_train_value);
-           rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_value, 0, 6);
-	   break;
-       case ATTR_EFF_VREF_DQ_TRAIN_RANGE:
-	   if (vrefdq_train_range == ENUM_ATTR_EFF_VREF_DQ_TRAIN_RANGE_RANGE1)
-           {
-               vrefdq_train_range = 0x00;
-           }
-           else if (vrefdq_train_range == ENUM_ATTR_EFF_VREF_DQ_TRAIN_RANGE_RANGE2)
-           {
-               vrefdq_train_range = 0xFF;
-           } 
-           rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_range, 6, 1);
-	   break;
-       case ATTR_EFF_VREF_DQ_TRAIN_ENABLE:
-	   if (vrefdq_train_enable == ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE)
-           {
-               vrefdq_train_enable = 0xFF;
-           }
-           else if (vrefdq_train_enable == ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_DISABLE)
-           {
-               vrefdq_train_enable = 0x00;
-           }   
-           rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_enable, 7, 1);
-	   break;
-       case ATTR_TCCD_L:
-           if (tccd_l == 4)
-           {
-               tccd_l = 0x00;
-           }
-           else if (tccd_l == 5)
-           {
-               tccd_l = 0x80;
-           }
-           else if (tccd_l == 6)
-           {
-               tccd_l = 0x40;
-           }	
-           else if (tccd_l == 7)
-           {
-               tccd_l = 0xC0;
-           }
-           else if (tccd_l == 8)
-           {
-               tccd_l = 0x20;
-           }
-           rc_num = rc_num | address_16.insert((uint8_t) tccd_l, 10, 3);
-	   break;
-	//MRS attribute not found, error out
-      default: 
-         const uint32_t NONMRS_ATTR_NAME = attribute_name;
-	 const fapi::Target & MBA_TARGET = i_target; 
-	 FAPI_SET_HWP_ERROR(rc, RC_MSS_PDA_NONMRS_ATTR_NAME);
-	 FAPI_ERR("ERROR!! Found attribute name not associated with an MRS! Exiting...");
-   }
-   if (rc_num)
-   {
-       FAPI_ERR( "mss_ddr4_modify_mrs_pda: Error setting up buffers");
-       rc.setEcmdError(rc_num);
-       return rc;
-   }
-   return rc;
-}
 
-//////////////////////////////////////////////////////////////////////////////////
-/// mss_ddr4_load_nominal_mrs_pda
-/// disables per-DRAM addressability funcitonality on both ports on the passed MBA
-//////////////////////////////////////////////////////////////////////////////////
-ReturnCode mss_ddr4_load_nominal_mrs_pda(Target& i_target,ecmdDataBufferBase& bank_3,ecmdDataBufferBase& address_16,uint8_t MRS,uint8_t i_port_number, uint8_t dimm_number, uint8_t rank_number) {
+//sets up the ODT holdtime and number of idles to be issued after 
+ReturnCode mss_get_pda_odt_timings(Target& i_target,uint8_t & wl_launch_time,uint8_t & odt_hold_time,uint8_t & post_odt_nop_idle) {
     ReturnCode rc;  
     ReturnCode rc_buff;
     uint32_t rc_num = 0;
+    ecmdDataBufferBase data_buffer(64);
     
-    rc_num = rc_num | address_16.clearBit(0,16);
-    rc_num = rc_num | bank_3.clearBit(0,3);
-    if (rc_num)
+    //reads out the register values
+    rc = fapiGetScom(i_target, MBA01_MBA_DSM0_0x0301040a, data_buffer);
+    if(rc) return rc;
+    
+    //gets the hold time
+    uint8_t launch_delay;
+    rc_num = rc_num | data_buffer.extractToRight(&launch_delay,12,6);
+    rc_num = rc_num | data_buffer.extractToRight(&odt_hold_time,18,6);
+    
+    odt_hold_time = odt_hold_time + launch_delay;
+    
+    if(rc_num)
     {
-    	FAPI_ERR( "mss_mrs_load: Error setting up buffers");
-    	rc_buff.setEcmdError(rc_num);
-    	return rc_buff;
-    }
-
-    //Lines commented out in the following section are waiting for xml attribute adds
-    //MRS0
-    if(MRS == MRS0_BA) {
-    	uint8_t dram_bl;
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_BL, &i_target, dram_bl);
-    	if(rc) return rc;
-    	uint8_t read_bt; //Read Burst Type 
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_RBT, &i_target, read_bt);
-    	if(rc) return rc;
-    	uint8_t dram_cl;
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_CL, &i_target, dram_cl);
-    	if(rc) return rc;
-    	uint8_t test_mode; //TEST MODE 
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_TM, &i_target, test_mode);
-    	if(rc) return rc;
-    	uint8_t dll_reset; //DLL Reset 
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_DLL_RESET, &i_target, dll_reset);
-    	if(rc) return rc;
-    	uint8_t dram_wr; //DRAM write recovery
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_WR, &i_target, dram_wr);
-    	if(rc) return rc;
-    	uint8_t dram_rtp; //DRAM RTP - read to precharge
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_TRTP, &i_target, dram_rtp);
-    	if(rc) return rc;
-    	uint8_t dll_precharge; //DLL Control For Precharge 
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_DLL_PPD, &i_target, dll_precharge);
-    	if(rc) return rc;
-
-    	if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_BL8)
-    	{
-    	    dram_bl = 0x00;
-    	}
-    	else if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_OTF)
-    	{
-    	    dram_bl = 0x80;
-    	}
-    	else if (dram_bl == ENUM_ATTR_EFF_DRAM_BL_BC4)
-    	{
-    	    dram_bl = 0x40;
-    	}
-
-    	uint8_t dram_wr_rtp = 0x00;
-    	if ( (dram_wr == 10) )//&& (dram_rtp == 5) )
-    	{
-    	    dram_wr_rtp = 0x00;
-    	}
-    	else if ( (dram_wr == 12) )//&& (dram_rtp == 6) )
-    	{
-    	    dram_wr_rtp = 0x80;
-    	}
-    	else if ( (dram_wr == 13) )//&& (dram_rtp == 7) )
-    	{
-    	    dram_wr_rtp = 0x40;
-    	}
-    	else if ( (dram_wr == 14) )//&& (dram_rtp == 8) )
-    	{
-    	    dram_wr_rtp = 0xC0;
-    	}
-    	else if ( (dram_wr == 18) )//&& (dram_rtp == 9) )
-    	{
-    	    dram_wr_rtp = 0x20;
-    	}
-    	else if ( (dram_wr == 20) )//&& (dram_rtp == 10) )
-    	{
-    	    dram_wr_rtp = 0xA0;
-    	}
-    	else if ( (dram_wr == 24) )//&& (dram_rtp == 12) )
-    	{
-    	    dram_wr_rtp = 0x60;
-    	}
-
-    	if (read_bt == ENUM_ATTR_EFF_DRAM_RBT_SEQUENTIAL)
-    	{
-    	    read_bt = 0x00;
-    	}
-    	else if (read_bt == ENUM_ATTR_EFF_DRAM_RBT_INTERLEAVE)
-    	{
-    	    read_bt = 0xFF;
-    	}
-
-    	if ((dram_cl > 8)&&(dram_cl < 17))
-    	{
-    	    dram_cl = dram_cl - 9; 
-    	}
-    	else if ((dram_cl > 17)&&(dram_cl < 25))
-    	{
-    	    dram_cl = (dram_cl >> 1) - 1;   
-    	}
-    	dram_cl = mss_reverse_8bits(dram_cl);
-
-    	if (test_mode == ENUM_ATTR_EFF_DRAM_TM_NORMAL)
-    	{
-    	    test_mode = 0x00;
-    	}
-    	else if (test_mode == ENUM_ATTR_EFF_DRAM_TM_TEST)
-    	{
-    	    test_mode = 0xFF;
-    	}
-	
-	FAPI_INF("Overwriting DLL reset with values to not reset the DRAM.");
-    	dll_reset = 0x00;
-
-    	if (dll_precharge == ENUM_ATTR_EFF_DRAM_DLL_PPD_SLOWEXIT)
-    	{
-    	    dll_precharge = 0x00;
-    	}
-    	else if (dll_precharge == ENUM_ATTR_EFF_DRAM_DLL_PPD_FASTEXIT)
-    	{
-    	    dll_precharge = 0xFF;
-    	}
-	//For DDR4:
-	//Address 14 = Address 17, Address 15 = BG1
-        rc_num = rc_num | address_16.insert((uint8_t) dram_bl, 0, 2, 0);
-        rc_num = rc_num | address_16.insert((uint8_t) dram_cl, 2, 1, 0);
-        rc_num = rc_num | address_16.insert((uint8_t) read_bt, 3, 1, 0);
-        rc_num = rc_num | address_16.insert((uint8_t) dram_cl, 4, 3, 1);
-        rc_num = rc_num | address_16.insert((uint8_t) test_mode, 7, 1);
-        rc_num = rc_num | address_16.insert((uint8_t) dll_reset, 8, 1);
-	rc_num = rc_num | address_16.insert((uint8_t) dram_wr_rtp, 9, 3);
-	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 12, 4);
-	
-	rc_num = rc_num | bank_3.insert((uint8_t) MRS0_BA, 0, 1, 7);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS0_BA, 1, 1, 6);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS0_BA, 2, 1, 5);
-	if (rc_num)
-        {
-            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
-            rc_buff.setEcmdError(rc_num);
-            return rc_buff;
-        }
+	rc.setEcmdError(rc_num);
+	return rc;
     }
     
-    //MRS1
-    else if(MRS == MRS1_BA) {
-    	uint8_t dll_enable; //DLL Enable 
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_DLL_ENABLE, &i_target, dll_enable);
-    	if(rc) return rc;
-    	uint8_t out_drv_imp_cntl[2][2];
-    	rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_RON, &i_target, out_drv_imp_cntl);
-    	if(rc) return rc;
-    	uint8_t dram_rtt_nom[2][2][4];
-    	rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_RTT_NOM, &i_target, dram_rtt_nom);
-    	if(rc) return rc;
-    	uint8_t dram_al;
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_AL, &i_target, dram_al);
-    	if(rc) return rc;
-    	uint8_t wr_lvl; //write leveling enable
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_WR_LVL_ENABLE, &i_target, wr_lvl);
-    	if(rc) return rc;
-    	uint8_t tdqs_enable; //TDQS Enable 
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_TDQS, &i_target, tdqs_enable);
-    	if(rc) return rc;
-    	uint8_t q_off; //Qoff - Output buffer Enable 
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_OUTPUT_BUFFER, &i_target, q_off);
-    	if(rc) return rc;
-
-    	if (dll_enable == ENUM_ATTR_EFF_DRAM_DLL_ENABLE_DISABLE)
-    	{
-    	    dll_enable = 0x00;
-    	}
-    	else if (dll_enable == ENUM_ATTR_EFF_DRAM_DLL_ENABLE_ENABLE)
-    	{
-    	    dll_enable = 0xFF;
-    	}
-
-    	if (dram_al == ENUM_ATTR_EFF_DRAM_AL_DISABLE)
-    	{
-    	    dram_al = 0x00;
-    	}
-    	else if (dram_al == ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_1)
-    	{
-    	    dram_al = 0x80;
-    	}
-    	else if (dram_al == ENUM_ATTR_EFF_DRAM_AL_CL_MINUS_2)
-    	{
-    	    dram_al = 0x40;
-    	}
-
-    	if (wr_lvl == ENUM_ATTR_EFF_DRAM_WR_LVL_ENABLE_DISABLE)
-    	{
-    	    wr_lvl = 0x00;
-    	}
-    	else if (wr_lvl == ENUM_ATTR_EFF_DRAM_WR_LVL_ENABLE_ENABLE)
-    	{
-    	    wr_lvl = 0xFF;
-    	}
-
-    	if (tdqs_enable == ENUM_ATTR_EFF_DRAM_TDQS_DISABLE)
-    	{
-    	    tdqs_enable = 0x00;
-    	}
-    	else if (tdqs_enable == ENUM_ATTR_EFF_DRAM_TDQS_ENABLE)
-    	{
-    	    tdqs_enable = 0xFF;
-    	}
-
-    	if (q_off == ENUM_ATTR_EFF_DRAM_OUTPUT_BUFFER_DISABLE)
-    	{
-    	    q_off = 0xFF;
-    	}
-    	else if (q_off == ENUM_ATTR_EFF_DRAM_OUTPUT_BUFFER_ENABLE)
-    	{
-    	    q_off = 0x00;
-    	}
-        if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_DISABLE)
-        {
-            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0x00;
-        }
-        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM240) //not supported
-        {
-            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0x20;
-        }
-        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM48) //not supported
-        {
-            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0xA0;
-        }
-        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM40)
-        {
-            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0xC0;
-        }
-        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM60)
-        {
-            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0x80;
-        }
-        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM120)
-        {
-            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0x40;
-        }
-        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM80) // not supported
-        {
-            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0x60;
-        }
-        else if (dram_rtt_nom[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_NOM_OHM34) // not supported
-        {
-            dram_rtt_nom[i_port_number][dimm_number][rank_number] = 0xE0;
-        }
-
-        if (out_drv_imp_cntl[i_port_number][dimm_number] == ENUM_ATTR_VPD_DRAM_RON_OHM34)
-        {
-            out_drv_imp_cntl[i_port_number][dimm_number] = 0x00;
-        }
-	// Not currently supported
-        else if (out_drv_imp_cntl[i_port_number][dimm_number] == ENUM_ATTR_VPD_DRAM_RON_OHM48) //not supported
-        {
-            out_drv_imp_cntl[i_port_number][dimm_number] = 0x80;
-        }
-
-	//For DDR4:
-	//Address 14 = Address 17, Address 15 = BG1
-        rc_num = rc_num | address_16.insert((uint8_t) dll_enable, 0, 1, 0);
-        rc_num = rc_num | address_16.insert((uint8_t) out_drv_imp_cntl[i_port_number][dimm_number], 1, 2, 0);
-        rc_num = rc_num | address_16.insert((uint8_t) dram_al, 3, 2, 0);
-        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 5, 2);
-        rc_num = rc_num | address_16.insert((uint8_t) wr_lvl, 7, 1, 0);
-        rc_num = rc_num | address_16.insert((uint8_t) dram_rtt_nom[i_port_number][dimm_number][rank_number], 8, 3, 0);
-        rc_num = rc_num | address_16.insert((uint8_t) tdqs_enable, 11, 1, 0);
-        rc_num = rc_num | address_16.insert((uint8_t) q_off, 12, 1, 0);
-        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 13, 3);
-	
-	rc_num = rc_num | bank_3.insert((uint8_t) MRS1_BA, 0, 1, 7);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS1_BA, 1, 1, 6);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS1_BA, 2, 1, 5);
-	if (rc_num)
-        {
-            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
-            rc_buff.setEcmdError(rc_num);
-            return rc_buff;
-        }
-    }
-    //MRS2
-    else if(MRS == MRS2_BA) {
-    	uint8_t lpasr; // Low Power Auto Self-Refresh -- new not yet supported
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_LPASR, &i_target, lpasr);
-    	if(rc) return rc;
-    	uint8_t cwl; // CAS Write Latency 
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_CWL, &i_target, cwl);
-    	if(rc) return rc;
-    	uint8_t dram_rtt_wr[2][2][4];
-    	rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_RTT_WR, &i_target, dram_rtt_wr);
-    	if(rc) return rc;
-    	uint8_t write_crc; // CAS Write Latency 
-    	rc = FAPI_ATTR_GET(ATTR_EFF_WRITE_CRC, &i_target, write_crc);
-    	if(rc) return rc;
-
-    	if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_NORMAL)
-    	{
-    	    lpasr = 0x00;
-    	}
-    	else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_REDUCED)
-    	{
-    	    lpasr = 0x80;
-    	}
-    	else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_MANUAL_EXTENDED)
-    	{
-    	    lpasr = 0x40;
-    	}
-    	else if (lpasr == ENUM_ATTR_EFF_DRAM_LPASR_ASR)
-    	{
-    	    lpasr = 0xFF;
-    	}
-
-    	if ((cwl > 8)&&(cwl < 13))
-    	{
-    	    cwl = cwl - 9; 
-    	}
-    	else if ((cwl > 13)&&(cwl < 19))
-    	{
-    	    cwl = (cwl >> 1) - 3;   
-    	}
-    	else
-    	{
-    	   //no correcct value for CWL was found
-    	   FAPI_INF("ERROR: Improper CWL value found. Setting CWL to 9 and continuing...");
-    	   cwl = 0;
-    	}
-    	cwl = mss_reverse_8bits(cwl);
-
-    	if ( write_crc == ENUM_ATTR_EFF_WRITE_CRC_ENABLE)
-    	{
-    	    write_crc = 0xFF;
-    	}
-    	else if (write_crc == ENUM_ATTR_EFF_WRITE_CRC_DISABLE)
-    	{
-    	    write_crc = 0x00;
-    	}
-	if (dram_rtt_wr[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_WR_DISABLE)
-        {
-            dram_rtt_wr[i_port_number][dimm_number][rank_number] = 0x00;
-        }
-        else if (dram_rtt_wr[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_WR_OHM120)
-        {
-            dram_rtt_wr[i_port_number][dimm_number][rank_number] = 0x80;
-        }
-        else if (dram_rtt_wr[i_port_number][dimm_number][rank_number] == 240)//ENUM_ATTR_EFF_DRAM_RTT_WR_OHM240)
-        {
-            dram_rtt_wr[i_port_number][dimm_number][rank_number] = 0x40;
-        }
-        else if (dram_rtt_wr[i_port_number][dimm_number][rank_number] == 0xFF)//ENUM_ATTR_EFF_DRAM_RTT_WR_HIGHZ)
-        {
-            dram_rtt_wr[i_port_number][dimm_number][rank_number] = 0xFF;
-        }
-
-        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 0, 3);
-        rc_num = rc_num | address_16.insert((uint8_t) cwl, 3, 3);
-        rc_num = rc_num | address_16.insert((uint8_t) lpasr, 6, 2);
-        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 8, 1);
-        rc_num = rc_num | address_16.insert((uint8_t) dram_rtt_wr[i_port_number][dimm_number][rank_number], 9, 2);
-        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 11, 1);
-        rc_num = rc_num | address_16.insert((uint8_t) write_crc, 12, 1);
-        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 13, 2);
-	
-	rc_num = rc_num | bank_3.insert((uint8_t) MRS2_BA, 0, 1, 7);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS2_BA, 1, 1, 6);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS2_BA, 2, 1, 5);
-	if (rc_num)
-        {
-            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
-            rc_buff.setEcmdError(rc_num);
-            return rc_buff;
-        }
-    }
-    //MRS3
-    else if(MRS == MRS3_BA) {
-    	uint8_t mpr_op; // MPR Op
-    	rc = FAPI_ATTR_GET(ATTR_EFF_MPR_MODE, &i_target, mpr_op);
-    	if(rc) return rc;
-    	uint8_t mpr_page; // MPR Page Selection  - NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_MPR_PAGE, &i_target, mpr_page);
-    	if(rc) return rc;
-    	uint8_t geardown_mode; // Gear Down Mode  - NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_GEARDOWN_MODE, &i_target, geardown_mode);
-    	if(rc) return rc;
-    	uint8_t temp_readout; // Temperature sensor readout  - NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_TEMP_READOUT, &i_target, temp_readout);
-    	if(rc) return rc;
-    	uint8_t fine_refresh; // fine refresh mode  - NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_FINE_REFRESH_MODE, &i_target, fine_refresh);
-    	if(rc) return rc;
-    	uint8_t wr_latency; // write latency for CRC and DM  - NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_CRC_WR_LATENCY, &i_target, wr_latency);
-    	if(rc) return rc;
-    	uint8_t read_format; // MPR READ FORMAT  - NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_MPR_RD_FORMAT, &i_target, read_format);
-    	if(rc) return rc;
-
-    	if (mpr_op == ENUM_ATTR_EFF_MPR_MODE_ENABLE)
-    	{
-    	    mpr_op = 0xFF;
-    	}
-    	else if (mpr_op == ENUM_ATTR_EFF_MPR_MODE_DISABLE)
-    	{
-    	    mpr_op = 0x00;
-    	}
-
-    	mpr_page = mss_reverse_8bits(mpr_page);
-
-    	if ( geardown_mode == ENUM_ATTR_EFF_GEARDOWN_MODE_HALF)
-    	{
-    	     geardown_mode = 0x00;
-    	}
-    	else if ( geardown_mode == ENUM_ATTR_EFF_GEARDOWN_MODE_QUARTER)
-    	{
-    	     geardown_mode = 0xFF;
-    	}
-    	
-    	if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_ENABLE)
-    	{
-    	    temp_readout = 0xFF;
-    	}
-    	else if (temp_readout == ENUM_ATTR_EFF_TEMP_READOUT_DISABLE)
-    	{
-    	    temp_readout = 0x00;
-    	}
-
-    	if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_NORMAL)
-    	{
-    	    fine_refresh = 0x00;
-    	}
-    	else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FIXED_2X)
-    	{
-    	    fine_refresh = 0x80;
-    	}
-    	else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FIXED_4X)
-    	{
-    	    fine_refresh = 0x40;
-    	}
-    	else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FLY_2X)
-    	{
-    	    fine_refresh = 0xA0;
-    	}
-    	else if (fine_refresh == ENUM_ATTR_EFF_FINE_REFRESH_MODE_FLY_4X)
-    	{
-    	    fine_refresh = 0x60;
-    	}
-
-    	if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_4NCK)
-    	{
-    	    wr_latency = 0x00;
-    	}
-    	else if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_5NCK)
-    	{
-    	    wr_latency = 0x80;
-    	}
-    	else if (wr_latency == ENUM_ATTR_EFF_CRC_WR_LATENCY_6NCK)
-    	{
-    	    wr_latency = 0xC0;
-    	}
-
-    	if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_SERIAL)
-    	{
-    	    read_format = 0x00;
-    	}
-    	else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_PARALLEL)
-    	{
-    	    read_format = 0x80;
-    	}
-    	else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_STAGGERED)
-    	{
-    	    read_format = 0x40;
-    	}
-    	else if (read_format == ENUM_ATTR_EFF_MPR_RD_FORMAT_RESERVED_TEMP)
-    	{
-    	    read_format = 0xC0;
-    	}
-	
-	rc_num = rc_num | address_16.insert((uint8_t) mpr_page, 0, 2);
-        rc_num = rc_num | address_16.insert((uint8_t) mpr_op, 2, 1);
-        rc_num = rc_num | address_16.insert((uint8_t) geardown_mode, 3, 1);
-        rc_num = rc_num | address_16.insert((uint8_t) 0xFF, 4, 1); //has PDA mode enabled!!!! just for this code!
-        rc_num = rc_num | address_16.insert((uint8_t) temp_readout, 5, 1);
-        rc_num = rc_num | address_16.insert((uint8_t) fine_refresh, 6, 3);
-        rc_num = rc_num | address_16.insert((uint8_t) wr_latency, 9, 2);
-        rc_num = rc_num | address_16.insert((uint8_t) read_format, 11, 2);
-        rc_num = rc_num | address_16.insert((uint8_t) 0x00, 13, 2);
-	
-	rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 0, 1, 7);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 1, 1, 6);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS3_BA, 2, 1, 5);
-	if (rc_num)
-        {
-            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
-            rc_buff.setEcmdError(rc_num);
-            return rc_buff;
-        }
-    }
-    //MRS4
-    else if(MRS == MRS4_BA) {
-    	uint8_t max_pd_mode; // Max Power down mode -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_MAX_POWERDOWN_MODE, &i_target, max_pd_mode);
-    	if(rc) return rc;
-    	uint8_t temp_ref_range; // Temp ref range -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_TEMP_REF_RANGE, &i_target, temp_ref_range);
-    	if(rc) return rc;
-    	uint8_t temp_ref_mode; // Temp controlled ref mode -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_TEMP_REF_MODE, &i_target, temp_ref_mode);
-    	if(rc) return rc;
-    	uint8_t vref_mon; // Internal Vref Monitor -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_INT_VREF_MON, &i_target, vref_mon);
-    	if(rc) return rc;
-    	uint8_t cs_cmd_latency; // CS to CMD/ADDR Latency -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_CS_CMD_LATENCY, &i_target, cs_cmd_latency);
-    	if(rc) return rc;
-    	uint8_t ref_abort; // Self Refresh Abort -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_SELF_REF_ABORT, &i_target, ref_abort);
-    	if(rc) return rc;
-    	uint8_t rd_pre_train_mode; // Read Pre amble Training Mode -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_RD_PREAMBLE_TRAIN, &i_target, rd_pre_train_mode);
-    	if(rc) return rc;
-    	uint8_t rd_preamble; // Read Pre amble -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_RD_PREAMBLE, &i_target, rd_preamble);
-    	if(rc) return rc;
-    	uint8_t wr_preamble; // Write Pre amble -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_WR_PREAMBLE, &i_target, wr_preamble);
-    	if(rc) return rc;
-
-    	if ( max_pd_mode == ENUM_ATTR_EFF_MAX_POWERDOWN_MODE_ENABLE)
-    	{
-    	    max_pd_mode = 0xF0;
-    	}
-    	else if ( max_pd_mode == ENUM_ATTR_EFF_MAX_POWERDOWN_MODE_DISABLE)
-    	{
-    	    max_pd_mode = 0x00;
-    	}
-
-    	if (temp_ref_range == ENUM_ATTR_EFF_TEMP_REF_RANGE_NORMAL)
-    	{
-    	    temp_ref_range = 0x00;
-    	}
-    	else if ( temp_ref_range== ENUM_ATTR_EFF_TEMP_REF_RANGE_EXTEND)
-    	{
-    	    temp_ref_range = 0xFF;
-    	}
-
-    	if (temp_ref_mode == ENUM_ATTR_EFF_TEMP_REF_MODE_ENABLE)
-    	{
-    	    temp_ref_mode = 0x80;
-    	}
-    	else if (temp_ref_mode == ENUM_ATTR_EFF_TEMP_REF_MODE_DISABLE)
-    	{
-    	    temp_ref_mode = 0x00;
-    	}
-
-    	if ( vref_mon == ENUM_ATTR_EFF_INT_VREF_MON_ENABLE)
-    	{
-    	    vref_mon = 0xFF;
-    	}
-    	else if ( vref_mon == ENUM_ATTR_EFF_INT_VREF_MON_DISABLE)
-    	{
-    	    vref_mon = 0x00;
-    	}
-
-
-    	if ( cs_cmd_latency == 3)
-    	{
-    	    cs_cmd_latency = 0x80;
-    	}
-    	else if (cs_cmd_latency == 4)
-    	{
-    	    cs_cmd_latency = 0x40;
-    	}
-    	else if (cs_cmd_latency == 5)
-    	{
-    	    cs_cmd_latency = 0xC0;
-    	}
-    	else if (cs_cmd_latency == 6)
-    	{
-    	    cs_cmd_latency = 0x20;
-    	}
-    	else if (cs_cmd_latency == 8)
-    	{
-    	    cs_cmd_latency = 0xA0;
-    	}
-
-    	if (ref_abort == ENUM_ATTR_EFF_SELF_REF_ABORT_ENABLE)
-    	{
-    	    ref_abort = 0xFF;
-    	}
-    	else if (ref_abort == ENUM_ATTR_EFF_SELF_REF_ABORT_DISABLE)
-    	{
-    	    ref_abort = 0x00;
-    	}
-
-    	if (rd_pre_train_mode == ENUM_ATTR_EFF_RD_PREAMBLE_TRAIN_ENABLE)
-    	{
-    	    rd_pre_train_mode = 0xFF;
-    	}
-    	else if (rd_pre_train_mode == ENUM_ATTR_EFF_RD_PREAMBLE_TRAIN_DISABLE)
-    	{
-    	    rd_pre_train_mode = 0x00;
-    	}
-
-    	if (rd_preamble == ENUM_ATTR_EFF_RD_PREAMBLE_1NCLK)
-    	{
-    	    rd_preamble = 0x00;
-    	}
-    	else if (rd_preamble == ENUM_ATTR_EFF_RD_PREAMBLE_2NCLK)
-    	{
-    	    rd_preamble = 0xFF;
-    	}
-
-    	if (wr_preamble == ENUM_ATTR_EFF_WR_PREAMBLE_1NCLK)
-    	{
-    	    wr_preamble = 0x00;
-    	}
-    	else if (wr_preamble == ENUM_ATTR_EFF_WR_PREAMBLE_2NCLK)
-    	{
-    	    wr_preamble = 0xFF;
-    	}
-    	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 0, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) max_pd_mode, 1, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) temp_ref_range, 2, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) temp_ref_mode, 3, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) vref_mon, 4, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 5, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) cs_cmd_latency, 6, 3);
-    	rc_num = rc_num | address_16.insert((uint8_t) ref_abort, 9, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) rd_pre_train_mode, 10, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) rd_preamble, 11, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) wr_preamble, 12, 1);
-	
-	rc_num = rc_num | bank_3.insert((uint8_t) MRS4_BA, 0, 1, 7);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS4_BA, 1, 1, 6);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS4_BA, 2, 1, 5);
-	if (rc_num)
-        {
-            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
-            rc_buff.setEcmdError(rc_num);
-            return rc_buff;
-        }
-    }
-    //MRS5
-    else if(MRS == MRS5_BA) {
-    	uint8_t ca_parity_latency; //C/A Parity Latency Mode  -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_CA_PARITY_LATENCY , &i_target, ca_parity_latency);
-    	if(rc) return rc;
-    	uint8_t crc_error_clear; //CRC Error Clear  -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_CRC_ERROR_CLEAR , &i_target, crc_error_clear);
-    	if(rc) return rc;
-    	uint8_t ca_parity_error_status; //C/A Parity Error Status  -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_CA_PARITY_ERROR_STATUS , &i_target, ca_parity_error_status);
-    	if(rc) return rc;
-    	uint8_t odt_input_buffer; //ODT Input Buffer during power down  -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_ODT_INPUT_BUFF , &i_target, odt_input_buffer);
-    	if(rc) return rc;
-    	uint8_t rtt_park[2][2][4]; //RTT_Park value  -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_RTT_PARK , &i_target, rtt_park);
-    	if(rc) return rc;
-    	uint8_t ca_parity; //CA Parity Persistance Error  -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_CA_PARITY , &i_target, ca_parity);
-    	if(rc) return rc;
-    	uint8_t data_mask; //Data Mask  -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_DATA_MASK , &i_target, data_mask);
-    	if(rc) return rc;
-    	uint8_t write_dbi; //Write DBI  -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_WRITE_DBI , &i_target, write_dbi);
-    	if(rc) return rc;
-    	uint8_t read_dbi; //Read DBI  -  NEW
-    	rc = FAPI_ATTR_GET(ATTR_EFF_READ_DBI , &i_target, read_dbi);
-    	if(rc) return rc;
-
-
-    	if (ca_parity_latency == 4)
-    	{
-    	    ca_parity_latency = 0x80;
-    	}
-    	else if (ca_parity_latency == 5)
-    	{
-    	    ca_parity_latency = 0x40;
-    	}
-    	else if (ca_parity_latency == 6)
-    	{
-    	    ca_parity_latency = 0xC0;
-    	}
-    	else if (ca_parity_latency == 8)
-    	{
-    	    ca_parity_latency = 0x20;
-    	}
-    	else if (ca_parity_latency == ENUM_ATTR_EFF_CA_PARITY_LATENCY_DISABLE)
-    	{
-    	    ca_parity_latency = 0x00;
-    	}
-
-    	if (crc_error_clear == ENUM_ATTR_EFF_CRC_ERROR_CLEAR_ERROR)
-    	{
-    	    crc_error_clear = 0xFF;
-    	}
-    	else if (crc_error_clear == ENUM_ATTR_EFF_CRC_ERROR_CLEAR_CLEAR)
-    	{
-    	    crc_error_clear = 0x00;
-    	}
-
-    	if (ca_parity_error_status == ENUM_ATTR_EFF_CA_PARITY_ERROR_STATUS_ERROR)
-    	{
-    	    ca_parity_error_status = 0xFF;
-    	}
-    	else if (ca_parity_error_status == ENUM_ATTR_EFF_CA_PARITY_ERROR_STATUS_CLEAR)
-    	{
-    	    ca_parity_error_status = 0x00;
-    	}
-
-    	if (odt_input_buffer == ENUM_ATTR_EFF_ODT_INPUT_BUFF_ACTIVATED)
-    	{
-    	    odt_input_buffer = 0x00;
-    	}
-    	else if (odt_input_buffer == ENUM_ATTR_EFF_ODT_INPUT_BUFF_DEACTIVATED)
-    	{
-    	    odt_input_buffer = 0xFF;
-    	}
-
-
-    	if (ca_parity == ENUM_ATTR_EFF_CA_PARITY_ENABLE)
-    	{
-    	    ca_parity = 0xFF;
-    	}
-    	else if (ca_parity == ENUM_ATTR_EFF_CA_PARITY_DISABLE)
-    	{
-    	    ca_parity = 0x00;
-    	}
-
-    	if (data_mask == ENUM_ATTR_EFF_DATA_MASK_DISABLE)
-    	{
-    	    data_mask = 0x00;
-    	}
-    	else if (data_mask == ENUM_ATTR_EFF_DATA_MASK_ENABLE)
-    	{
-    	    data_mask = 0xFF;
-    	}
-
-    	if (write_dbi == ENUM_ATTR_EFF_WRITE_DBI_DISABLE)
-    	{
-    	    write_dbi = 0x00;
-    	}
-    	else if (write_dbi == ENUM_ATTR_EFF_WRITE_DBI_ENABLE)
-    	{
-    	    write_dbi = 0xFF;
-    	}
-
-    	if (read_dbi == ENUM_ATTR_EFF_READ_DBI_DISABLE)
-    	{
-    	    read_dbi = 0x00;
-    	}
-    	else if (read_dbi == ENUM_ATTR_EFF_READ_DBI_ENABLE)
-    	{
-    	    read_dbi = 0xFF;
-    	}
-    	if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_DISABLE)
-    	{
-    	    rtt_park[i_port_number][dimm_number][rank_number] = 0x00;
-    	}
-    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_60OHM)
-    	{
-    	    rtt_park[i_port_number][dimm_number][rank_number] = 0x80;
-    	}
-    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_40OHM)
-    	{
-    	    rtt_park[i_port_number][dimm_number][rank_number] = 0xC0;
-    	}
-    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_120OHM)
-    	{
-    	    rtt_park[i_port_number][dimm_number][rank_number] = 0x40;
-    	}
-    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_240OHM)
-    	{
-    	    rtt_park[i_port_number][dimm_number][rank_number] = 0x20;
-    	}
-    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_48OHM)
-    	{
-    	    rtt_park[i_port_number][dimm_number][rank_number] = 0xA0;
-    	}
-    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_80OHM)
-    	{
-    	    rtt_park[i_port_number][dimm_number][rank_number] = 0x60;
-    	}
-    	else if (rtt_park[i_port_number][dimm_number][rank_number] == ENUM_ATTR_VPD_DRAM_RTT_PARK_34OHM)
-    	{
-    	    rtt_park[i_port_number][dimm_number][rank_number] = 0xE0;
-    	}
-
-    	rc_num = rc_num | address_16.insert((uint8_t) ca_parity_latency, 0, 2);
-    	rc_num = rc_num | address_16.insert((uint8_t) crc_error_clear, 3, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) ca_parity_error_status, 4, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) odt_input_buffer, 5, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) rtt_park[i_port_number][dimm_number][rank_number], 6, 3);
-    	rc_num = rc_num | address_16.insert((uint8_t) ca_parity, 9, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) data_mask, 10, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) write_dbi, 11, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) read_dbi, 12, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 13, 2);
-	
-	rc_num = rc_num | bank_3.insert((uint8_t) MRS5_BA, 0, 1, 7);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS5_BA, 1, 1, 6);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS5_BA, 2, 1, 5);
-	if (rc_num)
-        {
-            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
-            rc_buff.setEcmdError(rc_num);
-            return rc_buff;
-        }
-    }
-    //MRS6
-    else if(MRS == MRS6_BA) {
-    	uint8_t vrefdq_train_value[2][2][4]; //vrefdq_train value   -  NEW
-    	rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_VALUE, &i_target, vrefdq_train_value);
-    	if(rc) return rc;
-    	uint8_t vrefdq_train_range[2][2][4]; //vrefdq_train range   -  NEW
-    	rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_RANGE, &i_target, vrefdq_train_range);
-    	if(rc) return rc;
-    	uint8_t vrefdq_train_enable[2][2][4]; //vrefdq_train enable  -  NEW
-    	rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target, vrefdq_train_enable);
-    	if(rc) return rc;
-    	uint8_t tccd_l; //tccd_l  -  NEW
-    	rc = FAPI_ATTR_GET( ATTR_TCCD_L, &i_target, tccd_l);
-    	if(rc) return rc;
-    	if (tccd_l == 4)
-    	{
-    	    tccd_l = 0x00;
-    	}
-    	else if (tccd_l == 5)
-    	{
-    	    tccd_l = 0x80;
-    	}
-    	else if (tccd_l == 6)
-    	{
-    	    tccd_l = 0x40;
-    	}    
-    	else if (tccd_l == 7)
-    	{
-    	    tccd_l = 0xC0;
-    	}
-    	else if (tccd_l == 8)
-    	{
-    	    tccd_l = 0x20;
-    	}
-
-    	vrefdq_train_value[i_port_number][dimm_number][rank_number] = mss_reverse_8bits(vrefdq_train_value[i_port_number][dimm_number][rank_number]);
-
-    	if (vrefdq_train_range[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_VREF_DQ_TRAIN_RANGE_RANGE1)
-    	{
-    	    vrefdq_train_range[i_port_number][dimm_number][rank_number] = 0x00;
-    	}
-    	else if (vrefdq_train_range[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_VREF_DQ_TRAIN_RANGE_RANGE2)
-    	{
-    	    vrefdq_train_range[i_port_number][dimm_number][rank_number] = 0xFF;
-    	}   
-
-    	if (vrefdq_train_enable[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_ENABLE)
-    	{
-    	    vrefdq_train_enable[i_port_number][dimm_number][rank_number] = 0xFF;
-    	}
-    	else if (vrefdq_train_enable[i_port_number][dimm_number][rank_number] == ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_DISABLE)
-    	{
-    	    vrefdq_train_enable[i_port_number][dimm_number][rank_number] = 0x00;
-    	}   
-
-    	rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_value[i_port_number][dimm_number][rank_number], 0, 6);
-    	rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_range[i_port_number][dimm_number][rank_number], 6, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) vrefdq_train_enable[i_port_number][dimm_number][rank_number], 7, 1);
-    	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 8, 2);
-    	rc_num = rc_num | address_16.insert((uint8_t) tccd_l, 10, 3);
-    	rc_num = rc_num | address_16.insert((uint8_t) 0x00, 13, 2);
-	
-	rc_num = rc_num | bank_3.insert((uint8_t) MRS6_BA, 0, 1, 7);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS6_BA, 1, 1, 6);
-        rc_num = rc_num | bank_3.insert((uint8_t) MRS6_BA, 2, 1, 5);
-	if (rc_num)
-        {
-            FAPI_ERR( "mss_mrs_load: Error setting up buffers");
-            rc_buff.setEcmdError(rc_num);
-            return rc_buff;
-        }
-    }
-    else {
-        const uint32_t MRS_VALUE = MRS;
-	const fapi::Target & MBA_TARGET = i_target; 
-	FAPI_SET_HWP_ERROR(rc, RC_MSS_PDA_MRS_NOT_FOUND);
-	FAPI_ERR("ERROR!! Found attribute name not associated with an MRS! Exiting...");
+    //gets write latency
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_CWL, &i_target, wl_launch_time);
+    if(rc) return rc;
+    
+    wl_launch_time += launch_delay;
+    
+    uint8_t dram_al;
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_AL, &i_target, dram_al);
+    if(rc) return rc;
+    
+    //Addative latency enabled - need to add CL-AL
+    if(dram_al != ENUM_ATTR_EFF_DRAM_AL_DISABLE) {
+       uint8_t dram_cl;
+       rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_CL, &i_target, dram_cl);
+       if(rc) return rc;
+       wl_launch_time += (dram_cl-dram_al);
     }
     
+    post_odt_nop_idle = wl_launch_time + odt_hold_time + 50;
+    
     return rc;
 }
+
+//returns a 1 if the PDA is empty for the given DIMM rank - returns 0 if not empty
+uint32_t mss_ddr4_check_pda_empty_for_rank(
+	    vector<PDA_MRS_Storage> pda,
+	    uint8_t dimm_to_run,
+	    uint8_t rank_to_run
+            ) {
+   uint32_t rc = 1;
+   
+   for(uint32_t i=0;i<pda.size();i++) {
+      //found, return 0
+      if(pda[i].dimm == dimm_to_run && pda[i].rank == rank_to_run) return 0;
+   }
+   
+   //not found, return 1
+   return rc;
+}
 }
 
diff --git a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_pda.H b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_pda.H
index ac136bd..27b3e36 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_pda.H
+++ b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_ddr4_pda.H
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2015                             */
+/* Contributors Listed Below - COPYRIGHT 2015,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_ddr4_pda.H,v 1.38 2015/07/27 14:49:59 sglancy Exp $
+// $Id: mss_ddr4_pda.H,v 1.41 2016/02/12 19:45:54 sglancy Exp $
 //------------------------------------------------------------------------------
 // *! (C) Copyright International Business Machines Corp. 2013
 // *! All Rights Reserved -- Property of IBM
@@ -42,6 +42,8 @@
 //------------------------------------------------------------------------------
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|-----------------------------------------------
+//  1.7    | 02/16/16 | sglancy | Addressed FW comments
+//  1.6    | 11/09/15 | sglancy | Added new function call
 //  1.5    | 05/13/15 | sglancy | Added dox and updated functions for better FFDC
 //  1.4    | 05/11/15 | sglancy | Addressed FW comments
 //  1.3    | 05/07/15 | sglancy | Updated Doxygen header
@@ -106,16 +108,23 @@ ReturnCode mss_ddr4_run_pda(Target& i_target,vector<PDA_MRS_Storage> pda);
  *
  * @return ReturnCode
  */
-ReturnCode mss_ddr4_setup_pda(Target& i_target,uint32_t& io_ccs_inst_cnt);
+ReturnCode mss_ddr4_setup_pda(
+            Target& i_target,
+            uint32_t& io_ccs_inst_cnt,
+	    uint8_t dimm_to_run,
+	    uint8_t rank_to_run
+            );
 /**
  * @Takes the DRAM out of per-DRAM addressability mode (PDA mode)
  *
  * @param[in]  target:  Reference to centaur.mba target, 
  * @param[in/out]  io_ccs_inst_cnt: starting point of CCS array - needed to properly setup CCS
+ * @param[in]  dimm_to_run: which DIMM to run PDA commands on 
+ * @param[in]  rank_to_run: which rank on which DIMM to run PDA commands on 
  *
  * @return ReturnCode
  */
-ReturnCode mss_ddr4_disable_pda(Target& i_target,uint32_t& io_ccs_inst_cnt);
+ReturnCode mss_ddr4_disable_pda(Target& i_target,uint32_t& io_ccs_inst_cnt, uint8_t dimm_to_run, uint8_t rank_to_run);
 /**
  * @called by wrapper - sets up a PDA vector if it's not already configured
  *
@@ -135,17 +144,6 @@ ReturnCode mss_ddr4_pda(Target& i_target,vector<PDA_MRS_Storage> pda);
  */
 ReturnCode mss_ddr4_checksort_pda(Target& i_target, vector<PDA_MRS_Storage>& pda);
 /**
- * @Modifies the passed in address_16 buffer based upon the given attribute and data
- *
- * @param[in]  target:  Reference to centaur.mba target, 
- * @param[in/out]  ecmdDataBufferBase& address_16:  MRS values - this is modified by the given attribute name and data
- * @param[in]  uint32_t attribute_name:  enumerated value containing the attribute name to be modified - attr_name tells the function which bits to modify
- * @param[in]  uint8_t attribute_data:   data telss the function what values to set to the modified bits
- *
- * @return ReturnCode
- */
-ReturnCode mss_ddr4_modify_mrs_pda(Target& i_target,ecmdDataBufferBase& address_16,uint32_t attribute_name,uint8_t attribute_data);
-/**
  * @Adds a given DRAM into the scom_storage vector
  *
  * @param[in]  target:  Reference to centaur.mba target, 
@@ -156,20 +154,31 @@ ReturnCode mss_ddr4_modify_mrs_pda(Target& i_target,ecmdDataBufferBase& address_
  * @return ReturnCode
  */
 ReturnCode mss_ddr4_add_dram_pda(Target& i_target,uint8_t port,uint8_t dram,vector<PDA_Scom_Storage> & scom_storage);
+
 /**
- * @loads in a nominal MRS value into the address_16 and bank_3
+ * @Adds a given DRAM into the scom_storage vector
  *
  * @param[in]  target:  Reference to centaur.mba target, 
- * @param[out]  ecmdDataBufferBase& bank_3:  bank bits to be issued during MRS
- * @param[out]  ecmdDataBufferBase& address_16:  16 address lanes to be issued during MRS - setup during function
- * @param[in]  uint8_t MRS:  which MRS to configure
- * @param[in]  uint8_t i_port_number: the port on which to configure the MRS - used for ID'ing which attributes to use
- * @param[in]  uint8_t dimm_number: the DIMM on which to configure the MRS - used for ID'ing which attributes to use
- * @param[in]  uint8_t rank_number: the rank on which to configure the MRS - used for ID'ing which attributes to use
+ * @param[out]  uint8_t wl_launch_time:  holds the number of cycles that the data must be launched after the PDA command is issued
+ * @param[out]  uint8_t odt_hold_time:  holds the number of cycles that the ODT must be held for PDA
+ * @param[out]  uint8_t post_odt_nop_idle:  holds the number of cycles that 
  *
  * @return ReturnCode
  */
-ReturnCode mss_ddr4_load_nominal_mrs_pda(Target& i_target,ecmdDataBufferBase& bank_3,ecmdDataBufferBase& address_16,uint8_t MRS,uint8_t i_port_number, uint8_t dimm_number, uint8_t rank_number);
+ReturnCode mss_get_pda_odt_timings(Target& i_target,uint8_t & wl_launch_time,uint8_t & odt_hold_time,uint8_t & post_odt_nop_idle);
+ReturnCode mss_ddr4_run_pda_by_dimm_rank(
+            Target& i_target,
+	    vector<PDA_MRS_Storage> pda,
+	    uint8_t dimm_to_run,
+	    uint8_t rank_to_run
+            );
+
+uint32_t mss_ddr4_check_pda_empty_for_rank(
+	    vector<PDA_MRS_Storage> pda,
+	    uint8_t dimm_to_run,
+	    uint8_t rank_to_run
+            );
+
 } // extern "C"
 
 #endif /* _MSS_DDR4_PDA_H */
diff --git a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_draminit_training_advanced.C b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_draminit_training_advanced.C
index 927a539..cb31b0b 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_draminit_training_advanced.C
+++ b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_draminit_training_advanced.C
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_draminit_training_advanced.C,v 1.58 2015/11/13 16:53:22 dcrowell Exp $
+// $Id: mss_draminit_training_advanced.C,v 1.60 2015/12/08 19:16:51 sglancy Exp $
 /* File is created by SARAVANAN SETHURAMAN on Thur 29 Sept 2011. */
 
 //------------------------------------------------------------------------------
@@ -46,7 +46,7 @@
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|-----------------------------------------------
 //  1.1    | sasethur |30-Sep-11| Initial draft.
-//  1.2    | sasethur |18-Nov-11| Changed function names 
+//  1.2    | sasethur |18-Nov-11| Changed function names
 //  1.3    | sasethur |01-Dec-11| Added details on Vref shmoo, reg addresses
 //  1.4    | sasethur |29-Jan-12| Updated wr&rd vref, removed ecmd workarounds
 //  1.5    | sasethur |13-Feb-12| Updated register naming conventions
@@ -64,24 +64,24 @@
 //  1.20   | bellows  |13-Nov-12| Updated for new SI attributes
 //  1.21   | sasethur |11-Nov-12| Updated for new SI attribute change, fw review comments
 //  1.22   | sasethur |07-Dec-12| Updated for FW review comments - multiple changes
-//  1.23   | sasethur |14-Dec-12| Updated for FW review comments 
-//  1.24   | sasethur |17-Jan-13| Updated for mss_mcbist_common.C include file 
-//  1.25   | abhijsau |31-Jan-13| Removed  mss_mcbist_common.C include file , needs to be included while compiling 
-//  1.26   | abhijsau |06-Mar-13| Fixed fw comment 
+//  1.23   | sasethur |14-Dec-12| Updated for FW review comments
+//  1.24   | sasethur |17-Jan-13| Updated for mss_mcbist_common.C include file
+//  1.25   | abhijsau |31-Jan-13| Removed  mss_mcbist_common.C include file , needs to be included while compiling
+//  1.26   | abhijsau |06-Mar-13| Fixed fw comment
 //  1.27   | sasethur |09-Apr-13| Updated for port in parallel and pass shmoo param
-//  1.28   | sasethur |22-Apr-13| Fixed fw comment 
-//  1.29   | sasethur |23-Apr-13| Fixed fw comment 
-//  1.30   | sasethur |24-Apr-13| Fixed fw comment 
-//  1.31   | sasethur |10-May-13| Added user input for test type, pattern from wrapper 
+//  1.28   | sasethur |22-Apr-13| Fixed fw comment
+//  1.29   | sasethur |23-Apr-13| Fixed fw comment
+//  1.30   | sasethur |24-Apr-13| Fixed fw comment
+//  1.31   | sasethur |10-May-13| Added user input for test type, pattern from wrapper
 //  1.32   | sasethur |04-Jun-13| Fixed for PortD cnfg, vref print for min setup, hold, fixed rdvref print, added set/reset mcbist attr
-//  1.33   | sasethur |12-Jun-13| Updated mcbist setup attribute 
+//  1.33   | sasethur |12-Jun-13| Updated mcbist setup attribute
 //  1.34   | sasethur |20-Jun-13| Fixed read_vref print, setup attribute
 //  1.35   | sasethur |08-Aug-13| Fixed fw comment
 //  1.36   | sasethur |23-Aug-13| Ability to run MCBIST is enabled.
 //  1.37   | sasethur |04-Sep-13| Fixed fw review comment
 //  1.38   | bellows  |19-SEP-13| fixed possible buffer overrun found by stradale
-//  1.39   | abhijsau |17-OCT-13| fixed a logical bug 
-//  1.40   | abhijsau |17-DEC-13| added creation and deletion of schmoo object  
+//  1.39   | abhijsau |17-OCT-13| fixed a logical bug
+//  1.40   | abhijsau |17-DEC-13| added creation and deletion of schmoo object
 //  1.41   | abhijsau |16-JAN-14| removed EFF_DIMM_TYPE attribute
 //  1.42   | mjjones  |17-Jan-14| Fixed layout and error handling for RAS Review
 //  1.43   | jdsloat  |10-MAR-14| Edited comments
@@ -99,10 +99,11 @@
 //  1.56   |preeragh  |12-Nov-15| V-ref CAL_CONTROL options
 //  1.57   |preeragh  |13-Nov-15| Mask MCBIT_DONE bit FIR before Schmoos
 //  1.58   |dcrowell  |13-Nov-15| Change allocation of generic_shmoo object
+//  1.59   |preeragh  |18-Nov-15| Update Nibble PDA while PDA_Storage
 // This procedure Schmoo's DRV_IMP, SLEW, VREF (DDR, CEN), RCV_IMP based on attribute from effective config procedure
 // DQ & DQS Driver impedance, Slew rate, WR_Vref shmoo would call only write_eye shmoo for margin calculation
 // DQ & DQS VREF (rd_vref), RCV_IMP shmoo would call rd_eye for margin calculation
-// Internal Vref controlled by this function & external vref 
+// Internal Vref controlled by this function & external vref
 
 // Not supported
 // DDR4, DIMM Types
@@ -130,99 +131,99 @@ const uint32_t MAX_DIMM =2;
 
 enum shmoo_param
 {
-	PARAM_NONE = 0x00,
-	DELAY_REG = 0x01,
-	DRV_IMP = 0x02, 
-	SLEW_RATE = 0x04,
-	WR_VREF = 0x08,
-	RD_VREF = 0x10,
-	RCV_IMP = 0x20 
+    PARAM_NONE = 0x00,
+    DELAY_REG = 0x01,
+    DRV_IMP = 0x02,
+    SLEW_RATE = 0x04,
+    WR_VREF = 0x08,
+    RD_VREF = 0x10,
+    RCV_IMP = 0x20
 };
 
 
-extern "C" 
+extern "C"
 {
 
-	using namespace fapi;
-
-	fapi::ReturnCode mss_draminit_training_advanced_cloned(const fapi::Target & i_target_mba);
-
-	fapi::ReturnCode drv_imped_shmoo(const fapi::Target & i_target_mba, uint8_t i_port,
-	shmoo_type_t i_shmoo_type_valid); 
-
-	fapi::ReturnCode slew_rate_shmoo(const fapi::Target & i_target_mba, uint8_t i_port,
-	shmoo_type_t i_shmoo_type_valid); 
-
-	fapi::ReturnCode wr_vref_shmoo(const fapi::Target & i_target_mba, uint8_t i_port,
-	shmoo_type_t i_shmoo_type_valid);
-	
-	fapi::ReturnCode wr_vref_shmoo_ddr4(const fapi::Target & i_target_mba);
-	fapi::ReturnCode wr_vref_shmoo_ddr4_bin(const fapi::Target & i_target_mba);
-	fapi::ReturnCode rd_vref_shmoo_ddr4(const fapi::Target & i_target_mba);
-
-	fapi::ReturnCode rd_vref_shmoo(const fapi::Target & i_target_mba, uint8_t i_port,
-	shmoo_type_t i_shmoo_type_valid); 
-
-	fapi::ReturnCode rcv_imp_shmoo(const fapi::Target & i_target_mba, uint8_t i_port,
-	shmoo_type_t i_shmoo_type_valid);
-
-	fapi::ReturnCode delay_shmoo(const fapi::Target & i_target_mba, uint8_t i_port,
-	shmoo_type_t i_shmoo_type_valid, 
-	uint32_t *o_left_margin, uint32_t *o_right_margin,
-	uint32_t i_shmoo_param);
-	fapi::ReturnCode delay_shmoo_ddr4(const fapi::Target & i_target_mba, uint8_t i_port,
-	shmoo_type_t i_shmoo_type_valid, 
-	uint32_t *o_left_margin, uint32_t *o_right_margin,
-	uint32_t i_shmoo_param,uint32_t pda_nibble_table[2][2][4][16][2]);
-	
-	fapi::ReturnCode delay_shmoo_ddr4_pda(const fapi::Target & i_target_mba, uint8_t i_port,
-	shmoo_type_t i_shmoo_type_valid, 
-	uint32_t *o_left_margin, uint32_t *o_right_margin,
-	uint32_t i_shmoo_param,uint32_t pda_nibble_table[2][2][4][16][2]);
-
-	void find_best_margin(shmoo_param i_shmoo_param_valid,uint32_t i_left[], 
-	uint32_t i_right[], const uint8_t l_max, 
-	uint32_t i_param_nom, uint8_t& o_index);
-
-	fapi::ReturnCode set_attribute(const fapi::Target & i_target_mba);
-
-	fapi::ReturnCode reset_attribute(const fapi::Target & i_target_mba);
-
-
-	//-----------------------------------------------------------------------------------
-	//Function name: mss_draminit_training_advanced()
-	//Description: This function varies driver impedance, receiver impedance, slew, wr & rd vref
-	//based on attribute definition and runs either mcbist/delay shmoo based on attribute
-	//Also calls unmask function mss_unmask_draminit_training_advanced_errors() 
-	//Input : const fapi::Target MBA, i_pattern = pattern selection during mcbist @ lab, 
-	//	l_test type  = test type selection during mcbist @ lab 
-	//	Default vlaues are Zero
-	//-----------------------------------------------------------------------------------
-
-	fapi::ReturnCode mss_draminit_training_advanced(const fapi::Target & i_target_mba)
-	{
-		// const fapi::Target is centaur.mba
-		fapi::ReturnCode rc;
-		//FAPI_INF(" pattern bit is %d and test_type_bit is %d");   
-		rc = mss_draminit_training_advanced_cloned(i_target_mba);
-		if (rc) 
-		{
-			FAPI_ERR("Advanced DRAM Init training procedure is Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
-		}
-		
-		// If mss_unmask_draminit_training_advanced_errors gets it's own bad rc,
-		// it will commit the passed in rc (if non-zero), and return it's own bad rc.
-		// Else if mss_unmask_draminit_training_advanced_errors runs clean, 
-		// it will just return the passed in rc.
-		
-		rc = mss_unmask_draminit_training_advanced_errors(i_target_mba, rc);
-		if (rc) 
-		{
-			FAPI_ERR("Unmask Function is Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
-			return rc;
-		}
-		return rc;
-	}
+    using namespace fapi;
+
+    fapi::ReturnCode mss_draminit_training_advanced_cloned(const fapi::Target & i_target_mba);
+
+    fapi::ReturnCode drv_imped_shmoo(const fapi::Target & i_target_mba, uint8_t i_port,
+                                     shmoo_type_t i_shmoo_type_valid);
+
+    fapi::ReturnCode slew_rate_shmoo(const fapi::Target & i_target_mba, uint8_t i_port,
+                                     shmoo_type_t i_shmoo_type_valid);
+
+    fapi::ReturnCode wr_vref_shmoo(const fapi::Target & i_target_mba, uint8_t i_port,
+                                   shmoo_type_t i_shmoo_type_valid);
+
+    fapi::ReturnCode wr_vref_shmoo_ddr4(const fapi::Target & i_target_mba);
+    fapi::ReturnCode wr_vref_shmoo_ddr4_bin(const fapi::Target & i_target_mba);
+    fapi::ReturnCode rd_vref_shmoo_ddr4(const fapi::Target & i_target_mba);
+
+    fapi::ReturnCode rd_vref_shmoo(const fapi::Target & i_target_mba, uint8_t i_port,
+                                   shmoo_type_t i_shmoo_type_valid);
+
+    fapi::ReturnCode rcv_imp_shmoo(const fapi::Target & i_target_mba, uint8_t i_port,
+                                   shmoo_type_t i_shmoo_type_valid);
+
+    fapi::ReturnCode delay_shmoo(const fapi::Target & i_target_mba, uint8_t i_port,
+                                 shmoo_type_t i_shmoo_type_valid,
+                                 uint32_t *o_left_margin, uint32_t *o_right_margin,
+                                 uint32_t i_shmoo_param);
+    fapi::ReturnCode delay_shmoo_ddr4(const fapi::Target & i_target_mba, uint8_t i_port,
+                                      shmoo_type_t i_shmoo_type_valid,
+                                      uint32_t *o_left_margin, uint32_t *o_right_margin,
+                                      uint32_t i_shmoo_param,uint32_t pda_nibble_table[2][2][4][16][2]);
+
+    fapi::ReturnCode delay_shmoo_ddr4_pda(const fapi::Target & i_target_mba, uint8_t i_port,
+                                          shmoo_type_t i_shmoo_type_valid,
+                                          uint32_t *o_left_margin, uint32_t *o_right_margin,
+                                          uint32_t i_shmoo_param,uint32_t pda_nibble_table[2][2][4][16][2]);
+
+    void find_best_margin(shmoo_param i_shmoo_param_valid,uint32_t i_left[],
+                          uint32_t i_right[], const uint8_t l_max,
+                          uint32_t i_param_nom, uint8_t& o_index);
+
+    fapi::ReturnCode set_attribute(const fapi::Target & i_target_mba);
+
+    fapi::ReturnCode reset_attribute(const fapi::Target & i_target_mba);
+
+
+    //-----------------------------------------------------------------------------------
+    //Function name: mss_draminit_training_advanced()
+    //Description: This function varies driver impedance, receiver impedance, slew, wr & rd vref
+    //based on attribute definition and runs either mcbist/delay shmoo based on attribute
+    //Also calls unmask function mss_unmask_draminit_training_advanced_errors()
+    //Input : const fapi::Target MBA, i_pattern = pattern selection during mcbist @ lab,
+    //	l_test type  = test type selection during mcbist @ lab
+    //	Default vlaues are Zero
+    //-----------------------------------------------------------------------------------
+
+    fapi::ReturnCode mss_draminit_training_advanced(const fapi::Target & i_target_mba)
+    {
+        // const fapi::Target is centaur.mba
+        fapi::ReturnCode rc;
+        //FAPI_INF(" pattern bit is %d and test_type_bit is %d");
+        rc = mss_draminit_training_advanced_cloned(i_target_mba);
+        if (rc)
+        {
+            FAPI_ERR("Advanced DRAM Init training procedure is Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
+        }
+
+        // If mss_unmask_draminit_training_advanced_errors gets it's own bad rc,
+        // it will commit the passed in rc (if non-zero), and return it's own bad rc.
+        // Else if mss_unmask_draminit_training_advanced_errors runs clean,
+        // it will just return the passed in rc.
+
+        rc = mss_unmask_draminit_training_advanced_errors(i_target_mba, rc);
+        if (rc)
+        {
+            FAPI_ERR("Unmask Function is Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
+            return rc;
+        }
+        return rc;
+    }
 
 }
 //end of extern C
@@ -236,254 +237,254 @@ extern "C"
 //-----------------------------------------------------------------------------------
 fapi::ReturnCode mss_draminit_training_advanced_cloned(const fapi::Target & i_target_mba)
 {
-	//const fapi::Target is centaur.mba
-	fapi::ReturnCode rc;
-
-	FAPI_INF("+++++++ Executing mss_draminit_training_advanced +++++++");
-	
-	// Define attribute variables
-	uint32_t l_attr_mss_freq_u32 = 0;
-	uint32_t l_attr_mss_volt_u32 = 0;  
-	uint8_t l_num_drops_per_port_u8 = 2;
-	uint8_t l_num_ranks_per_dimm_u8array[MAX_PORT][MAX_DIMM] = {{0}};
-	uint8_t l_port = 0;
-	uint32_t l_left_margin=0;  
-	uint32_t l_right_margin=0;  
-	uint32_t l_shmoo_param=0; 
-	uint8_t l_dram_type=0;
-	uint8_t bin_pda=0;
-	uint8_t vref_cal_control = 0;
-	uint8_t temp_cal_control = 0;
-	uint32_t int32_cal_control[2] = {0};
-	uint64_t int64_cal_control = 0;
-	
-	
-	// Define local variables
-	uint8_t l_shmoo_type_valid_t=0;
-	uint8_t l_shmoo_param_valid_t=0;
-	enum dram_type { EMPTY = 0, DDR3 = 1, DDR4 = 2};   	
-	//const fapi::Target is centaur
-	fapi::Target l_target_centaur;
-	rc = fapiGetParentChip(i_target_mba, l_target_centaur); 
-	if(rc) return rc;
-	rc = FAPI_ATTR_GET(ATTR_MSS_FREQ, &l_target_centaur, l_attr_mss_freq_u32); 
-	if(rc) return rc;
-	rc = FAPI_ATTR_GET(ATTR_MSS_VOLT, &l_target_centaur, l_attr_mss_volt_u32); 
-	if(rc) return rc;
-	//Preet Add MSS_CAL control here
-	rc = FAPI_ATTR_GET(ATTR_MSS_VREF_CAL_CNTL, &l_target_centaur, vref_cal_control); 
-	if(rc) return rc;
-	FAPI_INF("+++++++++++++++++++++++++++++ - DDR4 - CAL Control - %d +++++++++++++++++++++++++++++++++++++++++++++",vref_cal_control);
-	
-	
-	//const fapi::Target is centaur.mba   
-	rc = FAPI_ATTR_GET(ATTR_EFF_NUM_DROPS_PER_PORT, &i_target_mba, l_num_drops_per_port_u8); 
-	if(rc) return rc;
-	rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target_mba, l_num_ranks_per_dimm_u8array); 
-	if(rc) return rc;
-	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_GEN, &i_target_mba, l_dram_type); 
-	if(rc) return rc;
-	rc = FAPI_ATTR_GET(ATTR_MCBIST_USER_BANK, &i_target_mba, bin_pda); 
-	if(rc) return rc;
-	
-	if ((vref_cal_control == 0) && (l_dram_type == fapi::ENUM_ATTR_EFF_DRAM_GEN_DDR4)&& (bin_pda != 3))
-	{
-		FAPI_INF("+++++++++++++++++++++++++++++ - DDR4 - Skipping - V-Ref CAL Control +++++++++++++++++++++++++++++++++++++++++++++");
-		int32_cal_control[0] = 37;
-		rc = FAPI_ATTR_SET(ATTR_MCBIST_TEST_TYPE, &i_target_mba, int32_cal_control[0]); 
-		if(rc) return rc;
-		
-		rc = wr_vref_shmoo_ddr4_bin(i_target_mba);
-						if (rc)
-						{
-							FAPI_ERR("Write Vref Schmoo Function is Failed rc = 0x%08X (creator = %d)",
-							uint32_t(rc), rc.getCreator());
-							return rc;
-						}
-	return rc;
-	}
-		
-	else if ((vref_cal_control != 0) && (l_dram_type == fapi::ENUM_ATTR_EFF_DRAM_GEN_DDR4) && (bin_pda != 3))
-	{
-		FAPI_INF("+++++++++++++++++++++++++++++ - DDR4 - CAL Control +++++++++++++++++++++++++++++++++++++++++++++");
-		
-		temp_cal_control = 8;
-		rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_PARAM_VALID, &i_target_mba, temp_cal_control); 
-		if(rc) return rc;
-		temp_cal_control = 6;
-		rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_MODE, &i_target_mba, temp_cal_control); 
-		if(rc) return rc;
-		temp_cal_control = 1;
-		rc = FAPI_ATTR_SET(ATTR_MCBIST_USER_BANK, &i_target_mba, temp_cal_control); 
-		if(rc) return rc;
-		temp_cal_control = 2;
-		rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_TEST_VALID, &i_target_mba, temp_cal_control); 
-		if(rc) return rc;
-		l_shmoo_param_valid_t = 1;
-		rc = FAPI_ATTR_SET(ATTR_MCBIST_RANK, &i_target_mba, l_shmoo_param_valid_t); 
-		if(rc) return rc;
-		l_shmoo_param_valid_t = 1;
-		rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_ADDR_MODE, &i_target_mba, l_shmoo_param_valid_t); 
-		if(rc) return rc;
-		int32_cal_control[0] = 0xFFFFFFFF;
-		int32_cal_control[1] = 0xFFFFFFFF;
-		rc = FAPI_ATTR_SET(ATTR_EFF_DRAM_WR_VREF_SCHMOO, &i_target_mba, int32_cal_control); 
-		if(rc) return rc;
-		int32_cal_control[0] = 37;
-		rc = FAPI_ATTR_SET(ATTR_MCBIST_TEST_TYPE, &i_target_mba, int32_cal_control[0]); 
-		if(rc) return rc;
-		int64_cal_control = 0x0000000000000000ull;
-		rc = FAPI_ATTR_SET(ATTR_MCBIST_START_ADDR, &i_target_mba, int64_cal_control); 
-		if(rc) return rc;
-		int64_cal_control = 0x0000001fc0000000ull;
-		rc = FAPI_ATTR_SET(ATTR_MCBIST_END_ADDR, &i_target_mba, int64_cal_control); 
-		if(rc) return rc;
-	}
-	
-	rc = FAPI_ATTR_GET(ATTR_MCBIST_USER_BANK, &i_target_mba, bin_pda); 
-	if(rc) return rc;
-	
-	
-	FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
-	FAPI_INF("freq = %d on %s.", l_attr_mss_freq_u32, l_target_centaur.toEcmdString());
-	FAPI_INF("volt = %d on %s.", l_attr_mss_volt_u32, l_target_centaur.toEcmdString());
-	FAPI_INF("num_drops_per_port = %d on %s.", l_num_drops_per_port_u8, i_target_mba.toEcmdString());
-	FAPI_INF("num_ranks_per_dimm = [%02d][%02d][%02d][%02d]",
-	l_num_ranks_per_dimm_u8array[0][0],
-	l_num_ranks_per_dimm_u8array[0][1],
-	l_num_ranks_per_dimm_u8array[1][0],
-	l_num_ranks_per_dimm_u8array[1][1]);
-	
-	
-	FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
-
-	rc = FAPI_ATTR_GET(ATTR_EFF_SCHMOO_TEST_VALID, &i_target_mba, l_shmoo_type_valid_t);  
-	if(rc) return rc; 
-	rc = FAPI_ATTR_GET(ATTR_EFF_SCHMOO_PARAM_VALID, &i_target_mba, l_shmoo_param_valid_t); 
-	if(rc) return rc;
-
-	shmoo_type_t l_shmoo_type_valid;
-	shmoo_param l_shmoo_param_valid;
-
-	l_shmoo_type_valid=(shmoo_type_t)l_shmoo_type_valid_t;
-	l_shmoo_param_valid=(shmoo_param)l_shmoo_param_valid_t;
-	FAPI_INF("+++++++++++++++++++++++++ Read Schmoo Attributes ++++++++++++++++++++++++++");
-	FAPI_INF("Schmoo param valid = 0x%x on %s", l_shmoo_param_valid, i_target_mba.toEcmdString());
-	FAPI_INF("Schmoo test valid = 0x%x on %s", l_shmoo_type_valid, i_target_mba.toEcmdString());
-	FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
-	//Check for Shmoo Parameter, if anyof them is enabled then go into the loop else the procedure exit 
-
-	if ((l_num_ranks_per_dimm_u8array[0][0] > 0) ||
-			(l_num_ranks_per_dimm_u8array[0][1] > 0) ||
-			(l_num_ranks_per_dimm_u8array[1][0] > 0) ||
-			(l_num_ranks_per_dimm_u8array[1][1] > 0))
-	{
-		if ((l_shmoo_param_valid != PARAM_NONE) ||
-				(l_shmoo_type_valid != TEST_NONE))
-		{
-			if ((l_shmoo_param_valid & DRV_IMP) != 0)
-			{
-				rc = drv_imped_shmoo(i_target_mba, l_port, l_shmoo_type_valid);
-				if (rc)
-				{
-					FAPI_ERR("Driver Impedance Schmoo function is Failed rc = 0x%08X (creator = %d)",
-					uint32_t(rc), rc.getCreator());
-					return rc;
-				}
-			}
-			if ((l_shmoo_param_valid & SLEW_RATE) != 0)
-			{
-				rc = slew_rate_shmoo(i_target_mba, l_port, l_shmoo_type_valid);
-				if (rc)
-				{
-					FAPI_ERR("Slew Rate Schmoo Function is Failed rc = 0x%08X (creator = %d)",
-					uint32_t(rc), rc.getCreator());
-					return rc;
-				}
-			}
-			if ((l_shmoo_param_valid & WR_VREF) != 0)
-			{
-				if(l_dram_type==DDR3){
-					rc = wr_vref_shmoo(i_target_mba, l_port, l_shmoo_type_valid);
-					if (rc)
-					{
-						FAPI_ERR("Write Vref Schmoo Function is Failed rc = 0x%08X (creator = %d)",
-						uint32_t(rc), rc.getCreator());
-						return rc;
-					}
-				}
-				else{
-					if(bin_pda == 1)
-					{
-						FAPI_INF("************* Bin - PDA - Vref_Schmoo **************");
-						
-						rc = wr_vref_shmoo_ddr4_bin(i_target_mba);
-						if (rc)
-						{
-							FAPI_ERR("Write Vref Schmoo Function is Failed rc = 0x%08X (creator = %d)",
-							uint32_t(rc), rc.getCreator());
-							return rc;
-						}
-					}
-					else
-					{
-						rc = wr_vref_shmoo_ddr4(i_target_mba);
-						if (rc)
-						{
-							FAPI_ERR("Write Vref Schmoo Function is Failed rc = 0x%08X (creator = %d)",
-							uint32_t(rc), rc.getCreator());
-							return rc;
-						}
-					}
-				}
-			}
-			if ((l_shmoo_param_valid & RD_VREF) != 0)
-			{
-				if(l_dram_type==DDR3){
-					rc = rd_vref_shmoo(i_target_mba, l_port, l_shmoo_type_valid);
-					if (rc)
-					{
-						FAPI_ERR("Read Vref Schmoo Function is Failed rc = 0x%08X (creator = %d)",
-						uint32_t(rc), rc.getCreator());
-						return rc;
-					}
-				}
-				else 
-				{
-					rc = rd_vref_shmoo_ddr4(i_target_mba);
-					if (rc)
-					{
-						FAPI_ERR("rd_vref_shmoo_ddr4 Function is Failed rc = 0x%08X (creator = %d)",
-						uint32_t(rc), rc.getCreator());
-						return rc;
-					}
-				}
-			}
-			if ((l_shmoo_param_valid & RCV_IMP) != 0)
-			{
-				rc = rcv_imp_shmoo(i_target_mba, l_port, l_shmoo_type_valid);
-				if (rc)
-				{
-					FAPI_ERR("Receiver Impedance Schmoo Function is Failed rc = 0x%08X (creator = %d)",
-					uint32_t(rc), rc.getCreator());
-					return rc;
-				}
-			}
-			if (((l_shmoo_param_valid == PARAM_NONE)))
-			{
-				rc = delay_shmoo(i_target_mba, l_port, l_shmoo_type_valid,
-				&l_left_margin, &l_right_margin,
-				l_shmoo_param);
-				if (rc)
-				{
-					FAPI_ERR("Delay Schmoo Function is Failed rc = 0x%08X (creator = %d)",
-					uint32_t(rc), rc.getCreator());
-					return rc;
-				}
-			}
-		}
-	}
-	return rc;
+    //const fapi::Target is centaur.mba
+    fapi::ReturnCode rc;
+
+    FAPI_INF("+++++++ Executing mss_draminit_training_advanced +++++++");
+
+    // Define attribute variables
+    uint32_t l_attr_mss_freq_u32 = 0;
+    uint32_t l_attr_mss_volt_u32 = 0;
+    uint8_t l_num_drops_per_port_u8 = 2;
+    uint8_t l_num_ranks_per_dimm_u8array[MAX_PORT][MAX_DIMM] = {{0}};
+    uint8_t l_port = 0;
+    uint32_t l_left_margin=0;
+    uint32_t l_right_margin=0;
+    uint32_t l_shmoo_param=0;
+    uint8_t l_dram_type=0;
+    uint8_t bin_pda=0;
+    uint8_t vref_cal_control = 0;
+    uint8_t temp_cal_control = 0;
+    uint32_t int32_cal_control[2] = {0};
+    uint64_t int64_cal_control = 0;
+
+
+    // Define local variables
+    uint8_t l_shmoo_type_valid_t=0;
+    uint8_t l_shmoo_param_valid_t=0;
+    enum dram_type { EMPTY = 0, DDR3 = 1, DDR4 = 2};
+    //const fapi::Target is centaur
+    fapi::Target l_target_centaur;
+    rc = fapiGetParentChip(i_target_mba, l_target_centaur);
+    if(rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_MSS_FREQ, &l_target_centaur, l_attr_mss_freq_u32);
+    if(rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_MSS_VOLT, &l_target_centaur, l_attr_mss_volt_u32);
+    if(rc) return rc;
+    //Preet Add MSS_CAL control here
+    rc = FAPI_ATTR_GET(ATTR_MSS_VREF_CAL_CNTL, &l_target_centaur, vref_cal_control);
+    if(rc) return rc;
+    FAPI_INF("+++++++++++++++++++++++++++++ - DDR4 - CAL Control - %d +++++++++++++++++++++++++++++++++++++++++++++",vref_cal_control);
+
+
+    //const fapi::Target is centaur.mba
+    rc = FAPI_ATTR_GET(ATTR_EFF_NUM_DROPS_PER_PORT, &i_target_mba, l_num_drops_per_port_u8);
+    if(rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target_mba, l_num_ranks_per_dimm_u8array);
+    if(rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_GEN, &i_target_mba, l_dram_type);
+    if(rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_MCBIST_USER_BANK, &i_target_mba, bin_pda);
+    if(rc) return rc;
+
+    if ((vref_cal_control == 0) && (l_dram_type == fapi::ENUM_ATTR_EFF_DRAM_GEN_DDR4)&& (bin_pda != 3))
+    {
+        FAPI_INF("+++++++++++++++++++++++++++++ - DDR4 - Skipping - V-Ref CAL Control +++++++++++++++++++++++++++++++++++++++++++++");
+        int32_cal_control[0] = 37;
+        rc = FAPI_ATTR_SET(ATTR_MCBIST_TEST_TYPE, &i_target_mba, int32_cal_control[0]);
+        if(rc) return rc;
+
+        rc = wr_vref_shmoo_ddr4_bin(i_target_mba);
+        if (rc)
+        {
+            FAPI_ERR("Write Vref Schmoo Function is Failed rc = 0x%08X (creator = %d)",
+                     uint32_t(rc), rc.getCreator());
+            return rc;
+        }
+        return rc;
+    }
+
+    else if ((vref_cal_control != 0) && (l_dram_type == fapi::ENUM_ATTR_EFF_DRAM_GEN_DDR4) && (bin_pda != 3))
+    {
+        FAPI_INF("+++++++++++++++++++++++++++++ - DDR4 - CAL Control +++++++++++++++++++++++++++++++++++++++++++++");
+
+        temp_cal_control = 8;
+        rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_PARAM_VALID, &i_target_mba, temp_cal_control);
+        if(rc) return rc;
+        temp_cal_control = 6;
+        rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_MODE, &i_target_mba, temp_cal_control);
+        if(rc) return rc;
+        temp_cal_control = 1;
+        rc = FAPI_ATTR_SET(ATTR_MCBIST_USER_BANK, &i_target_mba, temp_cal_control);
+        if(rc) return rc;
+        temp_cal_control = 2;
+        rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_TEST_VALID, &i_target_mba, temp_cal_control);
+        if(rc) return rc;
+        l_shmoo_param_valid_t = 1;
+        rc = FAPI_ATTR_SET(ATTR_MCBIST_RANK, &i_target_mba, l_shmoo_param_valid_t);
+        if(rc) return rc;
+        l_shmoo_param_valid_t = 1;
+        rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_ADDR_MODE, &i_target_mba, l_shmoo_param_valid_t);
+        if(rc) return rc;
+        int32_cal_control[0] = 0xFFFFFFFF;
+        int32_cal_control[1] = 0xFFFFFFFF;
+        rc = FAPI_ATTR_SET(ATTR_EFF_DRAM_WR_VREF_SCHMOO, &i_target_mba, int32_cal_control);
+        if(rc) return rc;
+        int32_cal_control[0] = 37;
+        rc = FAPI_ATTR_SET(ATTR_MCBIST_TEST_TYPE, &i_target_mba, int32_cal_control[0]);
+        if(rc) return rc;
+        int64_cal_control = 0x0000000000000000ull;
+        rc = FAPI_ATTR_SET(ATTR_MCBIST_START_ADDR, &i_target_mba, int64_cal_control);
+        if(rc) return rc;
+        int64_cal_control = 0x0000001fc0000000ull;
+        rc = FAPI_ATTR_SET(ATTR_MCBIST_END_ADDR, &i_target_mba, int64_cal_control);
+        if(rc) return rc;
+    }
+
+    rc = FAPI_ATTR_GET(ATTR_MCBIST_USER_BANK, &i_target_mba, bin_pda);
+    if(rc) return rc;
+
+
+    FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
+    FAPI_INF("freq = %d on %s.", l_attr_mss_freq_u32, l_target_centaur.toEcmdString());
+    FAPI_INF("volt = %d on %s.", l_attr_mss_volt_u32, l_target_centaur.toEcmdString());
+    FAPI_INF("num_drops_per_port = %d on %s.", l_num_drops_per_port_u8, i_target_mba.toEcmdString());
+    FAPI_INF("num_ranks_per_dimm = [%02d][%02d][%02d][%02d]",
+             l_num_ranks_per_dimm_u8array[0][0],
+             l_num_ranks_per_dimm_u8array[0][1],
+             l_num_ranks_per_dimm_u8array[1][0],
+             l_num_ranks_per_dimm_u8array[1][1]);
+
+
+    FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
+
+    rc = FAPI_ATTR_GET(ATTR_EFF_SCHMOO_TEST_VALID, &i_target_mba, l_shmoo_type_valid_t);
+    if(rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_EFF_SCHMOO_PARAM_VALID, &i_target_mba, l_shmoo_param_valid_t);
+    if(rc) return rc;
+
+    shmoo_type_t l_shmoo_type_valid;
+    shmoo_param l_shmoo_param_valid;
+
+    l_shmoo_type_valid=(shmoo_type_t)l_shmoo_type_valid_t;
+    l_shmoo_param_valid=(shmoo_param)l_shmoo_param_valid_t;
+    FAPI_INF("+++++++++++++++++++++++++ Read Schmoo Attributes ++++++++++++++++++++++++++");
+    FAPI_INF("Schmoo param valid = 0x%x on %s", l_shmoo_param_valid, i_target_mba.toEcmdString());
+    FAPI_INF("Schmoo test valid = 0x%x on %s", l_shmoo_type_valid, i_target_mba.toEcmdString());
+    FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
+    //Check for Shmoo Parameter, if anyof them is enabled then go into the loop else the procedure exit
+
+    if ((l_num_ranks_per_dimm_u8array[0][0] > 0) ||
+            (l_num_ranks_per_dimm_u8array[0][1] > 0) ||
+            (l_num_ranks_per_dimm_u8array[1][0] > 0) ||
+            (l_num_ranks_per_dimm_u8array[1][1] > 0))
+    {
+        if ((l_shmoo_param_valid != PARAM_NONE) ||
+                (l_shmoo_type_valid != TEST_NONE))
+        {
+            if ((l_shmoo_param_valid & DRV_IMP) != 0)
+            {
+                rc = drv_imped_shmoo(i_target_mba, l_port, l_shmoo_type_valid);
+                if (rc)
+                {
+                    FAPI_ERR("Driver Impedance Schmoo function is Failed rc = 0x%08X (creator = %d)",
+                             uint32_t(rc), rc.getCreator());
+                    return rc;
+                }
+            }
+            if ((l_shmoo_param_valid & SLEW_RATE) != 0)
+            {
+                rc = slew_rate_shmoo(i_target_mba, l_port, l_shmoo_type_valid);
+                if (rc)
+                {
+                    FAPI_ERR("Slew Rate Schmoo Function is Failed rc = 0x%08X (creator = %d)",
+                             uint32_t(rc), rc.getCreator());
+                    return rc;
+                }
+            }
+            if ((l_shmoo_param_valid & WR_VREF) != 0)
+            {
+                if(l_dram_type==DDR3) {
+                    rc = wr_vref_shmoo(i_target_mba, l_port, l_shmoo_type_valid);
+                    if (rc)
+                    {
+                        FAPI_ERR("Write Vref Schmoo Function is Failed rc = 0x%08X (creator = %d)",
+                                 uint32_t(rc), rc.getCreator());
+                        return rc;
+                    }
+                }
+                else {
+                    if(bin_pda == 1)
+                    {
+                        FAPI_INF("************* Bin - PDA - Vref_Schmoo **************");
+
+                        rc = wr_vref_shmoo_ddr4_bin(i_target_mba);
+                        if (rc)
+                        {
+                            FAPI_ERR("Write Vref Schmoo Function is Failed rc = 0x%08X (creator = %d)",
+                                     uint32_t(rc), rc.getCreator());
+                            return rc;
+                        }
+                    }
+                    else
+                    {
+                        rc = wr_vref_shmoo_ddr4(i_target_mba);
+                        if (rc)
+                        {
+                            FAPI_ERR("Write Vref Schmoo Function is Failed rc = 0x%08X (creator = %d)",
+                                     uint32_t(rc), rc.getCreator());
+                            return rc;
+                        }
+                    }
+                }
+            }
+            if ((l_shmoo_param_valid & RD_VREF) != 0)
+            {
+                if(l_dram_type==DDR3) {
+                    rc = rd_vref_shmoo(i_target_mba, l_port, l_shmoo_type_valid);
+                    if (rc)
+                    {
+                        FAPI_ERR("Read Vref Schmoo Function is Failed rc = 0x%08X (creator = %d)",
+                                 uint32_t(rc), rc.getCreator());
+                        return rc;
+                    }
+                }
+                else
+                {
+                    rc = rd_vref_shmoo_ddr4(i_target_mba);
+                    if (rc)
+                    {
+                        FAPI_ERR("rd_vref_shmoo_ddr4 Function is Failed rc = 0x%08X (creator = %d)",
+                                 uint32_t(rc), rc.getCreator());
+                        return rc;
+                    }
+                }
+            }
+            if ((l_shmoo_param_valid & RCV_IMP) != 0)
+            {
+                rc = rcv_imp_shmoo(i_target_mba, l_port, l_shmoo_type_valid);
+                if (rc)
+                {
+                    FAPI_ERR("Receiver Impedance Schmoo Function is Failed rc = 0x%08X (creator = %d)",
+                             uint32_t(rc), rc.getCreator());
+                    return rc;
+                }
+            }
+            if (((l_shmoo_param_valid == PARAM_NONE)))
+            {
+                rc = delay_shmoo(i_target_mba, l_port, l_shmoo_type_valid,
+                                 &l_left_margin, &l_right_margin,
+                                 l_shmoo_param);
+                if (rc)
+                {
+                    FAPI_ERR("Delay Schmoo Function is Failed rc = 0x%08X (creator = %d)",
+                             uint32_t(rc), rc.getCreator());
+                    return rc;
+                }
+            }
+        }
+    }
+    return rc;
 }
 
 //-------------------------------------------------------------------------------
@@ -499,137 +500,137 @@ fapi::ReturnCode mss_draminit_training_advanced_cloned(const fapi::Target & i_ta
 //-------------------------------------------------------------------------------
 
 fapi::ReturnCode drv_imped_shmoo(const fapi::Target & i_target_mba,
-uint8_t i_port,
-shmoo_type_t i_shmoo_type_valid)
+                                 uint8_t i_port,
+                                 shmoo_type_t i_shmoo_type_valid)
 {
-	fapi::ReturnCode rc;
-	uint8_t l_drv_imp_dq_dqs[MAX_PORT] = {0};
-	uint8_t l_drv_imp_dq_dqs_nom[MAX_PORT] = {0};
-	//uint8_t l_drv_imp_dq_dqs_new[MAX_PORT] = {0};
-	uint8_t index=0;
-	uint8_t l_slew_rate_dq_dqs[MAX_PORT] = {0};
-	uint8_t l_slew_rate_dq_dqs_schmoo[MAX_PORT] = {0};
-	uint32_t l_drv_imp_dq_dqs_schmoo[MAX_PORT] = {0};
-	uint8_t l_drv_imp_dq_dqs_nom_fc = 0;
-	uint8_t l_drv_imp_dq_dqs_in = 0;
-	//Temporary 
-	i_shmoo_type_valid = WR_EYE;  //Hard coded, since no other schmoo is applicable for this parameter
-	uint32_t l_left_margin_drv_imp_array[MAX_DRV_IMP] = {0};
-	uint32_t l_right_margin_drv_imp_array[MAX_DRV_IMP] = {0};
-	uint32_t l_left_margin = 0;
-	uint32_t l_right_margin = 0;
-	uint8_t count = 0;
-	uint8_t shmoo_param_count = 0;
-	uint8_t l_slew_type = 0; // Hard coded since this procedure will touch only DQ_DQS and not address
-	
-	rc = FAPI_ATTR_GET(ATTR_EFF_CEN_DRV_IMP_DQ_DQS, &i_target_mba, l_drv_imp_dq_dqs_nom); 
-	if (rc) return rc;
-	rc = FAPI_ATTR_GET(ATTR_EFF_CEN_SLEW_RATE_DQ_DQS, &i_target_mba, l_slew_rate_dq_dqs); 
-	if (rc) return rc;
-	rc = FAPI_ATTR_GET(ATTR_EFF_CEN_DRV_IMP_DQ_DQS_SCHMOO, &i_target_mba, l_drv_imp_dq_dqs_schmoo);
-	if (rc) return rc;
-	rc = FAPI_ATTR_GET(ATTR_EFF_CEN_SLEW_RATE_DQ_DQS_SCHMOO, &i_target_mba, l_slew_rate_dq_dqs_schmoo);
-	if (rc) return rc;
-	
-	FAPI_INF("+++++++++++++++++Read DRIVER IMP Attributes values++++++++++++++++");
-	FAPI_INF("CEN_DRV_IMP_DQ_DQS[%d]  = [%02d] Ohms, on %s",
-	i_port,
-	l_drv_imp_dq_dqs_nom[i_port],
-	i_target_mba.toEcmdString());
-	FAPI_INF("CEN_DRV_IMP_DQ_DQS_SCHMOO[0]  = [0x%x], CEN_DRV_IMP_DQ_DQS_SCHMOO[1]  = [0x%x] on %s",
-	l_drv_imp_dq_dqs_schmoo[0],
-	l_drv_imp_dq_dqs_schmoo[1],
-	i_target_mba.toEcmdString());
-	FAPI_INF("CEN_SLEW_RATE_DQ_DQS[0] = [%02d]V/ns , CEN_SLEW_RATE_DQ_DQS[1] = [%02d]V/ns on %s",
-	l_slew_rate_dq_dqs[0],
-	l_slew_rate_dq_dqs[1],
-	i_target_mba.toEcmdString());
-	FAPI_INF("CEN_SLEW_RATE_DQ_DQS_SCHMOO[0] = [0x%x], CEN_SLEW_RATE_DQ_DQS_SCHMOO[1] = [0x%x] on %s",
-	l_slew_rate_dq_dqs_schmoo[0],
-	l_slew_rate_dq_dqs_schmoo[1],
-	i_target_mba.toEcmdString());
-	FAPI_INF("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
-
-	if(l_drv_imp_dq_dqs_schmoo[i_port] == 0) //Check for any of the bits enabled in the shmoo
-	{
-		FAPI_INF("DRIVER IMP Shmoo set to FAST Mode and won't do anything");
-	}
-	else
-	{
-		for (index = 0; index < MAX_DRV_IMP; index += 1)
-		{
-			if (l_drv_imp_dq_dqs_schmoo[i_port] & MASK)
-			{
-				l_drv_imp_dq_dqs[i_port] = drv_imp_array[index];
-				FAPI_INF("Current Driver Impedance Value = %d Ohms",
-				drv_imp_array[index]);
-				FAPI_INF("Configuring Driver Impedance Registers:");
-				rc = config_drv_imp(i_target_mba, i_port,
-				l_drv_imp_dq_dqs[i_port]);
-				if (rc) return rc;
-				l_drv_imp_dq_dqs_in = l_drv_imp_dq_dqs[i_port];
-				FAPI_INF("Configuring Slew Rate Registers:");
-				rc = config_slew_rate(i_target_mba, i_port, l_slew_type,
-				l_drv_imp_dq_dqs[i_port],
-				l_slew_rate_dq_dqs[i_port]);
-				if (rc) return rc;
-				FAPI_INF("Calling Shmoo for finding Timing Margin:");
-				if (shmoo_param_count)
-				{
-					rc = set_attribute(i_target_mba);
-					if (rc) return rc;
-				}
-				rc = delay_shmoo(i_target_mba, i_port, i_shmoo_type_valid,
-				&l_left_margin, &l_right_margin,
-				l_drv_imp_dq_dqs_in);
-				if (rc) return rc;
-				l_left_margin_drv_imp_array[index] = l_left_margin;
-				l_right_margin_drv_imp_array[index] = l_right_margin;
-				shmoo_param_count++;
-			}
-			else
-			{
-				l_left_margin_drv_imp_array[index] = 0;
-				l_right_margin_drv_imp_array[index] = 0;
-			}
-			l_drv_imp_dq_dqs_schmoo[i_port] = (l_drv_imp_dq_dqs_schmoo[i_port] >> 1);
-		}
-		l_drv_imp_dq_dqs_nom_fc = l_drv_imp_dq_dqs_nom[i_port];
-		find_best_margin(DRV_IMP, l_left_margin_drv_imp_array,
-		l_right_margin_drv_imp_array, MAX_DRV_IMP,
-		l_drv_imp_dq_dqs_nom_fc, count);
-
-		if (count >= MAX_DRV_IMP)
-		{
-			FAPI_ERR("Driver Imp new input(%d) out of bounds, (>= %d)", count,
-			MAX_DRV_IMP);
-			const uint8_t & COUNT_DATA = count;
-			FAPI_SET_HWP_ERROR(rc, RC_DRV_IMPED_SHMOO_INVALID_MARGIN_DATA);
-			return rc;
-		}
-		else
-		{
-			FAPI_INF("Restoring the nominal values!");
-			rc = FAPI_ATTR_SET(ATTR_EFF_CEN_DRV_IMP_DQ_DQS, &i_target_mba,
-			l_drv_imp_dq_dqs_nom);
-			if (rc) return rc;
-			rc = config_drv_imp(i_target_mba, i_port,
-			l_drv_imp_dq_dqs_nom[i_port]);
-			if (rc) return rc;
-			rc = FAPI_ATTR_SET(ATTR_EFF_CEN_SLEW_RATE_DQ_DQS, &i_target_mba,
-			l_slew_rate_dq_dqs);
-			if (rc) return rc;
-			rc = config_slew_rate(i_target_mba, i_port, l_slew_type,
-			l_drv_imp_dq_dqs_nom[i_port],
-			l_slew_rate_dq_dqs[i_port]);
-			if (rc) return rc;
-		}
-		FAPI_INF("Restoring mcbist setup attribute...");
-		rc = reset_attribute(i_target_mba);
-		if (rc) return rc;
-		FAPI_INF("++++ Driver impedance shmoo function executed successfully ++++");
-	}
-	return rc;
+    fapi::ReturnCode rc;
+    uint8_t l_drv_imp_dq_dqs[MAX_PORT] = {0};
+    uint8_t l_drv_imp_dq_dqs_nom[MAX_PORT] = {0};
+    //uint8_t l_drv_imp_dq_dqs_new[MAX_PORT] = {0};
+    uint8_t index=0;
+    uint8_t l_slew_rate_dq_dqs[MAX_PORT] = {0};
+    uint8_t l_slew_rate_dq_dqs_schmoo[MAX_PORT] = {0};
+    uint32_t l_drv_imp_dq_dqs_schmoo[MAX_PORT] = {0};
+    uint8_t l_drv_imp_dq_dqs_nom_fc = 0;
+    uint8_t l_drv_imp_dq_dqs_in = 0;
+    //Temporary
+    i_shmoo_type_valid = WR_EYE;  //Hard coded, since no other schmoo is applicable for this parameter
+    uint32_t l_left_margin_drv_imp_array[MAX_DRV_IMP] = {0};
+    uint32_t l_right_margin_drv_imp_array[MAX_DRV_IMP] = {0};
+    uint32_t l_left_margin = 0;
+    uint32_t l_right_margin = 0;
+    uint8_t count = 0;
+    uint8_t shmoo_param_count = 0;
+    uint8_t l_slew_type = 0; // Hard coded since this procedure will touch only DQ_DQS and not address
+
+    rc = FAPI_ATTR_GET(ATTR_EFF_CEN_DRV_IMP_DQ_DQS, &i_target_mba, l_drv_imp_dq_dqs_nom);
+    if (rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_EFF_CEN_SLEW_RATE_DQ_DQS, &i_target_mba, l_slew_rate_dq_dqs);
+    if (rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_EFF_CEN_DRV_IMP_DQ_DQS_SCHMOO, &i_target_mba, l_drv_imp_dq_dqs_schmoo);
+    if (rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_EFF_CEN_SLEW_RATE_DQ_DQS_SCHMOO, &i_target_mba, l_slew_rate_dq_dqs_schmoo);
+    if (rc) return rc;
+
+    FAPI_INF("+++++++++++++++++Read DRIVER IMP Attributes values++++++++++++++++");
+    FAPI_INF("CEN_DRV_IMP_DQ_DQS[%d]  = [%02d] Ohms, on %s",
+             i_port,
+             l_drv_imp_dq_dqs_nom[i_port],
+             i_target_mba.toEcmdString());
+    FAPI_INF("CEN_DRV_IMP_DQ_DQS_SCHMOO[0]  = [0x%x], CEN_DRV_IMP_DQ_DQS_SCHMOO[1]  = [0x%x] on %s",
+             l_drv_imp_dq_dqs_schmoo[0],
+             l_drv_imp_dq_dqs_schmoo[1],
+             i_target_mba.toEcmdString());
+    FAPI_INF("CEN_SLEW_RATE_DQ_DQS[0] = [%02d]V/ns , CEN_SLEW_RATE_DQ_DQS[1] = [%02d]V/ns on %s",
+             l_slew_rate_dq_dqs[0],
+             l_slew_rate_dq_dqs[1],
+             i_target_mba.toEcmdString());
+    FAPI_INF("CEN_SLEW_RATE_DQ_DQS_SCHMOO[0] = [0x%x], CEN_SLEW_RATE_DQ_DQS_SCHMOO[1] = [0x%x] on %s",
+             l_slew_rate_dq_dqs_schmoo[0],
+             l_slew_rate_dq_dqs_schmoo[1],
+             i_target_mba.toEcmdString());
+    FAPI_INF("++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
+
+    if(l_drv_imp_dq_dqs_schmoo[i_port] == 0) //Check for any of the bits enabled in the shmoo
+    {
+        FAPI_INF("DRIVER IMP Shmoo set to FAST Mode and won't do anything");
+    }
+    else
+    {
+        for (index = 0; index < MAX_DRV_IMP; index += 1)
+        {
+            if (l_drv_imp_dq_dqs_schmoo[i_port] & MASK)
+            {
+                l_drv_imp_dq_dqs[i_port] = drv_imp_array[index];
+                FAPI_INF("Current Driver Impedance Value = %d Ohms",
+                         drv_imp_array[index]);
+                FAPI_INF("Configuring Driver Impedance Registers:");
+                rc = config_drv_imp(i_target_mba, i_port,
+                                    l_drv_imp_dq_dqs[i_port]);
+                if (rc) return rc;
+                l_drv_imp_dq_dqs_in = l_drv_imp_dq_dqs[i_port];
+                FAPI_INF("Configuring Slew Rate Registers:");
+                rc = config_slew_rate(i_target_mba, i_port, l_slew_type,
+                                      l_drv_imp_dq_dqs[i_port],
+                                      l_slew_rate_dq_dqs[i_port]);
+                if (rc) return rc;
+                FAPI_INF("Calling Shmoo for finding Timing Margin:");
+                if (shmoo_param_count)
+                {
+                    rc = set_attribute(i_target_mba);
+                    if (rc) return rc;
+                }
+                rc = delay_shmoo(i_target_mba, i_port, i_shmoo_type_valid,
+                                 &l_left_margin, &l_right_margin,
+                                 l_drv_imp_dq_dqs_in);
+                if (rc) return rc;
+                l_left_margin_drv_imp_array[index] = l_left_margin;
+                l_right_margin_drv_imp_array[index] = l_right_margin;
+                shmoo_param_count++;
+            }
+            else
+            {
+                l_left_margin_drv_imp_array[index] = 0;
+                l_right_margin_drv_imp_array[index] = 0;
+            }
+            l_drv_imp_dq_dqs_schmoo[i_port] = (l_drv_imp_dq_dqs_schmoo[i_port] >> 1);
+        }
+        l_drv_imp_dq_dqs_nom_fc = l_drv_imp_dq_dqs_nom[i_port];
+        find_best_margin(DRV_IMP, l_left_margin_drv_imp_array,
+                         l_right_margin_drv_imp_array, MAX_DRV_IMP,
+                         l_drv_imp_dq_dqs_nom_fc, count);
+
+        if (count >= MAX_DRV_IMP)
+        {
+            FAPI_ERR("Driver Imp new input(%d) out of bounds, (>= %d)", count,
+                     MAX_DRV_IMP);
+            const uint8_t & COUNT_DATA = count;
+            FAPI_SET_HWP_ERROR(rc, RC_DRV_IMPED_SHMOO_INVALID_MARGIN_DATA);
+            return rc;
+        }
+        else
+        {
+            FAPI_INF("Restoring the nominal values!");
+            rc = FAPI_ATTR_SET(ATTR_EFF_CEN_DRV_IMP_DQ_DQS, &i_target_mba,
+                               l_drv_imp_dq_dqs_nom);
+            if (rc) return rc;
+            rc = config_drv_imp(i_target_mba, i_port,
+                                l_drv_imp_dq_dqs_nom[i_port]);
+            if (rc) return rc;
+            rc = FAPI_ATTR_SET(ATTR_EFF_CEN_SLEW_RATE_DQ_DQS, &i_target_mba,
+                               l_slew_rate_dq_dqs);
+            if (rc) return rc;
+            rc = config_slew_rate(i_target_mba, i_port, l_slew_type,
+                                  l_drv_imp_dq_dqs_nom[i_port],
+                                  l_slew_rate_dq_dqs[i_port]);
+            if (rc) return rc;
+        }
+        FAPI_INF("Restoring mcbist setup attribute...");
+        rc = reset_attribute(i_target_mba);
+        if (rc) return rc;
+        FAPI_INF("++++ Driver impedance shmoo function executed successfully ++++");
+    }
+    return rc;
 }
 
 //-----------------------------------------------------------------------------------------
@@ -645,126 +646,126 @@ shmoo_type_t i_shmoo_type_valid)
 //-----------------------------------------------------------------------------------------
 
 fapi::ReturnCode slew_rate_shmoo(const fapi::Target & i_target_mba,
-uint8_t i_port,
-shmoo_type_t i_shmoo_type_valid)
+                                 uint8_t i_port,
+                                 shmoo_type_t i_shmoo_type_valid)
 {
-	fapi::ReturnCode rc;
-	uint8_t l_slew_rate_dq_dqs[MAX_PORT] = {0};
-	uint8_t l_slew_rate_dq_dqs_nom[MAX_PORT] = {0};
-	uint8_t l_slew_rate_dq_dqs_nom_fc = 0;
-	uint8_t l_slew_rate_dq_dqs_in = 0;
-	uint32_t l_slew_rate_dq_dqs_schmoo[MAX_PORT] = {0};
-	uint8_t l_drv_imp_dq_dqs_nom[MAX_PORT] = {0};
-	i_shmoo_type_valid = WR_EYE; // Hard coded - Other shmoo type is not valid - Temporary
-	
-	uint8_t index = 0;
-	uint8_t count = 0;
-	uint8_t shmoo_param_count = 0;
-	uint32_t l_left_margin_slew_array[MAX_NUM_SLEW_RATES] = {0};
-	uint32_t l_right_margin_slew_array[MAX_NUM_SLEW_RATES] = {0};
-	uint32_t l_left_margin = 0;
-	uint32_t l_right_margin = 0;
-	uint8_t l_slew_type = 0; // Hard coded since this procedure will touch only DQ_DQS and not address
-	
-	//Read Attributes - DRV IMP, SLEW, SLEW RATES values to be Schmoo'ed
-	rc = FAPI_ATTR_GET(ATTR_EFF_CEN_DRV_IMP_DQ_DQS, &i_target_mba, l_drv_imp_dq_dqs_nom); 
-	if (rc) return rc;
-	rc = FAPI_ATTR_GET(ATTR_EFF_CEN_SLEW_RATE_DQ_DQS, &i_target_mba, l_slew_rate_dq_dqs_nom); 
-	if (rc) return rc;
-	rc = FAPI_ATTR_GET(ATTR_EFF_CEN_DRV_IMP_DQ_DQS_SCHMOO, &i_target_mba, l_slew_rate_dq_dqs_schmoo);
-	if (rc) return rc;
-	
-	FAPI_INF("+++++++++++++++++Read Slew Shmoo Attributes values+++++++++++++++");
-	FAPI_INF("CEN_DRV_IMP_DQ_DQS[0]  = [%02d] Ohms, CEN_DRV_IMP_DQ_DQS[1]  = [%02d] Ohms on %s",
-	l_drv_imp_dq_dqs_nom[0],
-	l_drv_imp_dq_dqs_nom[1],
-	i_target_mba.toEcmdString());
-	FAPI_INF("CEN_SLEW_RATE_DQ_DQS[0] = [%02d]V/ns , CEN_SLEW_RATE_DQ_DQS[1] = [%02d]V/ns on %s",
-	l_slew_rate_dq_dqs_nom[0],
-	l_slew_rate_dq_dqs_nom[1],
-	i_target_mba.toEcmdString());
-	FAPI_INF("CEN_SLEW_RATE_DQ_DQS_SCHMOO[0] = [0x%x], CEN_SLEW_RATE_DQ_DQS_SCHMOO[1] = [0x%x] on %s",
-	l_slew_rate_dq_dqs_schmoo[0],
-	l_slew_rate_dq_dqs_schmoo[1],
-	i_target_mba.toEcmdString());
-	FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
-	
-	if(l_slew_rate_dq_dqs_schmoo == 0) //Check for any of the bits enabled in the shmoo
-	{
-		FAPI_INF("Slew Rate Shmoo set to FAST Mode and won't do anything");
-	}
-	else
-	{
-		for (index = 0; index < MAX_NUM_SLEW_RATES; index += 1)
-		{
-			if (l_slew_rate_dq_dqs_schmoo[i_port] & MASK)
-			{
-				l_slew_rate_dq_dqs[i_port] = slew_rate_array[index];
-				FAPI_INF("Current Slew rate value is %d V/ns",
-				slew_rate_array[index]);
-				FAPI_INF("Configuring Slew registers:");
-				rc = config_slew_rate(i_target_mba, i_port, l_slew_type,
-				l_drv_imp_dq_dqs_nom[i_port],
-				l_slew_rate_dq_dqs[i_port]);
-				if (rc) return rc;
-				l_slew_rate_dq_dqs_in = l_slew_rate_dq_dqs[i_port];
-				FAPI_INF("Calling Shmoo for finding Timing Margin:");
-				if (shmoo_param_count)
-				{
-					rc = set_attribute(i_target_mba);
-					if (rc) return rc;
-				}
-				rc = delay_shmoo(i_target_mba, i_port, i_shmoo_type_valid,
-				&l_left_margin, &l_right_margin,
-				l_slew_rate_dq_dqs_in);
-				if (rc) return rc;
-				l_left_margin_slew_array[index] = l_left_margin;
-				l_right_margin_slew_array[index] = l_right_margin;
-				shmoo_param_count++;
-			}
-			else
-			{
-				l_left_margin_slew_array[index] = 0;
-				l_right_margin_slew_array[index] = 0;
-			}
-			l_slew_rate_dq_dqs_schmoo[i_port]
-			= (l_slew_rate_dq_dqs_schmoo[i_port] >> 1);
-		}
-		l_slew_rate_dq_dqs_nom_fc = l_slew_rate_dq_dqs_nom[i_port];
-		find_best_margin(SLEW_RATE, l_left_margin_slew_array,
-		l_right_margin_slew_array, MAX_NUM_SLEW_RATES,
-		l_slew_rate_dq_dqs_nom_fc, count);
-		if (count >= MAX_NUM_SLEW_RATES)
-		{
-			FAPI_ERR("Driver Imp new input(%d) out of bounds, (>= %d)", count,
-			MAX_NUM_SLEW_RATES);
-			const uint8_t & COUNT_DATA = count;
-			FAPI_SET_HWP_ERROR(rc, RC_SLEW_RATE_SHMOO_INVALID_MARGIN_DATA);
-			return rc;
-		}
-		else
-		{
-			FAPI_INF("Restoring the nominal values!");
-			rc = FAPI_ATTR_SET(ATTR_EFF_CEN_DRV_IMP_DQ_DQS, &i_target_mba,
-			l_drv_imp_dq_dqs_nom);
-			if (rc) return rc;
-			rc = config_drv_imp(i_target_mba, i_port,
-			l_drv_imp_dq_dqs_nom[i_port]);
-			if (rc) return rc;
-			rc = FAPI_ATTR_SET(ATTR_EFF_CEN_SLEW_RATE_DQ_DQS, &i_target_mba,
-			l_slew_rate_dq_dqs_nom);
-			if (rc) return rc;
-			rc = config_slew_rate(i_target_mba, i_port, l_slew_type,
-			l_drv_imp_dq_dqs_nom[i_port],
-			l_slew_rate_dq_dqs_nom[i_port]);
-			if (rc) return rc;
-		}
-		FAPI_INF("Restoring mcbist setup attribute...");
-		rc = reset_attribute(i_target_mba);
-		if (rc) return rc;
-		FAPI_INF("++++ Slew Rate shmoo function executed successfully ++++");
-	}
-	return rc;
+    fapi::ReturnCode rc;
+    uint8_t l_slew_rate_dq_dqs[MAX_PORT] = {0};
+    uint8_t l_slew_rate_dq_dqs_nom[MAX_PORT] = {0};
+    uint8_t l_slew_rate_dq_dqs_nom_fc = 0;
+    uint8_t l_slew_rate_dq_dqs_in = 0;
+    uint32_t l_slew_rate_dq_dqs_schmoo[MAX_PORT] = {0};
+    uint8_t l_drv_imp_dq_dqs_nom[MAX_PORT] = {0};
+    i_shmoo_type_valid = WR_EYE; // Hard coded - Other shmoo type is not valid - Temporary
+
+    uint8_t index = 0;
+    uint8_t count = 0;
+    uint8_t shmoo_param_count = 0;
+    uint32_t l_left_margin_slew_array[MAX_NUM_SLEW_RATES] = {0};
+    uint32_t l_right_margin_slew_array[MAX_NUM_SLEW_RATES] = {0};
+    uint32_t l_left_margin = 0;
+    uint32_t l_right_margin = 0;
+    uint8_t l_slew_type = 0; // Hard coded since this procedure will touch only DQ_DQS and not address
+
+    //Read Attributes - DRV IMP, SLEW, SLEW RATES values to be Schmoo'ed
+    rc = FAPI_ATTR_GET(ATTR_EFF_CEN_DRV_IMP_DQ_DQS, &i_target_mba, l_drv_imp_dq_dqs_nom);
+    if (rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_EFF_CEN_SLEW_RATE_DQ_DQS, &i_target_mba, l_slew_rate_dq_dqs_nom);
+    if (rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_EFF_CEN_DRV_IMP_DQ_DQS_SCHMOO, &i_target_mba, l_slew_rate_dq_dqs_schmoo);
+    if (rc) return rc;
+
+    FAPI_INF("+++++++++++++++++Read Slew Shmoo Attributes values+++++++++++++++");
+    FAPI_INF("CEN_DRV_IMP_DQ_DQS[0]  = [%02d] Ohms, CEN_DRV_IMP_DQ_DQS[1]  = [%02d] Ohms on %s",
+             l_drv_imp_dq_dqs_nom[0],
+             l_drv_imp_dq_dqs_nom[1],
+             i_target_mba.toEcmdString());
+    FAPI_INF("CEN_SLEW_RATE_DQ_DQS[0] = [%02d]V/ns , CEN_SLEW_RATE_DQ_DQS[1] = [%02d]V/ns on %s",
+             l_slew_rate_dq_dqs_nom[0],
+             l_slew_rate_dq_dqs_nom[1],
+             i_target_mba.toEcmdString());
+    FAPI_INF("CEN_SLEW_RATE_DQ_DQS_SCHMOO[0] = [0x%x], CEN_SLEW_RATE_DQ_DQS_SCHMOO[1] = [0x%x] on %s",
+             l_slew_rate_dq_dqs_schmoo[0],
+             l_slew_rate_dq_dqs_schmoo[1],
+             i_target_mba.toEcmdString());
+    FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
+
+    if(l_slew_rate_dq_dqs_schmoo == 0) //Check for any of the bits enabled in the shmoo
+    {
+        FAPI_INF("Slew Rate Shmoo set to FAST Mode and won't do anything");
+    }
+    else
+    {
+        for (index = 0; index < MAX_NUM_SLEW_RATES; index += 1)
+        {
+            if (l_slew_rate_dq_dqs_schmoo[i_port] & MASK)
+            {
+                l_slew_rate_dq_dqs[i_port] = slew_rate_array[index];
+                FAPI_INF("Current Slew rate value is %d V/ns",
+                         slew_rate_array[index]);
+                FAPI_INF("Configuring Slew registers:");
+                rc = config_slew_rate(i_target_mba, i_port, l_slew_type,
+                                      l_drv_imp_dq_dqs_nom[i_port],
+                                      l_slew_rate_dq_dqs[i_port]);
+                if (rc) return rc;
+                l_slew_rate_dq_dqs_in = l_slew_rate_dq_dqs[i_port];
+                FAPI_INF("Calling Shmoo for finding Timing Margin:");
+                if (shmoo_param_count)
+                {
+                    rc = set_attribute(i_target_mba);
+                    if (rc) return rc;
+                }
+                rc = delay_shmoo(i_target_mba, i_port, i_shmoo_type_valid,
+                                 &l_left_margin, &l_right_margin,
+                                 l_slew_rate_dq_dqs_in);
+                if (rc) return rc;
+                l_left_margin_slew_array[index] = l_left_margin;
+                l_right_margin_slew_array[index] = l_right_margin;
+                shmoo_param_count++;
+            }
+            else
+            {
+                l_left_margin_slew_array[index] = 0;
+                l_right_margin_slew_array[index] = 0;
+            }
+            l_slew_rate_dq_dqs_schmoo[i_port]
+                = (l_slew_rate_dq_dqs_schmoo[i_port] >> 1);
+        }
+        l_slew_rate_dq_dqs_nom_fc = l_slew_rate_dq_dqs_nom[i_port];
+        find_best_margin(SLEW_RATE, l_left_margin_slew_array,
+                         l_right_margin_slew_array, MAX_NUM_SLEW_RATES,
+                         l_slew_rate_dq_dqs_nom_fc, count);
+        if (count >= MAX_NUM_SLEW_RATES)
+        {
+            FAPI_ERR("Driver Imp new input(%d) out of bounds, (>= %d)", count,
+                     MAX_NUM_SLEW_RATES);
+            const uint8_t & COUNT_DATA = count;
+            FAPI_SET_HWP_ERROR(rc, RC_SLEW_RATE_SHMOO_INVALID_MARGIN_DATA);
+            return rc;
+        }
+        else
+        {
+            FAPI_INF("Restoring the nominal values!");
+            rc = FAPI_ATTR_SET(ATTR_EFF_CEN_DRV_IMP_DQ_DQS, &i_target_mba,
+                               l_drv_imp_dq_dqs_nom);
+            if (rc) return rc;
+            rc = config_drv_imp(i_target_mba, i_port,
+                                l_drv_imp_dq_dqs_nom[i_port]);
+            if (rc) return rc;
+            rc = FAPI_ATTR_SET(ATTR_EFF_CEN_SLEW_RATE_DQ_DQS, &i_target_mba,
+                               l_slew_rate_dq_dqs_nom);
+            if (rc) return rc;
+            rc = config_slew_rate(i_target_mba, i_port, l_slew_type,
+                                  l_drv_imp_dq_dqs_nom[i_port],
+                                  l_slew_rate_dq_dqs_nom[i_port]);
+            if (rc) return rc;
+        }
+        FAPI_INF("Restoring mcbist setup attribute...");
+        rc = reset_attribute(i_target_mba);
+        if (rc) return rc;
+        FAPI_INF("++++ Slew Rate shmoo function executed successfully ++++");
+    }
+    return rc;
 }
 
 //----------------------------------------------------------------------------------------------
@@ -780,656 +781,842 @@ shmoo_type_t i_shmoo_type_valid)
 //----------------------------------------------------------------------------------------------
 
 fapi::ReturnCode wr_vref_shmoo(const fapi::Target & i_target_mba,
-uint8_t i_port,
-shmoo_type_t i_shmoo_type_valid)
+                               uint8_t i_port,
+                               shmoo_type_t i_shmoo_type_valid)
 {
-	fapi::ReturnCode rc;
-	uint32_t l_wr_dram_vref[MAX_PORT] = {0};
-	uint32_t l_wr_dram_vref_nom[MAX_PORT] = {0};
-	uint32_t l_wr_dram_vref_schmoo[MAX_PORT] = {0}; 
-	uint32_t l_wr_dram_vref_nom_fc = 0;
-	uint32_t l_wr_dram_vref_in = 0;
-	i_shmoo_type_valid = MCBIST; 
-	
-	uint8_t index = 0;
-	uint8_t count = 0;
-	//uint8_t shmoo_param_count = 0;
-	uint32_t l_left_margin = 0;
-	uint32_t l_right_margin = 0;
-	uint32_t l_left_margin_wr_vref_array[MAX_WR_VREF]= {0};
-	uint32_t l_right_margin_wr_vref_array[MAX_WR_VREF]= {0};
-	
-	//Read the write vref attributes
-	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_WR_VREF, &i_target_mba, l_wr_dram_vref_nom); 
-	if (rc) return rc;
-	rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_WR_VREF_SCHMOO, &i_target_mba, l_wr_dram_vref_schmoo);
-	if (rc) return rc;
-	
-	FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++ Patch - Preet - WR_VREF - Check Sanity only at 500 +++++++++++++++++++++++++++");
-	rc = delay_shmoo(i_target_mba, i_port, i_shmoo_type_valid,
-	&l_left_margin, &l_right_margin,
-	l_wr_dram_vref_in);
-	if(rc) return rc;
-	FAPI_INF(" Setup and Sanity - Check disabled from now on..... Continuing .....");
-	rc = set_attribute(i_target_mba);
-	if (rc) return rc;
-	
-	
-	
-	i_shmoo_type_valid = WR_EYE;
-	
-	FAPI_INF("+++++++++++++++++WRITE DRAM VREF Shmoo Attributes Values+++++++++++++++");
-	FAPI_INF("DRAM_WR_VREF[0]  = %d , DRAM_WR_VREF[1]  = %d on %s",
-	l_wr_dram_vref_nom[0],
-	l_wr_dram_vref_nom[1],
-	i_target_mba.toEcmdString());
-	FAPI_INF("DRAM_WR_VREF_SCHMOO[0] = [%x],DRAM_WR_VREF_SCHMOO[1] = [%x] on %s",
-	l_wr_dram_vref_schmoo[0],
-	l_wr_dram_vref_schmoo[1],
-	i_target_mba.toEcmdString());
-	FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
-	
-	
-	if (l_wr_dram_vref_schmoo[i_port] == 0)
-	{
-		FAPI_INF("FAST Shmoo Mode: This function will not change any Write DRAM VREF settings");
-	}
-	else
-	{
-		for (index = 0; index < MAX_WR_VREF; index += 1)
-		{
-			if (l_wr_dram_vref_schmoo[i_port] & MASK)
-			{
-				FAPI_INF("Current Vref multiplier value is %d",
-				wr_vref_array[index]);
-				l_wr_dram_vref[i_port] = wr_vref_array[index];
-				rc = config_wr_dram_vref(i_target_mba, i_port,
-				l_wr_dram_vref[i_port]);
-				if (rc) return rc;
-				l_wr_dram_vref_in = l_wr_dram_vref[i_port];
-				//FAPI_INF(" Calling Shmoo for finding Timing Margin:");
-				
-				rc = delay_shmoo(i_target_mba, i_port, i_shmoo_type_valid,
-				&l_left_margin, &l_right_margin,
-				l_wr_dram_vref_in);
-				if (rc) return rc;
-				l_left_margin_wr_vref_array[index] = l_left_margin;
-				l_right_margin_wr_vref_array[index] = l_right_margin;
-				
-				FAPI_INF("Wr Vref = %d ; Min Setup time = %d; Min Hold time = %d",
-				wr_vref_array[index],
-				l_left_margin_wr_vref_array[index],
-				l_right_margin_wr_vref_array[index]);
-			}
-			else
-			{
-				l_left_margin_wr_vref_array[index] = 0;
-				l_right_margin_wr_vref_array[index] = 0;
-			}
-			l_wr_dram_vref_schmoo[i_port] = (l_wr_dram_vref_schmoo[i_port] >> 1);
-			//FAPI_INF("Wr Vref = %d ; Min Setup time = %d; Min Hold time = %d", wr_vref_array[index],l_left_margin_wr_vref_array[index],  l_right_margin_wr_vref_array[index]);
-			//FAPI_INF("Configuring Vref registers_2:, index %d , max value %d, schmoo %x mask %d ", index, MAX_WR_VREF, l_wr_dram_vref_schmoo[i_port], MASK);
-		}
-		l_wr_dram_vref_nom_fc = l_wr_dram_vref_nom[i_port];
-		find_best_margin(WR_VREF, l_left_margin_wr_vref_array,
-		l_right_margin_wr_vref_array, MAX_WR_VREF,
-		l_wr_dram_vref_nom_fc, count);
-		if (count >= MAX_WR_VREF)
-		{
-			FAPI_ERR("Write dram vref input(%d) out of bounds, (>= %d)", count,
-			MAX_WR_VREF);
-			const uint8_t & COUNT_DATA = count;
-			FAPI_SET_HWP_ERROR(rc, RC_WR_VREF_SHMOO_INVALID_MARGIN_DATA);
-			return rc;
-		}
-		else
-		{
-			//   FAPI_INF("Nominal value will not be changed!- Restoring the original values!");
-			FAPI_INF(" Restoring the nominal values!");
-			rc = FAPI_ATTR_SET(ATTR_EFF_DRAM_WR_VREF, &i_target_mba,
-			l_wr_dram_vref_nom);
-			if (rc) return rc;
-			rc = config_wr_dram_vref(i_target_mba, i_port,
-			l_wr_dram_vref_nom[i_port]);
-			if (rc) return rc;
-		}
-		FAPI_INF("Restoring mcbist setup attribute...");
-		rc = reset_attribute(i_target_mba);
-		if (rc) return rc;
-		FAPI_INF("++++ Write DRAM Vref Shmoo function executed successfully ++++");
-	}
-	return rc;
+    fapi::ReturnCode rc;
+    uint32_t l_wr_dram_vref[MAX_PORT] = {0};
+    uint32_t l_wr_dram_vref_nom[MAX_PORT] = {0};
+    uint32_t l_wr_dram_vref_schmoo[MAX_PORT] = {0};
+    uint32_t l_wr_dram_vref_nom_fc = 0;
+    uint32_t l_wr_dram_vref_in = 0;
+    i_shmoo_type_valid = MCBIST;
+
+    uint8_t index = 0;
+    uint8_t count = 0;
+    //uint8_t shmoo_param_count = 0;
+    uint32_t l_left_margin = 0;
+    uint32_t l_right_margin = 0;
+    uint32_t l_left_margin_wr_vref_array[MAX_WR_VREF]= {0};
+    uint32_t l_right_margin_wr_vref_array[MAX_WR_VREF]= {0};
+
+    //Read the write vref attributes
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_WR_VREF, &i_target_mba, l_wr_dram_vref_nom);
+    if (rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_WR_VREF_SCHMOO, &i_target_mba, l_wr_dram_vref_schmoo);
+    if (rc) return rc;
+
+    FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++ Patch - Preet - WR_VREF - Check Sanity only at 500 +++++++++++++++++++++++++++");
+    rc = delay_shmoo(i_target_mba, i_port, i_shmoo_type_valid,
+                     &l_left_margin, &l_right_margin,
+                     l_wr_dram_vref_in);
+    if(rc) return rc;
+    FAPI_INF(" Setup and Sanity - Check disabled from now on..... Continuing .....");
+    rc = set_attribute(i_target_mba);
+    if (rc) return rc;
+
+
+
+    i_shmoo_type_valid = WR_EYE;
+
+    FAPI_INF("+++++++++++++++++WRITE DRAM VREF Shmoo Attributes Values+++++++++++++++");
+    FAPI_INF("DRAM_WR_VREF[0]  = %d , DRAM_WR_VREF[1]  = %d on %s",
+             l_wr_dram_vref_nom[0],
+             l_wr_dram_vref_nom[1],
+             i_target_mba.toEcmdString());
+    FAPI_INF("DRAM_WR_VREF_SCHMOO[0] = [%x],DRAM_WR_VREF_SCHMOO[1] = [%x] on %s",
+             l_wr_dram_vref_schmoo[0],
+             l_wr_dram_vref_schmoo[1],
+             i_target_mba.toEcmdString());
+    FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
+
+
+    if (l_wr_dram_vref_schmoo[i_port] == 0)
+    {
+        FAPI_INF("FAST Shmoo Mode: This function will not change any Write DRAM VREF settings");
+    }
+    else
+    {
+        for (index = 0; index < MAX_WR_VREF; index += 1)
+        {
+            if (l_wr_dram_vref_schmoo[i_port] & MASK)
+            {
+                FAPI_INF("Current Vref multiplier value is %d",
+                         wr_vref_array[index]);
+                l_wr_dram_vref[i_port] = wr_vref_array[index];
+                rc = config_wr_dram_vref(i_target_mba, i_port,
+                                         l_wr_dram_vref[i_port]);
+                if (rc) return rc;
+                l_wr_dram_vref_in = l_wr_dram_vref[i_port];
+                //FAPI_INF(" Calling Shmoo for finding Timing Margin:");
+
+                rc = delay_shmoo(i_target_mba, i_port, i_shmoo_type_valid,
+                                 &l_left_margin, &l_right_margin,
+                                 l_wr_dram_vref_in);
+                if (rc) return rc;
+                l_left_margin_wr_vref_array[index] = l_left_margin;
+                l_right_margin_wr_vref_array[index] = l_right_margin;
+
+                FAPI_INF("Wr Vref = %d ; Min Setup time = %d; Min Hold time = %d",
+                         wr_vref_array[index],
+                         l_left_margin_wr_vref_array[index],
+                         l_right_margin_wr_vref_array[index]);
+            }
+            else
+            {
+                l_left_margin_wr_vref_array[index] = 0;
+                l_right_margin_wr_vref_array[index] = 0;
+            }
+            l_wr_dram_vref_schmoo[i_port] = (l_wr_dram_vref_schmoo[i_port] >> 1);
+            //FAPI_INF("Wr Vref = %d ; Min Setup time = %d; Min Hold time = %d", wr_vref_array[index],l_left_margin_wr_vref_array[index],  l_right_margin_wr_vref_array[index]);
+            //FAPI_INF("Configuring Vref registers_2:, index %d , max value %d, schmoo %x mask %d ", index, MAX_WR_VREF, l_wr_dram_vref_schmoo[i_port], MASK);
+        }
+        l_wr_dram_vref_nom_fc = l_wr_dram_vref_nom[i_port];
+        find_best_margin(WR_VREF, l_left_margin_wr_vref_array,
+                         l_right_margin_wr_vref_array, MAX_WR_VREF,
+                         l_wr_dram_vref_nom_fc, count);
+        if (count >= MAX_WR_VREF)
+        {
+            FAPI_ERR("Write dram vref input(%d) out of bounds, (>= %d)", count,
+                     MAX_WR_VREF);
+            const uint8_t & COUNT_DATA = count;
+            FAPI_SET_HWP_ERROR(rc, RC_WR_VREF_SHMOO_INVALID_MARGIN_DATA);
+            return rc;
+        }
+        else
+        {
+            //   FAPI_INF("Nominal value will not be changed!- Restoring the original values!");
+            FAPI_INF(" Restoring the nominal values!");
+            rc = FAPI_ATTR_SET(ATTR_EFF_DRAM_WR_VREF, &i_target_mba,
+                               l_wr_dram_vref_nom);
+            if (rc) return rc;
+            rc = config_wr_dram_vref(i_target_mba, i_port,
+                                     l_wr_dram_vref_nom[i_port]);
+            if (rc) return rc;
+        }
+        FAPI_INF("Restoring mcbist setup attribute...");
+        rc = reset_attribute(i_target_mba);
+        if (rc) return rc;
+        FAPI_INF("++++ Write DRAM Vref Shmoo function executed successfully ++++");
+    }
+    return rc;
 }
 
 //////////////////////////////////////////////wr_vref schmoo for ddr4 ////////////////////////////////////////////////////////////
 fapi::ReturnCode wr_vref_shmoo_ddr4(const fapi::Target & i_target_mba)
 {
-	fapi::ReturnCode rc;
-	uint8_t max_port = 2;
-	uint8_t max_ddr4_vrefs1 = 51;
-	shmoo_type_t i_shmoo_type_valid = MCBIST; // Hard coded - Temporary
-	ecmdDataBufferBase l_data_buffer_64(64);
-	uint32_t l_left_margin = 0;
-	uint32_t l_right_margin = 0;
-	uint8_t l_attr_eff_dimm_type_u8 = 0;
-	uint8_t vrefdq_train_range[2][2][4];
-	uint8_t num_ranks_per_dimm[2][2];
-	uint8_t l_MAX_RANKS[2];
-	uint32_t rc_num = 0;
-	uint8_t l_SCHMOO_NIBBLES=20;
-	uint32_t base_percent = 60000;
-	
-	uint32_t index_mul_print = 650;
-	uint8_t l_attr_schmoo_test_type_u8 = 1;
-	uint32_t vref_val_print = 0;
-	rc = FAPI_ATTR_GET(ATTR_EFF_CUSTOM_DIMM, &i_target_mba, l_attr_eff_dimm_type_u8); if(rc) return rc;
-	rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target_mba, num_ranks_per_dimm); if(rc) return rc;
-	rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_RANGE, &i_target_mba, vrefdq_train_range);if(rc) return rc;
-	rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_TEST_VALID, &i_target_mba, l_attr_schmoo_test_type_u8); if(rc) return rc;
-	if(vrefdq_train_range[0][0][0] == 1)
-	{
-		base_percent = 45000;
-	}
-	
-	l_MAX_RANKS[0]=num_ranks_per_dimm[0][0]+num_ranks_per_dimm[0][1];
-	l_MAX_RANKS[1]=num_ranks_per_dimm[1][0]+num_ranks_per_dimm[1][1];
-	//FAPI_INF("\n ** l_max_rank 0 = %d",l_MAX_RANKS[0]);
-	if ( l_attr_eff_dimm_type_u8 == fapi::ENUM_ATTR_EFF_CUSTOM_DIMM_YES )
-		{
-			l_SCHMOO_NIBBLES=20;
-		}
-	else
-		{
-			l_SCHMOO_NIBBLES=18;
-		}
-		FAPI_INF(" +++  l_SCHMOO_NIBBLES = %d +++ ",l_SCHMOO_NIBBLES);
-	///// ddr4 vref //////
-	fapi::Target l_target_centaur=i_target_mba;
-	
-	uint8_t vrefdq_train_value[2][2][4]; 
-	uint8_t vrefdq_train_enable[2][2][4]; 
-	//uint32_t best_margin[2][8][20];
-	//uint32_t best_vref[50][2][8][20];
-	//uint32_t best_vref_nibble[2][8][20];
-	uint32_t vref_val=0;
-	uint32_t pda_nibble_table[2][2][4][16][2];
-	uint8_t i=0;
-	uint8_t j=0;
-	uint8_t k=0;
-	uint8_t a=0;
-	uint8_t c=0;
-	uint8_t l_ranks = 0;
-	uint8_t l_vref_num = 0;
-	uint8_t i_port=0;
-		
-	FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++ Patch - WR_VREF - Check Sanity only at 500 ddr4 +++++++++++++++++++++++++++");
-	rc = delay_shmoo_ddr4(i_target_mba, i_port, i_shmoo_type_valid,
-	&l_left_margin, &l_right_margin,
-	vref_val,pda_nibble_table);
-	
-	if(rc) return rc;
-	FAPI_INF(" Setup and Sanity - Check disabled from now on..... Continuing .....");
-	rc = set_attribute(i_target_mba);
-	if (rc) return rc;
-	
-	
-	
-	i_shmoo_type_valid = WR_EYE;
-	l_attr_schmoo_test_type_u8 = 2;
-	rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_TEST_VALID, &i_target_mba, l_attr_schmoo_test_type_u8); if(rc) return rc;
-	//Initialize all to zero
-
-for(l_vref_num=0; l_vref_num < max_ddr4_vrefs1; l_vref_num++){
-		vref_val = l_vref_num;
-		vref_val_print = base_percent + (l_vref_num * index_mul_print);	
-		
-		rc = fapiGetScom(i_target_mba,0x03010432,l_data_buffer_64); if(rc) return rc;
-		rc_num = rc_num | l_data_buffer_64.clearBit(0); if(rc_num) return rc;
-		rc = fapiPutScom(i_target_mba,0x03010432,l_data_buffer_64); if(rc) return rc;
-		//system("putscom cen.mba 03010432 0 1 0 -ib -all");
-		FAPI_INF("\n After Clearing Refresh");
-		for(i=0;i< max_port;i++){
-			for(j=0;j<2;j++){
-				for(k=0;k<4;k++){
-					
-					vrefdq_train_enable[i][j][k]=0x00;
-					
-				}
-			}
-		}	
-		
-		rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_RANGE, &i_target_mba, vrefdq_train_range);if(rc) return rc;
-		rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);if(rc) return rc;
-		rc = mss_mrs6_DDR4(l_target_centaur);
-		if(rc)
-		{
-			//FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
-			return rc;
-		}
-		
-		
-		
-		for(a=0;a < max_port;a++){
-			for(l_ranks=0;l_ranks < l_MAX_RANKS[0];l_ranks++){
-				for(c=0;c<4;c++){
-					
-					vrefdq_train_value[a][l_ranks][c]=vref_val;
-					
-				}
-			}
-		}
-		
-		rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_VALUE, &i_target_mba, vrefdq_train_value);
-		
-		
-		rc = mss_mrs6_DDR4(l_target_centaur);
-		if(rc)
-		{
-			//FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
-			return rc;
-		}
-		
-		FAPI_INF("The Vref value is %d .... The percent voltage bump = %d ",vref_val,vref_val_print);
-		
-		for(i=0;i< max_port;i++){
-			for(j=0;j<l_MAX_RANKS[0];j++){
-				for(k=0;k<4;k++){
-					
-					vrefdq_train_enable[i][j][k]=0x01;
-					
-				}
-			}
-		}	
-		rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);if(rc) return rc;
-		rc = mss_mrs6_DDR4(l_target_centaur);
-		if(rc)
-		{
-			//FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
-			return rc;
-		}
-		
-		rc = fapiGetScom(i_target_mba,0x03010432,l_data_buffer_64); if(rc) return rc;
-		rc_num = rc_num | l_data_buffer_64.setBit(0); if(rc_num) return rc;
-		rc = fapiPutScom(i_target_mba,0x03010432,l_data_buffer_64); if(rc) return rc;
-		
-		//system("putscom cen.mba 03010432 0 1 1 -ib -all");
-		
-		rc = delay_shmoo_ddr4(i_target_mba, i_port, i_shmoo_type_valid,
-		&l_left_margin, &l_right_margin,
-		vref_val,pda_nibble_table);
-		if (rc) return rc;
-		
-		FAPI_INF("Wr Vref = %d ; Min Setup time = %d; Min Hold time = %d",
-		vref_val_print,
-		l_left_margin,
-		l_right_margin);
-		
-		//vref_val=vref_val+1;
-	}   
-	
-	
-	
-	
-	//Read the write vref attributes
-	
-	
-	
-	return rc;
+    fapi::ReturnCode rc;
+    uint8_t max_port = 2;
+    uint8_t max_ddr4_vrefs1 = 51;
+    shmoo_type_t i_shmoo_type_valid = MCBIST; // Hard coded - Temporary
+    ecmdDataBufferBase l_data_buffer_64(64);
+    uint32_t l_left_margin = 0;
+    uint32_t l_right_margin = 0;
+    uint8_t l_attr_eff_dimm_type_u8 = 0;
+    uint8_t vrefdq_train_range[2][2][4];
+    uint8_t num_ranks_per_dimm[2][2];
+    uint8_t l_MAX_RANKS[2];
+    uint32_t rc_num = 0;
+    uint8_t l_SCHMOO_NIBBLES=20;
+    uint32_t base_percent = 60000;
+
+    uint32_t index_mul_print = 650;
+    uint8_t l_attr_schmoo_test_type_u8 = 1;
+    uint32_t vref_val_print = 0;
+    rc = FAPI_ATTR_GET(ATTR_EFF_CUSTOM_DIMM, &i_target_mba, l_attr_eff_dimm_type_u8);
+    if(rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_EFF_NUM_RANKS_PER_DIMM, &i_target_mba, num_ranks_per_dimm);
+    if(rc) return rc;
+    rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_RANGE, &i_target_mba, vrefdq_train_range);
+    if(rc) return rc;
+    rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_TEST_VALID, &i_target_mba, l_attr_schmoo_test_type_u8);
+    if(rc) return rc;
+    if(vrefdq_train_range[0][0][0] == 1)
+    {
+        base_percent = 45000;
+    }
+
+    l_MAX_RANKS[0]=num_ranks_per_dimm[0][0]+num_ranks_per_dimm[0][1];
+    l_MAX_RANKS[1]=num_ranks_per_dimm[1][0]+num_ranks_per_dimm[1][1];
+    //FAPI_INF("\n ** l_max_rank 0 = %d",l_MAX_RANKS[0]);
+    if ( l_attr_eff_dimm_type_u8 == fapi::ENUM_ATTR_EFF_CUSTOM_DIMM_YES )
+    {
+        l_SCHMOO_NIBBLES=20;
+    }
+    else
+    {
+        l_SCHMOO_NIBBLES=18;
+    }
+    FAPI_INF(" +++  l_SCHMOO_NIBBLES = %d +++ ",l_SCHMOO_NIBBLES);
+    ///// ddr4 vref //////
+    fapi::Target l_target_centaur=i_target_mba;
+
+    uint8_t vrefdq_train_value[2][2][4];
+    uint8_t vrefdq_train_enable[2][2][4];
+    //uint32_t best_margin[2][8][20];
+    //uint32_t best_vref[50][2][8][20];
+    //uint32_t best_vref_nibble[2][8][20];
+    uint32_t vref_val=0;
+    uint32_t pda_nibble_table[2][2][4][16][2];
+    uint8_t i=0;
+    uint8_t j=0;
+    uint8_t k=0;
+    uint8_t a=0;
+    uint8_t c=0;
+    uint8_t l_ranks = 0;
+    uint8_t l_vref_num = 0;
+    uint8_t i_port=0;
+
+    FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++ Patch - WR_VREF - Check Sanity only at 500 ddr4 +++++++++++++++++++++++++++");
+    rc = delay_shmoo_ddr4(i_target_mba, i_port, i_shmoo_type_valid,
+                          &l_left_margin, &l_right_margin,
+                          vref_val,pda_nibble_table);
+
+    if(rc) return rc;
+    FAPI_INF(" Setup and Sanity - Check disabled from now on..... Continuing .....");
+    rc = set_attribute(i_target_mba);
+    if (rc) return rc;
+
+
+
+    i_shmoo_type_valid = WR_EYE;
+    l_attr_schmoo_test_type_u8 = 2;
+    rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_TEST_VALID, &i_target_mba, l_attr_schmoo_test_type_u8);
+    if(rc) return rc;
+    //Initialize all to zero
+
+    for(l_vref_num=0; l_vref_num < max_ddr4_vrefs1; l_vref_num++) {
+        vref_val = l_vref_num;
+        vref_val_print = base_percent + (l_vref_num * index_mul_print);
+
+        rc = fapiGetScom(i_target_mba,0x03010432,l_data_buffer_64);
+        if(rc) return rc;
+        rc_num = rc_num | l_data_buffer_64.clearBit(0);
+        if(rc_num) return rc;
+        rc = fapiPutScom(i_target_mba,0x03010432,l_data_buffer_64);
+        if(rc) return rc;
+        //system("putscom cen.mba 03010432 0 1 0 -ib -all");
+        FAPI_INF("\n After Clearing Refresh");
+        for(i=0; i< max_port; i++) {
+            for(j=0; j<2; j++) {
+                for(k=0; k<4; k++) {
+
+                    vrefdq_train_enable[i][j][k]=0x00;
+
+                }
+            }
+        }
+
+        rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_RANGE, &i_target_mba, vrefdq_train_range);
+        if(rc) return rc;
+        rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);
+        if(rc) return rc;
+        rc = mss_mrs6_DDR4(l_target_centaur);
+        if(rc)
+        {
+            //FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
+            return rc;
+        }
+
+
+
+        for(a=0; a < max_port; a++) {
+            for(l_ranks=0; l_ranks < l_MAX_RANKS[0]; l_ranks++) {
+                for(c=0; c<4; c++) {
+
+                    vrefdq_train_value[a][l_ranks][c]=vref_val;
+
+                }
+            }
+        }
+
+        rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_VALUE, &i_target_mba, vrefdq_train_value);
+
+
+        rc = mss_mrs6_DDR4(l_target_centaur);
+        if(rc)
+        {
+            //FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
+            return rc;
+        }
+
+        FAPI_INF("The Vref value is %d .... The percent voltage bump = %d ",vref_val,vref_val_print);
+
+        for(i=0; i< max_port; i++) {
+            for(j=0; j<l_MAX_RANKS[0]; j++) {
+                for(k=0; k<4; k++) {
+
+                    vrefdq_train_enable[i][j][k]=0x01;
+
+                }
+            }
+        }
+        rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);
+        if(rc) return rc;
+        rc = mss_mrs6_DDR4(l_target_centaur);
+        if(rc)
+        {
+            //FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
+            return rc;
+        }
+
+        rc = fapiGetScom(i_target_mba,0x03010432,l_data_buffer_64);
+        if(rc) return rc;
+        rc_num = rc_num | l_data_buffer_64.setBit(0);
+        if(rc_num) return rc;
+        rc = fapiPutScom(i_target_mba,0x03010432,l_data_buffer_64);
+        if(rc) return rc;
+
+        //system("putscom cen.mba 03010432 0 1 1 -ib -all");
+
+        rc = delay_shmoo_ddr4(i_target_mba, i_port, i_shmoo_type_valid,
+                              &l_left_margin, &l_right_margin,
+                              vref_val,pda_nibble_table);
+        if (rc) return rc;
+
+        FAPI_INF("Wr Vref = %d ; Min Setup time = %d; Min Hold time = %d",
+                 vref_val_print,
+                 l_left_margin,
+                 l_right_margin);
+
+        //vref_val=vref_val+1;
+    }
+
+
+
+
+    //Read the write vref attributes
+
+
+
+    return rc;
 }
 
 
 fapi::ReturnCode wr_vref_shmoo_ddr4_bin(const fapi::Target & i_target_mba)
 {
-	fapi::ReturnCode rc;
-	uint8_t MAX_PORT = 2;
-	uint8_t MAX_DIMM = 2;
-	//uint8_t max_ddr4_vrefs1 = 52;
-	shmoo_type_t i_shmoo_type_valid = MCBIST;
-	ecmdDataBufferBase l_data_buffer_64(64);
-	ecmdDataBufferBase refresh_reg(64); 
-	uint32_t l_left_margin = 0;
-	uint32_t l_right_margin = 0;
-	uint8_t l_attr_eff_dimm_type_u8 = 0;
-	uint8_t vrefdq_train_range[2][2][4];
-	uint8_t num_ranks_per_dimm[2][2];
-	//uint8_t l_MAX_RANKS[2];
-	uint32_t total_val = 0;
-	uint32_t last_total = 0;
-	uint32_t base_percent = 60000;
-	uint32_t pda_nibble_table[2][2][4][16][2];  // Port,Dimm,Rank,Nibble,[2]
-	uint32_t best_pda_nibble_table[2][2][4][16][2];
-	uint8_t cal_control = 0;
-	///// ddr4 vref //////
-	uint8_t vrefdq_train_value[2][2][4]; 
-	uint8_t vrefdq_train_enable[2][2][4]; 
-	uint32_t vref_val=0;
-	uint8_t i=0;
-	uint8_t j=0;
-	uint8_t k=0;
-	uint8_t a=0;
-	uint8_t c=0;
-	uint32_t rc_num = 0;
-	uint8_t l_dimm = 0;
-	uint8_t i_port=0;
-	uint8_t l_vref_mid = 0;
-	uint8_t imax = 	39;
-	uint8_t imin = 13;
-	uint8_t last_known_vref = 0;
-	uint8_t l_loop_count = 0;
-	vector<PDA_MRS_Storage> pda;
-	pda.clear();
-	uint32_t index_mul_print = 650;
-	uint8_t l_attr_schmoo_test_type_u8 = 1;
-	uint32_t vref_val_print = 0;
-	uint8_t vpd_wr_vref_value[2] = {0};
-	fapi::Target l_target_centaur=i_target_mba;
-	fapi::Target l_target_centaur1;
-	rc = fapiGetParentChip(i_target_mba, l_target_centaur1); 
-	if(rc) return rc;
-	
-	rc = FAPI_ATTR_GET(ATTR_EFF_CUSTOM_DIMM, &i_target_mba, l_attr_eff_dimm_type_u8); if(rc) return rc;
-	rc = FAPI_ATTR_GET(ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, &i_target_mba, num_ranks_per_dimm); if(rc) return rc;
-	rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_RANGE, &i_target_mba, vrefdq_train_range);if(rc) return rc;
-	rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_TEST_VALID, &i_target_mba, l_attr_schmoo_test_type_u8); if(rc) return rc;
-	rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_WRDDR4_VREF, &i_target_mba, vpd_wr_vref_value); if(rc) return rc;
-	rc = FAPI_ATTR_GET( ATTR_MSS_VREF_CAL_CNTL, &l_target_centaur1, cal_control);if(rc) return rc;
-	//FAPI_INF("++++++++++++++ATTR_MSS_VREF_CAL_CNTL = %d +++++++++++++++++++++++++++",cal_control);
-	
-	if(vrefdq_train_range[0][0][0] == 1)
-	{
-		base_percent = 45;
-	}
-	
-	FAPI_INF("Setting MCBIST DONE bit MASK as FW reports FIR bits!...");
-	//Workaround MCBIST MASK Bit as FW reports FIR bits --- > SET
-	rc = fapiGetScom(i_target_mba, 0x03010614, l_data_buffer_64);
-        if (rc) return rc;
-        rc_num = l_data_buffer_64.setBit(10);
-        if (rc_num)
+    fapi::ReturnCode rc;
+    uint8_t MAX_PORT = 2;
+    uint8_t MAX_DIMM = 2;
+    //uint8_t max_ddr4_vrefs1 = 52;
+    shmoo_type_t i_shmoo_type_valid = MCBIST;
+    ecmdDataBufferBase l_data_buffer_64(64);
+    ecmdDataBufferBase refresh_reg(64);
+    uint32_t l_left_margin = 0;
+    uint32_t l_right_margin = 0;
+    uint8_t l_attr_eff_dimm_type_u8 = 0;
+    uint8_t vrefdq_train_range[2][2][4];
+    uint8_t num_ranks_per_dimm[2][2];
+    //uint8_t l_MAX_RANKS[2];
+    uint32_t total_val = 0;
+    uint32_t last_total = 0;
+    uint32_t base_percent = 60000;
+    uint32_t pda_nibble_table[2][2][4][16][2];  // Port,Dimm,Rank,Nibble,[2]
+    uint32_t best_pda_nibble_table[2][2][4][16][2];
+    uint8_t cal_control = 0;
+    ///// ddr4 vref //////
+    uint8_t vrefdq_train_value[2][2][4];
+    uint8_t vrefdq_train_enable[2][2][4];
+    uint32_t vref_val=0;
+    uint8_t i=0;
+    uint8_t j=0;
+    uint8_t k=0;
+    uint8_t a=0;
+    uint8_t c=0;
+    uint32_t avg_best_vref = 0;
+    uint32_t rc_num = 0;
+    uint8_t l_dimm = 0;
+    uint8_t i_port=0;
+    uint8_t l_vref_mid = 0;
+    uint8_t imax = 	39;
+    uint8_t imin = 13;
+    uint8_t last_known_vref = 0;
+    uint8_t l_loop_count = 0;
+    uint8_t dram_width = 0;
+    vector<PDA_MRS_Storage> pda;
+    pda.clear();
+    uint32_t index_mul_print = 650;
+    uint8_t l_attr_schmoo_test_type_u8 = 1;
+    uint32_t vref_val_print = 0;
+    uint8_t vpd_wr_vref_value[2] = {0};
+    fapi::Target l_target_centaur=i_target_mba;
+    fapi::Target l_target_centaur1;
+    rc = fapiGetParentChip(i_target_mba, l_target_centaur1);
+    if(rc) return rc;
+
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_WIDTH, &i_target_mba, dram_width);
+    if(rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_EFF_CUSTOM_DIMM, &i_target_mba, l_attr_eff_dimm_type_u8);
+    if(rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, &i_target_mba, num_ranks_per_dimm);
+    if(rc) return rc;
+    rc = FAPI_ATTR_GET( ATTR_EFF_VREF_DQ_TRAIN_RANGE, &i_target_mba, vrefdq_train_range);
+    if(rc) return rc;
+    rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_TEST_VALID, &i_target_mba, l_attr_schmoo_test_type_u8);
+    if(rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_WRDDR4_VREF, &i_target_mba, vpd_wr_vref_value);
+    if(rc) return rc;
+    rc = FAPI_ATTR_GET( ATTR_MSS_VREF_CAL_CNTL, &l_target_centaur1, cal_control);
+    if(rc) return rc;
+    rc = FAPI_ATTR_GET( ATTR_MSS_VREF_CAL_CNTL, &l_target_centaur1, cal_control);
+    if(rc) return rc;
+    //FAPI_INF("++++++++++++++ATTR_MSS_VREF_CAL_CNTL = %d +++++++++++++++++++++++++++",cal_control);
+
+    if(vrefdq_train_range[0][0][0] == 1)
+    {
+        base_percent = 45;
+    }
+
+    FAPI_INF("Setting MCBIST DONE bit MASK as FW reports FIR bits!...");
+    //Workaround MCBIST MASK Bit as FW reports FIR bits --- > SET
+    rc = fapiGetScom(i_target_mba, 0x03010614, l_data_buffer_64);
+    if (rc) return rc;
+    rc_num = l_data_buffer_64.setBit(10);
+    if (rc_num)
+    {
+        FAPI_ERR("Buffer error in function wr_vref_shmoo_ddr4_bin Workaround MCBIST MASK Bit");
+        rc.setEcmdError(rc_num);
+        return rc;
+    }
+
+
+    FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++ WR_VREF - Check Sanity only MCBIST +++++++++++++++++++++++++++");
+    rc = delay_shmoo_ddr4_pda(i_target_mba, i_port, i_shmoo_type_valid,
+                              &l_left_margin, &l_right_margin,
+                              vref_val,pda_nibble_table);
+
+    if(rc) return rc;
+    FAPI_INF(" Setup and Sanity - Check disabled from now on..... Continuing .....");
+    FAPI_INF(" RUNNING GLANCY'S CODE UPDATES!!!!!!!!!!!!!!");
+    rc = set_attribute(i_target_mba);
+    if (rc) return rc;
+
+    if (cal_control !=0)
+    {
+        i_shmoo_type_valid = WR_EYE;
+        l_attr_schmoo_test_type_u8 = 2;
+        rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_TEST_VALID, &i_target_mba, l_attr_schmoo_test_type_u8);
+        if(rc) return rc;
+        //Initialize all to zero
+        /*for(index = 0; index < 50;index++)
+        {
+        	best_vref[index] = 0;
+
+        }
+        */
+        //Initialise All to Zero [2][2][4]
+
+        for(k=0; k < MAX_PORT; k++) // port
         {
-            FAPI_ERR("Buffer error in function wr_vref_shmoo_ddr4_bin Workaround MCBIST MASK Bit");
-            rc.setEcmdError(rc_num);
+            for(l_dimm=0; l_dimm < 2; l_dimm++) //Dimm
+            {
+                for(j=0; j < 4; j++) //Rank
+                {
+                    for(i=0; i<16; i++) //Nibble
+                    {
+                        pda_nibble_table[k][l_dimm][j][i][0] = 0;  //  Index 0 Are V-refs
+                        pda_nibble_table[k][l_dimm][j][i][1] = 0;   // Index 1 are Total Margin Values
+                        best_pda_nibble_table[k][l_dimm][j][i][0] = 0;   //  Index 0 Are V-refs
+                        best_pda_nibble_table[k][l_dimm][j][i][1] = 0;    // Index 1 are Total Margin Values
+                    }
+                }
+            }
+        }
+
+        while(imax >= imin) {
+
+            if(l_loop_count==0)
+                l_vref_mid = imin;
+            else
+                l_vref_mid = (imax+imin)/2;
+
+            vref_val = l_vref_mid;
+            vref_val_print = base_percent + (l_vref_mid * index_mul_print);
+            FAPI_INF("The Vref value is = %d; The percent voltage bump = %d ",vref_val,vref_val_print);
+            //FAPI_INF("\n Before Clearing Refresh");
+            rc = fapiGetScom(i_target_mba,0x03010432,l_data_buffer_64);
+            if(rc) return rc;
+            l_data_buffer_64.clearBit(0);
+            rc = fapiPutScom(i_target_mba,0x03010432,l_data_buffer_64);
+            if(rc) return rc;
+            //FAPI_INF("\n After Clearing Refresh");
+
+            for(i=0; i<MAX_PORT; i++) {
+                for(j=0; j<MAX_DIMM; j++) {
+                    for(k=0; k<4; k++) {
+
+                        vrefdq_train_enable[i][j][k]=0x01;
+
+                    }
+                }
+            }
+
+            rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_RANGE, &i_target_mba, vrefdq_train_range);
+            if(rc) return rc;
+            rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);
+            if(rc) return rc;
+            for(a=0; a < MAX_PORT; a++) //Port
+            {
+                for(l_dimm=0; l_dimm < MAX_DIMM; l_dimm++) //Max dimms
+                {
+                    for(c=0; c < 4; c++) //Ranks
+                    {
+
+                        vrefdq_train_value[a][l_dimm][c]=vref_val;
+
+                    }
+                }
+            }
+
+            rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_VALUE, &i_target_mba, vrefdq_train_value);
+            if(rc) return rc;
+            rc = mss_mrs6_DDR4(l_target_centaur);
+            if(rc)
+            {
+                FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
+                return rc;
+            }
+            // Call it Twice to Latch (Steve)
+            rc = mss_mrs6_DDR4(l_target_centaur);
+            if(rc)
+            {
+                FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
+                return rc;
+            }
+
+            for(i=0; i < MAX_PORT; i++) {
+                for(j=0; j<2; j++) {
+                    for(k=0; k<4; k++) {
+
+                        vrefdq_train_enable[i][j][k]=0x00;
+
+                    }
+                }
+            }
+            rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);
+            if(rc) return rc;
+            rc = mss_mrs6_DDR4(l_target_centaur);
+            if(rc)
+            {
+                FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
+                return rc;
+            }
+
+            rc = fapiGetScom(i_target_mba,0x03010432,l_data_buffer_64);
+            if(rc) return rc;
+            l_data_buffer_64.setBit(0);
+            rc = fapiPutScom(i_target_mba,0x03010432,l_data_buffer_64);
+            if(rc) return rc;
+
+
+            rc = delay_shmoo_ddr4_pda(i_target_mba, i_port, i_shmoo_type_valid,&l_left_margin,&l_right_margin,vref_val,pda_nibble_table);
+            if (rc) return rc;
+
+            total_val = l_right_margin+l_left_margin;
+            FAPI_INF("Preet2 - %d ; Wr Vref = %d ; Min Setup time = %d; Min Hold time = %d and Total = %d",vref_val,vref_val_print,l_left_margin,l_right_margin,total_val);
+
+            if(total_val > last_total)
+            {
+                last_known_vref = vref_val;
+                last_total = total_val;
+                if(l_loop_count != 0)
+                    imin = l_vref_mid+1;
+            }
+            else
+            {
+                imax = l_vref_mid - 1;
+            }
+            l_loop_count ++;
+            for(int i_port=0; i_port < MAX_PORT; i_port++) {
+                for(l_dimm=0; l_dimm < 2; l_dimm++) {
+                    for(int i_rank=0; i_rank < num_ranks_per_dimm[i_port][l_dimm]; i_rank++) {
+                        for(int i_nibble=0; i_nibble < 16; i_nibble++) {
+                            if (best_pda_nibble_table[i_port][l_dimm][i_rank][i_nibble][1] < pda_nibble_table[i_port][l_dimm][i_rank][i_nibble][1])
+                            {
+                                best_pda_nibble_table[i_port][l_dimm][i_rank][i_nibble][1] = pda_nibble_table[i_port][l_dimm][i_rank][i_nibble][1];
+                                best_pda_nibble_table[i_port][l_dimm][i_rank][i_nibble][0] = vref_val;
+                            }
+                        }
+                    } //Rank Loop
+                } //dimm loop
+            } //Port loop
+
+        } //end of While
+
+
+        vref_val_print = base_percent + (last_known_vref * index_mul_print);
+        FAPI_INF("Best V-Ref - %d - %d  ; Total Window = %d",last_known_vref,vref_val_print,last_total);
+        // What do we do Once we know best V-Ref
+
+        rc = fapiGetScom( i_target_mba,  0x03010432,  refresh_reg);
+        if(rc) return rc;
+        refresh_reg.clearBit(0);
+        fapiPutScom( i_target_mba,  0x03010432,  refresh_reg);
+        if(rc) return rc;
+
+        if(cal_control==2)
+        {
+            FAPI_INF("CAL_CONTROL in RANK_Wise Mode!! ");
+            rc = fapiGetScom(i_target_mba,0x03010432,l_data_buffer_64);
+            if(rc) return rc;
+            l_data_buffer_64.clearBit(0);
+            rc = fapiPutScom(i_target_mba,0x03010432,l_data_buffer_64);
+            if(rc) return rc;
+            //FAPI_INF("\n After Clearing Refresh");
+
+            for(i=0; i<MAX_PORT; i++) {
+                for(j=0; j<MAX_DIMM; j++) {
+                    for(k=0; k<4; k++) {
+
+                        vrefdq_train_enable[i][j][k]=0x01;
+
+                    }
+                }
+            }
+            rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);
+            if(rc) return rc;
+            //Calculate the Average V-Ref Value
+
+            for(int i_port=0; i_port < 2; i_port++) {
+                for(int i_dimm=0; i_dimm < 2; i_dimm++) {
+                    for(int i_rank=0; i_rank < num_ranks_per_dimm[i_port][i_dimm]; i_rank++) {
+                        for(int i_nibble=0; i_nibble < 16; i_nibble++) {
+
+                            avg_best_vref = best_pda_nibble_table[i_port][i_dimm][i_rank][i_nibble][0] + avg_best_vref;
+                        }
+                        avg_best_vref = avg_best_vref/16;
+                        FAPI_INF("++ RANK_Wise  ++++ Best Avg V-Ref = %d !! ",avg_best_vref);
+                        vrefdq_train_value[i_port][i_dimm][i_rank] = avg_best_vref;
+
+                    } //End of Rank Loop
+                } //end of dimm loop
+            } //End of Port Loop
+
+            rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_VALUE, &i_target_mba, vrefdq_train_value);
+            if(rc) return rc;
+
+            //issue call to run_pda (entering into train mode)
+            rc = mss_mrs6_DDR4(l_target_centaur);
+            if(rc)
+            {
+                FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
+                return rc;
+            }
+
+            // Call it Twice to Latch (Steve)
+            rc = mss_mrs6_DDR4(l_target_centaur);
+            if(rc)
+            {
+                FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
+                return rc;
+            }
+
+            for(i=0; i < MAX_PORT; i++) {
+                for(j=0; j<2; j++) {
+                    for(k=0; k<4; k++) {
+
+                        vrefdq_train_enable[i][j][k]=0x00;
+
+                    }
+                }
+            }
+            rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);
+            if(rc) return rc;
+            rc = mss_mrs6_DDR4(l_target_centaur);
+            if(rc)
+            {
+                FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
+                return rc;
+            }
+
+        } //end of RANK wise if
+        else
+        {
+//1 - Issue PDA commands with enable train enable 1 for all DRAMs with good VREF values
+            uint32_t max_vref;
+            uint8_t dram_num;
+            for(int i_port=0; i_port < 2; i_port++) {
+                for(int i_dimm=0; i_dimm < 2; i_dimm++) {
+                    for(int i_rank=0; i_rank < num_ranks_per_dimm[i_port][i_dimm]; i_rank++) {
+                        for(int i_nibble=0; i_nibble < 16; i_nibble++) {
+                            FAPI_INF("\n Port %d Dimm %d Rank:%d Pda_Nibble: %d  V-ref:%d  Margin:%d",i_port,i_dimm,i_rank,i_nibble,best_pda_nibble_table[i_port][i_dimm][i_rank][i_nibble][0],best_pda_nibble_table[i_port][i_dimm][i_rank][i_nibble][1]);
+
+                            //if x8, averages the two nibbles together and, regardless, converts the DRAM over to the nibble
+                            dram_num = i_nibble;
+                            max_vref = best_pda_nibble_table[i_port][i_dimm][i_rank][i_nibble][0];
+                            if(dram_width == fapi::ENUM_ATTR_EFF_DRAM_WIDTH_X8) {
+                                i_nibble++;
+                                dram_num = dram_num / 2;
+                                max_vref += best_pda_nibble_table[i_port][i_dimm][i_rank][i_nibble][0];
+                                max_vref = max_vref / 2;
+                            }
+                            FAPI_INF("\n Port %d Dimm %d Rank:%d Pda_Nibble: %d DRAM_num %d  V-ref:%d  Margin:%d",i_port,i_dimm,i_rank,i_nibble,dram_num,best_pda_nibble_table[i_port][i_dimm][i_rank][i_nibble][0],best_pda_nibble_table[i_port][i_dimm][i_rank][i_nibble][1]);
+
+                            pda.push_back(PDA_MRS_Storage(0x01,ATTR_EFF_VREF_DQ_TRAIN_ENABLE,dram_num,i_dimm,i_rank,i_port));
+                            FAPI_INF("PDA STRING: %s %d %s",i_target_mba.toEcmdString(),pda.size()-1,pda[pda.size()-1].c_str());
+                            pda.push_back(PDA_MRS_Storage(max_vref,ATTR_EFF_VREF_DQ_TRAIN_VALUE,dram_num,i_dimm,i_rank,i_port));
+                            FAPI_INF("PDA STRING: %s %d %s",i_target_mba.toEcmdString(),pda.size()-1,pda[pda.size()-1].c_str());
+                        }
+
+
+                    } //End of Rank Loop
+                } //end of dimm loop
+            } //End of Port Loop
+            FAPI_INF("RUNNING PDA FOR 1ST TIME");
+            rc = mss_ddr4_run_pda((fapi::Target &)i_target_mba,pda);
+            if(rc) return rc;
+            FAPI_INF("FINISHED RUNNING PDA FOR 1ST TIME");
+	    
+            //issue call to run PDA again (latching good value in train mode)
+            FAPI_INF("RUNNING PDA FOR 2ND TIME");
+            rc = mss_ddr4_run_pda((fapi::Target &)i_target_mba,pda);
+            if(rc) return rc;
+            FAPI_INF("FINISHED RUNNING PDA FOR 2ND TIME");
+            //clear the PDA vector
+            pda.clear();
+
+            //build PDA vector with good VREF values and train enable DISABLED
+
+            for(int i_port=0; i_port < 2; i_port++) {
+                for(int i_dimm=0; i_dimm < 2; i_dimm++) {
+                    for(int i_rank=0; i_rank < num_ranks_per_dimm[i_port][i_dimm]; i_rank++) {
+                        for(int i_nibble=0; i_nibble < 16; i_nibble++) {
+                            //if x8, averages the two nibbles together and, regardless, converts the DRAM over to the nibble
+                            dram_num = i_nibble;
+                            max_vref = best_pda_nibble_table[i_port][i_dimm][i_rank][i_nibble][0];
+                            if(dram_width == fapi::ENUM_ATTR_EFF_DRAM_WIDTH_X8) {
+                                i_nibble++;
+                                dram_num = dram_num / 2;
+                                max_vref += best_pda_nibble_table[i_port][i_dimm][i_rank][i_nibble][0];
+                                max_vref = max_vref / 2;
+                            }
+                            FAPI_INF("\n Port %d Dimm %d Rank:%d Pda_Nibble: %d DRAM_num %d  V-ref:%d  Margin:%d",i_port,i_dimm,i_rank,i_nibble,dram_num,best_pda_nibble_table[i_port][i_dimm][i_rank][i_nibble][0],best_pda_nibble_table[i_port][i_dimm][i_rank][i_nibble][1]);
+
+                            pda.push_back(PDA_MRS_Storage(0x00,ATTR_EFF_VREF_DQ_TRAIN_ENABLE,dram_num,i_dimm,i_rank,i_port));
+                            FAPI_INF("%s PDA STRING: %d %s",i_target_mba.toEcmdString(),pda.size()-1,pda[pda.size()-1].c_str());
+                            pda.push_back(PDA_MRS_Storage(max_vref,ATTR_EFF_VREF_DQ_TRAIN_VALUE,dram_num,i_dimm,i_rank,i_port));
+                            FAPI_INF("%s PDA STRING: %d %s",i_target_mba.toEcmdString(),pda.size()-1,pda[pda.size()-1].c_str());
+                        }
+                    } //End of Rank Loop
+                } //end of dimm loop
+            } //End of Port Loop
+
+            FAPI_INF("RUNNING PDA FOR 3RD TIME");
+            //issue call to PDA command
+            rc = mss_ddr4_run_pda((fapi::Target &)i_target_mba,pda);
+            if(rc) return rc;
+            FAPI_INF("FINISHED RUNNING PDA FOR 3RD TIME");
+        } //End of Else
+
+        //turn on refresh then exit
+        rc = fapiGetScom( i_target_mba,0x03010432,refresh_reg);
+        refresh_reg.setBit(0);
+        fapiPutScom( i_target_mba,0x03010432,refresh_reg);
+
+    } // end of if
+
+    else     //Skipping Shmoos ... Writing VPD data directly
+
+    {
+        vref_val_print = base_percent + (vpd_wr_vref_value[0] * index_mul_print);
+        FAPI_INF("The Vref value is from VPD = %d; The  Voltage bump = %d ",vpd_wr_vref_value[0],vref_val_print);
+
+        rc = fapiGetScom(i_target_mba,0x03010432,l_data_buffer_64);
+        if(rc) return rc;
+        l_data_buffer_64.clearBit(0);
+        rc = fapiPutScom(i_target_mba,0x03010432,l_data_buffer_64);
+        if(rc) return rc;
+        //FAPI_INF("\n After Clearing Refresh");
+
+        for(i=0; i<MAX_PORT; i++) {
+            for(j=0; j<MAX_DIMM; j++) {
+                for(k=0; k<4; k++) {
+
+                    vrefdq_train_enable[i][j][k]=0x01;
+
+                }
+            }
+        }
+
+        rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_RANGE, &i_target_mba, vrefdq_train_range);
+        if(rc) return rc;
+        rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);
+        if(rc) return rc;
+        rc = mss_mrs6_DDR4(l_target_centaur);
+        if(rc)
+        {
+            FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
             return rc;
         }
-		
-	
-	FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++ WR_VREF - Check Sanity only MCBIST +++++++++++++++++++++++++++");
-	rc = delay_shmoo_ddr4_pda(i_target_mba, i_port, i_shmoo_type_valid,
-	&l_left_margin, &l_right_margin,
-	vref_val,pda_nibble_table);
-	
-	if(rc) return rc;
-	FAPI_INF(" Setup and Sanity - Check disabled from now on..... Continuing .....");
-	rc = set_attribute(i_target_mba);
-	if (rc) return rc;
-	
-	if (cal_control !=0)
-	{
-	i_shmoo_type_valid = WR_EYE;
-	l_attr_schmoo_test_type_u8 = 2;
-	rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_TEST_VALID, &i_target_mba, l_attr_schmoo_test_type_u8); if(rc) return rc;
-	//Initialize all to zero
-	/*for(index = 0; index < 50;index++)
-	{
-		best_vref[index] = 0;
-		
-	}
-	*/
-	//Initialise All to Zero [2][2][4]
-	
-	for(k=0;k < MAX_PORT;k++)  // port
-	{
-		for(l_dimm=0;l_dimm < 2;l_dimm++)   //Dimm
-		{
-			for(j=0;j < 4;j++)   //Rank
-			{
-				for(i=0;i<16;i++)  //Nibble
-				{
-				pda_nibble_table[k][l_dimm][j][i][0] = 0;  //  Index 0 Are V-refs
-				pda_nibble_table[k][l_dimm][j][i][1] = 0;   // Index 1 are Total Margin Values
-				best_pda_nibble_table[k][l_dimm][j][i][0] = 0;   //  Index 0 Are V-refs
-				best_pda_nibble_table[k][l_dimm][j][i][1] = 0;    // Index 1 are Total Margin Values
-				}
-			}
-		}
-	}               
-			
-	while(imax >= imin){	
-
-		if(l_loop_count==0)
-		l_vref_mid = imin;
-		else	
-		l_vref_mid = (imax+imin)/2;
-
-		vref_val = l_vref_mid;
-		vref_val_print = base_percent + (l_vref_mid * index_mul_print);
-		FAPI_INF("The Vref value is = %d; The percent voltage bump = %d ",vref_val,vref_val_print);
-		//FAPI_INF("\n Before Clearing Refresh");
-		rc = fapiGetScom(i_target_mba,0x03010432,l_data_buffer_64); if(rc) return rc;
-		l_data_buffer_64.clearBit(0);
-		rc = fapiPutScom(i_target_mba,0x03010432,l_data_buffer_64); if(rc) return rc;
-		//FAPI_INF("\n After Clearing Refresh");
-		
-		for(i=0;i<MAX_PORT;i++){
-			for(j=0;j<MAX_DIMM;j++){
-				for(k=0;k<4;k++){
-					
-					vrefdq_train_enable[i][j][k]=0x01;
-					
-				}
-			}
-		}	
-		
-		rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_RANGE, &i_target_mba, vrefdq_train_range);if(rc) return rc;
-		rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);if(rc) return rc;
-		for(a=0;a < MAX_PORT;a++) //Port
-		{
-			for(l_dimm=0;l_dimm < MAX_DIMM;l_dimm++)  //Max dimms
-			{
-				for(c=0;c < 4;c++)   //Ranks
-				{
-					
-					vrefdq_train_value[a][l_dimm][c]=vref_val;
-					
-				}
-			}
-		}
-		
-		rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_VALUE, &i_target_mba, vrefdq_train_value); if(rc) return rc;
-		rc = mss_mrs6_DDR4(l_target_centaur);
-		if(rc)
-		{
-			FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
-			return rc;
-		}
-		
-		for(i=0;i < MAX_PORT;i++){
-			for(j=0;j<2;j++){
-				for(k=0;k<4;k++){
-					
-					vrefdq_train_enable[i][j][k]=0x00;
-					
-				}
-			}
-		}	
-		rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);if(rc) return rc;
-		rc = mss_mrs6_DDR4(l_target_centaur);
-		if(rc)
-		{
-			FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
-			return rc;
-		}
-		
-		rc = fapiGetScom(i_target_mba,0x03010432,l_data_buffer_64); if(rc) return rc;
-		l_data_buffer_64.setBit(0);
-		rc = fapiPutScom(i_target_mba,0x03010432,l_data_buffer_64); if(rc) return rc;
-		
-		
-		rc = delay_shmoo_ddr4_pda(i_target_mba, i_port, i_shmoo_type_valid,&l_left_margin,&l_right_margin,vref_val,pda_nibble_table);
-		if (rc) return rc;
-		
-		total_val = l_right_margin+l_left_margin;
-		FAPI_INF("Preet2 - %d ; Wr Vref = %d ; Min Setup time = %d; Min Hold time = %d and Total = %d",vref_val,vref_val_print,l_left_margin,l_right_margin,total_val);
-		
-		if(total_val > last_total)
-		{
-			last_known_vref = vref_val;
-			last_total = total_val;
-			if(l_loop_count != 0)
-			imin = l_vref_mid+1;
-		}
-		else
-		{
-			imax = l_vref_mid - 1;
-		}
-		l_loop_count ++;
-		for(int i_port=0;i_port < MAX_PORT;i_port++){
-			for(l_dimm=0;l_dimm < 2;l_dimm++){
-			for(int i_rank=0;i_rank < num_ranks_per_dimm[i_port][l_dimm];i_rank++){
-				for(int i_nibble=0;i_nibble < 16;i_nibble++){
-					if (best_pda_nibble_table[i_port][l_dimm][i_rank][i_nibble][1] < pda_nibble_table[i_port][l_dimm][i_rank][i_nibble][1])
-					{
-						best_pda_nibble_table[i_port][l_dimm][i_rank][i_nibble][1] = pda_nibble_table[i_port][l_dimm][i_rank][i_nibble][1];
-						best_pda_nibble_table[i_port][l_dimm][i_rank][i_nibble][0] = vref_val;
-					}
-				}
-			} //Rank Loop
-		} //dimm loop
-		} //Port loop
-		
-	} //end of While
-
-	
-	vref_val_print = base_percent + (last_known_vref * index_mul_print);		
-	FAPI_INF("Best V-Ref - %d - %d  ; Total Window = %d",last_known_vref,vref_val_print,last_total);
-	// What do we do Once we know best V-Ref
-	
-	rc = fapiGetScom( i_target_mba,  0x03010432,  refresh_reg); if(rc) return rc;
-	refresh_reg.clearBit(0);
-	fapiPutScom( i_target_mba,  0x03010432,  refresh_reg);if(rc) return rc;
-	
-	for(int i_port=0;i_port < 2;i_port++){
-		for(int i_dimm=0;i_dimm < 2;i_dimm++){
-		for(int i_rank=0;i_rank < num_ranks_per_dimm[i_port][i_dimm];i_rank++){
-			for(int i_nibble=0;i_nibble < 16;i_nibble++){
-				FAPI_INF("\n Port %d Dimm %d Rank:%d Pda_Nibble: %d  V-ref:%d  Margin:%d",i_port,i_dimm,i_rank,i_nibble,best_pda_nibble_table[i_port][i_dimm][i_rank][i_nibble][0],best_pda_nibble_table[i_port][i_dimm][i_rank][i_nibble][1]);
-				pda.push_back(PDA_MRS_Storage(best_pda_nibble_table[i_port][i_dimm][i_rank][i_nibble][0],ATTR_EFF_VREF_DQ_TRAIN_VALUE,0,i_dimm,i_rank,i_port));
-				}
-				FAPI_INF("FINAL %s PDA STRING: %d %s",i_target_mba.toEcmdString(),pda.size()-1,pda[pda.size()-1].c_str());
-				rc = mss_ddr4_run_pda((fapi::Target &)i_target_mba,pda); if(rc) return rc; 
-		} //End of Rank Loop
-		} //end of dimm loop
-} //End of Port Loop
-
-for(i=0;i<MAX_PORT;i++){
-			for(j=0;j<2;j++){
-				for(k=0;k<4;k++){
-					
-					vrefdq_train_enable[i][j][k]=0x00;
-					
-				}
-			}
-		}	
-rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);if(rc) return rc;
-		rc = mss_mrs6_DDR4(l_target_centaur);
-		if(rc)
-		{
-			FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
-			return rc;
-		}
-	rc = fapiGetScom( i_target_mba,0x03010432,refresh_reg);
-	refresh_reg.setBit(0);
-	fapiPutScom( i_target_mba,0x03010432,refresh_reg);
-			
-} // end of if
-
-else     //Skipping Shmoos ... Writing VPD data directly
 
-{
-	vref_val_print = base_percent + (vpd_wr_vref_value[0] * index_mul_print);
-	FAPI_INF("The Vref value is from VPD = %d; The  Voltage bump = %d ",vpd_wr_vref_value[0],vref_val_print);
-		
-	rc = fapiGetScom(i_target_mba,0x03010432,l_data_buffer_64); if(rc) return rc;
-		l_data_buffer_64.clearBit(0);
-		rc = fapiPutScom(i_target_mba,0x03010432,l_data_buffer_64); if(rc) return rc;
-		//FAPI_INF("\n After Clearing Refresh");
-		
-		for(i=0;i<MAX_PORT;i++){
-			for(j=0;j<MAX_DIMM;j++){
-				for(k=0;k<4;k++){
-					
-					vrefdq_train_enable[i][j][k]=0x01;
-					
-				}
-			}
-		}	
-		
-		rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_RANGE, &i_target_mba, vrefdq_train_range);if(rc) return rc;
-		rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);if(rc) return rc;
-		for(a=0;a < MAX_PORT;a++) //Port
-		{
-			for(l_dimm=0;l_dimm < MAX_DIMM;l_dimm++)  //Max dimms
-			{
-				for(c=0;c < 4;c++)   //Ranks
-				{
-					
-					vrefdq_train_value[a][l_dimm][c]=vpd_wr_vref_value[0];
-					
-				}
-			}
-		}
-		
-		rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_VALUE, &i_target_mba, vrefdq_train_value); if(rc) return rc;
-		rc = mss_mrs6_DDR4(l_target_centaur);
-		if(rc)
-		{
-			FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
-			return rc;
-		}
-		
-		for(i=0;i < MAX_PORT;i++){
-			for(j=0;j<2;j++){
-				for(k=0;k<4;k++){
-					
-					vrefdq_train_enable[i][j][k]=0x00;
-					
-				}
-			}
-		}	
-		rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);if(rc) return rc;
-		rc = mss_mrs6_DDR4(l_target_centaur);
-		if(rc)
-		{
-			FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
-			return rc;
-		}
-		
-		rc = fapiGetScom(i_target_mba,0x03010432,l_data_buffer_64); if(rc) return rc;
-		l_data_buffer_64.setBit(0);
-		rc = fapiPutScom(i_target_mba,0x03010432,l_data_buffer_64); if(rc) return rc;
-		
-}	
-	
-//Workaround MCBIST MASK Bit as FW reports FIR bits --- > CLEAR
-	rc = fapiGetScom(i_target_mba, 0x03010614, l_data_buffer_64);
-        if (rc) return rc;
-        rc_num = l_data_buffer_64.clearBit(10);
-        if (rc_num)
+        for(a=0; a < MAX_PORT; a++) //Port
         {
-            FAPI_ERR("Buffer error in function wr_vref_shmoo_ddr4_bin Workaround MCBIST MASK Bit");
-            rc.setEcmdError(rc_num);
+            for(l_dimm=0; l_dimm < MAX_DIMM; l_dimm++) //Max dimms
+            {
+                for(c=0; c < 4; c++) //Ranks
+                {
+
+                    vrefdq_train_value[a][l_dimm][c]=vpd_wr_vref_value[0];
+
+                }
+            }
+        }
+
+        rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_VALUE, &i_target_mba, vrefdq_train_value);
+        if(rc) return rc;
+        rc = mss_mrs6_DDR4(l_target_centaur);
+        if(rc)
+        {
+            FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
             return rc;
         }
-		
+
+        for(i=0; i < MAX_PORT; i++) {
+            for(j=0; j<2; j++) {
+                for(k=0; k<4; k++) {
+
+                    vrefdq_train_enable[i][j][k]=0x00;
+
+                }
+            }
+        }
+        rc = FAPI_ATTR_SET( ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target_mba, vrefdq_train_enable);
+        if(rc) return rc;
+        rc = mss_mrs6_DDR4(l_target_centaur);
+        if(rc)
+        {
+            FAPI_ERR(" mrs_load Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
+            return rc;
+        }
+
+        rc = fapiGetScom(i_target_mba,0x03010432,l_data_buffer_64);
+        if(rc) return rc;
+        l_data_buffer_64.setBit(0);
+        rc = fapiPutScom(i_target_mba,0x03010432,l_data_buffer_64);
+        if(rc) return rc;
+
+    }
+
+//Workaround MCBIST MASK Bit as FW reports FIR bits --- > CLEAR
+    rc = fapiGetScom(i_target_mba, 0x03010614, l_data_buffer_64);
+    if (rc) return rc;
+    rc_num = l_data_buffer_64.clearBit(10);
+    if (rc_num)
+    {
+        FAPI_ERR("Buffer error in function wr_vref_shmoo_ddr4_bin Workaround MCBIST MASK Bit");
+        rc.setEcmdError(rc_num);
+        return rc;
+    }
+
 //Read the write vref attributes
-	return rc;
+    return rc;
 }
 
 
 //----------------------------------------------------------------------------------------------
-// Function name: rd_vref_shmoo()                                                               
-// Description: This function varies the Centaur IO vref in 16 steps 
-// 		Calls write eye shmoo function                 
+// Function name: rd_vref_shmoo()
+// Description: This function varies the Centaur IO vref in 16 steps
+// 		Calls write eye shmoo function
 // Input param: const fapi::Target MBA, port = 0,1
 // 	Shmoo type: MCBIST, WR_EYE, RD_EYE, WR_DQS, RD_DQS
 // 	Shmoo param: PARAM_NONE, DRV_IMP, SLEW_RATE, WR_VREF, RD_VREF, RCV_IMP
@@ -1438,122 +1625,123 @@ else     //Skipping Shmoos ... Writing VPD data directly
 //----------------------------------------------------------------------------------------------
 
 fapi::ReturnCode rd_vref_shmoo(const fapi::Target & i_target_mba,
-uint8_t i_port,
-shmoo_type_t i_shmoo_type_valid)
+                               uint8_t i_port,
+                               shmoo_type_t i_shmoo_type_valid)
 {
-	fapi::ReturnCode rc;
-	uint32_t l_rd_cen_vref[MAX_PORT] = {0};
-	uint32_t l_rd_cen_vref_nom[MAX_PORT] = {0};
-	uint32_t l_rd_cen_vref_nom_fc = 0;
-	uint32_t l_rd_cen_vref_in = 0;
-	uint32_t l_rd_cen_vref_schmoo[MAX_PORT] = {0};
-	uint8_t index  = 0;
-	uint8_t count  = 0;
-	//uint8_t shmoo_param_count = 0;
-	//i_shmoo_type_valid = RD_EYE; // Hard coded - Temporary
-	
-	uint32_t l_left_margin = 0;
-	uint32_t l_right_margin = 0;
-	uint32_t l_left_margin_rd_vref_array[MAX_RD_VREF] = {0};
-	uint32_t l_right_margin_rd_vref_array[MAX_RD_VREF] = {0};
-
-	rc = FAPI_ATTR_GET(ATTR_EFF_CEN_RD_VREF, &i_target_mba, l_rd_cen_vref_nom);
-	if (rc) return rc;
-	rc = FAPI_ATTR_GET(ATTR_EFF_CEN_RD_VREF_SCHMOO, &i_target_mba, l_rd_cen_vref_schmoo);
-	if (rc) return rc;
-	i_shmoo_type_valid = MCBIST;
-	
-	
-	FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++ Patch - Preet - RD_VREF - Check Sanity only at 500000 +++++++++++++++++++++++++++");
-	rc = delay_shmoo(i_target_mba, i_port, i_shmoo_type_valid,
-	&l_left_margin, &l_right_margin,
-	l_rd_cen_vref_in);
-	if(rc) return rc;
-	FAPI_INF(" Setup and Sanity - Check disabled from now on..... Continuing .....");
-	rc = set_attribute(i_target_mba);
-	if (rc) return rc;
-	
-	i_shmoo_type_valid = RD_EYE;
-	FAPI_INF("+++++++++++++++++CENTAUR VREF Read Shmoo Attributes values+++++++++++++++");
-	FAPI_INF("CEN_RD_VREF[0]  = %d CEN_RD_VREF[1]  = %d on %s",
-	l_rd_cen_vref_nom[0],
-	l_rd_cen_vref_nom[1],
-	i_target_mba.toEcmdString());
-	FAPI_INF("CEN_RD_VREF_SCHMOO[0] = [%x], CEN_RD_VREF_SCHMOO[1] = [%x] on %s",
-	l_rd_cen_vref_schmoo[0],
-	l_rd_cen_vref_schmoo[1],
-	i_target_mba.toEcmdString());
-	FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++ Patch - Preet - RD_VREF +++++++++++++++++++++++++++");
-	
-	if (l_rd_cen_vref_schmoo[i_port] == 0)
-	{
-		FAPI_INF("FAST Shmoo Mode: This function will not change any Read Centaur VREF settings");
-	}
-	else
-	{
-		for (index = 0; index < MAX_RD_VREF; index += 1)
-		{
-			if ((l_rd_cen_vref_schmoo[i_port] & MASK) == 1)
-			{
-				l_rd_cen_vref[i_port] = rd_cen_vref_array[index];
-				FAPI_INF("Current Read Vref Multiplier value is %d",
-				rd_cen_vref_array[index]);
-				FAPI_INF("Configuring Read Vref Registers:");
-				rc = config_rd_cen_vref(i_target_mba, i_port,
-				l_rd_cen_vref[i_port]);
-				if (rc) return rc;
-				l_rd_cen_vref_in = l_rd_cen_vref[i_port];
-				//FAPI_INF(" Calling Shmoo function to find out Timing Margin:");
-				
-				rc = delay_shmoo(i_target_mba, i_port, i_shmoo_type_valid,
-				&l_left_margin, &l_right_margin,
-				l_rd_cen_vref_in);
-				if (rc) return rc;
-				l_left_margin_rd_vref_array[index] = l_left_margin;
-				l_right_margin_rd_vref_array[index] = l_right_margin;
-				
-				FAPI_INF("Read Vref = %d ; Min Setup time = %d; Min Hold time = %d",
-				rd_cen_vref_array[index],
-				l_left_margin_rd_vref_array[index],
-				l_right_margin_rd_vref_array[index]);
-			}
-			else
-			{
-				l_left_margin_rd_vref_array[index] = 0;
-				l_right_margin_rd_vref_array[index] = 0;
-			}
-			l_rd_cen_vref_schmoo[i_port] = (l_rd_cen_vref_schmoo[i_port] >> 1);
-			/* FAPI_INF("Read Vref = %d ; Min Setup time = %d; Min Hold time = %d", rd_cen_vref_array[index],l_left_margin_rd_vref_array[index],  l_right_margin_rd_vref_array[index]);  */
-		}
-		l_rd_cen_vref_nom_fc = l_rd_cen_vref_nom[i_port];
-		find_best_margin(RD_VREF, l_left_margin_rd_vref_array,
-		l_right_margin_rd_vref_array, MAX_RD_VREF,
-		l_rd_cen_vref_nom_fc, count);
-		if (count >= MAX_RD_VREF)
-		{
-			FAPI_ERR("Read vref new input(%d) out of bounds, (>= %d)", count,
-			MAX_RD_VREF);
-			const uint8_t & COUNT_DATA = count;
-			FAPI_SET_HWP_ERROR(rc, RC_RD_VREF_SHMOO_INVALID_MARGIN_DATA);
-			return rc;
-		}
-		else
-		{
-			// FAPI_INF("Nominal value will not be changed!- Restoring the original values!");
-			FAPI_INF("Restoring Nominal values!");
-			rc = FAPI_ATTR_SET(ATTR_EFF_CEN_RD_VREF, &i_target_mba,
-			l_rd_cen_vref_nom);
-			if (rc) return rc;
-			rc = config_rd_cen_vref(i_target_mba, i_port,
-			l_rd_cen_vref_nom[i_port]);
-			if (rc) return rc;
-		}
-		
-		FAPI_INF("++++ Centaur Read Vref Shmoo function executed successfully ++++");
-	}
-	FAPI_INF("Restoring mcbist setup attribute...");
-	rc = reset_attribute(i_target_mba);if (rc) return rc;
-	return rc;
+    fapi::ReturnCode rc;
+    uint32_t l_rd_cen_vref[MAX_PORT] = {0};
+    uint32_t l_rd_cen_vref_nom[MAX_PORT] = {0};
+    uint32_t l_rd_cen_vref_nom_fc = 0;
+    uint32_t l_rd_cen_vref_in = 0;
+    uint32_t l_rd_cen_vref_schmoo[MAX_PORT] = {0};
+    uint8_t index  = 0;
+    uint8_t count  = 0;
+    //uint8_t shmoo_param_count = 0;
+    //i_shmoo_type_valid = RD_EYE; // Hard coded - Temporary
+
+    uint32_t l_left_margin = 0;
+    uint32_t l_right_margin = 0;
+    uint32_t l_left_margin_rd_vref_array[MAX_RD_VREF] = {0};
+    uint32_t l_right_margin_rd_vref_array[MAX_RD_VREF] = {0};
+
+    rc = FAPI_ATTR_GET(ATTR_EFF_CEN_RD_VREF, &i_target_mba, l_rd_cen_vref_nom);
+    if (rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_EFF_CEN_RD_VREF_SCHMOO, &i_target_mba, l_rd_cen_vref_schmoo);
+    if (rc) return rc;
+    i_shmoo_type_valid = MCBIST;
+
+
+    FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++ Patch - Preet - RD_VREF - Check Sanity only at 500000 +++++++++++++++++++++++++++");
+    rc = delay_shmoo(i_target_mba, i_port, i_shmoo_type_valid,
+                     &l_left_margin, &l_right_margin,
+                     l_rd_cen_vref_in);
+    if(rc) return rc;
+    FAPI_INF(" Setup and Sanity - Check disabled from now on..... Continuing .....");
+    rc = set_attribute(i_target_mba);
+    if (rc) return rc;
+
+    i_shmoo_type_valid = RD_EYE;
+    FAPI_INF("+++++++++++++++++CENTAUR VREF Read Shmoo Attributes values+++++++++++++++");
+    FAPI_INF("CEN_RD_VREF[0]  = %d CEN_RD_VREF[1]  = %d on %s",
+             l_rd_cen_vref_nom[0],
+             l_rd_cen_vref_nom[1],
+             i_target_mba.toEcmdString());
+    FAPI_INF("CEN_RD_VREF_SCHMOO[0] = [%x], CEN_RD_VREF_SCHMOO[1] = [%x] on %s",
+             l_rd_cen_vref_schmoo[0],
+             l_rd_cen_vref_schmoo[1],
+             i_target_mba.toEcmdString());
+    FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++ Patch - Preet - RD_VREF +++++++++++++++++++++++++++");
+
+    if (l_rd_cen_vref_schmoo[i_port] == 0)
+    {
+        FAPI_INF("FAST Shmoo Mode: This function will not change any Read Centaur VREF settings");
+    }
+    else
+    {
+        for (index = 0; index < MAX_RD_VREF; index += 1)
+        {
+            if ((l_rd_cen_vref_schmoo[i_port] & MASK) == 1)
+            {
+                l_rd_cen_vref[i_port] = rd_cen_vref_array[index];
+                FAPI_INF("Current Read Vref Multiplier value is %d",
+                         rd_cen_vref_array[index]);
+                FAPI_INF("Configuring Read Vref Registers:");
+                rc = config_rd_cen_vref(i_target_mba, i_port,
+                                        l_rd_cen_vref[i_port]);
+                if (rc) return rc;
+                l_rd_cen_vref_in = l_rd_cen_vref[i_port];
+                //FAPI_INF(" Calling Shmoo function to find out Timing Margin:");
+
+                rc = delay_shmoo(i_target_mba, i_port, i_shmoo_type_valid,
+                                 &l_left_margin, &l_right_margin,
+                                 l_rd_cen_vref_in);
+                if (rc) return rc;
+                l_left_margin_rd_vref_array[index] = l_left_margin;
+                l_right_margin_rd_vref_array[index] = l_right_margin;
+
+                FAPI_INF("Read Vref = %d ; Min Setup time = %d; Min Hold time = %d",
+                         rd_cen_vref_array[index],
+                         l_left_margin_rd_vref_array[index],
+                         l_right_margin_rd_vref_array[index]);
+            }
+            else
+            {
+                l_left_margin_rd_vref_array[index] = 0;
+                l_right_margin_rd_vref_array[index] = 0;
+            }
+            l_rd_cen_vref_schmoo[i_port] = (l_rd_cen_vref_schmoo[i_port] >> 1);
+            /* FAPI_INF("Read Vref = %d ; Min Setup time = %d; Min Hold time = %d", rd_cen_vref_array[index],l_left_margin_rd_vref_array[index],  l_right_margin_rd_vref_array[index]);  */
+        }
+        l_rd_cen_vref_nom_fc = l_rd_cen_vref_nom[i_port];
+        find_best_margin(RD_VREF, l_left_margin_rd_vref_array,
+                         l_right_margin_rd_vref_array, MAX_RD_VREF,
+                         l_rd_cen_vref_nom_fc, count);
+        if (count >= MAX_RD_VREF)
+        {
+            FAPI_ERR("Read vref new input(%d) out of bounds, (>= %d)", count,
+                     MAX_RD_VREF);
+            const uint8_t & COUNT_DATA = count;
+            FAPI_SET_HWP_ERROR(rc, RC_RD_VREF_SHMOO_INVALID_MARGIN_DATA);
+            return rc;
+        }
+        else
+        {
+            // FAPI_INF("Nominal value will not be changed!- Restoring the original values!");
+            FAPI_INF("Restoring Nominal values!");
+            rc = FAPI_ATTR_SET(ATTR_EFF_CEN_RD_VREF, &i_target_mba,
+                               l_rd_cen_vref_nom);
+            if (rc) return rc;
+            rc = config_rd_cen_vref(i_target_mba, i_port,
+                                    l_rd_cen_vref_nom[i_port]);
+            if (rc) return rc;
+        }
+
+        FAPI_INF("++++ Centaur Read Vref Shmoo function executed successfully ++++");
+    }
+    FAPI_INF("Restoring mcbist setup attribute...");
+    rc = reset_attribute(i_target_mba);
+    if (rc) return rc;
+    return rc;
 }
 
 //------------------------------------------------------------------------------
@@ -1566,109 +1754,109 @@ shmoo_type_t i_shmoo_type_valid)
 // i_pattern, i_test_type : Default = 0, mcbist lab function would use this arg
 //------------------------------------------------------------------------------
 fapi::ReturnCode rcv_imp_shmoo(const fapi::Target & i_target_mba,
-uint8_t i_port,
-shmoo_type_t i_shmoo_type_valid)
+                               uint8_t i_port,
+                               shmoo_type_t i_shmoo_type_valid)
 {
-	fapi::ReturnCode rc;
-	uint8_t l_rcv_imp_dq_dqs[MAX_PORT] = {0};
-	uint8_t l_rcv_imp_dq_dqs_nom[MAX_PORT] = {0};
-	uint8_t l_rcv_imp_dq_dqs_nom_fc = 0;
-	uint8_t l_rcv_imp_dq_dqs_in = 0;
-	uint32_t l_rcv_imp_dq_dqs_schmoo[MAX_PORT] = {0};
-	uint8_t index = 0;
-	uint8_t count  = 0;
-	uint8_t shmoo_param_count = 0;
-	i_shmoo_type_valid = RD_EYE;   //Hard coded since no other shmoo is applicable - Temporary
-	
-	uint32_t l_left_margin = 0;
-	uint32_t l_right_margin = 0;
-	uint32_t l_left_margin_rcv_imp_array[MAX_RCV_IMP] = {0};
-	uint32_t l_right_margin_rcv_imp_array[MAX_RCV_IMP] = {0};
-
-	rc = FAPI_ATTR_GET(ATTR_EFF_CEN_RCV_IMP_DQ_DQS, &i_target_mba, l_rcv_imp_dq_dqs_nom);
-	if (rc) return rc;
-	rc = FAPI_ATTR_GET(ATTR_EFF_CEN_RCV_IMP_DQ_DQS_SCHMOO, &i_target_mba, l_rcv_imp_dq_dqs_schmoo);
-	if (rc) return rc;
-	
-	FAPI_INF("+++++++++++++++++RECIVER IMP Read Shmoo Attributes values+++++++++++++++");
-	FAPI_INF("CEN_RCV_IMP_DQ_DQS[0]  = %d , CEN_RCV_IMP_DQ_DQS[1]  = %d on %s",
-	l_rcv_imp_dq_dqs_nom[0],
-	l_rcv_imp_dq_dqs_nom[1],
-	i_target_mba.toEcmdString());
-	FAPI_INF("CEN_RCV_IMP_DQ_DQS_SCHMOO[0] = [%d], CEN_RCV_IMP_DQ_DQS_SCHMOO[1] = [%d], on %s",
-	l_rcv_imp_dq_dqs_schmoo[0],
-	l_rcv_imp_dq_dqs_schmoo[1],
-	i_target_mba.toEcmdString());
-	FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
-
-	if (l_rcv_imp_dq_dqs_schmoo[i_port] == 0)
-	{
-		FAPI_INF("FAST Shmoo Mode: This function will not change any Write DRAM VREF settings");
-	}
-	else
-	{
-		for (index = 0; index < MAX_RCV_IMP; index += 1)
-		{
-			if ((l_rcv_imp_dq_dqs_schmoo[i_port] & MASK) == 1)
-			{
-				l_rcv_imp_dq_dqs[i_port] = rcv_imp_array[index];
-				FAPI_INF("Current Receiver Impedance: %d Ohms ",
-				rcv_imp_array[index]);
-				FAPI_INF("Configuring Receiver impedance registers:");
-				rc = config_rcv_imp(i_target_mba, i_port,
-				l_rcv_imp_dq_dqs[i_port]);
-				if (rc) return rc;
-				l_rcv_imp_dq_dqs_in = l_rcv_imp_dq_dqs[i_port];
-				//FAPI_INF("Calling Shmoo function to find out timing margin:");
-				if (shmoo_param_count)
-				{
-					rc = set_attribute(i_target_mba);
-					if (rc) return rc;
-				}
-				rc = delay_shmoo(i_target_mba, i_port, i_shmoo_type_valid,
-				&l_left_margin, &l_right_margin,
-				l_rcv_imp_dq_dqs_in);
-				if (rc) return rc;
-				l_left_margin_rcv_imp_array[index] = l_left_margin;
-				l_right_margin_rcv_imp_array[index] = l_right_margin;
-				shmoo_param_count++;
-			}
-			else
-			{
-				l_left_margin_rcv_imp_array[index] = 0;
-				l_right_margin_rcv_imp_array[index] = 0;
-			}
-			l_rcv_imp_dq_dqs_schmoo[i_port] = (l_rcv_imp_dq_dqs_schmoo[i_port] >> 1);
-		}
-		l_rcv_imp_dq_dqs_nom_fc = l_rcv_imp_dq_dqs_nom[i_port];
-		find_best_margin(RCV_IMP, l_left_margin_rcv_imp_array,
-		l_right_margin_rcv_imp_array, MAX_RCV_IMP,
-		l_rcv_imp_dq_dqs_nom_fc, count);
-		if (count >= MAX_RCV_IMP)
-		{
-			FAPI_ERR("Receiver Imp new input(%d) out of bounds, (>= %d)",
-			count, MAX_RCV_IMP);
-			const uint8_t & COUNT_DATA = count;
-			FAPI_SET_HWP_ERROR(rc, RC_RCV_IMP_SHMOO_INVALID_MARGIN_DATA);
-			return rc;
-		}
-		else
-		{
-			//   FAPI_INF("Nominal value will not be changed!- Restoring the original values!");
-			FAPI_INF("Restoring the nominal values!");
-			rc = FAPI_ATTR_SET(ATTR_EFF_CEN_RCV_IMP_DQ_DQS, &i_target_mba,
-			l_rcv_imp_dq_dqs_nom);
-			if (rc) return rc;
-			rc = config_rcv_imp(i_target_mba, i_port,
-			l_rcv_imp_dq_dqs_nom[i_port]);
-			if (rc) return rc;
-		}
-		FAPI_INF("Restoring mcbist setup attribute...");
-		rc = reset_attribute(i_target_mba);
-		if (rc) return rc;
-		FAPI_INF("++++ Receiver Impdeance Shmoo function executed successfully ++++");
-	}
-	return rc;
+    fapi::ReturnCode rc;
+    uint8_t l_rcv_imp_dq_dqs[MAX_PORT] = {0};
+    uint8_t l_rcv_imp_dq_dqs_nom[MAX_PORT] = {0};
+    uint8_t l_rcv_imp_dq_dqs_nom_fc = 0;
+    uint8_t l_rcv_imp_dq_dqs_in = 0;
+    uint32_t l_rcv_imp_dq_dqs_schmoo[MAX_PORT] = {0};
+    uint8_t index = 0;
+    uint8_t count  = 0;
+    uint8_t shmoo_param_count = 0;
+    i_shmoo_type_valid = RD_EYE;   //Hard coded since no other shmoo is applicable - Temporary
+
+    uint32_t l_left_margin = 0;
+    uint32_t l_right_margin = 0;
+    uint32_t l_left_margin_rcv_imp_array[MAX_RCV_IMP] = {0};
+    uint32_t l_right_margin_rcv_imp_array[MAX_RCV_IMP] = {0};
+
+    rc = FAPI_ATTR_GET(ATTR_EFF_CEN_RCV_IMP_DQ_DQS, &i_target_mba, l_rcv_imp_dq_dqs_nom);
+    if (rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_EFF_CEN_RCV_IMP_DQ_DQS_SCHMOO, &i_target_mba, l_rcv_imp_dq_dqs_schmoo);
+    if (rc) return rc;
+
+    FAPI_INF("+++++++++++++++++RECIVER IMP Read Shmoo Attributes values+++++++++++++++");
+    FAPI_INF("CEN_RCV_IMP_DQ_DQS[0]  = %d , CEN_RCV_IMP_DQ_DQS[1]  = %d on %s",
+             l_rcv_imp_dq_dqs_nom[0],
+             l_rcv_imp_dq_dqs_nom[1],
+             i_target_mba.toEcmdString());
+    FAPI_INF("CEN_RCV_IMP_DQ_DQS_SCHMOO[0] = [%d], CEN_RCV_IMP_DQ_DQS_SCHMOO[1] = [%d], on %s",
+             l_rcv_imp_dq_dqs_schmoo[0],
+             l_rcv_imp_dq_dqs_schmoo[1],
+             i_target_mba.toEcmdString());
+    FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++");
+
+    if (l_rcv_imp_dq_dqs_schmoo[i_port] == 0)
+    {
+        FAPI_INF("FAST Shmoo Mode: This function will not change any Write DRAM VREF settings");
+    }
+    else
+    {
+        for (index = 0; index < MAX_RCV_IMP; index += 1)
+        {
+            if ((l_rcv_imp_dq_dqs_schmoo[i_port] & MASK) == 1)
+            {
+                l_rcv_imp_dq_dqs[i_port] = rcv_imp_array[index];
+                FAPI_INF("Current Receiver Impedance: %d Ohms ",
+                         rcv_imp_array[index]);
+                FAPI_INF("Configuring Receiver impedance registers:");
+                rc = config_rcv_imp(i_target_mba, i_port,
+                                    l_rcv_imp_dq_dqs[i_port]);
+                if (rc) return rc;
+                l_rcv_imp_dq_dqs_in = l_rcv_imp_dq_dqs[i_port];
+                //FAPI_INF("Calling Shmoo function to find out timing margin:");
+                if (shmoo_param_count)
+                {
+                    rc = set_attribute(i_target_mba);
+                    if (rc) return rc;
+                }
+                rc = delay_shmoo(i_target_mba, i_port, i_shmoo_type_valid,
+                                 &l_left_margin, &l_right_margin,
+                                 l_rcv_imp_dq_dqs_in);
+                if (rc) return rc;
+                l_left_margin_rcv_imp_array[index] = l_left_margin;
+                l_right_margin_rcv_imp_array[index] = l_right_margin;
+                shmoo_param_count++;
+            }
+            else
+            {
+                l_left_margin_rcv_imp_array[index] = 0;
+                l_right_margin_rcv_imp_array[index] = 0;
+            }
+            l_rcv_imp_dq_dqs_schmoo[i_port] = (l_rcv_imp_dq_dqs_schmoo[i_port] >> 1);
+        }
+        l_rcv_imp_dq_dqs_nom_fc = l_rcv_imp_dq_dqs_nom[i_port];
+        find_best_margin(RCV_IMP, l_left_margin_rcv_imp_array,
+                         l_right_margin_rcv_imp_array, MAX_RCV_IMP,
+                         l_rcv_imp_dq_dqs_nom_fc, count);
+        if (count >= MAX_RCV_IMP)
+        {
+            FAPI_ERR("Receiver Imp new input(%d) out of bounds, (>= %d)",
+                     count, MAX_RCV_IMP);
+            const uint8_t & COUNT_DATA = count;
+            FAPI_SET_HWP_ERROR(rc, RC_RCV_IMP_SHMOO_INVALID_MARGIN_DATA);
+            return rc;
+        }
+        else
+        {
+            //   FAPI_INF("Nominal value will not be changed!- Restoring the original values!");
+            FAPI_INF("Restoring the nominal values!");
+            rc = FAPI_ATTR_SET(ATTR_EFF_CEN_RCV_IMP_DQ_DQS, &i_target_mba,
+                               l_rcv_imp_dq_dqs_nom);
+            if (rc) return rc;
+            rc = config_rcv_imp(i_target_mba, i_port,
+                                l_rcv_imp_dq_dqs_nom[i_port]);
+            if (rc) return rc;
+        }
+        FAPI_INF("Restoring mcbist setup attribute...");
+        rc = reset_attribute(i_target_mba);
+        if (rc) return rc;
+        FAPI_INF("++++ Receiver Impdeance Shmoo function executed successfully ++++");
+    }
+    return rc;
 }
 
 //------------------------------------------------------------------------------
@@ -1678,32 +1866,32 @@ shmoo_type_t i_shmoo_type_valid)
 // Shmoo type: MCBIST, WR_EYE, RD_EYE, WR_DQS, RD_DQS
 // Shmoo Mode: FEW_ADDR, QUARTER_ADDR, HALF_ADDR, FULL_ADDR
 // i_pattern, i_test_type : Default = 0, mcbist lab function would use this arg
-// Output param: l_left_margin = Left Margin(Setup time), 
+// Output param: l_left_margin = Left Margin(Setup time),
 // l_right_margin = Right Margin (Hold time) in ps
 //------------------------------------------------------------------------------
 
 fapi::ReturnCode delay_shmoo(const fapi::Target & i_target_mba, uint8_t i_port,
-shmoo_type_t i_shmoo_type_valid,
-uint32_t *o_left_margin,
-uint32_t *o_right_margin,
-uint32_t i_shmoo_param)
+                             shmoo_type_t i_shmoo_type_valid,
+                             uint32_t *o_left_margin,
+                             uint32_t *o_right_margin,
+                             uint32_t i_shmoo_param)
 {
-	fapi::ReturnCode rc;
-	//FAPI_INF(" Inside before the delay shmoo " );
-	//Constructor CALL: generic_shmoo::generic_shmoo(uint8_t i_port, uint32_t shmoo_mask,shmoo_algorithm_t shmoo_algorithm)
-	//generic_shmoo mss_shmoo=generic_shmoo(i_port,2,SEQ_LIN);
-
-        //need to use fapi allocator to avoid memory fragmentation issues in Hostboot
-        //  then use an in-place new to put the object in the pre-allocated memory
-        void* l_mallocptr = fapiMalloc(sizeof(generic_shmoo));
-	generic_shmoo * l_pShmoo = new (l_mallocptr) generic_shmoo(i_port,i_shmoo_type_valid,SEQ_LIN);
-	rc = l_pShmoo->run(i_target_mba, o_left_margin, o_right_margin,i_shmoo_param);
-	if(rc)
-	{
-		FAPI_ERR("Delay Schmoo Function is Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
-	}
-        fapiFree(l_mallocptr);
-	return rc;
+    fapi::ReturnCode rc;
+    //FAPI_INF(" Inside before the delay shmoo " );
+    //Constructor CALL: generic_shmoo::generic_shmoo(uint8_t i_port, uint32_t shmoo_mask,shmoo_algorithm_t shmoo_algorithm)
+    //generic_shmoo mss_shmoo=generic_shmoo(i_port,2,SEQ_LIN);
+
+    //need to use fapi allocator to avoid memory fragmentation issues in Hostboot
+    //  then use an in-place new to put the object in the pre-allocated memory
+    void* l_mallocptr = fapiMalloc(sizeof(generic_shmoo));
+    generic_shmoo * l_pShmoo = new (l_mallocptr) generic_shmoo(i_port,i_shmoo_type_valid,SEQ_LIN);
+    rc = l_pShmoo->run(i_target_mba, o_left_margin, o_right_margin,i_shmoo_param);
+    if(rc)
+    {
+        FAPI_ERR("Delay Schmoo Function is Failed rc = 0x%08X (creator = %d)", uint32_t(rc), rc.getCreator());
+    }
+    fapiFree(l_mallocptr);
+    return rc;
 }
 
 //------------------------------------------------------------------------------
@@ -1713,50 +1901,53 @@ uint32_t i_shmoo_param)
 // Shmoo type: MCBIST, WR_EYE, RD_EYE, WR_DQS, RD_DQS
 // Shmoo Mode: FEW_ADDR, QUARTER_ADDR, HALF_ADDR, FULL_ADDR
 // i_pattern, i_test_type : Default = 0, mcbist lab function would use this arg
-// Output param: l_left_margin = Left Margin(Setup time), 
+// Output param: l_left_margin = Left Margin(Setup time),
 // l_right_margin = Right Margin (Hold time) in ps
 //------------------------------------------------------------------------------
 
 fapi::ReturnCode delay_shmoo_ddr4(const fapi::Target & i_target_mba, uint8_t i_port,
-shmoo_type_t i_shmoo_type_valid,
-uint32_t *o_left_margin,
-uint32_t *o_right_margin,
-uint32_t i_shmoo_param,uint32_t pda_nibble_table[2][2][4][16][2])
+                                  shmoo_type_t i_shmoo_type_valid,
+                                  uint32_t *o_left_margin,
+                                  uint32_t *o_right_margin,
+                                  uint32_t i_shmoo_param,uint32_t pda_nibble_table[2][2][4][16][2])
 {
-	fapi::ReturnCode rc;
-
-        //need to use fapi allocator to avoid memory fragmentation issues in Hostboot
-        //  then use an in-place new to put the object in the pre-allocated memory
-        void* l_mallocptr = fapiMalloc(sizeof(generic_shmoo));
-	generic_shmoo * l_pShmoo = new (l_mallocptr) generic_shmoo(i_port,i_shmoo_type_valid,SEQ_LIN);
-
-	rc = l_pShmoo->run(i_target_mba, o_left_margin, o_right_margin,i_shmoo_param); if (rc) return rc;
-	
-	
-	
-        fapiFree(l_mallocptr);
-	return rc;
+    fapi::ReturnCode rc;
+
+    //need to use fapi allocator to avoid memory fragmentation issues in Hostboot
+    //  then use an in-place new to put the object in the pre-allocated memory
+    void* l_mallocptr = fapiMalloc(sizeof(generic_shmoo));
+    generic_shmoo * l_pShmoo = new (l_mallocptr) generic_shmoo(i_port,i_shmoo_type_valid,SEQ_LIN);
+
+    rc = l_pShmoo->run(i_target_mba, o_left_margin, o_right_margin,i_shmoo_param);
+    if (rc) return rc;
+
+
+
+    fapiFree(l_mallocptr);
+    return rc;
 }
 
 fapi::ReturnCode delay_shmoo_ddr4_pda(const fapi::Target & i_target_mba, uint8_t i_port,
-shmoo_type_t i_shmoo_type_valid,
-uint32_t *o_left_margin,
-uint32_t *o_right_margin,
-uint32_t i_shmoo_param,uint32_t pda_nibble_table[2][2][4][16][2])
+                                      shmoo_type_t i_shmoo_type_valid,
+                                      uint32_t *o_left_margin,
+                                      uint32_t *o_right_margin,
+                                      uint32_t i_shmoo_param,uint32_t pda_nibble_table[2][2][4][16][2])
 {
-	fapi::ReturnCode rc;
-
-        //need to use fapi allocator to avoid memory fragmentation issues in Hostboot
-        //  then use an in-place new to put the object in the pre-allocated memory
-        void* l_mallocptr = fapiMalloc(sizeof(generic_shmoo));
-	generic_shmoo * l_pShmoo = new (l_mallocptr) generic_shmoo(i_port,i_shmoo_type_valid,SEQ_LIN);
-
-	rc = l_pShmoo->run(i_target_mba, o_left_margin, o_right_margin,i_shmoo_param); if (rc) return rc;
-	
-	rc = l_pShmoo->get_nibble_pda(i_target_mba,pda_nibble_table); if (rc) return rc;
-	
-        fapiFree(l_mallocptr);
-	return rc;
+    fapi::ReturnCode rc;
+
+    //need to use fapi allocator to avoid memory fragmentation issues in Hostboot
+    //  then use an in-place new to put the object in the pre-allocated memory
+    void* l_mallocptr = fapiMalloc(sizeof(generic_shmoo));
+    generic_shmoo * l_pShmoo = new (l_mallocptr) generic_shmoo(i_port,i_shmoo_type_valid,SEQ_LIN);
+
+    rc = l_pShmoo->run(i_target_mba, o_left_margin, o_right_margin,i_shmoo_param);
+    if (rc) return rc;
+
+    rc = l_pShmoo->get_nibble_pda(i_target_mba,pda_nibble_table);
+    if (rc) return rc;
+
+    fapiFree(l_mallocptr);
+    return rc;
 }
 
 //------------------------------------------------------------------------------
@@ -1766,229 +1957,258 @@ uint32_t i_shmoo_param,uint32_t pda_nibble_table[2][2][4][16][2])
 
 fapi::ReturnCode set_attribute(const fapi::Target & i_target_mba)
 {
-	fapi::ReturnCode rc;
-	uint8_t l_mcbist_setup_multiple_set = 1;  //Hard coded it wont change
-	rc =  FAPI_ATTR_SET(ATTR_SCHMOO_MULTIPLE_SETUP_CALL, &i_target_mba, l_mcbist_setup_multiple_set);
-	return rc;
+    fapi::ReturnCode rc;
+    uint8_t l_mcbist_setup_multiple_set = 1;  //Hard coded it wont change
+    rc =  FAPI_ATTR_SET(ATTR_SCHMOO_MULTIPLE_SETUP_CALL, &i_target_mba, l_mcbist_setup_multiple_set);
+    return rc;
 }
 
 fapi::ReturnCode rd_vref_shmoo_ddr4(const fapi::Target & i_target_mba)
 {
-	fapi::ReturnCode rc;
-	shmoo_type_t i_shmoo_type_valid = MCBIST; // Hard coded - Temporary
-	ecmdDataBufferBase l_data_buffer_64(64);
-	ecmdDataBufferBase data_buffer(64);
-	uint32_t l_rd_cen_vref_schmoo[MAX_PORT] = {0};
-	uint32_t l_left_margin = 0;
-	uint32_t l_right_margin = 0;
-	uint32_t l_rd_cen_vref_in = 0;
-	uint8_t l_attr_schmoo_test_type_u8 = 1;
-	rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_TEST_VALID, &i_target_mba, l_attr_schmoo_test_type_u8); if(rc) return rc;
-	uint8_t i_port=0;
-	uint32_t diff_value = 1375;
-	uint32_t base = 70000;
-	uint32_t vref_value_print = 0;
-	uint32_t l_left_margin_rd_vref_array[16] = {0};
-	uint32_t l_right_margin_rd_vref_array[16] = {0};
-	uint32_t rc_num = 0;
-	uint8_t l_vref_num = 0;
-	
-	FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++ Patch - Preet - RD_VREF - Check Sanity only - DDR4 +++++++++++++++++++++++++++");
-	rc = delay_shmoo(i_target_mba, i_port, i_shmoo_type_valid,
-	&l_left_margin, &l_right_margin,
-	l_rd_cen_vref_in);
-	if(rc) return rc;
-	FAPI_INF(" Setup and Sanity - Check disabled from now on..... Continuing .....");
-	rc = set_attribute(i_target_mba);
-	if (rc) return rc;
-	
-	i_shmoo_type_valid = RD_EYE;
-	l_attr_schmoo_test_type_u8 = 4;
-	rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_TEST_VALID, &i_target_mba, l_attr_schmoo_test_type_u8); if(rc) return rc;
-	//rc = FAPI_ATTR_GET(ATTR_EFF_CEN_RD_VREF, &i_target_mba, l_rd_cen_vref_nom);if (rc) return rc;
-	rc = FAPI_ATTR_GET(ATTR_EFF_CEN_RD_VREF_SCHMOO, &i_target_mba, l_rd_cen_vref_schmoo);if (rc) return rc;
-	
-
-	FAPI_INF("CEN_RD_VREF_SCHMOO[0] = [%x], CEN_RD_VREF_SCHMOO[1] = [%x] on %s",
-	l_rd_cen_vref_schmoo[0],
-	l_rd_cen_vref_schmoo[1],
-	i_target_mba.toEcmdString());
-	FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++ Patch - Preet - RD_VREF DDR4 +++++++++++++++++++++++++++");
-
-	//For DDR3 - DDR4 Range 
-	if (l_rd_cen_vref_schmoo[i_port] == 1)
-	{
-		FAPI_INF("\n Testing Range - DDR3 to DDR4 - Vrefs");
-		base = 50000;
-	}
-	else
-	{
-		FAPI_INF("\n Testing Range - DDR4 Range Only - Vrefs");
-		
-		for(l_vref_num = 7; l_vref_num > 0 ; l_vref_num--)
-		{
-			l_rd_cen_vref_in = l_vref_num;
-			vref_value_print = base - (l_vref_num*diff_value);     
-			FAPI_INF("Current Vref value is %d",vref_value_print);
-			FAPI_INF("Configuring Read Vref Registers:");
-			rc = fapiGetScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_0_0x800000060301143F,  
-			data_buffer); if(rc) return rc;
-			rc_num = rc_num | data_buffer.insertFromRight(l_rd_cen_vref_in,56,4);
-			if (rc_num)
-			{
-				FAPI_ERR( "config_rd_vref: Error in setting up buffer ");
-				rc.setEcmdError(rc_num);
-				return rc;
-			}
-			rc_num = data_buffer.setBit(60); 
-			if (rc_num)
-			{
-				FAPI_ERR( "config_rd_vref: Error in setting up buffer ");
-				rc.setEcmdError(rc_num);
-				return rc;
-			}
-			rc = fapiPutScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_0_0x800000060301143F,
-			data_buffer); if(rc) return rc;
-			rc = fapiPutScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_1_0x800004060301143F,
-			data_buffer); if(rc) return rc;
-			rc = fapiPutScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_2_0x800008060301143F,
-			data_buffer); if(rc) return rc;
-			rc = fapiPutScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_3_0x80000c060301143F,
-			data_buffer); if(rc) return rc;
-			rc = fapiPutScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_4_0x800010060301143F,
-			data_buffer); if(rc) return rc;
-			rc = fapiGetScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_0_0x800100060301143F,
-			data_buffer); if(rc) return rc;
-			rc_num = rc_num | data_buffer.insertFromRight(l_rd_cen_vref_in,56,4);
-			if (rc_num)
-			{
-				FAPI_ERR( "config_rd_vref: Error in setting up buffer ");
-				rc.setEcmdError(rc_num);
-				return rc;
-			}
-			rc_num = data_buffer.setBit(60); 
-			if (rc_num)
-			{
-				FAPI_ERR( "config_rd_vref: Error in setting up buffer ");
-				rc.setEcmdError(rc_num);
-				return rc;
-			}
-			rc = fapiPutScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_0_0x800100060301143F,
-			data_buffer); if(rc) return rc;
-			rc = fapiPutScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_1_0x800104060301143F,
-			data_buffer); if(rc) return rc;
-			rc = fapiPutScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_2_0x800108060301143F,
-			data_buffer); if(rc) return rc;
-			rc = fapiPutScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_3_0x80010c060301143F,
-			data_buffer); if(rc) return rc;
-			rc = fapiPutScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_4_0x800110060301143F,
-			data_buffer); if(rc) return rc;
-
-			rc = delay_shmoo(i_target_mba, i_port, i_shmoo_type_valid,&l_left_margin, &l_right_margin,l_rd_cen_vref_in);if (rc) return rc;
-			l_left_margin_rd_vref_array[l_vref_num] = l_left_margin;
-			l_right_margin_rd_vref_array[l_vref_num] = l_right_margin;
-
-			FAPI_INF("Read Vref = %d ; Min Setup time = %d; Min Hold time = %d",vref_value_print, l_left_margin_rd_vref_array[l_vref_num],l_right_margin_rd_vref_array[l_vref_num]);
-		}
-		// For base + values
-
-		for(l_vref_num = 0; l_vref_num < 9; l_vref_num++)
-		{
-			
-			l_rd_cen_vref_in = l_vref_num;
-			vref_value_print = base + (l_vref_num*diff_value);     
-			FAPI_INF("Current Vref value is %d",vref_value_print);
-			FAPI_INF("Configuring Read Vref Registers:");
-			rc = fapiGetScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_0_0x800000060301143F,  
-			data_buffer); if(rc) return rc;
-			rc_num = rc_num | data_buffer.insertFromRight(l_rd_cen_vref_in,56,4);
-			if (rc_num)
-			{
-				FAPI_ERR( "config_rd_vref: Error in setting up buffer ");
-				rc.setEcmdError(rc_num);
-				return rc;
-			}
-			rc_num = data_buffer.setBit(60); 
-			if (rc_num)
-			{
-				FAPI_ERR( "config_rd_vref: Error in setting up buffer ");
-				rc.setEcmdError(rc_num);
-				return rc;
-			}
-			rc = fapiPutScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_0_0x800000060301143F,
-			data_buffer); if(rc) return rc;
-			rc = fapiPutScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_1_0x800004060301143F,
-			data_buffer); if(rc) return rc;
-			rc = fapiPutScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_2_0x800008060301143F,
-			data_buffer); if(rc) return rc;
-			rc = fapiPutScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_3_0x80000c060301143F,
-			data_buffer); if(rc) return rc;
-			rc = fapiPutScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_4_0x800010060301143F,
-			data_buffer); if(rc) return rc;
-			rc = fapiGetScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_0_0x800100060301143F,
-			data_buffer); if(rc) return rc;
-			rc_num = rc_num | data_buffer.insertFromRight(l_rd_cen_vref_in,56,4);
-			if (rc_num)
-			{
-				FAPI_ERR( "config_rd_vref: Error in setting up buffer ");
-				rc.setEcmdError(rc_num);
-				return rc;
-			}
-			rc_num = data_buffer.setBit(60);
-			if (rc_num)
-			{
-				FAPI_ERR( "config_rd_vref: Error in setting up buffer ");
-				rc.setEcmdError(rc_num);
-				return rc;
-			}
-			rc = fapiPutScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_0_0x800100060301143F,
-			data_buffer); if(rc) return rc;
-			rc = fapiPutScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_1_0x800104060301143F,
-			data_buffer); if(rc) return rc;
-			rc = fapiPutScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_2_0x800108060301143F,
-			data_buffer); if(rc) return rc;
-			rc = fapiPutScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_3_0x80010c060301143F,
-			data_buffer); if(rc) return rc;
-			rc = fapiPutScom(i_target_mba,
-			DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_4_0x800110060301143F,
-			data_buffer); if(rc) return rc;
-
-			rc = delay_shmoo(i_target_mba, i_port, i_shmoo_type_valid,&l_left_margin, &l_right_margin,l_rd_cen_vref_in);if (rc) return rc;
-			l_left_margin_rd_vref_array[l_vref_num] = l_left_margin;
-			l_right_margin_rd_vref_array[l_vref_num] = l_right_margin;
-
-			FAPI_INF("Read Vref = %d ; Min Setup time = %d; Min Hold time = %d",vref_value_print, l_left_margin_rd_vref_array[l_vref_num],l_right_margin_rd_vref_array[l_vref_num]);
-		}
-		
-
-	}
-	FAPI_INF("++++ Centaur Read Vref Shmoo function DDR4 done ! ++++");
-	FAPI_INF("Restoring mcbist setup attribute...");
-	rc = reset_attribute(i_target_mba);		
-	return rc;
+    fapi::ReturnCode rc;
+    shmoo_type_t i_shmoo_type_valid = MCBIST; // Hard coded - Temporary
+    ecmdDataBufferBase l_data_buffer_64(64);
+    ecmdDataBufferBase data_buffer(64);
+    uint32_t l_rd_cen_vref_schmoo[MAX_PORT] = {0};
+    uint32_t l_left_margin = 0;
+    uint32_t l_right_margin = 0;
+    uint32_t l_rd_cen_vref_in = 0;
+    uint8_t l_attr_schmoo_test_type_u8 = 1;
+    rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_TEST_VALID, &i_target_mba, l_attr_schmoo_test_type_u8);
+    if(rc) return rc;
+    uint8_t i_port=0;
+    uint32_t diff_value = 1375;
+    uint32_t base = 70000;
+    uint32_t vref_value_print = 0;
+    uint32_t l_left_margin_rd_vref_array[16] = {0};
+    uint32_t l_right_margin_rd_vref_array[16] = {0};
+    uint32_t rc_num = 0;
+    uint8_t l_vref_num = 0;
+
+    FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++ Patch - Preet - RD_VREF - Check Sanity only - DDR4 +++++++++++++++++++++++++++");
+    rc = delay_shmoo(i_target_mba, i_port, i_shmoo_type_valid,
+                     &l_left_margin, &l_right_margin,
+                     l_rd_cen_vref_in);
+    if(rc) return rc;
+    FAPI_INF(" Setup and Sanity - Check disabled from now on..... Continuing .....");
+    rc = set_attribute(i_target_mba);
+    if (rc) return rc;
+
+    i_shmoo_type_valid = RD_EYE;
+    l_attr_schmoo_test_type_u8 = 4;
+    rc = FAPI_ATTR_SET(ATTR_EFF_SCHMOO_TEST_VALID, &i_target_mba, l_attr_schmoo_test_type_u8);
+    if(rc) return rc;
+    //rc = FAPI_ATTR_GET(ATTR_EFF_CEN_RD_VREF, &i_target_mba, l_rd_cen_vref_nom);if (rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_EFF_CEN_RD_VREF_SCHMOO, &i_target_mba, l_rd_cen_vref_schmoo);
+    if (rc) return rc;
+
+
+    FAPI_INF("CEN_RD_VREF_SCHMOO[0] = [%x], CEN_RD_VREF_SCHMOO[1] = [%x] on %s",
+             l_rd_cen_vref_schmoo[0],
+             l_rd_cen_vref_schmoo[1],
+             i_target_mba.toEcmdString());
+    FAPI_INF("+++++++++++++++++++++++++++++++++++++++++++++ Patch - Preet - RD_VREF DDR4 +++++++++++++++++++++++++++");
+
+    //For DDR3 - DDR4 Range
+    if (l_rd_cen_vref_schmoo[i_port] == 1)
+    {
+        FAPI_INF("\n Testing Range - DDR3 to DDR4 - Vrefs");
+        base = 50000;
+    }
+    else
+    {
+        FAPI_INF("\n Testing Range - DDR4 Range Only - Vrefs");
+
+        for(l_vref_num = 7; l_vref_num > 0 ; l_vref_num--)
+        {
+            l_rd_cen_vref_in = l_vref_num;
+            vref_value_print = base - (l_vref_num*diff_value);
+            FAPI_INF("Current Vref value is %d",vref_value_print);
+            FAPI_INF("Configuring Read Vref Registers:");
+            rc = fapiGetScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_0_0x800000060301143F,
+                             data_buffer);
+            if(rc) return rc;
+            rc_num = rc_num | data_buffer.insertFromRight(l_rd_cen_vref_in,56,4);
+            if (rc_num)
+            {
+                FAPI_ERR( "config_rd_vref: Error in setting up buffer ");
+                rc.setEcmdError(rc_num);
+                return rc;
+            }
+            rc_num = data_buffer.setBit(60);
+            if (rc_num)
+            {
+                FAPI_ERR( "config_rd_vref: Error in setting up buffer ");
+                rc.setEcmdError(rc_num);
+                return rc;
+            }
+            rc = fapiPutScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_0_0x800000060301143F,
+                             data_buffer);
+            if(rc) return rc;
+            rc = fapiPutScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_1_0x800004060301143F,
+                             data_buffer);
+            if(rc) return rc;
+            rc = fapiPutScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_2_0x800008060301143F,
+                             data_buffer);
+            if(rc) return rc;
+            rc = fapiPutScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_3_0x80000c060301143F,
+                             data_buffer);
+            if(rc) return rc;
+            rc = fapiPutScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_4_0x800010060301143F,
+                             data_buffer);
+            if(rc) return rc;
+            rc = fapiGetScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_0_0x800100060301143F,
+                             data_buffer);
+            if(rc) return rc;
+            rc_num = rc_num | data_buffer.insertFromRight(l_rd_cen_vref_in,56,4);
+            if (rc_num)
+            {
+                FAPI_ERR( "config_rd_vref: Error in setting up buffer ");
+                rc.setEcmdError(rc_num);
+                return rc;
+            }
+            rc_num = data_buffer.setBit(60);
+            if (rc_num)
+            {
+                FAPI_ERR( "config_rd_vref: Error in setting up buffer ");
+                rc.setEcmdError(rc_num);
+                return rc;
+            }
+            rc = fapiPutScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_0_0x800100060301143F,
+                             data_buffer);
+            if(rc) return rc;
+            rc = fapiPutScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_1_0x800104060301143F,
+                             data_buffer);
+            if(rc) return rc;
+            rc = fapiPutScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_2_0x800108060301143F,
+                             data_buffer);
+            if(rc) return rc;
+            rc = fapiPutScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_3_0x80010c060301143F,
+                             data_buffer);
+            if(rc) return rc;
+            rc = fapiPutScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_4_0x800110060301143F,
+                             data_buffer);
+            if(rc) return rc;
+
+            rc = delay_shmoo(i_target_mba, i_port, i_shmoo_type_valid,&l_left_margin, &l_right_margin,vref_value_print);
+            if (rc) return rc;
+            l_left_margin_rd_vref_array[l_vref_num] = l_left_margin;
+            l_right_margin_rd_vref_array[l_vref_num] = l_right_margin;
+
+            FAPI_INF("Read Vref = %d ; Min Setup time = %d; Min Hold time = %d",vref_value_print, l_left_margin_rd_vref_array[l_vref_num],l_right_margin_rd_vref_array[l_vref_num]);
+        }
+        // For base + values
+
+        for(l_vref_num = 0; l_vref_num < 9; l_vref_num++)
+        {
+
+            l_rd_cen_vref_in = l_vref_num;
+            vref_value_print = base + (l_vref_num*diff_value);
+            FAPI_INF("Current Vref value is %d",vref_value_print);
+            FAPI_INF("Configuring Read Vref Registers:");
+            rc = fapiGetScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_0_0x800000060301143F,
+                             data_buffer);
+            if(rc) return rc;
+            rc_num = rc_num | data_buffer.insertFromRight(l_rd_cen_vref_in,56,4);
+            if (rc_num)
+            {
+                FAPI_ERR( "config_rd_vref: Error in setting up buffer ");
+                rc.setEcmdError(rc_num);
+                return rc;
+            }
+            rc_num = data_buffer.setBit(60);
+            if (rc_num)
+            {
+                FAPI_ERR( "config_rd_vref: Error in setting up buffer ");
+                rc.setEcmdError(rc_num);
+                return rc;
+            }
+            rc = fapiPutScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_0_0x800000060301143F,
+                             data_buffer);
+            if(rc) return rc;
+            rc = fapiPutScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_1_0x800004060301143F,
+                             data_buffer);
+            if(rc) return rc;
+            rc = fapiPutScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_2_0x800008060301143F,
+                             data_buffer);
+            if(rc) return rc;
+            rc = fapiPutScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_3_0x80000c060301143F,
+                             data_buffer);
+            if(rc) return rc;
+            rc = fapiPutScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P0_4_0x800010060301143F,
+                             data_buffer);
+            if(rc) return rc;
+            rc = fapiGetScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_0_0x800100060301143F,
+                             data_buffer);
+            if(rc) return rc;
+            rc_num = rc_num | data_buffer.insertFromRight(l_rd_cen_vref_in,56,4);
+            if (rc_num)
+            {
+                FAPI_ERR( "config_rd_vref: Error in setting up buffer ");
+                rc.setEcmdError(rc_num);
+                return rc;
+            }
+            rc_num = data_buffer.setBit(60);
+            if (rc_num)
+            {
+                FAPI_ERR( "config_rd_vref: Error in setting up buffer ");
+                rc.setEcmdError(rc_num);
+                return rc;
+            }
+            rc = fapiPutScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_0_0x800100060301143F,
+                             data_buffer);
+            if(rc) return rc;
+            rc = fapiPutScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_1_0x800104060301143F,
+                             data_buffer);
+            if(rc) return rc;
+            rc = fapiPutScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_2_0x800108060301143F,
+                             data_buffer);
+            if(rc) return rc;
+            rc = fapiPutScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_3_0x80010c060301143F,
+                             data_buffer);
+            if(rc) return rc;
+            rc = fapiPutScom(i_target_mba,
+                             DPHY01_DDRPHY_DP18_RX_PEAK_AMP_P1_4_0x800110060301143F,
+                             data_buffer);
+            if(rc) return rc;
+
+            rc = delay_shmoo(i_target_mba, i_port, i_shmoo_type_valid,&l_left_margin, &l_right_margin,vref_value_print);
+            if (rc) return rc;
+            l_left_margin_rd_vref_array[l_vref_num] = l_left_margin;
+            l_right_margin_rd_vref_array[l_vref_num] = l_right_margin;
+
+            FAPI_INF("Read Vref = %d ; Min Setup time = %d; Min Hold time = %d",vref_value_print, l_left_margin_rd_vref_array[l_vref_num],l_right_margin_rd_vref_array[l_vref_num]);
+        }
+
+
+    }
+    FAPI_INF("++++ Centaur Read Vref Shmoo function DDR4 done ! ++++");
+    FAPI_INF("Restoring mcbist setup attribute...");
+    rc = reset_attribute(i_target_mba);
+    return rc;
 }
 
 //------------------------------------------------------------------------------
@@ -1998,10 +2218,10 @@ fapi::ReturnCode rd_vref_shmoo_ddr4(const fapi::Target & i_target_mba)
 
 fapi::ReturnCode reset_attribute(const fapi::Target & i_target_mba)
 {
-	fapi::ReturnCode rc;
-	uint8_t l_mcbist_setup_multiple_reset = 0; //Hard coded it wont change
-	rc = FAPI_ATTR_SET(ATTR_SCHMOO_MULTIPLE_SETUP_CALL, &i_target_mba, l_mcbist_setup_multiple_reset);
-	return rc;
+    fapi::ReturnCode rc;
+    uint8_t l_mcbist_setup_multiple_reset = 0; //Hard coded it wont change
+    rc = FAPI_ATTR_SET(ATTR_SCHMOO_MULTIPLE_SETUP_CALL, &i_target_mba, l_mcbist_setup_multiple_reset);
+    return rc;
 }
 
 //------------------------------------------------------------------------------
@@ -2016,108 +2236,108 @@ fapi::ReturnCode reset_attribute(const fapi::Target & i_target_mba)
 
 
 void find_best_margin(shmoo_param i_shmoo_param_valid,
-uint32_t i_left[],
-uint32_t i_right[],
-const uint8_t i_max,
-uint32_t i_param_nom,
-uint8_t& o_index)
+                      uint32_t i_left[],
+                      uint32_t i_right[],
+                      const uint8_t i_max,
+                      uint32_t i_param_nom,
+                      uint8_t& o_index)
 {
-	uint32_t left_margin = 0;
-	uint32_t right_margin = 0;
-	uint32_t left_margin_nom = 0;
-	uint32_t right_margin_nom = 0;
-	uint32_t diff_margin_nom = 0;
-	//uint32_t total_margin = 0;
-	uint32_t diff_margin = 0;
-	uint8_t index = 0;
-	uint8_t index2 = 0;
-
-	for (index = 0; index < i_max; index += 1) //send max from top function
-	{
-		if (i_shmoo_param_valid & DRV_IMP)
-		{
-			if (drv_imp_array[index] == i_param_nom)
-			{
-				left_margin_nom = i_left[index];
-				right_margin_nom = i_right[index];
-				diff_margin_nom = (i_left[index] >= i_right[index]) ?
-				(i_left[index]- i_right[index]) :
-				(i_right[index] - i_left[index]);
-				//FAPI_INF("Driver impedance value (NOM): %d Ohms  Setup Margin: %d Hold Margin: %d", i_param_nom, i_left[index], i_right[index]);
-				break;
-			}
-		}
-		else if (i_shmoo_param_valid & SLEW_RATE)
-		{
-			if (slew_rate_array[index] == i_param_nom)
-			{
-				left_margin_nom = i_left[index];
-				right_margin_nom = i_right[index];
-				diff_margin_nom = (i_left[index] >= i_right[index]) ?
-				(i_left[index] - i_right[index]) :
-				(i_right[index] - i_left[index]);
-				//FAPI_INF("Slew rate value (NOM): %d V/ns  Setup Margin: %d Hold Margin: %d", i_param_nom, i_left[index], i_right[index]);
-				break;
-			}
-		}
-		else if (i_shmoo_param_valid & WR_VREF)
-		{
-			if (wr_vref_array_fitness[index] == i_param_nom)
-			{
-				left_margin_nom = i_left[index];
-				right_margin_nom = i_right[index];
-				diff_margin_nom = (i_left[index] >= i_right[index]) ?
-				(i_left[index] - i_right[index]) :
-				(i_right[index] - i_left[index]);
-				//FAPI_INF("Write DRAM Vref Multiplier value (NOM): %d   Setup Margin: %d Hold Margin: %d", i_param_nom, i_left[index], i_right[index]);
-				break;
-			}
-		}
-		else if (i_shmoo_param_valid & RD_VREF)
-		{
-			if (rd_cen_vref_array_fitness[index] == i_param_nom)
-			{
-				left_margin_nom = i_left[index];
-				right_margin_nom = i_right[index];
-				diff_margin_nom = (i_left[index] >= i_right[index]) ?
-				(i_left[index] - i_right[index]) :
-				(i_right[index] - i_left[index]);
-				//FAPI_INF("Centaur Read Vref Multiplier value (NOM): %d  Setup Margin: %d Hold Margin: %d", i_param_nom, i_left[index], i_right[index]);
-				break;
-			}
-		}
-		else if (i_shmoo_param_valid & RCV_IMP)
-		{
-			if (rcv_imp_array[index] == i_param_nom)
-			{
-				left_margin_nom = i_left[index];
-				right_margin_nom = i_right[index];
-				diff_margin_nom = (i_left[index] >= i_right[index]) ?
-				(i_left[index] - i_right[index]) :
-				(i_right[index] - i_left[index]);
-				// FAPI_INF("Receiver Impedance value (NOM): %d Ohms  Setup Margin: %d Hold Margin: %d", i_param_nom, i_left[index], i_right[index]);
-				break;
-			}
-		}
-	}
-	for (index2 = 0; index2 < i_max; index2 += 1)
-	{
-		left_margin = i_left[index2];
-		right_margin = i_right[index2];
-		//total_margin = i_left[index2] + i_right[index2];
-		diff_margin = (i_left[index2] >= i_right[index2]) ? (i_left[index2]
-		- i_right[index2]) : (i_right[index2] - i_left[index2]);
-		if ((left_margin > 0 && right_margin > 0))
-		{
-			if ((left_margin >= left_margin_nom) && (right_margin
-						>= right_margin_nom) && (diff_margin <= diff_margin_nom))
-			{
-				o_index = index2;
-				//wont break this loop, since the purpose is to find the best parameter value & best timing margin The enum is constructed to do that
-				//  FAPI_INF("Index value %d, Min Setup Margin: %d, Min Hold Margin: %d", o_index, i_left[index2], i_right[index2]);
-			}
-		}
-	}
+    uint32_t left_margin = 0;
+    uint32_t right_margin = 0;
+    uint32_t left_margin_nom = 0;
+    uint32_t right_margin_nom = 0;
+    uint32_t diff_margin_nom = 0;
+    //uint32_t total_margin = 0;
+    uint32_t diff_margin = 0;
+    uint8_t index = 0;
+    uint8_t index2 = 0;
+
+    for (index = 0; index < i_max; index += 1) //send max from top function
+    {
+        if (i_shmoo_param_valid & DRV_IMP)
+        {
+            if (drv_imp_array[index] == i_param_nom)
+            {
+                left_margin_nom = i_left[index];
+                right_margin_nom = i_right[index];
+                diff_margin_nom = (i_left[index] >= i_right[index]) ?
+                                  (i_left[index]- i_right[index]) :
+                                  (i_right[index] - i_left[index]);
+                //FAPI_INF("Driver impedance value (NOM): %d Ohms  Setup Margin: %d Hold Margin: %d", i_param_nom, i_left[index], i_right[index]);
+                break;
+            }
+        }
+        else if (i_shmoo_param_valid & SLEW_RATE)
+        {
+            if (slew_rate_array[index] == i_param_nom)
+            {
+                left_margin_nom = i_left[index];
+                right_margin_nom = i_right[index];
+                diff_margin_nom = (i_left[index] >= i_right[index]) ?
+                                  (i_left[index] - i_right[index]) :
+                                  (i_right[index] - i_left[index]);
+                //FAPI_INF("Slew rate value (NOM): %d V/ns  Setup Margin: %d Hold Margin: %d", i_param_nom, i_left[index], i_right[index]);
+                break;
+            }
+        }
+        else if (i_shmoo_param_valid & WR_VREF)
+        {
+            if (wr_vref_array_fitness[index] == i_param_nom)
+            {
+                left_margin_nom = i_left[index];
+                right_margin_nom = i_right[index];
+                diff_margin_nom = (i_left[index] >= i_right[index]) ?
+                                  (i_left[index] - i_right[index]) :
+                                  (i_right[index] - i_left[index]);
+                //FAPI_INF("Write DRAM Vref Multiplier value (NOM): %d   Setup Margin: %d Hold Margin: %d", i_param_nom, i_left[index], i_right[index]);
+                break;
+            }
+        }
+        else if (i_shmoo_param_valid & RD_VREF)
+        {
+            if (rd_cen_vref_array_fitness[index] == i_param_nom)
+            {
+                left_margin_nom = i_left[index];
+                right_margin_nom = i_right[index];
+                diff_margin_nom = (i_left[index] >= i_right[index]) ?
+                                  (i_left[index] - i_right[index]) :
+                                  (i_right[index] - i_left[index]);
+                //FAPI_INF("Centaur Read Vref Multiplier value (NOM): %d  Setup Margin: %d Hold Margin: %d", i_param_nom, i_left[index], i_right[index]);
+                break;
+            }
+        }
+        else if (i_shmoo_param_valid & RCV_IMP)
+        {
+            if (rcv_imp_array[index] == i_param_nom)
+            {
+                left_margin_nom = i_left[index];
+                right_margin_nom = i_right[index];
+                diff_margin_nom = (i_left[index] >= i_right[index]) ?
+                                  (i_left[index] - i_right[index]) :
+                                  (i_right[index] - i_left[index]);
+                // FAPI_INF("Receiver Impedance value (NOM): %d Ohms  Setup Margin: %d Hold Margin: %d", i_param_nom, i_left[index], i_right[index]);
+                break;
+            }
+        }
+    }
+    for (index2 = 0; index2 < i_max; index2 += 1)
+    {
+        left_margin = i_left[index2];
+        right_margin = i_right[index2];
+        //total_margin = i_left[index2] + i_right[index2];
+        diff_margin = (i_left[index2] >= i_right[index2]) ? (i_left[index2]
+                      - i_right[index2]) : (i_right[index2] - i_left[index2]);
+        if ((left_margin > 0 && right_margin > 0))
+        {
+            if ((left_margin >= left_margin_nom) && (right_margin
+                    >= right_margin_nom) && (diff_margin <= diff_margin_nom))
+            {
+                o_index = index2;
+                //wont break this loop, since the purpose is to find the best parameter value & best timing margin The enum is constructed to do that
+                //  FAPI_INF("Index value %d, Min Setup Margin: %d, Min Hold Margin: %d", o_index, i_left[index2], i_right[index2]);
+            }
+        }
+    }
 }
 
 
diff --git a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_mcbist_common.C b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_mcbist_common.C
index a892972..4955633 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_mcbist_common.C
+++ b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_mcbist_common.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2012,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2012,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_mcbist_common.C,v 1.76 2015/08/07 11:08:45 sasethur Exp $
+// $Id: mss_mcbist_common.C,v 1.78 2016/02/03 20:07:42 sglancy Exp $
 // *!***************************************************************************
 // *! (C) Copyright International Business Machines Corp. 1997, 1998
 // *!           All Rights Reserved -- Property of IBM
@@ -40,6 +40,8 @@
 //------------------------------------------------------------------------------
 // Version:|Author: | Date:  | Comment:
 // --------|--------|--------|--------------------------------------------------
+//   1.78  |sglancy |02/03/16|Fixed FW compile issue
+//   1.77  |lapietra|12/08/15|Added Flag to exit MCBIST before start (for examing Regs)
 //   1.76  |preeragh|07/15/15|R_W Infinite Added
 //   1.75  |lapietra|06/26/15|added RMWFIX and RMWFIX_I tests
 //   1.74  |preeragh|06/15/15|o_error_map Correction
@@ -500,6 +502,7 @@ fapi::ReturnCode start_mcb(const fapi::Target & i_target_mba)
     ecmdDataBufferBase l_data_buffer_64(64);
     ecmdDataBufferBase l_data_buffer_trap_64(64);
     uint8_t l_num_ranks_per_dimm[2][2];
+    uint64_t l_time = 0;
     fapi::ReturnCode rc;
     uint32_t rc_num = 0;
     FAPI_DBG("%s:Function - start_mcb", i_target_mba.toEcmdString());
@@ -573,7 +576,18 @@ fapi::ReturnCode start_mcb(const fapi::Target & i_target_mba)
         rc.setEcmdError(rc_num);
         return rc;
     }
+    rc = FAPI_ATTR_GET(ATTR_MCBIST_MAX_TIMEOUT, &i_target_mba, l_time); 
+    if (rc) return rc;
 
+
+#ifdef FAPI_MSSLABONLY                  
+    if (l_time == 0xDEADBEEF00000000ull)
+    {
+
+         FAPI_INF("******* Forced Exiting Before MCBIST_START to collect Reg Info!!!!!");    
+         exit(99);
+    }
+#endif
     rc = fapiPutScom(i_target_mba, MBA01_MCBIST_MCB_CNTLQ_0x030106db, l_data_buffer_64);
     if (rc) return rc;
 
diff --git a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_mrs6_DDR4.C b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_mrs6_DDR4.C
index 75f0a8e..c85dc2f 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_mrs6_DDR4.C
+++ b/src/usr/hwpf/hwp/dram_training/mss_draminit_trainadv/mss_mrs6_DDR4.C
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_mrs6_DDR4.C,v 1.7 2015/10/23 15:12:05 sglancy Exp $
+// $Id: mss_mrs6_DDR4.C,v 1.10 2016/01/14 13:46:12 sglancy Exp $
 
 
 //------------------------------------------------------------------------------
@@ -38,7 +38,10 @@
 //------------------------------------------------------------------------------
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|-----------------------------------------------
-//  1.06   |10-23-15  |sglancy | Fixed attribute names
+//  1.10   | 01-14-16 |sglancy | Fixed bug in parity code
+//  1.08   | 01-13-16 |sglancy | Added coverage for DDR4 parity bit
+//  1.07   | 11-03-15 |sglancy | Fixed attribute names for DDR4 RDIMM
+//  1.06   | 10-23-15 |sglancy | Fixed attribute names
 //  1.05   | 09/03/15 | kmack   | RC updates
 //  1.04   | 08/05/15 | sglancy | Fixed FW compile error
 //  1.03   | 08/04/15 | sglancy | Changed to address FW comments
@@ -251,7 +254,7 @@ ReturnCode mss_mr6_loader( fapi::Target& i_target,uint32_t i_port_number,uint32_
     if(rc) return rc;
 
     uint8_t address_mirror_map[2][2]; //address_mirror_map[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
     if(rc) return rc;
 
 
@@ -260,6 +263,8 @@ ReturnCode mss_mr6_loader( fapi::Target& i_target,uint32_t i_port_number,uint32_
     if(rc) return rc;
     //Setting up CCS mode
     rc_num = rc_num | data_buffer.setBit(51);
+    //set up parity bit manual computation - needed for DDR4
+    rc_num = rc_num | data_buffer.setBit(61);
     if (rc_num)
     {
         FAPI_ERR( "mss_mr6_loader: Error setting up buffers");
diff --git a/src/usr/hwpf/hwp/dram_training/mss_draminit_training/mss_draminit_training.C b/src/usr/hwpf/hwp/dram_training/mss_draminit_training/mss_draminit_training.C
index 9c1cc0d..0c15f46 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_draminit_training/mss_draminit_training.C
+++ b/src/usr/hwpf/hwp/dram_training/mss_draminit_training/mss_draminit_training.C
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_draminit_training.C,v 1.106 2015/10/23 16:28:15 sglancy Exp $
+// $Id: mss_draminit_training.C,v 1.107 2015/11/09 17:22:02 sglancy Exp $
 //------------------------------------------------------------------------------
 // Don't forget to create CVS comments when you check in your changes!
 //------------------------------------------------------------------------------
@@ -30,6 +30,7 @@
 //------------------------------------------------------------------------------
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|------------------------------------------------
+//  1.107  | sglancy  |03-NOV-15| Fixed attribute names for DDR4 RDIMM
 //  1.106  | sglancy  |23-OCT-15| Updated attribute names
 //  1.105  | rwheeler |20-OCT-15| updated the ifndef FAPI_LRDIMM.
 //  1.104  | rwheeler |19-OCT-15| Added support for the ddr4 lrdimm.
@@ -185,6 +186,7 @@
 //----------------------------------------------------------------------
 #include <cen_scom_addresses.H>
 #include <mss_funcs.H>
+#include <mss_ddr4_funcs.H>
 #include <dimmBadDqBitmapFuncs.H>
 #include <mss_unmask_errors.H>
 #include <mss_lrdimm_funcs.H>
@@ -192,7 +194,6 @@
 #include <mss_mrs6_DDR4.H>
 #ifdef FAPI_LRDIMM
 #include <mss_lrdimm_ddr4_funcs.H>
-#include <mss_ddr4_funcs.H>
 #endif
 
 #ifndef FAPI_LRDIMM
@@ -872,6 +873,23 @@ ReturnCode mss_draminit_training_cloned(Target& i_target)
 			       if(rc) return rc;
                             }
 			}
+			//DDR4 RDIMM, do the swap of the RTT_WR to RTT_NOM
+			if ( (cur_cal_step == 1) && (dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR4))
+			{
+                            if ( dimm_type != fapi::ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM )
+                            {
+
+			       dram_rtt_nom_original = 0xFF;
+			       rc = mss_ddr4_rtt_nom_rtt_wr_swap(i_target,
+			           			 mbaPosition,
+			           			 port,
+			           			 primary_ranks_array[group][port],
+			           			 group,
+			           			 instruction_number,
+			           			 dram_rtt_nom_original);
+			       if(rc) return rc;
+                            }
+			}
                         // Should only be called for DDR4 LRDIMMs, training code is in development. Does not effect any other configs
                         else if ( (group == 0) && (cur_cal_step == 1)
                                   && (dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR4)
@@ -1020,6 +1038,23 @@ ReturnCode mss_draminit_training_cloned(Target& i_target)
 			       if(rc) return rc;
                             }
 			}
+			
+			// Following WR_LVL -- Restore RTT_NOM to orignal value post-wr_lvl
+			if ((cur_cal_step == 1) && (dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR4))
+			{
+                            if ( dimm_type != fapi::ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM )
+                            {
+
+			       rc = mss_ddr4_rtt_nom_rtt_wr_swap(i_target,
+			           			 mbaPosition,
+			           			 port,
+			           			 primary_ranks_array[group][port],
+			           			 group,
+			           			 instruction_number,
+			           			 dram_rtt_nom_original);
+			       if(rc) return rc;
+                            }
+			}
 
 			// Following Read Centering -- Enter into READ CENTERING WORKAROUND
 			if  ( (cur_cal_step == 4) &&
@@ -5344,7 +5379,7 @@ ReturnCode mss_rtt_nom_rtt_wr_swap(
     if(rc) return rc;
 
     uint8_t address_mirror_map[2][2]; //address_mirror_map[port][dimm]
-    rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
     if(rc) return rc;
 
 
diff --git a/src/usr/hwpf/hwp/dram_training/mss_funcs.C b/src/usr/hwpf/hwp/dram_training/mss_funcs.C
index 2c1accb..986d6d3 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_funcs.C
+++ b/src/usr/hwpf/hwp/dram_training/mss_funcs.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2012,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2012,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -22,12 +22,13 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_funcs.C,v 1.43 2015/09/10 14:57:26 thi Exp $
+// $Id: mss_funcs.C,v 1.47 2016/02/15 18:36:59 sglancy Exp $
 /* File mss_funcs.C created by SLOAT JACOB D. (JAKE),2D3970 on Fri Apr 22 2011. */
 
 //------------------------------------------------------------------------------
 // *! (C) Copyright International Business Machines Corp. 2007
 // *! All Rights Reserved -- Property of IBM
+// *! ***  ***
 //------------------------------------------------------------------------------
 // *! TITLE : mss_funcs.C
 // *! DESCRIPTION : Tools for centaur procedures
@@ -44,6 +45,10 @@
 //------------------------------------------------------------------------------
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|-----------------------------------------------
+//  1.46   | sglancy  |15-FEB-16| Fixed compile issue
+//  1.46   | sglancy  |12-FEB-16| Addresed FW comments
+//  1.45   | rwheeler |18-DEC-15| updated mss_ccs_inst_arry_0 function for 3ds support.
+//  1.44   | rwheeler |23-OCT-15| ccs toggle between ports bug 
 //  1.43   | thi      |10-SEP-15| Fixed more RC stuff
 //  1.42   | kmack    |03-SEP-15| Fixed up some RC stuff
 //  1.41   | sglancy  |21-AUG-15| Fixed ODT initialization bug - ODT must be held low through ZQ cal
@@ -135,7 +140,7 @@ ReturnCode mss_ccs_set_end_bit(
 
     i_instruction_number = i_instruction_number + 1;
 
-    FAPI_INF( "Setting End Bit on instruction (NOP): %d.", i_instruction_number);
+    FAPI_DBG( "Setting End Bit on instruction (NOP): %d.", i_instruction_number);
 
     // Single NOP with CKE raised high and the end bit set high
     rc_num = rc_num | csn_8.setBit(0,8);
@@ -209,9 +214,9 @@ ReturnCode mss_address_mirror_swizzle(
         FAPI_INF( "ADDRESS MIRRORING ON %s PORT%d DIMM%d RANK%d", i_target.toEcmdString(), i_port, i_dimm, i_rank);
 
         rc_num = rc_num | io_address.extractPreserve(&mirror_mode_ad, 0, 16, 0);
-        FAPI_INF( "PRE - MIRROR MODE ADDRESS: 0x%04X", mirror_mode_ad);
+        FAPI_DBG( "PRE - MIRROR MODE ADDRESS: 0x%04X", mirror_mode_ad);
         rc_num = rc_num | io_bank.extractPreserve(&mirror_mode_ba, 0, 3, 0);
-        FAPI_INF( "PRE - MIRROR MODE BANK ADDRESS: 0x%04X", mirror_mode_ba);
+        FAPI_DBG( "PRE - MIRROR MODE BANK ADDRESS: 0x%04X", mirror_mode_ba);
 
         //Initialize address and bank address as the same pre mirror mode swizzle
         rc_num = rc_num | address_post_swizzle_16.insert(io_address, 0, 16, 0);
@@ -283,9 +288,9 @@ ReturnCode mss_address_mirror_swizzle(
         }
 
         rc_num = rc_num | address_post_swizzle_16.extractPreserve(&mirror_mode_ad, 0, 16, 0);
-        FAPI_INF( "POST - MIRROR MODE ADDRESS: 0x%04X", mirror_mode_ad);
+        FAPI_DBG( "POST - MIRROR MODE ADDRESS: 0x%04X", mirror_mode_ad);
         rc_num = rc_num | bank_post_swizzle_3.extractPreserve(&mirror_mode_ba, 0, 3, 0);
-        FAPI_INF( "POST - MIRROR MODE BANK ADDRESS: 0x%04X", mirror_mode_ba);
+        FAPI_DBG( "POST - MIRROR MODE BANK ADDRESS: 0x%04X", mirror_mode_ba);
 
         //copy address and bank address back to the IO variables
         rc_num = rc_num | io_address.insert(address_post_swizzle_16, 0, 16, 0);
@@ -314,7 +319,7 @@ ReturnCode mss_ccs_inst_arry_0(
             ecmdDataBufferBase i_csn,
             ecmdDataBufferBase i_odt,
             ecmdDataBufferBase i_ddr_cal_type,
-            uint32_t i_port
+            uint32_t i_port	    
               )
 {
     //Example Use:
@@ -324,7 +329,14 @@ ReturnCode mss_ccs_inst_arry_0(
     uint32_t rc_num = 0;
     uint32_t reg_address = 0;
     ecmdDataBufferBase data_buffer(64);
+    uint8_t dimm_type;
+    uint8_t dram_gen = 0;
 
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_GEN, &i_target, dram_gen);
+    if(rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_EFF_DIMM_TYPE, &i_target, dimm_type);
+    if(rc) return rc;
+    
     if ((io_instruction_number >= 30)&&(i_port != 0xFFFFFFFF))
     {
         uint32_t num_retry = 10;
@@ -354,14 +366,23 @@ ReturnCode mss_ccs_inst_arry_0(
         rc_num = rc_num | data_buffer.insert(i_odt, 48, 4, 0);
         rc_num = rc_num | data_buffer.insertFromRight((uint8_t)0x00,52,4);
     }
-    else
+    else if (i_port == 1)
     {
         rc_num = rc_num | data_buffer.insert((uint8_t)0xFF,32,8);
         rc_num = rc_num | data_buffer.insert(i_csn, 40, 8, 0);
         rc_num = rc_num | data_buffer.insertFromRight((uint8_t)0x00,48,4);
         rc_num = rc_num | data_buffer.insert(i_odt, 52, 4, 0);
+    } 
+    else if (i_port == 3)
+    {
+        rc_num = rc_num | data_buffer.insert(i_csn, 32, 8, 0);
+        rc_num = rc_num | data_buffer.insert(i_csn, 40, 8, 0);
+        rc_num = rc_num | data_buffer.insert(i_odt, 48, 4, 0);
+        rc_num = rc_num | data_buffer.insert(i_odt, 52, 4, 0);
+
     }
 
+
     //Placing bits into the data buffer
     rc_num = rc_num | data_buffer.insert( i_address, 0, 16, 0);
     rc_num = rc_num | data_buffer.insert( i_bank, 17, 3, 0);
@@ -370,14 +391,59 @@ ReturnCode mss_ccs_inst_arry_0(
     rc_num = rc_num | data_buffer.insert( i_casn, 22, 1, 0);
     rc_num = rc_num | data_buffer.insert( i_wen, 23, 1, 0);
     rc_num = rc_num | data_buffer.insert( i_ddr_cal_type, 56, 4, 0);
-
+    
+    //if in DDR4 mode, count the parity bit and set it
+    if((dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR4) && (dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM || dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_RDIMM) ) {
+       
+       //Port A control signals - Port A chip select set
+       uint8_t cs_start;
+       uint8_t cke_start;
+       uint8_t odt_start;
+       if(data_buffer.getNumBitsSet(32,8) < 8) {
+          //DIMM0 - DIMM0 CS set
+          if(data_buffer.getNumBitsSet(32,4) < 4) {
+             cke_start = 24;
+             cs_start  = 32;
+             odt_start = 48;
+          }
+          //DIMM1
+          else {
+             cke_start = 26;
+             cs_start  = 36;
+             odt_start = 50;
+          }
+       }
+       //Port B control signals
+       else {
+          //DIMM0 - DIMM0 CS set
+          if(data_buffer.getNumBitsSet(32,4) < 4) {
+             cke_start = 28;
+             cs_start  = 40;
+             odt_start = 52;
+          }
+          //DIMM1
+          else {
+             cke_start = 30;
+             cs_start  = 44;
+             odt_start = 54;
+          }
+       }
+       //adds CIDs + 1 extra bit for CID2
+       uint8_t parity_bit = data_buffer.getNumBitsSet(0,16) + data_buffer.getNumBitsSet(17,7) + data_buffer.getNumBitsSet(cs_start+2,2)  ;
+       //data_buffer.getNumBitsSet(cke_start,2) + data_buffer.getNumBitsSet(odt_start,2) + data_buffer.getNumBitsSet(cs_start,4);
+       FAPI_DBG("Change took???");
+       uint8_t parity_bit_even = parity_bit % 2;
+       FAPI_DBG("Address %d BA/BG/CMD %d parity %d O/E %d - cke,cs,odt starts - %d,%d,%d",data_buffer.getNumBitsSet(0,16),data_buffer.getNumBitsSet(17,7),parity_bit,parity_bit_even,cke_start,cs_start,odt_start);
+       rc_num = rc_num | data_buffer.insertFromRight( parity_bit_even, 60, 1);
+    }
+    
     if (rc_num)
     {
         FAPI_ERR( "mss_ccs_inst_arry_0: Error setting up buffers");
         rc_buff.setEcmdError(rc_num);
         return rc_buff;
     }
-
+    
     rc = fapiPutScom(i_target, reg_address, data_buffer);
 
     return rc;
@@ -488,7 +554,10 @@ ReturnCode mss_ccs_load_data_pattern(
 
     if (io_instruction_number > 31)
     {
-        FAPI_INF("mss_ccs_load_data_pattern: CCS Instruction Array index out of bounds");
+        FAPI_ERR("mss_ccs_load_data_pattern: CCS Instruction Array index out of bounds");
+	const uint32_t INDEX_VALUE = io_instruction_number;
+	FAPI_SET_HWP_ERROR(rc, RC_MSS_CCS_INDEX_OUT_OF_BOUNDS);
+        return rc;
     }
     else
     {
@@ -551,6 +620,19 @@ ReturnCode mss_ccs_mode(
     rc_num = rc_num | data_buffer.insert( i_resetn, 24, 1, 0);
     rc_num = rc_num | data_buffer.insert( i_reset_recover, 25, 1, 0);
     rc_num = rc_num | data_buffer.insert( i_copy_spare_cke, 26, 1, 0);
+    
+    uint8_t dimm_type;
+    uint8_t dram_gen = 0;
+
+    rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_GEN, &i_target, dram_gen);
+    if(rc) return rc;
+    rc = FAPI_ATTR_GET(ATTR_EFF_DIMM_TYPE, &i_target, dimm_type);
+    if(rc) return rc;
+    
+    //if in DDR4 mode, count the parity bit and set it
+    if((dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR4) && (dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM || dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_RDIMM) ) {
+       rc_num = rc_num | data_buffer.insertFromRight( (uint8_t)0xff, 61, 1);
+    }
 
     if (rc_num)
     {
@@ -582,12 +664,12 @@ ReturnCode mss_ccs_start_stop(
     if (i_start_stop == MSS_CCS_START)
     {
         rc_num = rc_num | data_buffer.setBit(0,1);
-        FAPI_INF(" Executing contents of CCS." );
+        FAPI_DBG(" Executing contents of CCS." );
     }
     else if (i_start_stop == MSS_CCS_STOP)
     {
         rc_num = rc_num | data_buffer.setBit(1,1);
-        FAPI_INF(" Halting execution of the CCS." );
+        FAPI_DBG(" Halting execution of the CCS." );
     }
 
     if (rc_num)
@@ -723,7 +805,7 @@ ReturnCode mss_execute_ccs_inst_array(
     }
     else if (status == MSS_STAT_QUERY_PASS)
     {
-        FAPI_INF("CCS Executed Successfully.");
+        FAPI_DBG("CCS Executed Successfully.");
     }
     else
     {
@@ -963,6 +1045,11 @@ ReturnCode mss_execute_zq_cal(
 
     rc_num = rc_num | data_buffer_64.insert(stop_on_err_buffer_1, 0, 1, 0);
     rc_num = rc_num | data_buffer_64.insert(resetn_buffer_1, 24, 1, 0);
+    //if in DDR4 mode, count the parity bit and set it
+    if((dram_gen == ENUM_ATTR_EFF_DRAM_GEN_DDR4) && (dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_LRDIMM || dimm_type == fapi::ENUM_ATTR_EFF_DIMM_TYPE_RDIMM) ) {
+       rc_num = rc_num | data_buffer_64.insertFromRight( (uint8_t)0xff, 61, 1);
+    }
+    
     if(rc_num)
     {
         rc.setEcmdError(rc_num);
diff --git a/src/usr/hwpf/hwp/dram_training/mss_lrdimm_funcs/mss_lrdimm_ddr4_funcs.H b/src/usr/hwpf/hwp/dram_training/mss_lrdimm_funcs/mss_lrdimm_ddr4_funcs.H
index 8025af4..3525e3c 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_lrdimm_funcs/mss_lrdimm_ddr4_funcs.H
+++ b/src/usr/hwpf/hwp/dram_training/mss_lrdimm_funcs/mss_lrdimm_ddr4_funcs.H
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2014                             */
+/* Contributors Listed Below - COPYRIGHT 2014,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_lrdimm_ddr4_funcs.H,v 1.1 2014/03/14 16:05:51 kcook Exp $
+// $Id: mss_lrdimm_ddr4_funcs.H,v 1.3 2015/10/28 14:52:02 rwheeler Exp $
 //------------------------------------------------------------------------------
 // *! (C) Copyright International Business Machines Corp. 2013
 // *! All Rights Reserved -- Property of IBM
@@ -45,6 +45,7 @@
 //------------------------------------------------------------------------------
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|-----------------------------------------------
+//  1.3    | 10/28/15 |rwheeler | added the ddrphy_pc_config1 reg definition.
 //  1.1    | 03/14/14 | kcook   | First drop of Centaur
 
 #ifndef _MSS_LRDIMM_DDR4_FUNCS_H
@@ -66,6 +67,23 @@ const uint64_t DPHY23_DDRPHY_DP18_DATA_BIT_ENABLE1_P1_1_0x800104010301183F = 0x8
 const uint64_t DPHY23_DDRPHY_DP18_DATA_BIT_ENABLE1_P1_2_0x800108010301183F = 0x800108010301183Full;
 const uint64_t DPHY23_DDRPHY_DP18_DATA_BIT_ENABLE1_P1_3_0x80010C010301183F = 0x80010C010301183Full;
 const uint64_t DPHY23_DDRPHY_DP18_DATA_BIT_ENABLE1_P1_4_0x800110010301183F = 0x800110010301183Full;
+//
+const uint64_t DPHY23_DDRPHY_DP18_DATA_BIT_ENABLE0_P0_0_0x800000000301183F = 0x800000000301183Full;
+const uint64_t DPHY23_DDRPHY_DP18_DATA_BIT_ENABLE0_P0_1_0x800004000301183F = 0x800004000301183Full;
+const uint64_t DPHY23_DDRPHY_DP18_DATA_BIT_ENABLE0_P0_2_0x800008000301183F = 0x800008000301183Full;
+const uint64_t DPHY23_DDRPHY_DP18_DATA_BIT_ENABLE0_P0_3_0x80000C000301183F = 0x80000C000301183Full;
+const uint64_t DPHY23_DDRPHY_DP18_DATA_BIT_ENABLE0_P0_4_0x800010000301183F = 0x800010000301183Full;
+const uint64_t DPHY23_DDRPHY_DP18_DATA_BIT_ENABLE0_P1_0_0x800100000301183F = 0x800100000301183Full;
+const uint64_t DPHY23_DDRPHY_DP18_DATA_BIT_ENABLE0_P1_1_0x800104000301183F = 0x800104000301183Full;
+const uint64_t DPHY23_DDRPHY_DP18_DATA_BIT_ENABLE0_P1_2_0x800108000301183F = 0x800108000301183Full;
+const uint64_t DPHY23_DDRPHY_DP18_DATA_BIT_ENABLE0_P1_3_0x80010C000301183F = 0x80010C000301183Full;
+const uint64_t DPHY23_DDRPHY_DP18_DATA_BIT_ENABLE0_P1_4_0x800110000301183F = 0x800110000301183Full;
+//                                                                            
+const uint64_t DPHY01_DDRPHY_PC_CONFIG1_P0_0x8000C00D0301143F = 0x8000C00D0301143Full;
+const uint64_t DPHY01_DDRPHY_PC_CONFIG1_P1_0x8001C00D0301143F = 0x8001C00D0301143Full;
+const uint64_t DPHY23_DDRPHY_PC_CONFIG1_P0_0x8000C00D0301183F = 0x8000C00D0301183Full;
+const uint64_t DPHY23_DDRPHY_PC_CONFIG1_P1_0x8001C00D0301183F = 0x8001C00D0301183Full;
+
 //----------------------------------------------------------------------
 //  Enums 
 //----------------------------------------------------------------------
@@ -127,16 +145,13 @@ fapi::ReturnCode mss_store_db_delay(fapi::Target& i_target_mba, uint8_t i_mbaPos
 //--------------------------------------------------------------
 fapi::ReturnCode mss_step_delay_cw0(fapi::Target& i_target_mba, uint8_t i_port_number, uint8_t i_dimm_number, uint8_t i_rank_number,
 		uint8_t i_num_wr_rd, uint8_t o_nibble_delay[], uint8_t i_type, uint32_t& io_ccs_inst_cnt);
-
 //--------------------------------------------------------------
-// mss_step_delay_cw
-// Used in dram_write_leveling and mrep_training to step DB CW delay registers and query data bus
+// mss_step_delay_cw_tran
+// Used in training to step DB CW  delay register and query data bus (works for both 0->1 transtion and 1->0 transition)
 // Target = centaur.mba
 //--------------------------------------------------------------
-fapi::ReturnCode mss_step_delay_cw(fapi::Target& i_target_mba, uint32_t i_port_number, uint32_t i_dimm_number, uint32_t i_rank_number,
-                                   uint8_t i_cw_reg, uint8_t i_num_reads, uint8_t o_nibble_delay[],
-                                   uint32_t& io_ccs_inst_cnt);
-
+fapi::ReturnCode mss_step_delay_cw_tran(fapi::Target& i_target_mba, uint32_t i_port_number, uint32_t i_dimm_number, uint32_t i_rank_number,
+		                              uint8_t i_cw_reg, uint8_t i_num_wr_rd, uint8_t o_nibble_delay[], uint8_t i_type, uint32_t& io_ccs_inst_cnt);
 //--------------------------------------------------------------
 // mss_mr1_wr_lvl  
 // Send MR1 command to set DRAM to write leveling mode or normal mode
@@ -145,8 +160,6 @@ fapi::ReturnCode mss_step_delay_cw(fapi::Target& i_target_mba, uint32_t i_port_n
 fapi::ReturnCode mss_mr1_wr_lvl(fapi::Target& i_target_mba, uint32_t i_port_number,
                                 uint8_t wr_lvl, uint32_t& io_ccs_inst_cnt);
 
-
-
 //--------------------------------------------------------------
 // mss_mrep_training
 // Conducts MDQ Receive Enable Phase Training between DB and DRAM
@@ -154,6 +167,44 @@ fapi::ReturnCode mss_mr1_wr_lvl(fapi::Target& i_target_mba, uint32_t i_port_numb
 //--------------------------------------------------------------
 fapi::ReturnCode mss_mrep_training( fapi::Target& i_target_mba, uint32_t i_port_number);
 //--------------------------------------------------------------
+// mss_db_mpr
+// Write the db Multi purpose register (mpr)
+// Target = centaur.mba
+//--------------------------------------------------------------
+fapi::ReturnCode mss_db_mpr( fapi::Target& i_target_mba, uint8_t i_port_number, uint8_t i_pattern, uint32_t& io_ccs_inst_cnt);
+
+
+//--------------------------------------------------------------
+// mss_custom_DB_MPR_pattern
+// custom db mpr pattern
+// Target = centaur.mba
+//--------------------------------------------------------------
+fapi::ReturnCode mss_custom_DB_MPR_pattern( fapi::Target& i_target_mba, uint8_t i_port_number);
+//--------------------------------------------------------------
+// mss_hostside_read_training_enable
+// enable bata buffer to Host Interface read training
+// Target = centaur.mba
+//--------------------------------------------------------------
+fapi::ReturnCode mss_hostside_read_training_enable( fapi::Target& i_target_mba, uint8_t i_port_number);
+//--------------------------------------------------------------
+// mss_hostside_read_training_disable
+// enable bata buffer to Host Interface read training
+// Target = centaur.mba
+//--------------------------------------------------------------
+fapi::ReturnCode mss_hostside_read_training_disable( fapi::Target& i_target_mba, uint8_t i_port_number);
+
+//--------------------------------------------------------------
+// disable Host Interface Write Leveling
+// Target = centaur.mba
+//--------------------------------------------------------------
+fapi::ReturnCode mss_hwl_training_disable( fapi::Target& i_target_mba, uint8_t i_port_number);
+//--------------------------------------------------------------
+// mss_hwl_training_enable
+// enable Host Interface Write Leveling
+// Target = centaur.mba
+//--------------------------------------------------------------
+fapi::ReturnCode mss_hwl_training_enable( fapi::Target& i_target_mba, uint8_t i_port_number);
+//--------------------------------------------------------------
 // mss_mxd_training
 // Conducts MRD or MWD coarse, normal, or find training. Still in development
 // Target = centaur.mba
@@ -169,6 +220,33 @@ fapi::ReturnCode mss_add_rdmpr( fapi::Target& i_target_mba,
                                uint32_t& io_ccs_inst_cnt);
 
 //--------------------------------------------------------------
+// mss_add_nop 
+// Adds read command without activate to ccs
+// Target = centaur.mba
+//--------------------------------------------------------------
+fapi::ReturnCode mss_add_nop( fapi::Target& i_target_mba, 
+                               uint32_t i_port_number, uint32_t dimm_number, uint32_t repeat_number,
+                               uint32_t& io_ccs_inst_cnt);
+
+//--------------------------------------------------------------
+// mss_add_act_write 
+// Adds write command with activate to ccs
+// Target = centaur.mba
+//--------------------------------------------------------------
+fapi::ReturnCode mss_add_act_write( fapi::Target& i_target_mba, 
+                                    uint32_t i_port_number, uint32_t dimm_number, uint32_t rank_number, uint32_t i_address,
+                                    uint32_t& io_ccs_inst_cnt);
+
+//--------------------------------------------------------------
+// mss_add_act_read 
+// Adds write command with activate to ccs
+// Target = centaur.mba
+//--------------------------------------------------------------
+fapi::ReturnCode mss_add_act_read( fapi::Target& i_target_mba, 
+                                    uint32_t i_port_number, uint32_t dimm_number, uint32_t rank_number, uint32_t i_address,
+                                    uint32_t& io_ccs_inst_cnt);
+
+//--------------------------------------------------------------
 // mss_mpr_operation
 // Sets MR3 command to MPR data flow or normal data flow
 // Target = centaur.mba
@@ -182,11 +260,17 @@ fapi::ReturnCode mss_mpr_operation( fapi::Target& i_target_mba, uint32_t i_port_
 // Sets force_fifo_capture bit in rd_dia_config5 registers to Force DQ capture or normal operation
 // Target = centaur.mba
 //--------------------------------------------------------------
-fapi::ReturnCode mss_force_fifo_capture(fapi::Target& i_target_centaur, uint8_t i_mbaPosition, 
-                                        uint32_t i_port_number,
-                            uint32_t force_fifo);
+fapi::ReturnCode mss_force_fifo_capture( fapi::Target& i_target_centaur, uint8_t i_mbaPosition, 
+                                        uint32_t i_port_number, uint32_t force_fifo);
 
 //--------------------------------------------------------------
+// mss_force_fifo_reliability
+// Sets loopback_fix_en bit in rd_dia_config5(bit 60) registers to reset the fifo pointers 
+// Target = centaur.mba
+//--------------------------------------------------------------
+fapi::ReturnCode mss_force_fifo_reliability( fapi::Target& i_target_centaur, uint8_t i_mbaPosition,
+                                            uint32_t i_port_number, uint32_t reliability);
+//--------------------------------------------------------------
 // mss_data_bit_set
 // Sets single DQ byte or all DQ bytes to 0 or 1 through DATA_BIT_DIR registers. 
 // Used with DFT_FORCE_OUTPUT during PBA mode
@@ -206,7 +290,15 @@ fapi::ReturnCode mss_dft_force_outputs(fapi::Target& i_target_centaur, uint8_t i
                             uint32_t force_outputs);
 
 //--------------------------------------------------------------
+// mss_dq_outputs
+// Sets DQ OUTPUTS enable bit to 0 or 1 to control DQ bus during MWD mode
+// Target = centaur.mba
+//--------------------------------------------------------------
+fapi::ReturnCode mss_dq_outputs(fapi::Target& i_target_centaur, uint8_t i_mbaPosition, 
+                                        uint32_t i_port_number,
+                            uint32_t force_outputs);
 
+//--------------------------------------------------------------
 
 
 
diff --git a/src/usr/hwpf/hwp/dram_training/mss_lrdimm_funcs/mss_lrdimm_funcs.C b/src/usr/hwpf/hwp/dram_training/mss_lrdimm_funcs/mss_lrdimm_funcs.C
index 499b1e8..fa49aac 100644
--- a/src/usr/hwpf/hwp/dram_training/mss_lrdimm_funcs/mss_lrdimm_funcs.C
+++ b/src/usr/hwpf/hwp/dram_training/mss_lrdimm_funcs/mss_lrdimm_funcs.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2013,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2013,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_lrdimm_funcs.C,v 1.10 2015/03/16 21:37:44 jdsloat Exp $
+// $Id: mss_lrdimm_funcs.C,v 1.11 2015/11/09 17:22:07 sglancy Exp $
 //------------------------------------------------------------------------------
 // *! (C) Copyright International Business Machines Corp. 2013
 // *! All Rights Reserved -- Property of IBM
@@ -42,6 +42,7 @@
 //------------------------------------------------------------------------------
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|-----------------------------------------------
+//  1.11   | sglancy  |03-NOV-15| Fixed attribute names for DDR4 RDIMM
 //  1.10   | jdsloat  |16-MAR-15| Fixed 2 declarations of ecmddatabuffer to ecmddatabufferbase
 //  1.8    | kcook    |13-FEB-14| More FW updates.
 //  1.7    | kcook    |12-FEB-14| Updated HWP_ERROR per RAS review to be used with memory_mss_lrdimm_funcs.xml
@@ -598,7 +599,7 @@ fapi::ReturnCode mss_lrdimm_mrs_load( fapi::Target& i_target , uint32_t i_port_n
         if(rc) return rc;
         rc = FAPI_ATTR_GET(ATTR_EFF_DIMM_RCD_CNTL_WORD_0_15, &i_target, rcd_array);
         if(rc) return rc;
-        rc = FAPI_ATTR_GET(ATTR_VPD_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
+        rc = FAPI_ATTR_GET(ATTR_EFF_DRAM_ADDRESS_MIRRORING, &i_target, address_mirror_map);
         if(rc) return rc;
         rc = FAPI_ATTR_GET(ATTR_IS_SIMULATION, NULL, is_sim);
         if(rc) return rc;
diff --git a/src/usr/hwpf/hwp/initfiles/cen_ddrphy.initfile b/src/usr/hwpf/hwp/initfiles/cen_ddrphy.initfile
index f83b959..fcffca8 100644
--- a/src/usr/hwpf/hwp/initfiles/cen_ddrphy.initfile
+++ b/src/usr/hwpf/hwp/initfiles/cen_ddrphy.initfile
@@ -1,4 +1,4 @@
-#-- $Id: cen_ddrphy.initfile,v 1.37 2015/11/16 17:07:27 dcrowell Exp $
+#-- $Id: cen_ddrphy.initfile,v 1.39 2015/12/10 21:57:02 sglancy Exp $
 #-- $Source: /afs/awd/projects/eclipz/KnowledgeBase/.cvsroot/eclipz/chips/
 #--          centaur/working/procedures/ec_ind/scoms/cen_ddrphy.initfile,v $
 #
@@ -6,6 +6,8 @@
 #--------------------------------------------------------------------------------
 #-- Version:|Author: | Date:  | Comment:
 #-- --------|--------|--------|--------------------------------------------------
+#  1.39     |sglancy |12/10/15| Updated to stop DDR3 RDIMM bug
+#  1.38     |jneaton |12/09/15| Changed DPHY01_DDRPHY_PC_CSID_CFG_P0 to 0x00 to support tsv_ddr4
 #  1.37     |dcrowell|11/16/15| Fix typo from v1.36 
 #  1.36     |dcrowell|09/23/15| Redefined interpretation of VPD_VERSION attribute 
 #  1.35     |asaetow |05/28/14| Removed v1.34 from working since we will not be GAing with those settings.
@@ -186,6 +188,10 @@ define def_val_qrg3_p1	= (ATTR_EFF_QUATERNARY_RANK_GROUP3[1] != ENUM_ATTR_EFF_QU
 # shorter test for DRAM gen
 #define def_is_empty	=	(ATTR_EFF_DRAM_GEN == ENUM_ATTR_EFF_DRAM_GEN_EMPTY)	;	# EMPTY, no dram?
 define def_is_ddr3	=	(ATTR_EFF_DRAM_GEN == ENUM_ATTR_EFF_DRAM_GEN_DDR3)	;	# DDR3 = 1
+define def_is_tsv_ddr4_p0	=	((ATTR_EFF_STACK_TYPE[0][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) && (ATTR_EFF_DRAM_GEN == ENUM_ATTR_EFF_DRAM_GEN_DDR4))	;	# DDR4 and tsv_ddr4
+define def_is_tsv_ddr4_p1	=	((ATTR_EFF_STACK_TYPE[1][0] == ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) && (ATTR_EFF_DRAM_GEN == ENUM_ATTR_EFF_DRAM_GEN_DDR4))	;	# DDR4 and tsv_ddr4
+define def_not_tsv_ddr4_p0	=	((ATTR_EFF_STACK_TYPE[0][0] != ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) || (ATTR_EFF_DRAM_GEN != ENUM_ATTR_EFF_DRAM_GEN_DDR4))	;	# DDR4 and tsv_ddr4
+define def_not_tsv_ddr4_p1	=	((ATTR_EFF_STACK_TYPE[1][0] != ENUM_ATTR_EFF_STACK_TYPE_STACK_3DS) || (ATTR_EFF_DRAM_GEN != ENUM_ATTR_EFF_DRAM_GEN_DDR4))	;	# DDR4 and tsv_ddr4
 define def_is_ddr4	=	(ATTR_EFF_DRAM_GEN == ENUM_ATTR_EFF_DRAM_GEN_DDR4)	;	# DDR4 = 2
 define def_not_ddr4	=	(ATTR_EFF_DRAM_GEN != ENUM_ATTR_EFF_DRAM_GEN_DDR4)	;	# not DDR4, (GEN != 2)
 
@@ -2795,7 +2801,7 @@ scom 0x8001c4010301143f {
 # 	ODT Default Configuration Register
 #
 # Determines the ODT values sent to all ranks during MRS commands
-# basically used when ODT pins used as CID (chip ID) for TSV DIMMs...
+# basically used when ODT pins used as CID (chip ID) for tsv_ddr4 DIMMs...
 #
 # DDRPHY_SEQ_ODT_DEFAULT_CONFIG		SEQ 0x024	0x...
 #
@@ -2944,19 +2950,28 @@ scom 0x8001C40D0301143F {
 # PHYW.PHYX.SYNTHX.D3SIDEA.PCX.REG28_RP0_L2
 
 # ---------------------------------------------------------------------------------------
-# PC Chip select ID configuration register	default=0		NEED to be programmed for DDR4/TSV dimms.
+# PC Chip select ID configuration register	default=0		NEED to be programmed for DDR4/tsv_ddr4 dimms.
 # 															HERE MW
 #
 # This register controls the value of Chip Select (CS) signals not selected
-# by any of the PC Rank Pair registers during initial calibration for DDR4 / TSV dimms.
+# by any of the PC Rank Pair registers during initial calibration for DDR4 / tsv_ddr4 dimms.
 #
 # DPHY01_DDRPHY_PC_CSID_CFG_P0		0x033	0x8000c0330301143f
 # PHYW.PHYX.SYNTHX.D3SIDEA.PCX.REG51_L2
-scom 0x800(0,1)c0330301143f {
-	bits	,	scom_data			;
-#	0:47	,	0x000000000000		;	# reserved
-	48:55	,	0xFF				;	# CS[0:7] level
-	56:63	,	0x00				;	# reserved
+scom 0x8000c0330301143f {
+	bits	,	scom_data	, expr		;
+#	0:47	,	0x000000000000	, any	;	# reserved
+	48:55	,	0x00		, def_is_tsv_ddr4_p0	;	# CS[0:7] level
+	48:55	,	0xff		, any	;	# CS[0:7] level
+	56:63	,	0x00		, any		;	# reserved
+}
+
+scom 0x8001c0330301143f {
+	bits	,	scom_data	, expr		;
+#	0:47	,	0x000000000000	, any	;	# reserved
+	48:55	,	0x00		, def_is_tsv_ddr4_p1	;	# CS[0:7] level
+	48:55	,	0xff		, any	;	# CS[0:7] level
+	56:63	,	0x00		, any		;	# reserved
 }
 
 # ---------------------------------------------------------------------------------------
diff --git a/src/usr/hwpf/hwp/lab_dimm_spd_attributes.xml b/src/usr/hwpf/hwp/lab_dimm_spd_attributes.xml
index 8e4af3c..2f3ad77 100755
--- a/src/usr/hwpf/hwp/lab_dimm_spd_attributes.xml
+++ b/src/usr/hwpf/hwp/lab_dimm_spd_attributes.xml
@@ -5,7 +5,7 @@
 <!--                                                                        -->
 <!-- OpenPOWER HostBoot Project                                             -->
 <!--                                                                        -->
-<!-- Contributors Listed Below - COPYRIGHT 2014,2015                        -->
+<!-- Contributors Listed Below - COPYRIGHT 2014,2016                        -->
 <!-- [+] International Business Machines Corp.                              -->
 <!--                                                                        -->
 <!--                                                                        -->
@@ -22,7 +22,7 @@
 <!-- permissions and limitations under the License.                         -->
 <!--                                                                        -->
 <!-- IBM_PROLOG_END_TAG                                                     -->
-<!-- $Id: lab_dimm_spd_attributes.xml,v 1.25 2015/09/28 12:09:12 mklight Exp $ -->
+<!-- $Id: lab_dimm_spd_attributes.xml,v 1.28 2015/12/16 13:18:44 sasethur Exp $ -->
 <!-- XML file specifying DIMM SPD attributes used by HW Procedures. -->
 <attributes>
 
@@ -400,11 +400,10 @@ The following attributes can be queried from both DDR3 and DDR4 DIMMs
     <targetType>TARGET_TYPE_DIMM</targetType>
     <description>
         SDRAM Device Type Die Count.
-        Located in DDR3 SPD byte 33, bits 6-4.
         Located in DDR4 SPD byte 6, bit 6-4.
     </description>
     <valueType>uint8</valueType>
-    <enum>DIE1 = 0x00, DIE2 = 0x01, DIE4 = 0x02, DIE8 = 0x03</enum>
+   <enum>DIE1 = 0x00, DIE2 = 0x01, DIE3 = 0x02, DIE4 = 0x03,DIE5 = 0x04,DIE6 = 0x05,DIE7 = 0x06,DIE8 = 0x07</enum>
     <platInit/>
 </attribute>
 
@@ -1868,7 +1867,11 @@ consumer: various
 firmware notes: none
 This is the nominal value
 This is for DDR4
-The value is from 0 to 50</description>
+The value is a decode that is passed into ATTR_EFF_VREF_DQ_TRAIN_RANGE and ATTR_EFF_VREF_DQ_TRAIN_VALUE:
+Decode: (R for Range V for Value, blank for unused)
+ WRDDR4_VREF Bits 01234567  
+        Attr Name  RVVVVVV
+        Attr Bits  0543210</description>
     <valueType>uint8</valueType>
     <platInit/>
     <writeable/>
diff --git a/src/usr/hwpf/hwp/mc_config/mss_eff_config/memory_mss_eff_config_rank_group.xml b/src/usr/hwpf/hwp/mc_config/mss_eff_config/memory_mss_eff_config_rank_group.xml
index b229cf1..7fb5971 100644
--- a/src/usr/hwpf/hwp/mc_config/mss_eff_config/memory_mss_eff_config_rank_group.xml
+++ b/src/usr/hwpf/hwp/mc_config/mss_eff_config/memory_mss_eff_config_rank_group.xml
@@ -5,7 +5,9 @@
 <!--                                                                        -->
 <!-- OpenPOWER HostBoot Project                                             -->
 <!--                                                                        -->
-<!-- COPYRIGHT International Business Machines Corp. 2013,2014              -->
+<!-- Contributors Listed Below - COPYRIGHT 2013,2016                        -->
+<!-- [+] International Business Machines Corp.                              -->
+<!--                                                                        -->
 <!--                                                                        -->
 <!-- Licensed under the Apache License, Version 2.0 (the "License");        -->
 <!-- you may not use this file except in compliance with the License.       -->
@@ -20,7 +22,7 @@
 <!-- permissions and limitations under the License.                         -->
 <!--                                                                        -->
 <!-- IBM_PROLOG_END_TAG                                                     -->
-<!-- $Id: memory_mss_eff_config_rank_group.xml,v 1.2 2014/04/01 17:06:22 asaetow Exp $ -->
+<!-- $Id: memory_mss_eff_config_rank_group.xml,v 1.3 2015/06/15 20:19:26 asaetow Exp $ -->
 <!-- For file ../../ipl/fapi/mss_eff_config_rank_group.C -->
 <!-- // *! OWNER NAME  : Anuwat Saetow     Email: asaetow@us.ibm.com -->
 <!-- // *! BACKUP NAME : Mark Bellows      Email: bellows@us.ibm.com -->
@@ -39,12 +41,18 @@
 	</callout>
 	
 	<callout>
-		<target>TARGET_MBA</target>
+        <childTargets>
+        <parent>TARGET_MBA</parent>
+        <childType>TARGET_TYPE_DIMM</childType>
+        </childTargets>
 		<priority>MEDIUM</priority>
 	</callout>
 	
 	<deconfigure>
-		<target>TARGET_MBA</target>
+        <childTargets>
+        <parent>TARGET_MBA</parent>
+        <childType>TARGET_TYPE_DIMM</childType>
+        </childTargets>
 	</deconfigure>
 </hwpError>
 
@@ -60,12 +68,18 @@
 	</callout>
 
 	<callout>
-		<target>TARGET_MBA</target>
+        <childTargets>
+        <parent>TARGET_MBA</parent>
+        <childType>TARGET_TYPE_DIMM</childType>
+        </childTargets>
 		<priority>MEDIUM</priority>
 	</callout>	
 
 	<deconfigure>
-		<target>TARGET_MBA</target>
+        <childTargets>
+        <parent>TARGET_MBA</parent>
+        <childType>TARGET_TYPE_DIMM</childType>
+        </childTargets>
 	</deconfigure>
 </hwpError>
 
@@ -81,12 +95,18 @@
 	</callout>
 
 	<callout>
-		<target>TARGET_MBA</target>
+        <childTargets>
+        <parent>TARGET_MBA</parent>
+        <childType>TARGET_TYPE_DIMM</childType>
+        </childTargets>
 		<priority>MEDIUM</priority>
 	</callout>	
 
 	<deconfigure>
-		<target>TARGET_MBA</target>
+        <childTargets>
+        <parent>TARGET_MBA</parent>
+        <childType>TARGET_TYPE_DIMM</childType>
+        </childTargets>
 	</deconfigure>
 </hwpError>
 <!-- *********************************************************************** -->
diff --git a/src/usr/hwpf/hwp/mc_config/mss_eff_config/memory_mss_eff_config_termination.xml b/src/usr/hwpf/hwp/mc_config/mss_eff_config/memory_mss_eff_config_termination.xml
index 9f3c89c..85c071f 100644
--- a/src/usr/hwpf/hwp/mc_config/mss_eff_config/memory_mss_eff_config_termination.xml
+++ b/src/usr/hwpf/hwp/mc_config/mss_eff_config/memory_mss_eff_config_termination.xml
@@ -5,7 +5,9 @@
 <!--                                                                        -->
 <!-- OpenPOWER HostBoot Project                                             -->
 <!--                                                                        -->
-<!-- COPYRIGHT International Business Machines Corp. 2013,2014              -->
+<!-- Contributors Listed Below - COPYRIGHT 2013,2016                        -->
+<!-- [+] International Business Machines Corp.                              -->
+<!--                                                                        -->
 <!--                                                                        -->
 <!-- Licensed under the Apache License, Version 2.0 (the "License");        -->
 <!-- you may not use this file except in compliance with the License.       -->
@@ -20,7 +22,7 @@
 <!-- permissions and limitations under the License.                         -->
 <!--                                                                        -->
 <!-- IBM_PROLOG_END_TAG                                                     -->
-<!-- $Id: memory_mss_eff_config_termination.xml,v 1.2 2014/04/07 23:02:10 lapietra Exp $ -->
+<!-- $Id: memory_mss_eff_config_termination.xml,v 1.3 2015/05/27 20:02:29 asaetow Exp $ -->
 <!-- For file ../../ipl/fapi/mss_eff_config_termination.C -->
 <!-- // *! OWNER NAME  : Dave Cadigan      Email: dcadiga@us.ibm.com -->
 <!-- // *! BACKUP NAME : Anuwat Saetow     Email: asaetow@us.ibm.com -->
@@ -195,9 +197,6 @@
         <target>TARGET_MBA</target>
     </deconfigure>
 
-    <gard>
-        <target>TARGET_MBA</target>
-    </gard>
 </hwpError>
 
 <!-- *********************************************************************** -->
@@ -220,9 +219,6 @@
         <target>TARGET_MBA</target>
     </deconfigure>
 
-    <gard>
-        <target>TARGET_MBA</target>
-    </gard>
 </hwpError>
 <!-- *********************************************************************** -->
   <hwpError>
@@ -245,9 +241,6 @@
         <target>TARGET_MBA</target>
     </deconfigure>
 
-    <gard>
-        <target>TARGET_MBA</target>
-    </gard>
 </hwpError>
 
 <!-- *********************************************************************** -->
@@ -271,9 +264,6 @@
         <target>TARGET_MBA</target>
     </deconfigure>
 
-    <gard>
-        <target>TARGET_MBA</target>
-    </gard>
 </hwpError>
 
 <!-- *********************************************************************** -->
@@ -297,9 +287,6 @@
         <target>TARGET_MBA</target>
     </deconfigure>
 
-    <gard>
-        <target>TARGET_MBA</target>
-    </gard>
 </hwpError>
 
 <!-- *********************************************************************** -->
@@ -323,9 +310,6 @@
         <target>TARGET_MBA</target>
     </deconfigure>
 
-    <gard>
-        <target>TARGET_MBA</target>
-    </gard>
 </hwpError>
 
 <!-- *********************************************************************** -->
@@ -349,9 +333,6 @@
         <target>TARGET_MBA</target>
     </deconfigure>
 
-    <gard>
-        <target>TARGET_MBA</target>
-    </gard>
 </hwpError>
 
 <!-- *********************************************************************** -->
@@ -374,9 +355,6 @@
         <target>TARGET_MBA</target>
     </deconfigure>
 
-    <gard>
-        <target>TARGET_MBA</target>
-    </gard>
 </hwpError>
 
 <!-- *********************************************************************** -->
@@ -400,9 +378,6 @@
         <target>TARGET_MBA</target>
     </deconfigure>
 
-    <gard>
-        <target>TARGET_MBA</target>
-    </gard>
 </hwpError>
 
 <!-- *********************************************************************** -->
@@ -425,9 +400,6 @@
         <target>TARGET_MBA</target>
     </deconfigure>
 
-    <gard>
-        <target>TARGET_MBA</target>
-    </gard>
 </hwpError>
 
 <!-- *********************************************************************** -->
@@ -450,9 +422,6 @@
         <target>TARGET_MBA</target>
     </deconfigure>
 
-    <gard>
-        <target>TARGET_MBA</target>
-    </gard>
 </hwpError>
 
 <!-- *********************************************************************** -->
@@ -476,9 +445,6 @@
         <target>TARGET_MBA</target>
     </deconfigure>
 
-    <gard>
-        <target>TARGET_MBA</target>
-    </gard>
 </hwpError>
 
 <!-- *********************************************************************** -->
@@ -497,9 +463,6 @@
         <target>TARGET_MBA</target>
     </deconfigure>
 
-    <gard>
-        <target>TARGET_MBA</target>
-    </gard>
 </hwpError>
 
 <!-- *********************************************************************** -->
@@ -523,9 +486,6 @@
         <target>TARGET_MBA</target>
     </deconfigure>
 
-    <gard>
-        <target>TARGET_MBA</target>
-    </gard>
 </hwpError>
 <!-- *********************************************************************** -->
   <hwpError>
@@ -650,9 +610,6 @@
         <target>TARGET_MBA</target>
     </deconfigure>
 
-    <gard>
-        <target>TARGET_MBA</target>
-    </gard>
 </hwpError>
 
 <!-- *********************************************************************** -->
@@ -675,9 +632,6 @@
         <target>TARGET_MBA</target>
     </deconfigure>
 
-    <gard>
-        <target>TARGET_MBA</target>
-    </gard>
 </hwpError>
 
 <!-- *********************************************************************** -->
@@ -699,9 +653,6 @@
         <target>TARGET_MBA</target>
     </deconfigure>
 
-    <gard>
-        <target>TARGET_MBA</target>
-    </gard>
 </hwpError>
 
 
@@ -724,9 +675,6 @@
         <target>TARGET_MBA</target>
     </deconfigure>
 
-    <gard>
-        <target>TARGET_MBA</target>
-    </gard>
 </hwpError>
 
 <!-- *********************************************************************** -->
@@ -750,9 +698,6 @@
         <target>TARGET_MBA</target>
     </deconfigure>
 
-    <gard>
-        <target>TARGET_MBA</target>
-    </gard>
 </hwpError>
 
 <!-- *********************************************************************** -->
@@ -820,9 +765,6 @@
         <target>TARGET_MBA</target>
     </deconfigure>
 
-    <gard>
-        <target>TARGET_MBA</target>
-    </gard>
 </hwpError>
 
 <!-- *********************************************************************** -->
@@ -845,9 +787,6 @@
         <target>TARGET_MBA</target>
     </deconfigure>
 
-    <gard>
-        <target>TARGET_MBA</target>
-    </gard>
 </hwpError>
 
 </hwpErrors>
diff --git a/src/usr/hwpf/hwp/mc_config/mss_eff_config/mss_eff_config.C b/src/usr/hwpf/hwp/mc_config/mss_eff_config/mss_eff_config.C
index d23db0c..48dc186 100644
--- a/src/usr/hwpf/hwp/mc_config/mss_eff_config/mss_eff_config.C
+++ b/src/usr/hwpf/hwp/mc_config/mss_eff_config/mss_eff_config.C
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_eff_config.C,v 1.67 2016/01/13 15:55:46 sglancy Exp $
+// $Id: mss_eff_config.C,v 1.68 2016/01/19 23:38:13 rwheeler Exp $
 // $Source: /afs/awd/projects/eclipz/KnowledgeBase/.cvsroot/eclipz/chips/
 //          centaur/working/procedures/ipl/fapi/mss_eff_config.C,v $
 //------------------------------------------------------------------------------
@@ -45,6 +45,7 @@
 //------------------------------------------------------------------------------
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|-----------------------------------------------
+//   1.68  | rwheeler |19-JAN-16| Added support for the kg4 card type.
 //   1.67  | sglancy  |13-JAN-16| Added RC checks and fixed white space issues
 //   1.66  | preeragh |18-DEC-15| Change ATTR_EFF_TEMP_REF_MODE to Disable by default. SW331045
 //   1.65  | preeragh |16-DEC-15| Updated DIE Count Enums
@@ -2635,6 +2636,8 @@ FAPI_DBG("DDR4 Check:  SPD=0x%x, p_i_tFAWmin (nCK) = %i",
                   p_o_atts->eff_ibm_type[l_cur_mba_port][l_cur_mba_dimm] = fapi::ENUM_ATTR_EFF_IBM_TYPE_TYPE_1B;
                } else if (p_o_atts->eff_num_ranks_per_dimm[l_cur_mba_port][l_cur_mba_dimm] == 4) {
                   p_o_atts->eff_ibm_type[l_cur_mba_port][l_cur_mba_dimm] = fapi::ENUM_ATTR_EFF_IBM_TYPE_TYPE_1D;
+               } else if (p_o_atts->eff_num_ranks_per_dimm[l_cur_mba_port][l_cur_mba_dimm] == 8) {
+                  p_o_atts->eff_ibm_type[l_cur_mba_port][l_cur_mba_dimm] = fapi::ENUM_ATTR_EFF_IBM_TYPE_TYPE_3A;
                } else {
                   p_o_atts->eff_ibm_type[l_cur_mba_port][l_cur_mba_dimm] = fapi::ENUM_ATTR_EFF_IBM_TYPE_UNDEFINED;
                   FAPI_ERR("Currently unsupported IBM_TYPE on %s!", i_target_mba.toEcmdString());
diff --git a/src/usr/hwpf/hwp/mc_config/mss_eff_config/mss_eff_config_termination.C b/src/usr/hwpf/hwp/mc_config/mss_eff_config/mss_eff_config_termination.C
index fa71f04..e078813 100644
--- a/src/usr/hwpf/hwp/mc_config/mss_eff_config/mss_eff_config_termination.C
+++ b/src/usr/hwpf/hwp/mc_config/mss_eff_config/mss_eff_config_termination.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2012,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2012,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_eff_config_termination.C,v 1.51 2015/09/04 18:16:24 thi Exp $
+// $Id: mss_eff_config_termination.C,v 1.54 2015/11/09 17:22:05 sglancy Exp $
 // $Source: /afs/awd/projects/eclipz/KnowledgeBase/.cvsroot/eclipz/chips/centaur/working/procedures/ipl/fapi/mss_eff_config_termination.C,v $
 //------------------------------------------------------------------------------
 // *! (C) Copyright International Business Machines Corp. 2011
@@ -44,6 +44,8 @@
 //------------------------------------------------------------------------------
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|-----------------------------------------------
+//   1.52  | sglancy  |03-NOV-15| Fixed attribute names for DDR4 RDIMM
+//   1.51  | sglancy  |10-Oct-15| Changed attribute names
 //   1.50  | sglancy  |28-Aug-15| Added RC checks - addressed FW comments
 //   1.49  | kmack    |05-Aug-15| Commented out FAPI_DDR4 code
 //   1.48  | asaetow  |01-OCT-14| Added setting for single-drop 4G1Rx8 and 16G2Rx4 from Ken/Anil for habanero at 1333Mbps under "rdimm_habanero_1333_r10_mba0", "rdimm_habanero_1333_r10_mba1", "rdimm_habanero_1333_r20_mba0", and "rdimm_habanero_1333_r20_mba1".
@@ -57,7 +59,7 @@
 //   1.41  | dcadiga  |13-JAN-14| Removed checking of dimm type attribute for CDIMM, replaced with custom dimm type attribute
 //   1.40  | bellows  |02-JAN-14| VPD attribute removal
 //   1.39  | bellows  |25-NOV-13| removed dimm spare temp, added using namespace fapi
-//   1.38  | dcadiga  |22-NOV-13| DDR4 ATTR_VREF_DQ_TRAIN_VALUE change for Menlo (0 to 16)
+//   1.38  | dcadiga  |22-NOV-13| DDR4 ATTR_EFF_VREF_DQ_TRAIN_VALUE change for Menlo (0 to 16)
 //   1.37  | dcadiga  |22-NOV-13| New Settings for RC/A and RC/C from Nov5/2013 Spreadsheet, DDR4 Enum Update
 //   1.36  | bellows  |19-SEP-13| Patched the AM keyword workaround.for >1 ranks
 //   1.35  | bellows  |16-SEP-13| Hostboot compile update.
@@ -1875,17 +1877,18 @@ extern "C" {
    uint8_t l_attr_tccd_l = 5;
 */
     uint8_t l_attr_eff_rtt_park[PORT_SIZE][DIMM_SIZE][RANK_SIZE];
-    uint8_t l_attr_vref_dq_train_value[PORT_SIZE][DIMM_SIZE][RANK_SIZE];
-    uint8_t l_attr_vref_dq_train_range[PORT_SIZE][DIMM_SIZE][RANK_SIZE];
-    uint8_t l_attr_vref_dq_train_enable[PORT_SIZE][DIMM_SIZE][RANK_SIZE];
+    uint8_t l_ATTR_EFF_VREF_DQ_TRAIN_value[PORT_SIZE][DIMM_SIZE][RANK_SIZE];
+    uint8_t l_ATTR_EFF_VREF_DQ_TRAIN_range[PORT_SIZE][DIMM_SIZE][RANK_SIZE];
+    uint8_t l_ATTR_EFF_VREF_DQ_TRAIN_enable[PORT_SIZE][DIMM_SIZE][RANK_SIZE];
 
     for( int l_port = 0; l_port < PORT_SIZE; l_port += 1 ) {
       for( int l_dimm = 0; l_dimm < DIMM_SIZE; l_dimm += 1 ) {
         for( int l_rank = 0; l_rank < RANK_SIZE; l_rank += 1 ) {
           l_attr_eff_rtt_park[l_port][l_dimm][l_rank] = 0;
-          l_attr_vref_dq_train_value[l_port][l_dimm][l_rank] = 16;
-          l_attr_vref_dq_train_range[l_port][l_dimm][l_rank] = 0;
-          l_attr_vref_dq_train_enable[l_port][l_dimm][l_rank] = ENUM_ATTR_VREF_DQ_TRAIN_ENABLE_DISABLE;
+          l_ATTR_EFF_VREF_DQ_TRAIN_value[l_port][l_dimm][l_rank] = 16;
+          l_ATTR_EFF_VREF_DQ_TRAIN_range[l_port][l_dimm][l_rank] = 0;
+          l_ATTR_EFF_VREF_DQ_TRAIN_enable[l_port][l_dimm][l_rank] = ENUM_ATTR_EFF_VREF_DQ_TRAIN_ENABLE_DISABLE;
+          FAPI_INF("AST:1 %d %d %d %d.", l_ATTR_EFF_VREF_DQ_TRAIN_value[l_port][l_dimm][l_rank], l_port, l_dimm, l_rank);
         }
       }
     }
@@ -2004,9 +2007,9 @@ extern "C" {
     rc = FAPI_ATTR_SET(ATTR_EFF_DATA_MASK, &i_target_mba, l_attr_eff_data_mask); if(rc) return rc;
     rc = FAPI_ATTR_SET(ATTR_EFF_WRITE_DBI, &i_target_mba, l_attr_eff_write_dbi); if(rc) return rc;
     rc = FAPI_ATTR_SET(ATTR_EFF_READ_DBI, &i_target_mba, l_attr_eff_read_dbi); if(rc) return rc;
-    rc = FAPI_ATTR_SET(ATTR_VREF_DQ_TRAIN_VALUE, &i_target_mba, l_attr_vref_dq_train_value); if(rc) return rc;
-    rc = FAPI_ATTR_SET(ATTR_VREF_DQ_TRAIN_RANGE, &i_target_mba, l_attr_vref_dq_train_range); if(rc) return rc;
-    rc = FAPI_ATTR_SET(ATTR_VREF_DQ_TRAIN_ENABLE, &i_target_mba, l_attr_vref_dq_train_enable); if(rc) return rc;
+    rc = FAPI_ATTR_SET(ATTR_EFF_VREF_DQ_TRAIN_VALUE, &i_target_mba, l_ATTR_EFF_VREF_DQ_TRAIN_value); if(rc) return rc;
+    rc = FAPI_ATTR_SET(ATTR_EFF_VREF_DQ_TRAIN_RANGE, &i_target_mba, l_ATTR_EFF_VREF_DQ_TRAIN_range); if(rc) return rc;
+    rc = FAPI_ATTR_SET(ATTR_EFF_VREF_DQ_TRAIN_ENABLE, &i_target_mba, l_ATTR_EFF_VREF_DQ_TRAIN_enable); if(rc) return rc;
    // rc = FAPI_ATTR_SET(ATTR_TCCD_L, &i_target_mba, l_attr_tccd_l); if(rc) return rc;
     FAPI_INF("Set some attributes, setting more\n");
 
@@ -2239,9 +2242,6 @@ extern "C" {
     const char * const PROCEDURE_NAME = "mss_eff_config_termination_vpd";
     FAPI_INF("*** Running %s on %s ... ***", PROCEDURE_NAME, i_target_mba.toEcmdString());
 
-   //for xml error usage
-   const fapi::Target& TARGET_MBA = i_target_mba;
-
     do {
       std::vector<fapi::Target> l_target_dimm_array;
       uint8_t spd_custom;
@@ -2353,8 +2353,8 @@ extern "C" {
         rc = FAPI_ATTR_SET(ATTR_VPD_CEN_SLEW_RATE_SPCKE,  &i_target_mba, attr_vpd_cen_slew_rate_spcke);
         if(rc) return rc;
 
-        uint8_t attr_vpd_dram_address_mirroring[2][2] = {{  0x00, 0x00 },{0x00, 0x00}};
-        rc = FAPI_ATTR_SET(ATTR_VPD_DRAM_ADDRESS_MIRRORING,  &i_target_mba, attr_vpd_dram_address_mirroring);
+        uint8_t ATTR_EFF_DRAM_ADDRESS_MIRRORING[2][2] = {{  0x00, 0x00 },{0x00, 0x00}};
+        rc = FAPI_ATTR_SET(ATTR_EFF_DRAM_ADDRESS_MIRRORING,  &i_target_mba, ATTR_EFF_DRAM_ADDRESS_MIRRORING);
         if(rc) return rc;
 
  ////////////////////////////////////////////////////////////////////////////////////////////
diff --git a/src/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttr.C b/src/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttr.C
index 499f225..bde281e 100644
--- a/src/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttr.C
+++ b/src/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttr.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2014,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2014,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: getMBvpdAttr.C,v 1.9 2015/10/06 15:17:45 dcrowell Exp $
+// $Id: getMBvpdAttr.C,v 1.11 2016/01/21 16:02:38 dcrowell Exp $
 /**
  *  @file getMBvpdAttr.C
  *
@@ -34,7 +34,6 @@
 //  fapi support
 #include    <fapi.H>
 #include    <getMBvpdAttr.H>
-#include    <getMBvpdVersion.H>
 
 // Used to ensure attribute enums are equal at compile time
 class Error_ConstantsDoNotMatch;
@@ -100,6 +99,8 @@ fapi::ReturnCode xlate_DRAM_RON (const fapi::AttributeId i_attr,
                                      uint8_t & io_value);
 fapi::ReturnCode xlate_RTT_NOM  (const fapi::AttributeId i_attr,
                                      uint8_t & io_value);
+fapi::ReturnCode xlate_RTT_PARK  (const fapi::AttributeId i_attr,
+                                     uint8_t & io_value);
 fapi::ReturnCode xlate_RTT_WR   (const fapi::AttributeId i_attr,
                                      uint8_t & io_value);
 fapi::ReturnCode xlate_WR_VREF  (const fapi::AttributeId i_attr,
@@ -425,7 +426,7 @@ fapi::ReturnCode getVersion  (const fapi::Target    & i_mbaTarget,
 
         if((l_fapirc == 0) && (!l_sizeMismatch))
         {
-            FAPI_DBG("getVersion:"
+            FAPI_DBG("getVersion:"
                      " returned vm data : 0x%x ",
                      l_vmVersionBuf.iv_version);
 
@@ -890,8 +891,7 @@ uint32_t getUint32 (const uint16_t & i_dataSpecial,
     }
     else
     {
-        memcpy(&o_val, i_pBuffer, sizeof(o_val));
-        o_val = FAPI_BE32TOH(o_val);
+        o_val  = FAPI_BE32TOH(*(uint32_t*) i_pBuffer);
     }
 
     return o_val;
@@ -1058,6 +1058,10 @@ fapi::ReturnCode returnValue (const MBvpdAttrDef*   i_pAttrDef,
                                 l_fapirc=xlate_RTT_NOM(i_pAttrDef->iv_attrId,
                                                                        l_value);
                                 break;
+                            case XLATE_RTT_PARK: // translate
+                                l_fapirc=xlate_RTT_PARK(i_pAttrDef->iv_attrId,
+                                                                       l_value);
+                                break;
                             case XLATE_RTT_WR: // translate
                                 l_fapirc=xlate_RTT_WR(i_pAttrDef->iv_attrId,
                                                                        l_value);
@@ -1315,6 +1319,61 @@ fapi::ReturnCode xlate_RTT_NOM (const fapi::AttributeId i_attr,
 }
 
 // ----------------------------------------------------------------------------
+// Translate vpd values to attribute enumeration for ATTR_VPD_DRAM_RTT_PARK
+// ----------------------------------------------------------------------------
+fapi::ReturnCode xlate_RTT_PARK (const fapi::AttributeId i_attr,
+                                         uint8_t & io_value)
+{
+    fapi::ReturnCode l_fapirc;
+    const uint8_t DRAM_RTT_PARK_DISABLE = 0x00;
+    const uint8_t DRAM_RTT_PARK_OHM34 = 0x07;
+    const uint8_t DRAM_RTT_PARK_OHM40 = 0x03;
+    const uint8_t DRAM_RTT_PARK_OHM48 = 0x85;
+    const uint8_t DRAM_RTT_PARK_OHM60 = 0x01;
+    const uint8_t DRAM_RTT_PARK_OHM80 = 0x06;
+    const uint8_t DRAM_RTT_PARK_OHM120 = 0x02;
+    const uint8_t DRAM_RTT_PARK_OHM240 = 0x84;
+
+    switch(io_value)
+    {
+    case DRAM_RTT_PARK_DISABLE:
+        io_value=fapi::ENUM_ATTR_VPD_DRAM_RTT_PARK_DISABLE;
+        break;
+    case DRAM_RTT_PARK_OHM34:
+        io_value = fapi::ENUM_ATTR_VPD_DRAM_RTT_PARK_34OHM;
+        break;
+    case DRAM_RTT_PARK_OHM40:
+        io_value = fapi::ENUM_ATTR_VPD_DRAM_RTT_PARK_40OHM;
+        break;
+    case DRAM_RTT_PARK_OHM48:
+        io_value = fapi::ENUM_ATTR_VPD_DRAM_RTT_PARK_48OHM;
+        break;
+    case DRAM_RTT_PARK_OHM60:
+        io_value = fapi::ENUM_ATTR_VPD_DRAM_RTT_PARK_60OHM;
+        break;
+    case DRAM_RTT_PARK_OHM80:
+        io_value = fapi::ENUM_ATTR_VPD_DRAM_RTT_PARK_80OHM;
+        break;
+    case DRAM_RTT_PARK_OHM120:
+        io_value = fapi::ENUM_ATTR_VPD_DRAM_RTT_PARK_120OHM;
+        break;
+    case DRAM_RTT_PARK_OHM240:
+        io_value = fapi::ENUM_ATTR_VPD_DRAM_RTT_PARK_240OHM;
+        break;
+    default:
+        FAPI_ERR("Unsupported VPD encode for ATTR_VPD_DRAM_RTT_PARK 0x%02x",
+                    io_value);
+        const fapi::AttributeId & ATTR_ID = i_attr;
+        const uint8_t  & VPD_VALUE = io_value;
+        FAPI_SET_HWP_ERROR(l_fapirc, RC_MBVPD_TERM_DATA_UNSUPPORTED_VPD_ENCODE);
+        break;
+    }
+
+    return  l_fapirc;
+}
+
+
+// ----------------------------------------------------------------------------
 // Translate vpd values to attribute enumeration for ATTR_VPD_DRAM_RTT_WR
 // ----------------------------------------------------------------------------
 fapi::ReturnCode xlate_RTT_WR (const fapi::AttributeId i_attr,
diff --git a/src/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttrData.C b/src/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttrData.C
index 27fd1d8..4653d49 100644
--- a/src/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttrData.C
+++ b/src/usr/hwpf/hwp/mvpd_accessors/getMBvpdAttrData.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2014,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2014,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -22,7 +22,7 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: getMBvpdAttrData.C,v 1.7 2015/09/30 20:44:12 janssens Exp $
+// $Id: getMBvpdAttrData.C,v 1.9 2015/11/02 21:42:23 sglancy Exp $
 /**
  *  @file getMBvpdAttrData.C
  *
@@ -61,11 +61,13 @@ const MBvpdAttrDef g_MBVPD_ATTR_DEF_array [] =
     {ATTR_VPD_MT_VERSION_BYTE,ALL_DIMM,VM_01,MBVPD_KEYWORD_MT,0,UINT8,0},
     {ATTR_VPD_MT_DATA_CONTROL_BYTE,ALL_DIMM,VM_01,MBVPD_KEYWORD_MT,1,UINT8,0},
     {ATTR_VPD_PERIODIC_MEMCAL_MODE_OPTIONS,ALL_DIMM,VM_01,MBVPD_KEYWORD_MR,50,UINT32_BY2|UINT16_DATA,0},
-    {ATTR_VPD_DRAM_RTT_PARK,ALL_DIMM,VM_01,MBVPD_KEYWORD_MT,10,UINT8_BY2_BY2_BY4|XLATE_RTT_WR,0},
+    {ATTR_VPD_DRAM_RTT_PARK,ALL_DIMM,VM_01,MBVPD_KEYWORD_MT,56,UINT8_BY2_BY2_BY4|XLATE_RTT_PARK,0},
     {ATTR_VPD_RD_CTR_WINDAGE_OFFSET,ALL_DIMM,VM_01,MBVPD_KEYWORD_MT,64,UINT32_BY2|UINT16_DATA,0},
 
-    {ATTR_VPD_DIMM_RCD_OUTPUT_TIMING,ALL_DIMM,VM_01,MBVPD_KEYWORD_MT,68,UINT8_BY2_BY2|DEFAULT_VALUE,0},
-    {ATTR_VPD_DIMM_RCD_IBT,ALL_DIMM,VM_01,MBVPD_KEYWORD_MT,66,UINT32_BY2_BY2|DEFAULT_VALUE,0},
+    {ATTR_VPD_DIMM_RCD_OUTPUT_TIMING,ISDIMM,VM_01,MBVPD_KEYWORD_MT,68,UINT8_BY2_BY2|BOTH_DIMMS,0},
+    {ATTR_VPD_DIMM_RCD_IBT,ISDIMM,VM_01,MBVPD_KEYWORD_MT,66,UINT32_BY2_BY2|UINT8_DATA,0},
+    {ATTR_VPD_DIMM_RCD_OUTPUT_TIMING,CDIMM,VM_01,MBVPD_KEYWORD_MT,68,UINT8_BY2_BY2|DEFAULT_VALUE,0},
+    {ATTR_VPD_DIMM_RCD_IBT,CDIMM,VM_01,MBVPD_KEYWORD_MT,66,UINT32_BY2_BY2|DEFAULT_VALUE,0},
     {ATTR_VPD_CEN_RD_VREF,ALL_DIMM,VM_01,MBVPD_KEYWORD_MT,34,UINT32_BY2|UINT8_DATA|XLATE_RD_VREF,0},
     {ATTR_VPD_DRAM_WR_VREF,ALL_DIMM,VM_01,MBVPD_KEYWORD_MT,35,UINT32_BY2|UINT8_DATA|XLATE_WR_VREF,0},
     {ATTR_VPD_DRAM_WRDDR4_VREF,ALL_DIMM,VM_01,MBVPD_KEYWORD_MT,36,UINT8_BY2,0},
diff --git a/src/usr/hwpf/hwp/mvpd_accessors/getMBvpdSpareDramData.C b/src/usr/hwpf/hwp/mvpd_accessors/getMBvpdSpareDramData.C
index e81334d..ac86943 100644
--- a/src/usr/hwpf/hwp/mvpd_accessors/getMBvpdSpareDramData.C
+++ b/src/usr/hwpf/hwp/mvpd_accessors/getMBvpdSpareDramData.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2013,2015                        */
+/* Contributors Listed Below - COPYRIGHT 2013,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
-- 
1.8.2.2

