From 6212cee695505c4e9f2240d23b621de7032eca5f Mon Sep 17 00:00:00 2001
From: Bill Schwartz <whs@us.ibm.com>
Date: Mon, 8 Feb 2016 14:56:26 -0600
Subject: [PATCH] Support 130W Turismo Parts

Restrict all processors to 2000 MHZ when a low power part is discovered.

Change-Id: Ie672e04646f8877abd203d23fe712ea5a23f3c61
RTC: 142598
---
 src/include/usr/sbe/sbereasoncodes.H               |   2 +
 src/usr/hwpf/hwp/mc_config/mc_config.C             |  37 ++-
 src/usr/sbe/sbe_update.C                           | 297 +++++++++++++++++++--
 src/usr/sbe/sbe_update.H                           |  10 +-
 .../common/xmltohb/attribute_types_hb.xml          |  18 ++
 .../targeting/common/xmltohb/target_types_hb.xml   |   1 +
 6 files changed, 337 insertions(+), 28 deletions(-)

diff --git a/src/include/usr/sbe/sbereasoncodes.H b/src/include/usr/sbe/sbereasoncodes.H
index aae931b..9dcf520 100644
--- a/src/include/usr/sbe/sbereasoncodes.H
+++ b/src/include/usr/sbe/sbereasoncodes.H
@@ -99,6 +99,8 @@ enum sbeReasonCode
     SBE_ERROR_ON_UPDATE                 = SBE_COMP_ID | 0x14,
     SBE_MASTER_VERSION_DOWNLEVEL        = SBE_COMP_ID | 0x15,
     SBE_IMAGE_GET_SET_SCALAR_FAIL       = SBE_COMP_ID | 0x16,
+    SBE_NO_2000_MHZ_NEST_FREQ_CAP       = SBE_COMP_ID | 0x17,
+    SBE_INCONSISTENT_NEST_FREQ          = SBE_COMP_ID | 0x18,
 
 };
 
diff --git a/src/usr/hwpf/hwp/mc_config/mc_config.C b/src/usr/hwpf/hwp/mc_config/mc_config.C
index 73f0b3d..4a5cb62 100644
--- a/src/usr/hwpf/hwp/mc_config/mc_config.C
+++ b/src/usr/hwpf/hwp/mc_config/mc_config.C
@@ -1085,7 +1085,9 @@ void findMinSpdAndDeconfigIncompatible(TargetHandleList::iterator i_iter,
 //
 errlHndl_t setNestBasedOffDimms()
 {
-    TRACDCOMP( ISTEPS_TRACE::g_trac_isteps_trace, ENTER_MRK"mc_config::setNestBasedOffDimms()");
+    TRACDCOMP( ISTEPS_TRACE::g_trac_isteps_trace,
+               ENTER_MRK"mc_config::setNestBasedOffDimms()");
+
     errlHndl_t l_err = NULL;
     bool l_isGoldenSide = false;
     ATTR_MRW_NEST_CAPABLE_FREQUENCIES_SYS_type l_capableNestFreq =
@@ -1119,7 +1121,8 @@ errlHndl_t setNestBasedOffDimms()
 
         if(l_err)
         {
-            // Error getting Golden side. Proceeding as if booting from safe Golden side
+            // Error getting Golden side. Proceeding as if booting from safe
+            // Golden side
             TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
                 ERR_MRK"setNestBasedOffDimms::isGoldenSide returned an error");
             errlCommit( l_err, HWPF_COMP_ID );
@@ -1128,18 +1131,36 @@ errlHndl_t setNestBasedOffDimms()
 
         if(!l_isGoldenSide)
         {
-            TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
-                    INFO_MRK"Booting from normal side. use "
-                    "MRW_NEST_CAPABLE_FREQUENCIES_SYS to calculate best freq "
-                    "across  membufs");
-            l_capableNestFreq = l_sys->getAttr
+            //Get the restricted capability and check if set up.
+            //If not, use the MRW capability. (has "MRW" in attribute name)
+            l_capableNestFreq = //cast to use the MRW attributes's enumeration
+                   (ATTR_MRW_NEST_CAPABLE_FREQUENCIES_SYS_type)
+                   l_sys->getAttr<ATTR_NEST_CAPABLE_FREQUENCIES_SYS>();
+            if (MRW_NEST_CAPABLE_FREQUENCIES_SYS_UNSUPPORTED_FREQ ==
+                    l_capableNestFreq) //Has not been set up. Get MRW capability
+            {
+                l_capableNestFreq = l_sys->getAttr
                                       <ATTR_MRW_NEST_CAPABLE_FREQUENCIES_SYS>();
+                TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
+                    INFO_MRK"Booting from normal side. use "
+                    "MRW_NEST_CAPABLE_FREQUENCIES_SYS "
+                    "to calculate best freq across membufs (%d)",
+                     l_capableNestFreq);
+            }
+            else //Use the restricted capability
+            {
+                TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
+                    INFO_MRK"Booting from normal side. use "
+                    "restricted NEST_CAPABLE_FREQUENCIES_SYS "
+                    "to calculate best freq across membufs (%d)",
+                     l_capableNestFreq);
+            }
         }
         else
         {
             // We booted using the Golden Side. Use NEST_FREQ_MHZ
             TRACFCOMP(ISTEPS_TRACE::g_trac_isteps_trace,
-                   INFO_MRK"Booting from Golden Side. Use default NEST_FREQ"
+                   INFO_MRK"Booting from Golden Side. Use default NEST_FREQ "
                            "to calculate best freq across membufs");
             if(l_currentSysNestFreq == 2000)
             {
diff --git a/src/usr/sbe/sbe_update.C b/src/usr/sbe/sbe_update.C
index f4d0d7f..52e0b16 100644
--- a/src/usr/sbe/sbe_update.C
+++ b/src/usr/sbe/sbe_update.C
@@ -76,7 +76,6 @@ TRAC_INIT( & g_trac_sbe, SBE_COMP_NAME, KILOBYTE );
 //#define TRACUCOMP(args...)  TRACFCOMP(args)
 #define TRACUCOMP(args...)
 
-
 // ----------------------------------------
 // Global Variables for MBOX Ipl Query
 static bool g_mbox_query_done   = false;
@@ -2992,6 +2991,21 @@ namespace SBE
     }
 
 /////////////////////////////////////////////////////////////////////
+    void setNestFreqAttributes(uint32_t i_nestFreq)
+    {
+        // Call targeting function to update NEST_FREQ
+        TargetService& tS = targetService();
+        TARGETING::Target* sys = NULL;
+        (void) tS.getTopLevelTarget( sys );
+        assert(sys, "setNestFreqAttributes() system target is NULL");
+
+        TRACFCOMP(g_trac_sbe, "setNestFreqAttributes(): "
+                  "UPDATE_NEST_FREQ to %d ",
+                  i_nestFreq);
+
+        TARGETING::setFrequencyAttributes(sys, i_nestFreq);
+    }
+/////////////////////////////////////////////////////////////////////
     errlHndl_t performUpdateActions(sbeTargetState_t& io_sbeState)
     {
         TRACUCOMP( g_trac_sbe,
@@ -3013,19 +3027,8 @@ namespace SBE
             // This can only be set with Golden/READ-ONLY Seeprom situation
             if (l_actions & UPDATE_NEST_FREQ)
             {
-                // Call targeting function to update NEST_FREQ
-                TargetService& tS = targetService();
-                TARGETING::Target* sys = NULL;
-                (void) tS.getTopLevelTarget( sys );
-                assert(sys, "performUpdateActions() system target is NULL");
-
-                TRACFCOMP( g_trac_sbe, "performUpdateActions(): "
-                           "UPDATE_NEST_FREQ to %d ",
-                           io_sbeState.mproc_nest_freq_mhz);
-
-                TARGETING::setFrequencyAttributes(
-                                       sys,
-                                       io_sbeState.mproc_nest_freq_mhz);
+                // update nest frequency attributes
+                setNestFreqAttributes(io_sbeState.mproc_nest_freq_mhz);
 
                 // This opeation only done by itself and does not need
                 // an informational error log
@@ -4149,30 +4152,288 @@ namespace SBE
         return;
     }
 
+/////////////////////////////////////////////////////////////////////
+// Return power bus frequency for this processor from vpd
+    errlHndl_t getPowerBusFreq(TARGETING::Target* i_target,
+                               uint32_t & o_powerBusFreq)
+    {
+        errlHndl_t err = NULL;
+        uint32_t l_record = (uint32_t) MVPD::LRP1;
+        fapi::voltageBucketData_t l_poundVdata = {0};
+
+        //convert to fapi target
+        fapi::Target l_pFapiProc(fapi::TARGET_TYPE_PROC_CHIP,
+                         (const_cast<TARGETING::Target*>(i_target) ));
+
+        //Read #V vpd
+        fapi::ReturnCode l_rc = fapiGetPoundVBucketData(l_pFapiProc,
+                                                        l_record,
+                                                        l_poundVdata);
+        if (l_rc)
+        {
+            TRACFCOMP(g_trac_sbe,
+                      ERR_MRK"checkNestFreqSettings(): "
+                      "Error getting #V data for HUID:0x%08X",
+                      TARGETING::get_huid(i_target));
+            // Convert fapi returnCode to Error handle
+            err = fapiRcToErrl(l_rc);
+        }
+        else
+        {
+            TRACFCOMP(g_trac_sbe,
+                      "checkNestFreqSettings(): "
+                      "VPD #V Power Bus frequency = %d for HUID=%x",
+                       l_poundVdata.labFreq,
+                       TARGETING::get_huid(i_target));
+            o_powerBusFreq = l_poundVdata.labFreq;
+         }
+         return err;
+      }
 
 /////////////////////////////////////////////////////////////////////
+// Confirm system is capable of low power nest frequency,
+// if so, set the restricted value attriabute.
+// Return error if system is not capable of low power nest frequency
+    errlHndl_t restrictSystemLowPowerCapability(TARGETING::Target * i_target)
+    {
+        errlHndl_t err = NULL;
+
+        TARGETING::Target * l_sys = NULL;
+        targetService().getTopLevelTarget(l_sys);
+        assert(l_sys, "restrictSystemLowPowerCapability(): Null system target");
+
+        //Get the MRW capabilities that this system can support
+        TARGETING::ATTR_MRW_NEST_CAPABLE_FREQUENCIES_SYS_type
+             l_mrwFreqCap =
+             l_sys->getAttr<TARGETING::ATTR_MRW_NEST_CAPABLE_FREQUENCIES_SYS>();
+
+        //Confirm the system is capable of a 2000 nest frequency.
+        //"not supported" will be seen when an MRW does not supply a value.
+        if (! (TARGETING::MRW_NEST_CAPABLE_FREQUENCIES_SYS_2000_MHZ &
+                                                            l_mrwFreqCap) )
+        {
+            TRACFCOMP(g_trac_sbe,
+                      ERR_MRK"restrictSystemLowPowerCapability(): "
+                      "System does not have capability for "
+                      "2000 nest frequency",
+                      l_mrwFreqCap);
+
+            /*@
+             * @errortype
+             * @moduleid     SBE_GET_TARGET_INFO_STATE
+             * @reasoncode   SBE_NO_2000_MHZ_NEST_FREQ_CAP
+             * @userdata1    Processor HUID
+             * @userdata2    MRW nest frequency capabilities
+             * @devdesc      System does not support 2000 MHZ
+             *               nest frequency required for
+             *               Low power Turismo
+             * @custdesc     Unsupported system configuration
+             */
+            err = new ErrlEntry(ERRL_SEV_UNRECOVERABLE,
+                                SBE_GET_TARGET_INFO_STATE,
+                                SBE_NO_2000_MHZ_NEST_FREQ_CAP,
+                                TARGETING::get_huid(i_target),
+                                l_mrwFreqCap);
+            err->collectTrace(SBE_COMP_NAME);
+            err->addHwCallout( i_target,
+                               HWAS::SRCI_PRIORITY_HIGH,
+                               HWAS::NO_DECONFIG,
+                               HWAS::GARD_NULL );
+        }
+        else //Use 2000 as the restricted system capability
+        {
+            l_sys->setAttr<TARGETING::ATTR_NEST_CAPABLE_FREQUENCIES_SYS>
+                (TARGETING::MRW_NEST_CAPABLE_FREQUENCIES_SYS_2000_MHZ);
+        }
+        return err;
+    }
+
+/////////////////////////////////////////////////////////////////////
+// There is a low power Turismo whose nest frequency should only
+// be set to 2000. These parts are identified by a module vpd power
+// bus frequency value of 2000 (reuse lab frequency).
+//
+// If either of a Turismo part's seeproms has been updated to
+// 2400, then we know this proc is not a low power part. If neither
+// seeprom's nest frequency can be established (version < 2) or has
+// been updated to 2000, we need to read the vpd.
+//
+// If this is a low power Turismo, then 2000 should be used for the default
+// value instead of a possible 2400 MRW provided default. The default value
+// is used to "assume" the seeprom's programmed nest frequency when the
+// programmed value can not be established (we programmed it and set the
+// version to 2 or higher). The default is not only used for matching against
+// the current nest frequency (ATTR_NEST_FREQ_MHZ) but could also be used
+// to set the current frequency in the untypical case of booting from a
+// read only golden side seeprom if this is the master proc.
+//
+// If we discover this is a low power Turismo, then we need to confirm that
+// the MRW capabilities support 2000. We also need to restrict the capabilities
+// to 2000.
+//
+// A part that can support 2400 could have been updated to 2000
+// due to dimm configuration. If the established frequency is 2000, we still
+// need to read the vpd to see if the capabiltiy needs to be restricted
+// to 2000.
+//
+// If the current nest frequency is 2400, then we need to change the current
+// frequency to 2000. All the procs need to be updated to 2000.
+//
+// A mix of low power Turismo with other capabilities is not supported.
+
     errlHndl_t checkNestFreqSettings(sbeTargetState_t& io_sbeState)
     {
         TRACDCOMP( g_trac_sbe,
-                   ENTER_MRK"checkNestFreqSettings");
+                   ENTER_MRK"checkNestFreqSettings(): HUID:0x%08X",
+                   TARGETING::get_huid(io_sbeState.target));
 
         errlHndl_t err = NULL;
-
         uint32_t default_nest_freq = 0;
 
+        //Used to ensure no mix of 2000 MHZ nest Turismo parts with others
+        enum procNestFreqRestriction
+        {
+            UNITIALIZED      = 0,
+            RESTRICTED_2000  = 1,  //restricted nest 2000 MHZ Turismo
+            OTHER            = 2,  //2400 MHZ Turismo or other module
+        };
+        static procNestFreqRestriction l_allProcNestType  = UNITIALIZED;
+        procNestFreqRestriction        l_thisProcNestType = OTHER;
+
         do{
 
             // Set defaults
             io_sbeState.seeprom_0_ver_Nest_Freq_Mismatch = false;
             io_sbeState.seeprom_1_ver_Nest_Freq_Mismatch = false;
 
-            // Get DEFAULT_PROC_MODULE_NEST_FREQ_MHZ attribute
+            // Get MRW DEFAULT_PROC_MODULE_NEST_FREQ_MHZ attribute
             default_nest_freq = io_sbeState.target->getAttr<
                          TARGETING::ATTR_DEFAULT_PROC_MODULE_NEST_FREQ_MHZ>();
 
-            TRACUCOMP( g_trac_sbe,"checkNestFreqSettings(): ATTR_NEST_FREQ_MHZ "
+            TRACUCOMP( g_trac_sbe,"checkNestFreqSettings(): ATTR_NEST_FREQ_MHZ"
                        "=%d, ATTR_DEFAULT_PROC_MODULE_NEST_FREQ_MHZ=%d",
                        g_current_nest_freq, default_nest_freq);
+            TRACUCOMP( g_trac_sbe,"checkNestFreqSettings(): "
+                       "seeprom0 ver=%d freq=%d seeprom1 ver=%d freq=%d",
+                       io_sbeState.seeprom_0_ver.struct_version,
+                       io_sbeState.seeprom_0_ver.nest_freq_mhz,
+                       io_sbeState.seeprom_1_ver.struct_version,
+                       io_sbeState.seeprom_1_ver.nest_freq_mhz);
+
+            // Check if we need to read module vpd to see if this is a
+            // low power Turismo.
+            if ( (MODEL_VENICE ==  //It is a Turismo
+                     io_sbeState.target->getAttr<TARGETING::ATTR_MODEL>()) &&
+               // neither seeprom established to be have been programmed to 2400
+               ! ( ((io_sbeState.seeprom_0_ver.struct_version >=
+                                 STRUCT_VERSION_LOW_POWER_CHECK   ) &&
+                    (io_sbeState.seeprom_0_ver.nest_freq_mhz ==
+                                               NEST_FREQ_2400)) ||
+                   ((io_sbeState.seeprom_1_ver.struct_version >=
+                                 STRUCT_VERSION_LOW_POWER_CHECK   ) &&
+                    (io_sbeState.seeprom_1_ver.nest_freq_mhz ==
+                                               NEST_FREQ_2400)) ) )
+            {
+                //Get the power bus frequency from proc module vpd
+                uint32_t l_powerBusFreq = 0;
+                err = getPowerBusFreq(io_sbeState.target, l_powerBusFreq);
+                if (err)
+                {
+                    break; //return with error
+                }
+
+                //If power bus is 2000, then it is a low power part.
+                //Any other value taken as a 2400 part.
+                if (NEST_FREQ_2000 == l_powerBusFreq)
+                {
+                    TRACUCOMP( g_trac_sbe,
+                           "checkNestFreqSettings(): "
+                           "2000 nest restriction determined from VPD");
+
+                    //confirm system has capability for low power nest freq
+                    //and restrict to low power
+                    err = restrictSystemLowPowerCapability(io_sbeState.target);
+                    if (err)
+                    {
+                        break; //return with error
+                    }
+
+                    //Since this processor is restricted to 2000,
+                    //all other processors must also be restricted to 2000
+                    l_thisProcNestType = RESTRICTED_2000;
+
+                    //Use 2000 as default for this proc instead of MRW attr.
+                    default_nest_freq = NEST_FREQ_2000;
+
+                    //Change current nest frequency to 2000 if needed
+                    if (NEST_FREQ_2000 != g_current_nest_freq)
+                    {
+                        TRACUCOMP( g_trac_sbe,
+                                   "checkNestFreqSettings(): "
+                                   "Changing Power Bus frequency to 2000");
+                        //set all the frequency attributes
+                        setNestFreqAttributes(NEST_FREQ_2000);
+
+                        //Update copy of ATTR_NEST_FREQ_MHZ
+                        g_current_nest_freq = NEST_FREQ_2000;
+                    }
+                    else
+                    {
+                        TRACUCOMP( g_trac_sbe,
+                                   "checkNestFreqSettings(): "
+                                   "Current nest frequency already 2000");
+                    }
+                }
+                else
+                {
+                    TRACUCOMP( g_trac_sbe,
+                           "checkNestFreqSettings(): "
+                           "2400 capable Turismo determined from VPD");
+                }
+            }
+            else
+            {
+                TRACUCOMP( g_trac_sbe,
+                           "checkNestFreqSettings(): "
+                           "Not low power Turismo, 2400 in seeprom header");
+            }
+
+            // Confirm that if any processor is a low power Turismo,
+            // then all processors are. A mix is not supported.
+            if (UNITIALIZED != l_allProcNestType) // this is not the first
+            {
+                if (l_allProcNestType != l_thisProcNestType) // mix detected
+                {
+                    TRACFCOMP( g_trac_sbe,
+                               ERR_MRK"checkNestFreqSettings(): "
+                               "System not can have mix of "
+                               "low and high power Turismo parts");
+                    /*@
+                     * @errortype
+                     * @moduleid     SBE_GET_TARGET_INFO_STATE
+                     * @reasoncode   SBE_INCONSISTENT_NEST_FREQ
+                     * @userdata1    Processor HUID
+                     * @devdesc      System not can have mix of
+                     *               low and high power Turismo parts
+                     * @custdesc     Unsupported system configuration
+                     */
+                    err = new ErrlEntry(ERRL_SEV_UNRECOVERABLE,
+                                    SBE_GET_TARGET_INFO_STATE,
+                                    SBE_INCONSISTENT_NEST_FREQ,
+                                    TARGETING::get_huid(io_sbeState.target),
+                                    0);
+                    err->collectTrace(SBE_COMP_NAME);
+                    err->addHwCallout(io_sbeState.target,
+                                   HWAS::SRCI_PRIORITY_HIGH,
+                                   HWAS::NO_DECONFIG,
+                                   HWAS::GARD_NULL );
+                    break; // return error
+                }
+            }
+            else //first proc, save to check the rest
+            {
+                l_allProcNestType = l_thisProcNestType;
+            }
 
             // Check Seeprom 0
             checkSeepromNestFreq(io_sbeState.target,
diff --git a/src/usr/sbe/sbe_update.H b/src/usr/sbe/sbe_update.H
index 3fc5086..f293de6 100644
--- a/src/usr/sbe/sbe_update.H
+++ b/src/usr/sbe/sbe_update.H
@@ -44,7 +44,7 @@ namespace SBE
     const size_t   SBE_MVPD_SHORT_IMAGE_VERSION_SIZE = 20;
 
     // Number of versions supported
-    const uint8_t SBE_SEEPROM_STRUCT_MAX_VERSIONS    = 0x05;
+    const uint8_t SBE_SEEPROM_STRUCT_MAX_VERSIONS    = 0x06;
 
     // Size of supported versions - must be 8-byte aligned
     const size_t  SBE_SEEPROM_STRUCT_SIZES[SBE_SEEPROM_STRUCT_MAX_VERSIONS] =
@@ -54,6 +54,7 @@ namespace SBE
                         80,  // ver2: size of struct is 80 bytes
                         80,  // ver3: size of struct is 80 bytes
                         80,  // ver4: size of struct is 80 bytes
+                        80,  // ver5: size of struct is 80 bytes
                       };
 
     // This enum provides the struct versions for sbeSeepromVersionInfo_t
@@ -63,10 +64,15 @@ namespace SBE
         STRUCT_VERSION_NEST_FREQ = 0x2,
         STRUCT_VERSION_ORIGIN_GOLD = 0x3,
         STRUCT_VERSION_HBB_FIXUP = 0x4,
-        STRUCT_VERSION_LATEST = 0x4,
+        STRUCT_VERSION_LOW_POWER_CHECK = 0x5,
+        STRUCT_VERSION_LATEST = 0x5,
         STRUCT_VERSION_SIMICS = 0x5A5A5A5A,
     };
 
+    // Nest frequencies
+    const uint32_t NEST_FREQ_2000 = 2000;
+    const uint32_t NEST_FREQ_2400 = 2400;
+
     // Constant written to SBE SEEPROM version struct to invalidate the
     // struct and the image - 'INVALID\0'
     const uint64_t SBE_SEEPROM_STRUCT_INVALID = 0x494E56414C494400;
diff --git a/src/usr/targeting/common/xmltohb/attribute_types_hb.xml b/src/usr/targeting/common/xmltohb/attribute_types_hb.xml
index d49829d..af88e3e 100644
--- a/src/usr/targeting/common/xmltohb/attribute_types_hb.xml
+++ b/src/usr/targeting/common/xmltohb/attribute_types_hb.xml
@@ -1769,4 +1769,22 @@ ID for the sensor number returned with the elog. -->
   </hwpfToHbAttrMap>
 </attribute>
 
+<attribute>
+  <id>NEST_CAPABLE_FREQUENCIES_SYS</id>
+  <description>
+      The NEST frequencies that the system supports. Can be restricted
+      to less values than MRW_NEST_CAPABLE_FREQUENCIES_SYS based on processor
+      VPD. The MRW_NEST_CAPABLE_FREQUENCIES_SYS enumeration values are used.
+  </description>
+  <simpleType>
+    <uint32_t>
+      <default>0</default>
+    </uint32_t>
+  </simpleType>
+  <persistency>volatile-zeroed</persistency>
+  <readable/>
+  <writeable/>
+  <hbOnly/>
+</attribute>
+
 </attributes>
diff --git a/src/usr/targeting/common/xmltohb/target_types_hb.xml b/src/usr/targeting/common/xmltohb/target_types_hb.xml
index 3d01944..edf56ad 100644
--- a/src/usr/targeting/common/xmltohb/target_types_hb.xml
+++ b/src/usr/targeting/common/xmltohb/target_types_hb.xml
@@ -83,6 +83,7 @@
     <attribute><id>WOF_PROC_SORT</id></attribute>
     <attribute><id>WOF_FREQUENCY_UPLIFT</id></attribute>
     <attribute><id>WOF_REGULATOR_EFFICIENCIES</id></attribute>
+    <attribute><id>NEST_CAPABLE_FREQUENCIES_SYS</id></attribute>
 </targetTypeExtension>
 
 <targetTypeExtension>
-- 
1.8.2.2

