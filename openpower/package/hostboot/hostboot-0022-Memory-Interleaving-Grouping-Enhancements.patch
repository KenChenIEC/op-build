From 5c951b3c59a3cce0ba97b7e59aade9c257fcd252 Mon Sep 17 00:00:00 2001
From: Bill Hoffa <wghoffa@us.ibm.com>
Date: Thu, 25 Feb 2016 09:32:06 -0600
Subject: [PATCH] Memory Interleaving Grouping Enhancements

Change-Id: If6d71a5c8192196e4cb5329eca06a8004249256c
---
 .../mc_config/mss_eff_config/mss_eff_grouping.C    | 191 +++++++++++++++++++--
 src/usr/hwpf/hwp/memory_attributes.xml             |  13 +-
 .../targeting/common/xmltohb/attribute_types.xml   |  21 +++
 src/usr/targeting/common/xmltohb/target_types.xml  |   4 +-
 4 files changed, 216 insertions(+), 13 deletions(-)

diff --git a/src/usr/hwpf/hwp/mc_config/mss_eff_config/mss_eff_grouping.C b/src/usr/hwpf/hwp/mc_config/mss_eff_config/mss_eff_grouping.C
index ced4133..565e7da 100644
--- a/src/usr/hwpf/hwp/mc_config/mss_eff_config/mss_eff_grouping.C
+++ b/src/usr/hwpf/hwp/mc_config/mss_eff_config/mss_eff_grouping.C
@@ -5,7 +5,7 @@
 /*                                                                        */
 /* OpenPOWER HostBoot Project                                             */
 /*                                                                        */
-/* Contributors Listed Below - COPYRIGHT 2012,2014                        */
+/* Contributors Listed Below - COPYRIGHT 2012,2016                        */
 /* [+] International Business Machines Corp.                              */
 /*                                                                        */
 /*                                                                        */
@@ -22,12 +22,12 @@
 /* permissions and limitations under the License.                         */
 /*                                                                        */
 /* IBM_PROLOG_END_TAG                                                     */
-// $Id: mss_eff_grouping.C,v 1.34 2014/09/29 16:25:38 gpaulraj Exp $
+// $Id: mss_eff_grouping.C,v 1.36 2016/02/25 10:38:59 gpaulraj Exp $
 // Mike Jones - modified version from 1.28 to 1.00 because it is a sandbox version
 //------------------------------------------------------------------------------
 // *! (C) Copyright International Business Machines Corp. 2011
 // *! All Rights Reserved -- Property of IBM
-// *! ***  ***
+// *! *** IBM Confidential ***
 //------------------------------------------------------------------------------
 // *! TITLE       : mss_eff_grouping.C
 // *! DESCRIPTION : see additional comments below
@@ -41,6 +41,8 @@
 //------------------------------------------------------------------------------
 // Version:|  Author: |  Date:  | Comment:
 //---------|----------|---------|-----------------------------------------------
+//  1.36   | gpaulraj | 02-25-16| Fixed 0/1/4/5 supermicro 2 MCS/G requirement
+//  1.35   | gpaulraj | 02-19-16| Fixed odd MCS grouping for Stradale
 //  1.34   |gpaulraj  | 09-23-14| fixed last check in issue
 //  1.33   |gpaulraj  | 09-23-14| fixed 2 MCS/group issue on starting with odd MCS grouping
 //  1.32   |gpaulraj  | 06-26-14| support MEM_MIRROR_PLACEMENT_POLICY_FLIPPED_DRAWER for Brazos
@@ -196,7 +198,8 @@ struct EffGroupingSysAttrs
      */
     EffGroupingSysAttrs() : iv_mcsInterleaveMode(0),
                             iv_selectiveMode(0),
-                            iv_enhancedNoMirrorMode(0) {}
+                            iv_enhancedNoMirrorMode(0) ,
+                            iv_mcs_group_with_adj_pair(0) {}
     /**
      * @brief Gets attributes
      */
@@ -206,6 +209,7 @@ struct EffGroupingSysAttrs
     uint8_t iv_mcsInterleaveMode;    // ATTR_ALL_MCS_IN_INTERLEAVING_GROUP
     uint8_t iv_selectiveMode;        // ATTR_MEM_MIRROR_PLACEMENT_POLICY
     uint8_t iv_enhancedNoMirrorMode; // ATTR_MRW_ENHANCED_GROUPING_NO_MIRRORING
+    uint8_t iv_mcs_group_with_adj_pair;    // ATTR_MRW_MCS_GROUP_ALLOW_ONLY_ADJ_PAIR 
 };
 
 /**
@@ -451,12 +455,23 @@ fapi::ReturnCode EffGroupingSysAttrs::getAttrs()
             break;
         }
 
+        rc = FAPI_ATTR_GET(ATTR_MRW_MCS_GROUP_ALLOW_ONLY_ADJ_PAIR, NULL,
+                           iv_mcs_group_with_adj_pair);
+        if (rc)
+        {
+            FAPI_ERR("Error querying sys ATTR_MRW_MCS_GROUP_ALLOW_ONLY_ADJ_PAIR");
+            break;
+        }
+
+
+
         FAPI_INF("mss_eff_grouping::EffGroupingSysAttrs: "
                  "ALL_MCS_IN_INTERLEAVING_GROUP 0x%02x, "
                  "MEM_MIRROR_PLACEMENT_POLICY 0x%02x, "
-                 "MRW_ENHANCED_GROUPING_NO_MIRRORING 0x%02x",
+                 "MRW_ENHANCED_GROUPING_NO_MIRRORING 0x%02x,"
+                 "ATTR_MRW_MCS_GROUP_ALLOW_ONLY_ADJ_PAIR 0x%02x",
                  iv_mcsInterleaveMode, iv_selectiveMode,
-                 iv_enhancedNoMirrorMode);
+                 iv_enhancedNoMirrorMode, iv_mcs_group_with_adj_pair);
     } while(0);
 
     return rc;
@@ -999,7 +1014,7 @@ void grouping_group2McsPerGroup(const EffGroupingMemInfo & i_memInfo,
     FAPI_INF("mss_eff_grouping: Attempting to group 2 MCSs per group");
     uint8_t & g = o_groupData.iv_numGroups;
 
-    for (uint8_t pos = 0; pos < NUM_MCS_PER_PROC - 1; pos = pos+2)
+    for (uint8_t pos = 0; pos < NUM_MCS_PER_PROC; pos = pos+2)
     {
         if ((!o_groupData.iv_mcsGrouped[pos]) &&
             (!o_groupData.iv_mcsGrouped[pos + 1]) &&
@@ -1036,6 +1051,127 @@ void grouping_group2McsPerGroup(const EffGroupingMemInfo & i_memInfo,
 }
 
 /**
+ * @brief Attempts to group 2 MCSs per group for starting with odd group MCS
+ *
+ * If they can be grouped, fills in the following fields in o_groupData:
+ * - iv_data[<group>][MCS_SIZE]
+ * - iv_data[<group>][MCS_IN_GROUP]
+ * - iv_data[<group>][GROUP_SIZE]
+ * - iv_data[<group>][MEMBER_IDX(<members>)]
+ * - iv_data[<group>][LARGEST_MBA_SIZE]
+ * - iv_mcsGrouped[<group>]
+ * - iv_numGroups
+ *
+ * @param[in]  i_memInfo   Reference to EffGroupingMemInfo structure
+ * @param[out] o_groupData Reference to output data
+ */
+void grouping_group2McsPerGroup_oddpair(const EffGroupingMemInfo & i_memInfo,
+                                EffGroupingData & o_groupData)
+{
+    // 2 adjacent MCSs are grouped if they have the same size
+    // 1/2,3/4,5/6 
+    FAPI_INF("mss_eff_grouping: Attempting to group 2 MCSs per group");
+    uint8_t & g = o_groupData.iv_numGroups;
+    uint8_t ADJ_PAIR_ALLOWED_MCS_LOOP = 2;
+
+    for (uint8_t pos = 1; pos < NUM_MCS_PER_PROC - ADJ_PAIR_ALLOWED_MCS_LOOP; pos = pos+2)
+    {
+        if ((!o_groupData.iv_mcsGrouped[pos]) &&
+            (!o_groupData.iv_mcsGrouped[pos + 1]) &&
+            (i_memInfo.iv_mcsSize[pos] != 0) &&
+            (i_memInfo.iv_mcsSize[pos] == i_memInfo.iv_mcsSize[pos + 1]))
+        {
+            // These 2 MCSs are not already grouped and have the same amount of
+            // memory
+            FAPI_INF("mss_eff_grouping: Grouped MCSs %u and %u", pos, pos + 1);
+            o_groupData.iv_data[g][MCS_SIZE] = i_memInfo.iv_mcsSize[pos];
+            o_groupData.iv_data[g][MCS_IN_GROUP] = 2;
+            o_groupData.iv_data[g][GROUP_SIZE] = 2 * i_memInfo.iv_mcsSize[pos];
+            o_groupData.iv_data[g][MEMBER_IDX(0)] = pos;
+            o_groupData.iv_data[g][MEMBER_IDX(1)] = pos + 1;
+            if (i_memInfo.iv_largestMbaSize[pos] >
+                i_memInfo.iv_largestMbaSize[pos + 1])
+            {
+                o_groupData.iv_data[g][LARGEST_MBA_SIZE] =
+                    i_memInfo.iv_largestMbaSize[pos];
+            }
+            else
+            {
+                o_groupData.iv_data[g][LARGEST_MBA_SIZE] =
+                    i_memInfo.iv_largestMbaSize[pos + 1];
+            }
+            g++;
+
+            // Record which MCSs were grouped
+            o_groupData.iv_mcsGrouped[pos] = true;
+            o_groupData.iv_mcsGrouped[pos + 1] = true;
+           
+        }
+    }
+}
+/**
+ * @brief Attempts to group 2 MCSs per group for starting with use case group MCS
+ *
+ * If they can be grouped, fills in the following fields in o_groupData:
+ * - iv_data[<group>][MCS_SIZE]
+ * - iv_data[<group>][MCS_IN_GROUP]
+ * - iv_data[<group>][GROUP_SIZE]
+ * - iv_data[<group>][MEMBER_IDX(<members>)]
+ * - iv_data[<group>][LARGEST_MBA_SIZE]
+ * - iv_mcsGrouped[<group>]
+ * - iv_numGroups
+ *
+ * @param[in]  i_memInfo   Reference to EffGroupingMemInfo structure
+ * @param[out] o_groupData Reference to output data
+ */
+void grouping_group2McsPerGroup_usecase(const EffGroupingMemInfo & i_memInfo,
+                                EffGroupingData & o_groupData)
+{
+    // 2 adjacent MCSs are grouped if they have the same size
+    // 1/5, 1/4, 0/4, 5/4, 
+    FAPI_INF("mss_eff_grouping: Attempting to group 2 MCSs per group");
+    uint8_t & g = o_groupData.iv_numGroups;
+    uint8_t SUPERMICRO_MCS_ALLOWED_LIMIT = 6;
+    uint8_t SUPERMICRO_ALLOWED_MCS_LOOP = 2;
+    for (uint8_t pos = 0; pos < NUM_MCS_PER_PROC - SUPERMICRO_MCS_ALLOWED_LIMIT; pos = pos+1)
+    {
+	    for (uint8_t var = 4; var < NUM_MCS_PER_PROC - SUPERMICRO_ALLOWED_MCS_LOOP; var = var+1)
+	    {   
+            if ((!o_groupData.iv_mcsGrouped[pos]) &&
+                (!o_groupData.iv_mcsGrouped[var]) &&
+                (i_memInfo.iv_mcsSize[pos] != 0) &&
+                (i_memInfo.iv_mcsSize[pos] == i_memInfo.iv_mcsSize[var]))
+            {
+                // These 2 MCSs are not already grouped and have the same amount of
+                // memory
+                FAPI_INF("mss_eff_grouping: Grouped MCSs %u and %u", pos, var);
+                o_groupData.iv_data[g][MCS_SIZE] = i_memInfo.iv_mcsSize[pos];
+                o_groupData.iv_data[g][MCS_IN_GROUP] = 2;
+                o_groupData.iv_data[g][GROUP_SIZE] = 2 * i_memInfo.iv_mcsSize[pos];
+                o_groupData.iv_data[g][MEMBER_IDX(0)] = pos;
+                o_groupData.iv_data[g][MEMBER_IDX(1)] = var;
+                if (i_memInfo.iv_largestMbaSize[pos] >
+                    i_memInfo.iv_largestMbaSize[var])
+                {
+                    o_groupData.iv_data[g][LARGEST_MBA_SIZE] =
+                        i_memInfo.iv_largestMbaSize[pos];
+                }
+                else
+                {
+                    o_groupData.iv_data[g][LARGEST_MBA_SIZE] =
+                        i_memInfo.iv_largestMbaSize[var];
+                }
+                g++;
+            
+                // Record which MCSs were grouped
+                o_groupData.iv_mcsGrouped[pos] = true;
+                o_groupData.iv_mcsGrouped[var] = true;
+               
+            }
+        }    
+    }
+}
+/**
  * @brief Attempts to group 1 MCS per group
  *
  * If they can be grouped, fills in the following fields in o_groupData:
@@ -2158,21 +2294,54 @@ fapi::ReturnCode mss_eff_grouping(const fapi::Target & i_target,
         // grouped by the subsequent functions
         if (procAttrs.iv_groupsAllowed & MCS_GROUP_8)
         {
-            grouping_group8McsPerGroup(memInfo, groupData);
+	        if( !sysAttrs.iv_enhancedNoMirrorMode)
+	        {
+                grouping_group8McsPerGroup(memInfo, groupData);
+            }    
         }
         if (procAttrs.iv_groupsAllowed & MCS_GROUP_4)
         {
-            grouping_group4McsPerGroup(memInfo, groupData);
+	      if( !sysAttrs.iv_enhancedNoMirrorMode)
+	       {
+                grouping_group4McsPerGroup(memInfo, groupData);
+           }
         }
         if (procAttrs.iv_groupsAllowed & MCS_GROUP_2)
         {
-            grouping_group2McsPerGroup(memInfo, groupData);
+	      if(sysAttrs.iv_mcs_group_with_adj_pair)
+          {  
+             if( sysAttrs.iv_enhancedNoMirrorMode)
+	         {
+		        grouping_group2McsPerGroup(memInfo, groupData);
+                        grouping_group2McsPerGroup_oddpair(memInfo, groupData);
+	         }
+	         else
+	         {
+		        grouping_group2McsPerGroup(memInfo, groupData); 
+	         }
+          }   
+	  else
+          {
+	        if(sysAttrs.iv_enhancedNoMirrorMode)
+	        {
+	           grouping_group2McsPerGroup(memInfo, groupData);
+		   grouping_group2McsPerGroup_oddpair(memInfo, groupData);
+                   grouping_group2McsPerGroup_usecase(memInfo, groupData);
+                }
+                else
+                {
+	           grouping_group2McsPerGroup_usecase(memInfo, groupData);
+                   grouping_group2McsPerGroup(memInfo, groupData);
+                }
+          }
+
         }
         if (procAttrs.iv_groupsAllowed & MCS_GROUP_1)
         {
             // Note that grouping_checkValidAttributes() ensures that this is
             // only in checkerboard mode
-            grouping_group1McsPerGroup(memInfo, groupData);
+    	    grouping_group1McsPerGroup(memInfo, groupData);
+                
         }
 
         // Find the ungrouped MCSs and deconfigure their associated membuf chips
diff --git a/src/usr/hwpf/hwp/memory_attributes.xml b/src/usr/hwpf/hwp/memory_attributes.xml
index d169448..28b4bff 100644
--- a/src/usr/hwpf/hwp/memory_attributes.xml
+++ b/src/usr/hwpf/hwp/memory_attributes.xml
@@ -23,7 +23,7 @@
 <!--                                                                        -->
 <!-- IBM_PROLOG_END_TAG                                                     -->
 <attributes>
-<!-- $Id: memory_attributes.xml,v 1.167 2015/11/09 20:32:01 pardeik Exp $ -->
+<!-- $Id: memory_attributes.xml,v 1.168 2016/02/02 17:25:18 asaetow Exp $ -->
 <!-- DO NOT EDIT THIS FILE DIRECTLY PLEASE UPDATE THE ODS FILE AND FOLLOW THE INSTRUCTION TAB -->
 <!-- PLEASE SEE MARK BELLOWS (BELLOWS.IBM.COM) OR OTHERS ON MEMORY TEAM FOR HELP -->
 <!-- *********************************************************************** --> 
@@ -3095,6 +3095,17 @@ Will be set at an MBA level with one policy to be used</description>
 </attribute> 
 
 <attribute>
+    <id>ATTR_MRW_MCS_GROUP_ALLOW_ONLY_ADJ_PAIR</id>
+    <targetType>TARGET_TYPE_SYSTEM</targetType>
+    <description>
+       The MRW for a system should be set to TRUE unless adjacent MCS pairs are not accessable for grouping of 2. IBM systems, such as Tuleta, Brazos, Alpine, Firestone, ... should set this attribute to TRUE. A FALSE setting would instruct the grouping code to attempt grouping of non-adjacent MCS into a pair.
+    </description>
+    <valueType>uint8</valueType>
+    <platInit/>
+    <enum>FALSE = 0, TRUE = 1</enum>
+</attribute>
+
+<attribute>
     <id>ATTR_MRW_ENHANCED_GROUPING_NO_MIRRORING</id>
     <targetType>TARGET_TYPE_SYSTEM</targetType>
     <description>
diff --git a/src/usr/targeting/common/xmltohb/attribute_types.xml b/src/usr/targeting/common/xmltohb/attribute_types.xml
index fb60c5a..954205f 100644
--- a/src/usr/targeting/common/xmltohb/attribute_types.xml
+++ b/src/usr/targeting/common/xmltohb/attribute_types.xml
@@ -16702,4 +16702,25 @@ firmware notes: Platforms should initialize this attribute to AUTO (0)</descript
     </hwpfToHbAttrMap>
 </attribute>
 
+<attribute>
+    <id>MRW_MCS_GROUP_ALLOW_ONLY_ADJ_PAIR</id>
+    <description>
+    The MRW for a system should be set to TRUE unless adjacent MCS pairs are not
+    accessable for grouping of 2. IBM systems, should be set this attribute to 
+    TRUE. A FALSE setting would instruct the grouping code to attempt 
+    grouping of non-adjacent MCS into a pair.
+    </description>
+    <simpleType>
+        <uint8_t>
+            <default> 1 </default>
+        </uint8_t>
+    </simpleType>
+    <persistency>non-volatile</persistency>
+    <readable/>
+    <hwpfToHbAttrMap>
+        <id>ATTR_MRW_MCS_GROUP_ALLOW_ONLY_ADJ_PAIR</id>
+        <macro>DIRECT</macro>
+    </hwpfToHbAttrMap>
+</attribute>
+
 </attributes>
diff --git a/src/usr/targeting/common/xmltohb/target_types.xml b/src/usr/targeting/common/xmltohb/target_types.xml
index 4610bc0..00ea56f 100644
--- a/src/usr/targeting/common/xmltohb/target_types.xml
+++ b/src/usr/targeting/common/xmltohb/target_types.xml
@@ -5,7 +5,7 @@
 <!--                                                                        -->
 <!-- OpenPOWER HostBoot Project                                             -->
 <!--                                                                        -->
-<!-- Contributors Listed Below - COPYRIGHT 2012,2015                        -->
+<!-- Contributors Listed Below - COPYRIGHT 2012,2016                        -->
 <!-- [+] Google Inc.                                                        -->
 <!-- [+] International Business Machines Corp.                              -->
 <!--                                                                        -->
@@ -251,6 +251,7 @@
     <attribute><id>PM_GLOBAL_FIR_TRACE_EN</id></attribute>
     <attribute><id>MRW_STRICT_MBA_PLUG_RULE_CHECKING</id></attribute>
     <attribute><id>MRW_ENHANCED_GROUPING_NO_MIRRORING</id></attribute>
+    <attribute><id>MRW_MCS_GROUP_ALLOW_ONLY_ADJ_PAIR</id></attribute>
     <attribute><id>MRW_MBA_CACHELINE_INTERLEAVE_MODE_CONTROL</id></attribute>
     <attribute><id>MRW_CDIMM_MASTER_I2C_TEMP_SENSOR_ENABLE</id></attribute>
     <attribute><id>MRW_CDIMM_SPARE_I2C_TEMP_SENSOR_ENABLE</id></attribute>
@@ -312,6 +313,7 @@
     <attribute><id>SBE_MASTER_INTR_SERVICE_DELAY_US</id></attribute>
     <attribute><id>CLEAR_DIMM_SPD_ENABLE</id></attribute>
     <attribute><id>MRW_MCS_PREFETCH_RETRY_THRESHOLD</id></attribute>
+
 </targetType>
 
 <targetType>
-- 
1.8.2.2

